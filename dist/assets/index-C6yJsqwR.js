let wo, Bv, xj, M3, gP, Ge, Yl, da, Wl, To, Ot, si, tr, lv, Pv, Te, hL, zh, b3, sf, rS, Ur, qr, Yo, dB, Ts, vd, CE, Wt, jae, qs, oG, _u, Ih, La, ST, ot, w_, D4, _D, Fe, gf, nq, An, Wv, Ij, $ae, L0, zae, oj, ga, SK, EK, DK, xo, ig, gd, kae, Uae, Fae, MD, Ej, Sj, Mj, Cd, jp, kH, $n, Cb, Tb, xb, Bae, tf, Gae, rT, g3, sc, u3, sr, So, wi, F4, uf, ua, sp, cp, LK, u_, f_, kC, tg, ws, Es, M0, Zo, hk, Xo, ZE, kz, eg, Ke, pn, Ys, Qc, cn, K, Xr, FL, zn, jn, xt, kr, We, El, Hc, kn, bi, Yr, r$;
let __tla = (async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);
        new MutationObserver((i)=>{
            for (const a of i)if (a.type === "childList") for (const o of a.addedNodes)o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function n(i) {
            const a = {};
            return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
        }
        function r(i) {
            if (i.ep) return;
            i.ep = !0;
            const a = n(i);
            fetch(i.href, a);
        }
    })();
    function Qa(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
    }
    function mM(t) {
        if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
        var e = t.default;
        if (typeof e == "function") {
            var n = function r() {
                var i = !1;
                try {
                    i = this instanceof r;
                } catch  {}
                return i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
            };
            n.prototype = e.prototype;
        } else n = {};
        return Object.defineProperty(n, "__esModule", {
            value: !0
        }), Object.keys(t).forEach(function(r) {
            var i = Object.getOwnPropertyDescriptor(t, r);
            Object.defineProperty(n, r, i.get ? i : {
                enumerable: !0,
                get: function() {
                    return t[r];
                }
            });
        }), n;
    }
    var Gm = {
        exports: {}
    }, kf = {}, Wm = {
        exports: {}
    }, on = {}, R6;
    function vM() {
        if (R6) return on;
        R6 = 1;
        var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), o = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), l = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), u = Symbol.iterator;
        function g(X) {
            return X === null || typeof X != "object" ? null : (X = u && X[u] || X["@@iterator"], typeof X == "function" ? X : null);
        }
        var h = {
            isMounted: function() {
                return !1;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        }, v = Object.assign, m = {};
        function y(X, ie, he) {
            this.props = X, this.context = ie, this.refs = m, this.updater = he || h;
        }
        y.prototype.isReactComponent = {}, y.prototype.setState = function(X, ie) {
            if (typeof X != "object" && typeof X != "function" && X != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, X, ie, "setState");
        }, y.prototype.forceUpdate = function(X) {
            this.updater.enqueueForceUpdate(this, X, "forceUpdate");
        };
        function C() {}
        C.prototype = y.prototype;
        function T(X, ie, he) {
            this.props = X, this.context = ie, this.refs = m, this.updater = he || h;
        }
        var x = T.prototype = new C;
        x.constructor = T, v(x, y.prototype), x.isPureReactComponent = !0;
        var S = Array.isArray, D = Object.prototype.hasOwnProperty, _ = {
            current: null
        }, M = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };
        function P(X, ie, he) {
            var $e, je = {}, He = null, rt = null;
            if (ie != null) for($e in ie.ref !== void 0 && (rt = ie.ref), ie.key !== void 0 && (He = "" + ie.key), ie)D.call(ie, $e) && !M.hasOwnProperty($e) && (je[$e] = ie[$e]);
            var Qe = arguments.length - 2;
            if (Qe === 1) je.children = he;
            else if (1 < Qe) {
                for(var et = Array(Qe), St = 0; St < Qe; St++)et[St] = arguments[St + 2];
                je.children = et;
            }
            if (X && X.defaultProps) for($e in Qe = X.defaultProps, Qe)je[$e] === void 0 && (je[$e] = Qe[$e]);
            return {
                $$typeof: t,
                type: X,
                key: He,
                ref: rt,
                props: je,
                _owner: _.current
            };
        }
        function F(X, ie) {
            return {
                $$typeof: t,
                type: X.type,
                key: ie,
                ref: X.ref,
                props: X.props,
                _owner: X._owner
            };
        }
        function N(X) {
            return typeof X == "object" && X !== null && X.$$typeof === t;
        }
        function B(X) {
            var ie = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + X.replace(/[=:]/g, function(he) {
                return ie[he];
            });
        }
        var G = /\/+/g;
        function Z(X, ie) {
            return typeof X == "object" && X !== null && X.key != null ? B("" + X.key) : ie.toString(36);
        }
        function H(X, ie, he, $e, je) {
            var He = typeof X;
            (He === "undefined" || He === "boolean") && (X = null);
            var rt = !1;
            if (X === null) rt = !0;
            else switch(He){
                case "string":
                case "number":
                    rt = !0;
                    break;
                case "object":
                    switch(X.$$typeof){
                        case t:
                        case e:
                            rt = !0;
                    }
            }
            if (rt) return rt = X, je = je(rt), X = $e === "" ? "." + Z(rt, 0) : $e, S(je) ? (he = "", X != null && (he = X.replace(G, "$&/") + "/"), H(je, ie, he, "", function(St) {
                return St;
            })) : je != null && (N(je) && (je = F(je, he + (!je.key || rt && rt.key === je.key ? "" : ("" + je.key).replace(G, "$&/") + "/") + X)), ie.push(je)), 1;
            if (rt = 0, $e = $e === "" ? "." : $e + ":", S(X)) for(var Qe = 0; Qe < X.length; Qe++){
                He = X[Qe];
                var et = $e + Z(He, Qe);
                rt += H(He, ie, he, et, je);
            }
            else if (et = g(X), typeof et == "function") for(X = et.call(X), Qe = 0; !(He = X.next()).done;)He = He.value, et = $e + Z(He, Qe++), rt += H(He, ie, he, et, je);
            else if (He === "object") throw ie = String(X), Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.");
            return rt;
        }
        function ne(X, ie, he) {
            if (X == null) return X;
            var $e = [], je = 0;
            return H(X, $e, "", "", function(He) {
                return ie.call(he, He, je++);
            }), $e;
        }
        function ae(X) {
            if (X._status === -1) {
                var ie = X._result;
                ie = ie(), ie.then(function(he) {
                    (X._status === 0 || X._status === -1) && (X._status = 1, X._result = he);
                }, function(he) {
                    (X._status === 0 || X._status === -1) && (X._status = 2, X._result = he);
                }), X._status === -1 && (X._status = 0, X._result = ie);
            }
            if (X._status === 1) return X._result.default;
            throw X._result;
        }
        var ue = {
            current: null
        }, le = {
            transition: null
        }, oe = {
            ReactCurrentDispatcher: ue,
            ReactCurrentBatchConfig: le,
            ReactCurrentOwner: _
        };
        function re() {
            throw Error("act(...) is not supported in production builds of React.");
        }
        return on.Children = {
            map: ne,
            forEach: function(X, ie, he) {
                ne(X, function() {
                    ie.apply(this, arguments);
                }, he);
            },
            count: function(X) {
                var ie = 0;
                return ne(X, function() {
                    ie++;
                }), ie;
            },
            toArray: function(X) {
                return ne(X, function(ie) {
                    return ie;
                }) || [];
            },
            only: function(X) {
                if (!N(X)) throw Error("React.Children.only expected to receive a single React element child.");
                return X;
            }
        }, on.Component = y, on.Fragment = n, on.Profiler = i, on.PureComponent = T, on.StrictMode = r, on.Suspense = c, on.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = oe, on.act = re, on.cloneElement = function(X, ie, he) {
            if (X == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + X + ".");
            var $e = v({}, X.props), je = X.key, He = X.ref, rt = X._owner;
            if (ie != null) {
                if (ie.ref !== void 0 && (He = ie.ref, rt = _.current), ie.key !== void 0 && (je = "" + ie.key), X.type && X.type.defaultProps) var Qe = X.type.defaultProps;
                for(et in ie)D.call(ie, et) && !M.hasOwnProperty(et) && ($e[et] = ie[et] === void 0 && Qe !== void 0 ? Qe[et] : ie[et]);
            }
            var et = arguments.length - 2;
            if (et === 1) $e.children = he;
            else if (1 < et) {
                Qe = Array(et);
                for(var St = 0; St < et; St++)Qe[St] = arguments[St + 2];
                $e.children = Qe;
            }
            return {
                $$typeof: t,
                type: X.type,
                key: je,
                ref: He,
                props: $e,
                _owner: rt
            };
        }, on.createContext = function(X) {
            return X = {
                $$typeof: o,
                _currentValue: X,
                _currentValue2: X,
                _threadCount: 0,
                Provider: null,
                Consumer: null,
                _defaultValue: null,
                _globalName: null
            }, X.Provider = {
                $$typeof: a,
                _context: X
            }, X.Consumer = X;
        }, on.createElement = P, on.createFactory = function(X) {
            var ie = P.bind(null, X);
            return ie.type = X, ie;
        }, on.createRef = function() {
            return {
                current: null
            };
        }, on.forwardRef = function(X) {
            return {
                $$typeof: s,
                render: X
            };
        }, on.isValidElement = N, on.lazy = function(X) {
            return {
                $$typeof: f,
                _payload: {
                    _status: -1,
                    _result: X
                },
                _init: ae
            };
        }, on.memo = function(X, ie) {
            return {
                $$typeof: l,
                type: X,
                compare: ie === void 0 ? null : ie
            };
        }, on.startTransition = function(X) {
            var ie = le.transition;
            le.transition = {};
            try {
                X();
            } finally{
                le.transition = ie;
            }
        }, on.unstable_act = re, on.useCallback = function(X, ie) {
            return ue.current.useCallback(X, ie);
        }, on.useContext = function(X) {
            return ue.current.useContext(X);
        }, on.useDebugValue = function() {}, on.useDeferredValue = function(X) {
            return ue.current.useDeferredValue(X);
        }, on.useEffect = function(X, ie) {
            return ue.current.useEffect(X, ie);
        }, on.useId = function() {
            return ue.current.useId();
        }, on.useImperativeHandle = function(X, ie, he) {
            return ue.current.useImperativeHandle(X, ie, he);
        }, on.useInsertionEffect = function(X, ie) {
            return ue.current.useInsertionEffect(X, ie);
        }, on.useLayoutEffect = function(X, ie) {
            return ue.current.useLayoutEffect(X, ie);
        }, on.useMemo = function(X, ie) {
            return ue.current.useMemo(X, ie);
        }, on.useReducer = function(X, ie, he) {
            return ue.current.useReducer(X, ie, he);
        }, on.useRef = function(X) {
            return ue.current.useRef(X);
        }, on.useState = function(X) {
            return ue.current.useState(X);
        }, on.useSyncExternalStore = function(X, ie, he) {
            return ue.current.useSyncExternalStore(X, ie, he);
        }, on.useTransition = function() {
            return ue.current.useTransition();
        }, on.version = "18.3.1", on;
    }
    var O6;
    function Wd() {
        return O6 || (O6 = 1, Wm.exports = vM()), Wm.exports;
    }
    var I6;
    function yM() {
        if (I6) return kf;
        I6 = 1;
        var t = Wd(), e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = {
            key: !0,
            ref: !0,
            __self: !0,
            __source: !0
        };
        function o(s, c, l) {
            var f, u = {}, g = null, h = null;
            l !== void 0 && (g = "" + l), c.key !== void 0 && (g = "" + c.key), c.ref !== void 0 && (h = c.ref);
            for(f in c)r.call(c, f) && !a.hasOwnProperty(f) && (u[f] = c[f]);
            if (s && s.defaultProps) for(f in c = s.defaultProps, c)u[f] === void 0 && (u[f] = c[f]);
            return {
                $$typeof: e,
                type: s,
                key: g,
                ref: h,
                props: u,
                _owner: i.current
            };
        }
        return kf.Fragment = n, kf.jsx = o, kf.jsxs = o, kf;
    }
    var M6;
    function CM() {
        return M6 || (M6 = 1, Gm.exports = yM()), Gm.exports;
    }
    var ge = CM(), _n = Wd();
    const Rh = Qa(_n);
    var u1 = {}, $m = {
        exports: {}
    }, Ha = {}, zm = {
        exports: {}
    }, jm = {};
    var b6;
    function wM() {
        return b6 || (b6 = 1, function(t) {
            function e(le, oe) {
                var re = le.length;
                le.push(oe);
                e: for(; 0 < re;){
                    var X = re - 1 >>> 1, ie = le[X];
                    if (0 < i(ie, oe)) le[X] = oe, le[re] = ie, re = X;
                    else break e;
                }
            }
            function n(le) {
                return le.length === 0 ? null : le[0];
            }
            function r(le) {
                if (le.length === 0) return null;
                var oe = le[0], re = le.pop();
                if (re !== oe) {
                    le[0] = re;
                    e: for(var X = 0, ie = le.length, he = ie >>> 1; X < he;){
                        var $e = 2 * (X + 1) - 1, je = le[$e], He = $e + 1, rt = le[He];
                        if (0 > i(je, re)) He < ie && 0 > i(rt, je) ? (le[X] = rt, le[He] = re, X = He) : (le[X] = je, le[$e] = re, X = $e);
                        else if (He < ie && 0 > i(rt, re)) le[X] = rt, le[He] = re, X = He;
                        else break e;
                    }
                }
                return oe;
            }
            function i(le, oe) {
                var re = le.sortIndex - oe.sortIndex;
                return re !== 0 ? re : le.id - oe.id;
            }
            if (typeof performance == "object" && typeof performance.now == "function") {
                var a = performance;
                t.unstable_now = function() {
                    return a.now();
                };
            } else {
                var o = Date, s = o.now();
                t.unstable_now = function() {
                    return o.now() - s;
                };
            }
            var c = [], l = [], f = 1, u = null, g = 3, h = !1, v = !1, m = !1, y = typeof setTimeout == "function" ? setTimeout : null, C = typeof clearTimeout == "function" ? clearTimeout : null, T = typeof setImmediate < "u" ? setImmediate : null;
            typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
            function x(le) {
                for(var oe = n(l); oe !== null;){
                    if (oe.callback === null) r(l);
                    else if (oe.startTime <= le) r(l), oe.sortIndex = oe.expirationTime, e(c, oe);
                    else break;
                    oe = n(l);
                }
            }
            function S(le) {
                if (m = !1, x(le), !v) if (n(c) !== null) v = !0, ae(D);
                else {
                    var oe = n(l);
                    oe !== null && ue(S, oe.startTime - le);
                }
            }
            function D(le, oe) {
                v = !1, m && (m = !1, C(P), P = -1), h = !0;
                var re = g;
                try {
                    for(x(oe), u = n(c); u !== null && (!(u.expirationTime > oe) || le && !B());){
                        var X = u.callback;
                        if (typeof X == "function") {
                            u.callback = null, g = u.priorityLevel;
                            var ie = X(u.expirationTime <= oe);
                            oe = t.unstable_now(), typeof ie == "function" ? u.callback = ie : u === n(c) && r(c), x(oe);
                        } else r(c);
                        u = n(c);
                    }
                    if (u !== null) var he = !0;
                    else {
                        var $e = n(l);
                        $e !== null && ue(S, $e.startTime - oe), he = !1;
                    }
                    return he;
                } finally{
                    u = null, g = re, h = !1;
                }
            }
            var _ = !1, M = null, P = -1, F = 5, N = -1;
            function B() {
                return !(t.unstable_now() - N < F);
            }
            function G() {
                if (M !== null) {
                    var le = t.unstable_now();
                    N = le;
                    var oe = !0;
                    try {
                        oe = M(!0, le);
                    } finally{
                        oe ? Z() : (_ = !1, M = null);
                    }
                } else _ = !1;
            }
            var Z;
            if (typeof T == "function") Z = function() {
                T(G);
            };
            else if (typeof MessageChannel < "u") {
                var H = new MessageChannel, ne = H.port2;
                H.port1.onmessage = G, Z = function() {
                    ne.postMessage(null);
                };
            } else Z = function() {
                y(G, 0);
            };
            function ae(le) {
                M = le, _ || (_ = !0, Z());
            }
            function ue(le, oe) {
                P = y(function() {
                    le(t.unstable_now());
                }, oe);
            }
            t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(le) {
                le.callback = null;
            }, t.unstable_continueExecution = function() {
                v || h || (v = !0, ae(D));
            }, t.unstable_forceFrameRate = function(le) {
                0 > le || 125 < le ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < le ? Math.floor(1e3 / le) : 5;
            }, t.unstable_getCurrentPriorityLevel = function() {
                return g;
            }, t.unstable_getFirstCallbackNode = function() {
                return n(c);
            }, t.unstable_next = function(le) {
                switch(g){
                    case 1:
                    case 2:
                    case 3:
                        var oe = 3;
                        break;
                    default:
                        oe = g;
                }
                var re = g;
                g = oe;
                try {
                    return le();
                } finally{
                    g = re;
                }
            }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(le, oe) {
                switch(le){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        le = 3;
                }
                var re = g;
                g = le;
                try {
                    return oe();
                } finally{
                    g = re;
                }
            }, t.unstable_scheduleCallback = function(le, oe, re) {
                var X = t.unstable_now();
                switch(typeof re == "object" && re !== null ? (re = re.delay, re = typeof re == "number" && 0 < re ? X + re : X) : re = X, le){
                    case 1:
                        var ie = -1;
                        break;
                    case 2:
                        ie = 250;
                        break;
                    case 5:
                        ie = 1073741823;
                        break;
                    case 4:
                        ie = 1e4;
                        break;
                    default:
                        ie = 5e3;
                }
                return ie = re + ie, le = {
                    id: f++,
                    callback: oe,
                    priorityLevel: le,
                    startTime: re,
                    expirationTime: ie,
                    sortIndex: -1
                }, re > X ? (le.sortIndex = re, e(l, le), n(c) === null && le === n(l) && (m ? (C(P), P = -1) : m = !0, ue(S, re - X))) : (le.sortIndex = ie, e(c, le), v || h || (v = !0, ae(D))), le;
            }, t.unstable_shouldYield = B, t.unstable_wrapCallback = function(le) {
                var oe = g;
                return function() {
                    var re = g;
                    g = oe;
                    try {
                        return le.apply(this, arguments);
                    } finally{
                        g = re;
                    }
                };
            };
        }(jm)), jm;
    }
    var L6;
    function TM() {
        return L6 || (L6 = 1, zm.exports = wM()), zm.exports;
    }
    var P6;
    function xM() {
        if (P6) return Ha;
        P6 = 1;
        var t = Wd(), e = TM();
        function n(d) {
            for(var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + d, w = 1; w < arguments.length; w++)p += "&args[]=" + encodeURIComponent(arguments[w]);
            return "Minified React error #" + d + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var r = new Set, i = {};
        function a(d, p) {
            o(d, p), o(d + "Capture", p);
        }
        function o(d, p) {
            for(i[d] = p, d = 0; d < p.length; d++)r.add(p[d]);
        }
        var s = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), c = Object.prototype.hasOwnProperty, l = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, f = {}, u = {};
        function g(d) {
            return c.call(u, d) ? !0 : c.call(f, d) ? !1 : l.test(d) ? u[d] = !0 : (f[d] = !0, !1);
        }
        function h(d, p, w, E) {
            if (w !== null && w.type === 0) return !1;
            switch(typeof p){
                case "function":
                case "symbol":
                    return !0;
                case "boolean":
                    return E ? !1 : w !== null ? !w.acceptsBooleans : (d = d.toLowerCase().slice(0, 5), d !== "data-" && d !== "aria-");
                default:
                    return !1;
            }
        }
        function v(d, p, w, E) {
            if (p === null || typeof p > "u" || h(d, p, w, E)) return !0;
            if (E) return !1;
            if (w !== null) switch(w.type){
                case 3:
                    return !p;
                case 4:
                    return p === !1;
                case 5:
                    return isNaN(p);
                case 6:
                    return isNaN(p) || 1 > p;
            }
            return !1;
        }
        function m(d, p, w, E, O, b, j) {
            this.acceptsBooleans = p === 2 || p === 3 || p === 4, this.attributeName = E, this.attributeNamespace = O, this.mustUseProperty = w, this.propertyName = d, this.type = p, this.sanitizeURL = b, this.removeEmptyString = j;
        }
        var y = {};
        "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d) {
            y[d] = new m(d, 0, !1, d, null, !1, !1);
        }), [
            [
                "acceptCharset",
                "accept-charset"
            ],
            [
                "className",
                "class"
            ],
            [
                "htmlFor",
                "for"
            ],
            [
                "httpEquiv",
                "http-equiv"
            ]
        ].forEach(function(d) {
            var p = d[0];
            y[p] = new m(p, 1, !1, d[1], null, !1, !1);
        }), [
            "contentEditable",
            "draggable",
            "spellCheck",
            "value"
        ].forEach(function(d) {
            y[d] = new m(d, 2, !1, d.toLowerCase(), null, !1, !1);
        }), [
            "autoReverse",
            "externalResourcesRequired",
            "focusable",
            "preserveAlpha"
        ].forEach(function(d) {
            y[d] = new m(d, 2, !1, d, null, !1, !1);
        }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d) {
            y[d] = new m(d, 3, !1, d.toLowerCase(), null, !1, !1);
        }), [
            "checked",
            "multiple",
            "muted",
            "selected"
        ].forEach(function(d) {
            y[d] = new m(d, 3, !0, d, null, !1, !1);
        }), [
            "capture",
            "download"
        ].forEach(function(d) {
            y[d] = new m(d, 4, !1, d, null, !1, !1);
        }), [
            "cols",
            "rows",
            "size",
            "span"
        ].forEach(function(d) {
            y[d] = new m(d, 6, !1, d, null, !1, !1);
        }), [
            "rowSpan",
            "start"
        ].forEach(function(d) {
            y[d] = new m(d, 5, !1, d.toLowerCase(), null, !1, !1);
        });
        var C = /[\-:]([a-z])/g;
        function T(d) {
            return d[1].toUpperCase();
        }
        "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d) {
            var p = d.replace(C, T);
            y[p] = new m(p, 1, !1, d, null, !1, !1);
        }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d) {
            var p = d.replace(C, T);
            y[p] = new m(p, 1, !1, d, "http://www.w3.org/1999/xlink", !1, !1);
        }), [
            "xml:base",
            "xml:lang",
            "xml:space"
        ].forEach(function(d) {
            var p = d.replace(C, T);
            y[p] = new m(p, 1, !1, d, "http://www.w3.org/XML/1998/namespace", !1, !1);
        }), [
            "tabIndex",
            "crossOrigin"
        ].forEach(function(d) {
            y[d] = new m(d, 1, !1, d.toLowerCase(), null, !1, !1);
        }), y.xlinkHref = new m("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), [
            "src",
            "href",
            "action",
            "formAction"
        ].forEach(function(d) {
            y[d] = new m(d, 1, !1, d.toLowerCase(), null, !0, !0);
        });
        function x(d, p, w, E) {
            var O = y.hasOwnProperty(p) ? y[p] : null;
            (O !== null ? O.type !== 0 : E || !(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (v(p, w, O, E) && (w = null), E || O === null ? g(p) && (w === null ? d.removeAttribute(p) : d.setAttribute(p, "" + w)) : O.mustUseProperty ? d[O.propertyName] = w === null ? O.type === 3 ? !1 : "" : w : (p = O.attributeName, E = O.attributeNamespace, w === null ? d.removeAttribute(p) : (O = O.type, w = O === 3 || O === 4 && w === !0 ? "" : "" + w, E ? d.setAttributeNS(E, p, w) : d.setAttribute(p, w))));
        }
        var S = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, D = Symbol.for("react.element"), _ = Symbol.for("react.portal"), M = Symbol.for("react.fragment"), P = Symbol.for("react.strict_mode"), F = Symbol.for("react.profiler"), N = Symbol.for("react.provider"), B = Symbol.for("react.context"), G = Symbol.for("react.forward_ref"), Z = Symbol.for("react.suspense"), H = Symbol.for("react.suspense_list"), ne = Symbol.for("react.memo"), ae = Symbol.for("react.lazy"), ue = Symbol.for("react.offscreen"), le = Symbol.iterator;
        function oe(d) {
            return d === null || typeof d != "object" ? null : (d = le && d[le] || d["@@iterator"], typeof d == "function" ? d : null);
        }
        var re = Object.assign, X;
        function ie(d) {
            if (X === void 0) try {
                throw Error();
            } catch (w) {
                var p = w.stack.trim().match(/\n( *(at )?)/);
                X = p && p[1] || "";
            }
            return `
` + X + d;
        }
        var he = !1;
        function $e(d, p) {
            if (!d || he) return "";
            he = !0;
            var w = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                if (p) if (p = function() {
                    throw Error();
                }, Object.defineProperty(p.prototype, "props", {
                    set: function() {
                        throw Error();
                    }
                }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(p, []);
                    } catch (Ie) {
                        var E = Ie;
                    }
                    Reflect.construct(d, [], p);
                } else {
                    try {
                        p.call();
                    } catch (Ie) {
                        E = Ie;
                    }
                    d.call(p.prototype);
                }
                else {
                    try {
                        throw Error();
                    } catch (Ie) {
                        E = Ie;
                    }
                    d();
                }
            } catch (Ie) {
                if (Ie && E && typeof Ie.stack == "string") {
                    for(var O = Ie.stack.split(`
`), b = E.stack.split(`
`), j = O.length - 1, fe = b.length - 1; 1 <= j && 0 <= fe && O[j] !== b[fe];)fe--;
                    for(; 1 <= j && 0 <= fe; j--, fe--)if (O[j] !== b[fe]) {
                        if (j !== 1 || fe !== 1) do if (j--, fe--, 0 > fe || O[j] !== b[fe]) {
                            var ve = `
` + O[j].replace(" at new ", " at ");
                            return d.displayName && ve.includes("<anonymous>") && (ve = ve.replace("<anonymous>", d.displayName)), ve;
                        }
                        while (1 <= j && 0 <= fe);
                        break;
                    }
                }
            } finally{
                he = !1, Error.prepareStackTrace = w;
            }
            return (d = d ? d.displayName || d.name : "") ? ie(d) : "";
        }
        function je(d) {
            switch(d.tag){
                case 5:
                    return ie(d.type);
                case 16:
                    return ie("Lazy");
                case 13:
                    return ie("Suspense");
                case 19:
                    return ie("SuspenseList");
                case 0:
                case 2:
                case 15:
                    return d = $e(d.type, !1), d;
                case 11:
                    return d = $e(d.type.render, !1), d;
                case 1:
                    return d = $e(d.type, !0), d;
                default:
                    return "";
            }
        }
        function He(d) {
            if (d == null) return null;
            if (typeof d == "function") return d.displayName || d.name || null;
            if (typeof d == "string") return d;
            switch(d){
                case M:
                    return "Fragment";
                case _:
                    return "Portal";
                case F:
                    return "Profiler";
                case P:
                    return "StrictMode";
                case Z:
                    return "Suspense";
                case H:
                    return "SuspenseList";
            }
            if (typeof d == "object") switch(d.$$typeof){
                case B:
                    return (d.displayName || "Context") + ".Consumer";
                case N:
                    return (d._context.displayName || "Context") + ".Provider";
                case G:
                    var p = d.render;
                    return d = d.displayName, d || (d = p.displayName || p.name || "", d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"), d;
                case ne:
                    return p = d.displayName || null, p !== null ? p : He(d.type) || "Memo";
                case ae:
                    p = d._payload, d = d._init;
                    try {
                        return He(d(p));
                    } catch  {}
            }
            return null;
        }
        function rt(d) {
            var p = d.type;
            switch(d.tag){
                case 24:
                    return "Cache";
                case 9:
                    return (p.displayName || "Context") + ".Consumer";
                case 10:
                    return (p._context.displayName || "Context") + ".Provider";
                case 18:
                    return "DehydratedFragment";
                case 11:
                    return d = p.render, d = d.displayName || d.name || "", p.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef");
                case 7:
                    return "Fragment";
                case 5:
                    return p;
                case 4:
                    return "Portal";
                case 3:
                    return "Root";
                case 6:
                    return "Text";
                case 16:
                    return He(p);
                case 8:
                    return p === P ? "StrictMode" : "Mode";
                case 22:
                    return "Offscreen";
                case 12:
                    return "Profiler";
                case 21:
                    return "Scope";
                case 13:
                    return "Suspense";
                case 19:
                    return "SuspenseList";
                case 25:
                    return "TracingMarker";
                case 1:
                case 0:
                case 17:
                case 2:
                case 14:
                case 15:
                    if (typeof p == "function") return p.displayName || p.name || null;
                    if (typeof p == "string") return p;
            }
            return null;
        }
        function Qe(d) {
            switch(typeof d){
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                    return d;
                case "object":
                    return d;
                default:
                    return "";
            }
        }
        function et(d) {
            var p = d.type;
            return (d = d.nodeName) && d.toLowerCase() === "input" && (p === "checkbox" || p === "radio");
        }
        function St(d) {
            var p = et(d) ? "checked" : "value", w = Object.getOwnPropertyDescriptor(d.constructor.prototype, p), E = "" + d[p];
            if (!d.hasOwnProperty(p) && typeof w < "u" && typeof w.get == "function" && typeof w.set == "function") {
                var O = w.get, b = w.set;
                return Object.defineProperty(d, p, {
                    configurable: !0,
                    get: function() {
                        return O.call(this);
                    },
                    set: function(j) {
                        E = "" + j, b.call(this, j);
                    }
                }), Object.defineProperty(d, p, {
                    enumerable: w.enumerable
                }), {
                    getValue: function() {
                        return E;
                    },
                    setValue: function(j) {
                        E = "" + j;
                    },
                    stopTracking: function() {
                        d._valueTracker = null, delete d[p];
                    }
                };
            }
        }
        function Ln(d) {
            d._valueTracker || (d._valueTracker = St(d));
        }
        function Nn(d) {
            if (!d) return !1;
            var p = d._valueTracker;
            if (!p) return !0;
            var w = p.getValue(), E = "";
            return d && (E = et(d) ? d.checked ? "true" : "false" : d.value), d = E, d !== w ? (p.setValue(d), !0) : !1;
        }
        function zt(d) {
            if (d = d || (typeof document < "u" ? document : void 0), typeof d > "u") return null;
            try {
                return d.activeElement || d.body;
            } catch  {
                return d.body;
            }
        }
        function Pe(d, p) {
            var w = p.checked;
            return re({}, p, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: void 0,
                checked: w ?? d._wrapperState.initialChecked
            });
        }
        function Ct(d, p) {
            var w = p.defaultValue == null ? "" : p.defaultValue, E = p.checked != null ? p.checked : p.defaultChecked;
            w = Qe(p.value != null ? p.value : w), d._wrapperState = {
                initialChecked: E,
                initialValue: w,
                controlled: p.type === "checkbox" || p.type === "radio" ? p.checked != null : p.value != null
            };
        }
        function yt(d, p) {
            p = p.checked, p != null && x(d, "checked", p, !1);
        }
        function En(d, p) {
            yt(d, p);
            var w = Qe(p.value), E = p.type;
            if (w != null) E === "number" ? (w === 0 && d.value === "" || d.value != w) && (d.value = "" + w) : d.value !== "" + w && (d.value = "" + w);
            else if (E === "submit" || E === "reset") {
                d.removeAttribute("value");
                return;
            }
            p.hasOwnProperty("value") ? Hn(d, p.type, w) : p.hasOwnProperty("defaultValue") && Hn(d, p.type, Qe(p.defaultValue)), p.checked == null && p.defaultChecked != null && (d.defaultChecked = !!p.defaultChecked);
        }
        function ln(d, p, w) {
            if (p.hasOwnProperty("value") || p.hasOwnProperty("defaultValue")) {
                var E = p.type;
                if (!(E !== "submit" && E !== "reset" || p.value !== void 0 && p.value !== null)) return;
                p = "" + d._wrapperState.initialValue, w || p === d.value || (d.value = p), d.defaultValue = p;
            }
            w = d.name, w !== "" && (d.name = ""), d.defaultChecked = !!d._wrapperState.initialChecked, w !== "" && (d.name = w);
        }
        function Hn(d, p, w) {
            (p !== "number" || zt(d.ownerDocument) !== d) && (w == null ? d.defaultValue = "" + d._wrapperState.initialValue : d.defaultValue !== "" + w && (d.defaultValue = "" + w));
        }
        var Un = Array.isArray;
        function q(d, p, w, E) {
            if (d = d.options, p) {
                p = {};
                for(var O = 0; O < w.length; O++)p["$" + w[O]] = !0;
                for(w = 0; w < d.length; w++)O = p.hasOwnProperty("$" + d[w].value), d[w].selected !== O && (d[w].selected = O), O && E && (d[w].defaultSelected = !0);
            } else {
                for(w = "" + Qe(w), p = null, O = 0; O < d.length; O++){
                    if (d[O].value === w) {
                        d[O].selected = !0, E && (d[O].defaultSelected = !0);
                        return;
                    }
                    p !== null || d[O].disabled || (p = d[O]);
                }
                p !== null && (p.selected = !0);
            }
        }
        function Q(d, p) {
            if (p.dangerouslySetInnerHTML != null) throw Error(n(91));
            return re({}, p, {
                value: void 0,
                defaultValue: void 0,
                children: "" + d._wrapperState.initialValue
            });
        }
        function me(d, p) {
            var w = p.value;
            if (w == null) {
                if (w = p.children, p = p.defaultValue, w != null) {
                    if (p != null) throw Error(n(92));
                    if (Un(w)) {
                        if (1 < w.length) throw Error(n(93));
                        w = w[0];
                    }
                    p = w;
                }
                p == null && (p = ""), w = p;
            }
            d._wrapperState = {
                initialValue: Qe(w)
            };
        }
        function J(d, p) {
            var w = Qe(p.value), E = Qe(p.defaultValue);
            w != null && (w = "" + w, w !== d.value && (d.value = w), p.defaultValue == null && d.defaultValue !== w && (d.defaultValue = w)), E != null && (d.defaultValue = "" + E);
        }
        function Ce(d) {
            var p = d.textContent;
            p === d._wrapperState.initialValue && p !== "" && p !== null && (d.value = p);
        }
        function Ue(d) {
            switch(d){
                case "svg":
                    return "http://www.w3.org/2000/svg";
                case "math":
                    return "http://www.w3.org/1998/Math/MathML";
                default:
                    return "http://www.w3.org/1999/xhtml";
            }
        }
        function lt(d, p) {
            return d == null || d === "http://www.w3.org/1999/xhtml" ? Ue(p) : d === "http://www.w3.org/2000/svg" && p === "foreignObject" ? "http://www.w3.org/1999/xhtml" : d;
        }
        var Mt, jt = function(d) {
            return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(p, w, E, O) {
                MSApp.execUnsafeLocalFunction(function() {
                    return d(p, w, E, O);
                });
            } : d;
        }(function(d, p) {
            if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in d) d.innerHTML = p;
            else {
                for(Mt = Mt || document.createElement("div"), Mt.innerHTML = "<svg>" + p.valueOf().toString() + "</svg>", p = Mt.firstChild; d.firstChild;)d.removeChild(d.firstChild);
                for(; p.firstChild;)d.appendChild(p.firstChild);
            }
        });
        function Cn(d, p) {
            if (p) {
                var w = d.firstChild;
                if (w && w === d.lastChild && w.nodeType === 3) {
                    w.nodeValue = p;
                    return;
                }
            }
            d.textContent = p;
        }
        var tn = {
            animationIterationCount: !0,
            aspectRatio: !0,
            borderImageOutset: !0,
            borderImageSlice: !0,
            borderImageWidth: !0,
            boxFlex: !0,
            boxFlexGroup: !0,
            boxOrdinalGroup: !0,
            columnCount: !0,
            columns: !0,
            flex: !0,
            flexGrow: !0,
            flexPositive: !0,
            flexShrink: !0,
            flexNegative: !0,
            flexOrder: !0,
            gridArea: !0,
            gridRow: !0,
            gridRowEnd: !0,
            gridRowSpan: !0,
            gridRowStart: !0,
            gridColumn: !0,
            gridColumnEnd: !0,
            gridColumnSpan: !0,
            gridColumnStart: !0,
            fontWeight: !0,
            lineClamp: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            tabSize: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0,
            fillOpacity: !0,
            floodOpacity: !0,
            stopOpacity: !0,
            strokeDasharray: !0,
            strokeDashoffset: !0,
            strokeMiterlimit: !0,
            strokeOpacity: !0,
            strokeWidth: !0
        }, Mr = [
            "Webkit",
            "ms",
            "Moz",
            "O"
        ];
        Object.keys(tn).forEach(function(d) {
            Mr.forEach(function(p) {
                p = p + d.charAt(0).toUpperCase() + d.substring(1), tn[p] = tn[d];
            });
        });
        function Yt(d, p, w) {
            return p == null || typeof p == "boolean" || p === "" ? "" : w || typeof p != "number" || p === 0 || tn.hasOwnProperty(d) && tn[d] ? ("" + p).trim() : p + "px";
        }
        function mn(d, p) {
            d = d.style;
            for(var w in p)if (p.hasOwnProperty(w)) {
                var E = w.indexOf("--") === 0, O = Yt(w, p[w], E);
                w === "float" && (w = "cssFloat"), E ? d.setProperty(w, O) : d[w] = O;
            }
        }
        var Tn = re({
            menuitem: !0
        }, {
            area: !0,
            base: !0,
            br: !0,
            col: !0,
            embed: !0,
            hr: !0,
            img: !0,
            input: !0,
            keygen: !0,
            link: !0,
            meta: !0,
            param: !0,
            source: !0,
            track: !0,
            wbr: !0
        });
        function De(d, p) {
            if (p) {
                if (Tn[d] && (p.children != null || p.dangerouslySetInnerHTML != null)) throw Error(n(137, d));
                if (p.dangerouslySetInnerHTML != null) {
                    if (p.children != null) throw Error(n(60));
                    if (typeof p.dangerouslySetInnerHTML != "object" || !("__html" in p.dangerouslySetInnerHTML)) throw Error(n(61));
                }
                if (p.style != null && typeof p.style != "object") throw Error(n(62));
            }
        }
        function ze(d, p) {
            if (d.indexOf("-") === -1) return typeof p.is == "string";
            switch(d){
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0;
            }
        }
        var ft = null;
        function nn(d) {
            return d = d.target || d.srcElement || window, d.correspondingUseElement && (d = d.correspondingUseElement), d.nodeType === 3 ? d.parentNode : d;
        }
        var Gr = null, ir = null, dr = null;
        function br(d) {
            if (d = xf(d)) {
                if (typeof Gr != "function") throw Error(n(280));
                var p = d.stateNode;
                p && (p = Dg(p), Gr(d.stateNode, d.type, p));
            }
        }
        function pa(d) {
            ir ? dr ? dr.push(d) : dr = [
                d
            ] : ir = d;
        }
        function Lr() {
            if (ir) {
                var d = ir, p = dr;
                if (dr = ir = null, br(d), p) for(d = 0; d < p.length; d++)br(p[d]);
            }
        }
        function Pr(d, p) {
            return d(p);
        }
        function Hi() {}
        var Li = !1;
        function Fn(d, p, w) {
            if (Li) return d(p, w);
            Li = !0;
            try {
                return Pr(d, p, w);
            } finally{
                Li = !1, (ir !== null || dr !== null) && (Hi(), Lr());
            }
        }
        function ci(d, p) {
            var w = d.stateNode;
            if (w === null) return null;
            var E = Dg(w);
            if (E === null) return null;
            w = E[p];
            e: switch(p){
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (E = !E.disabled) || (d = d.type, E = !(d === "button" || d === "input" || d === "select" || d === "textarea")), d = !E;
                    break e;
                default:
                    d = !1;
            }
            if (d) return null;
            if (w && typeof w != "function") throw Error(n(231, p, typeof w));
            return w;
        }
        var _t = !1;
        if (s) try {
            var Ht = {};
            Object.defineProperty(Ht, "passive", {
                get: function() {
                    _t = !0;
                }
            }), window.addEventListener("test", Ht, Ht), window.removeEventListener("test", Ht, Ht);
        } catch  {
            _t = !1;
        }
        function kt(d, p, w, E, O, b, j, fe, ve) {
            var Ie = Array.prototype.slice.call(arguments, 3);
            try {
                p.apply(w, Ie);
            } catch (Ye) {
                this.onError(Ye);
            }
        }
        var It = !1, pr = null, Zr = !1, to = null, _o = {
            onError: function(d) {
                It = !0, pr = d;
            }
        };
        function ma(d, p, w, E, O, b, j, fe, ve) {
            It = !1, pr = null, kt.apply(_o, arguments);
        }
        function no(d, p, w, E, O, b, j, fe, ve) {
            if (ma.apply(this, arguments), It) {
                if (It) {
                    var Ie = pr;
                    It = !1, pr = null;
                } else throw Error(n(198));
                Zr || (Zr = !0, to = Ie);
            }
        }
        function xi(d) {
            var p = d, w = d;
            if (d.alternate) for(; p.return;)p = p.return;
            else {
                d = p;
                do p = d, (p.flags & 4098) !== 0 && (w = p.return), d = p.return;
                while (d);
            }
            return p.tag === 3 ? w : null;
        }
        function Kn(d) {
            if (d.tag === 13) {
                var p = d.memoizedState;
                if (p === null && (d = d.alternate, d !== null && (p = d.memoizedState)), p !== null) return p.dehydrated;
            }
            return null;
        }
        function Pi(d) {
            if (xi(d) !== d) throw Error(n(188));
        }
        function Kt(d) {
            var p = d.alternate;
            if (!p) {
                if (p = xi(d), p === null) throw Error(n(188));
                return p !== d ? null : d;
            }
            for(var w = d, E = p;;){
                var O = w.return;
                if (O === null) break;
                var b = O.alternate;
                if (b === null) {
                    if (E = O.return, E !== null) {
                        w = E;
                        continue;
                    }
                    break;
                }
                if (O.child === b.child) {
                    for(b = O.child; b;){
                        if (b === w) return Pi(O), d;
                        if (b === E) return Pi(O), p;
                        b = b.sibling;
                    }
                    throw Error(n(188));
                }
                if (w.return !== E.return) w = O, E = b;
                else {
                    for(var j = !1, fe = O.child; fe;){
                        if (fe === w) {
                            j = !0, w = O, E = b;
                            break;
                        }
                        if (fe === E) {
                            j = !0, E = O, w = b;
                            break;
                        }
                        fe = fe.sibling;
                    }
                    if (!j) {
                        for(fe = b.child; fe;){
                            if (fe === w) {
                                j = !0, w = b, E = O;
                                break;
                            }
                            if (fe === E) {
                                j = !0, E = b, w = O;
                                break;
                            }
                            fe = fe.sibling;
                        }
                        if (!j) throw Error(n(189));
                    }
                }
                if (w.alternate !== E) throw Error(n(190));
            }
            if (w.tag !== 3) throw Error(n(188));
            return w.stateNode.current === w ? d : p;
        }
        function mr(d) {
            return d = Kt(d), d !== null ? Ro(d) : null;
        }
        function Ro(d) {
            if (d.tag === 5 || d.tag === 6) return d;
            for(d = d.child; d !== null;){
                var p = Ro(d);
                if (p !== null) return p;
                d = d.sibling;
            }
            return null;
        }
        var Si = e.unstable_scheduleCallback, Ki = e.unstable_cancelCallback, Vi = e.unstable_shouldYield, li = e.unstable_requestPaint, Pn = e.unstable_now, ro = e.unstable_getCurrentPriorityLevel, ui = e.unstable_ImmediatePriority, Qo = e.unstable_UserBlockingPriority, Jr = e.unstable_NormalPriority, Oo = e.unstable_LowPriority, Pa = e.unstable_IdlePriority, Qr = null, ei = null;
        function io(d) {
            if (ei && typeof ei.onCommitFiberRoot == "function") try {
                ei.onCommitFiberRoot(Qr, d, void 0, (d.current.flags & 128) === 128);
            } catch  {}
        }
        var qn = Math.clz32 ? Math.clz32 : Ni, _s = Math.log, Wr = Math.LN2;
        function Ni(d) {
            return d >>>= 0, d === 0 ? 32 : 31 - (_s(d) / Wr | 0) | 0;
        }
        var va = 64, ya = 4194304;
        function Ca(d) {
            switch(d & -d){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return d & 4194240;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    return d & 130023424;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 1073741824;
                default:
                    return d;
            }
        }
        function Ei(d, p) {
            var w = d.pendingLanes;
            if (w === 0) return 0;
            var E = 0, O = d.suspendedLanes, b = d.pingedLanes, j = w & 268435455;
            if (j !== 0) {
                var fe = j & ~O;
                fe !== 0 ? E = Ca(fe) : (b &= j, b !== 0 && (E = Ca(b)));
            } else j = w & ~O, j !== 0 ? E = Ca(j) : b !== 0 && (E = Ca(b));
            if (E === 0) return 0;
            if (p !== 0 && p !== E && (p & O) === 0 && (O = E & -E, b = p & -p, O >= b || O === 16 && (b & 4194240) !== 0)) return p;
            if ((E & 4) !== 0 && (E |= w & 16), p = d.entangledLanes, p !== 0) for(d = d.entanglements, p &= E; 0 < p;)w = 31 - qn(p), O = 1 << w, E |= d[w], p &= ~O;
            return E;
        }
        function dc(d, p) {
            switch(d){
                case 1:
                case 2:
                case 4:
                    return p + 250;
                case 8:
                case 16:
                case 32:
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return p + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                    return -1;
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function gc(d, p) {
            for(var w = d.suspendedLanes, E = d.pingedLanes, O = d.expirationTimes, b = d.pendingLanes; 0 < b;){
                var j = 31 - qn(b), fe = 1 << j, ve = O[j];
                ve === -1 ? ((fe & w) === 0 || (fe & E) !== 0) && (O[j] = dc(fe, p)) : ve <= p && (d.expiredLanes |= fe), b &= ~fe;
            }
        }
        function es(d) {
            return d = d.pendingLanes & -1073741825, d !== 0 ? d : d & 1073741824 ? 1073741824 : 0;
        }
        function Rs() {
            var d = va;
            return va <<= 1, (va & 4194240) === 0 && (va = 64), d;
        }
        function fi(d) {
            for(var p = [], w = 0; 31 > w; w++)p.push(d);
            return p;
        }
        function $r(d, p, w) {
            d.pendingLanes |= p, p !== 536870912 && (d.suspendedLanes = 0, d.pingedLanes = 0), d = d.eventTimes, p = 31 - qn(p), d[p] = w;
        }
        function Di(d, p) {
            var w = d.pendingLanes & ~p;
            d.pendingLanes = p, d.suspendedLanes = 0, d.pingedLanes = 0, d.expiredLanes &= p, d.mutableReadLanes &= p, d.entangledLanes &= p, p = d.entanglements;
            var E = d.eventTimes;
            for(d = d.expirationTimes; 0 < w;){
                var O = 31 - qn(w), b = 1 << O;
                p[O] = 0, E[O] = -1, d[O] = -1, w &= ~b;
            }
        }
        function vr(d, p) {
            var w = d.entangledLanes |= p;
            for(d = d.entanglements; w;){
                var E = 31 - qn(w), O = 1 << E;
                O & p | d[E] & p && (d[E] |= p), w &= ~O;
            }
        }
        var an = 0;
        function wa(d) {
            return d &= -d, 1 < d ? 4 < d ? (d & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
        }
        var Va, Bn, ts, ti, yr, ao = !1, Ai = [], Xn = null, ni = null, ki = null, Na = new Map, qi = new Map, un = [], oo = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
        function Cr(d, p) {
            switch(d){
                case "focusin":
                case "focusout":
                    Xn = null;
                    break;
                case "dragenter":
                case "dragleave":
                    ni = null;
                    break;
                case "mouseover":
                case "mouseout":
                    ki = null;
                    break;
                case "pointerover":
                case "pointerout":
                    Na.delete(p.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    qi.delete(p.pointerId);
            }
        }
        function Gn(d, p, w, E, O, b) {
            return d === null || d.nativeEvent !== b ? (d = {
                blockedOn: p,
                domEventName: w,
                eventSystemFlags: E,
                nativeEvent: b,
                targetContainers: [
                    O
                ]
            }, p !== null && (p = xf(p), p !== null && Bn(p)), d) : (d.eventSystemFlags |= E, p = d.targetContainers, O !== null && p.indexOf(O) === -1 && p.push(O), d);
        }
        function Os(d, p, w, E, O) {
            switch(p){
                case "focusin":
                    return Xn = Gn(Xn, d, p, w, E, O), !0;
                case "dragenter":
                    return ni = Gn(ni, d, p, w, E, O), !0;
                case "mouseover":
                    return ki = Gn(ki, d, p, w, E, O), !0;
                case "pointerover":
                    var b = O.pointerId;
                    return Na.set(b, Gn(Na.get(b) || null, d, p, w, E, O)), !0;
                case "gotpointercapture":
                    return b = O.pointerId, qi.set(b, Gn(qi.get(b) || null, d, p, w, E, O)), !0;
            }
            return !1;
        }
        function di(d) {
            var p = e0(d.target);
            if (p !== null) {
                var w = xi(p);
                if (w !== null) {
                    if (p = w.tag, p === 13) {
                        if (p = Kn(w), p !== null) {
                            d.blockedOn = p, yr(d.priority, function() {
                                ts(w);
                            });
                            return;
                        }
                    } else if (p === 3 && w.stateNode.current.memoizedState.isDehydrated) {
                        d.blockedOn = w.tag === 3 ? w.stateNode.containerInfo : null;
                        return;
                    }
                }
            }
            d.blockedOn = null;
        }
        function Io(d) {
            if (d.blockedOn !== null) return !1;
            for(var p = d.targetContainers; 0 < p.length;){
                var w = bo(d.domEventName, d.eventSystemFlags, p[0], d.nativeEvent);
                if (w === null) {
                    w = d.nativeEvent;
                    var E = new w.constructor(w.type, w);
                    ft = E, w.target.dispatchEvent(E), ft = null;
                } else return p = xf(w), p !== null && Bn(p), d.blockedOn = w, !1;
                p.shift();
            }
            return !0;
        }
        function zr(d, p, w) {
            Io(d) && w.delete(p);
        }
        function Xi() {
            ao = !1, Xn !== null && Io(Xn) && (Xn = null), ni !== null && Io(ni) && (ni = null), ki !== null && Io(ki) && (ki = null), Na.forEach(zr), qi.forEach(zr);
        }
        function Ta(d, p) {
            d.blockedOn === p && (d.blockedOn = null, ao || (ao = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Xi)));
        }
        function Ui(d) {
            function p(O) {
                return Ta(O, d);
            }
            if (0 < Ai.length) {
                Ta(Ai[0], d);
                for(var w = 1; w < Ai.length; w++){
                    var E = Ai[w];
                    E.blockedOn === d && (E.blockedOn = null);
                }
            }
            for(Xn !== null && Ta(Xn, d), ni !== null && Ta(ni, d), ki !== null && Ta(ki, d), Na.forEach(p), qi.forEach(p), w = 0; w < un.length; w++)E = un[w], E.blockedOn === d && (E.blockedOn = null);
            for(; 0 < un.length && (w = un[0], w.blockedOn === null);)di(w), w.blockedOn === null && un.shift();
        }
        var gr = S.ReactCurrentBatchConfig, so = !0;
        function hc(d, p, w, E) {
            var O = an, b = gr.transition;
            gr.transition = null;
            try {
                an = 1, Mo(d, p, w, E);
            } finally{
                an = O, gr.transition = b;
            }
        }
        function pc(d, p, w, E) {
            var O = an, b = gr.transition;
            gr.transition = null;
            try {
                an = 4, Mo(d, p, w, E);
            } finally{
                an = O, gr.transition = b;
            }
        }
        function Mo(d, p, w, E) {
            if (so) {
                var O = bo(d, p, w, E);
                if (O === null) b2(d, p, E, Yi, w), Cr(d, E);
                else if (Os(O, d, p, w, E)) E.stopPropagation();
                else if (Cr(d, E), p & 4 && -1 < oo.indexOf(d)) {
                    for(; O !== null;){
                        var b = xf(O);
                        if (b !== null && Va(b), b = bo(d, p, w, E), b === null && b2(d, p, E, Yi, w), b === O) break;
                        O = b;
                    }
                    O !== null && E.stopPropagation();
                } else b2(d, p, E, null, w);
            }
        }
        var Yi = null;
        function bo(d, p, w, E) {
            if (Yi = null, d = nn(E), d = e0(d), d !== null) if (p = xi(d), p === null) d = null;
            else if (w = p.tag, w === 13) {
                if (d = Kn(p), d !== null) return d;
                d = null;
            } else if (w === 3) {
                if (p.stateNode.current.memoizedState.isDehydrated) return p.tag === 3 ? p.stateNode.containerInfo : null;
                d = null;
            } else p !== d && (d = null);
            return Yi = d, null;
        }
        function Lo(d) {
            switch(d){
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 1;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "toggle":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 4;
                case "message":
                    switch(ro()){
                        case ui:
                            return 1;
                        case Qo:
                            return 4;
                        case Jr:
                        case Oo:
                            return 16;
                        case Pa:
                            return 536870912;
                        default:
                            return 16;
                    }
                default:
                    return 16;
            }
        }
        var Zi = null, ns = null, Po = null;
        function Is() {
            if (Po) return Po;
            var d, p = ns, w = p.length, E, O = "value" in Zi ? Zi.value : Zi.textContent, b = O.length;
            for(d = 0; d < w && p[d] === O[d]; d++);
            var j = w - d;
            for(E = 1; E <= j && p[w - E] === O[b - E]; E++);
            return Po = O.slice(d, 1 < E ? 1 - E : void 0);
        }
        function Vo(d) {
            var p = d.keyCode;
            return "charCode" in d ? (d = d.charCode, d === 0 && p === 13 && (d = 13)) : d = p, d === 10 && (d = 13), 32 <= d || d === 13 ? d : 0;
        }
        function No() {
            return !0;
        }
        function Ms() {
            return !1;
        }
        function Vr(d) {
            function p(w, E, O, b, j) {
                this._reactName = w, this._targetInst = O, this.type = E, this.nativeEvent = b, this.target = j, this.currentTarget = null;
                for(var fe in d)d.hasOwnProperty(fe) && (w = d[fe], this[fe] = w ? w(b) : b[fe]);
                return this.isDefaultPrevented = (b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1) ? No : Ms, this.isPropagationStopped = Ms, this;
            }
            return re(p.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                    var w = this.nativeEvent;
                    w && (w.preventDefault ? w.preventDefault() : typeof w.returnValue != "unknown" && (w.returnValue = !1), this.isDefaultPrevented = No);
                },
                stopPropagation: function() {
                    var w = this.nativeEvent;
                    w && (w.stopPropagation ? w.stopPropagation() : typeof w.cancelBubble != "unknown" && (w.cancelBubble = !0), this.isPropagationStopped = No);
                },
                persist: function() {},
                isPersistent: No
            }), p;
        }
        var Aa = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(d) {
                return d.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        }, Ao = Vr(Aa), ka = re({}, Aa, {
            view: 0,
            detail: 0
        }), mc = Vr(ka), co, ko, Ua, Fa = re({}, ka, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: lo,
            button: 0,
            buttons: 0,
            relatedTarget: function(d) {
                return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget;
            },
            movementX: function(d) {
                return "movementX" in d ? d.movementX : (d !== Ua && (Ua && d.type === "mousemove" ? (co = d.screenX - Ua.screenX, ko = d.screenY - Ua.screenY) : ko = co = 0, Ua = d), co);
            },
            movementY: function(d) {
                return "movementY" in d ? d.movementY : ko;
            }
        }), bs = Vr(Fa), Ls = re({}, Fa, {
            dataTransfer: 0
        }), vc = Vr(Ls), Ps = re({}, ka, {
            relatedTarget: 0
        }), rs = Vr(Ps), yc = re({}, Aa, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), Cc = Vr(yc), wc = re({}, Aa, {
            clipboardData: function(d) {
                return "clipboardData" in d ? d.clipboardData : window.clipboardData;
            }
        }), is = Vr(wc), as = re({}, Aa, {
            data: 0
        }), Ji = Vr(as), Ba = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, Fi = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, Vs = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function Ns(d) {
            var p = this.nativeEvent;
            return p.getModifierState ? p.getModifierState(d) : (d = Vs[d]) ? !!p[d] : !1;
        }
        function lo() {
            return Ns;
        }
        var As = re({}, ka, {
            key: function(d) {
                if (d.key) {
                    var p = Ba[d.key] || d.key;
                    if (p !== "Unidentified") return p;
                }
                return d.type === "keypress" ? (d = Vo(d), d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? Fi[d.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: lo,
            charCode: function(d) {
                return d.type === "keypress" ? Vo(d) : 0;
            },
            keyCode: function(d) {
                return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
            },
            which: function(d) {
                return d.type === "keypress" ? Vo(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0;
            }
        }), Uo = Vr(As), ks = re({}, Fa, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), W = Vr(ks), $ = re({}, ka, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: lo
        }), ce = Vr($), xe = re({}, Aa, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), Oe = Vr(xe), Ve = re({}, Fa, {
            deltaX: function(d) {
                return "deltaX" in d ? d.deltaX : "wheelDeltaX" in d ? -d.wheelDeltaX : 0;
            },
            deltaY: function(d) {
                return "deltaY" in d ? d.deltaY : "wheelDeltaY" in d ? -d.wheelDeltaY : "wheelDelta" in d ? -d.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        }), Ne = Vr(Ve), Me = [
            9,
            13,
            27,
            32
        ], ke = s && "CompositionEvent" in window, Je = null;
        s && "documentMode" in document && (Je = document.documentMode);
        var mt = s && "TextEvent" in window && !Je, Et = s && (!ke || Je && 8 < Je && 11 >= Je), Rt = " ", U = !1;
        function k(d, p) {
            switch(d){
                case "keyup":
                    return Me.indexOf(p.keyCode) !== -1;
                case "keydown":
                    return p.keyCode !== 229;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1;
            }
        }
        function ee(d) {
            return d = d.detail, typeof d == "object" && "data" in d ? d.data : null;
        }
        var ye = !1;
        function _e(d, p) {
            switch(d){
                case "compositionend":
                    return ee(p);
                case "keypress":
                    return p.which !== 32 ? null : (U = !0, Rt);
                case "textInput":
                    return d = p.data, d === Rt && U ? null : d;
                default:
                    return null;
            }
        }
        function Be(d, p) {
            if (ye) return d === "compositionend" || !ke && k(d, p) ? (d = Is(), Po = ns = Zi = null, ye = !1, d) : null;
            switch(d){
                case "paste":
                    return null;
                case "keypress":
                    if (!(p.ctrlKey || p.altKey || p.metaKey) || p.ctrlKey && p.altKey) {
                        if (p.char && 1 < p.char.length) return p.char;
                        if (p.which) return String.fromCharCode(p.which);
                    }
                    return null;
                case "compositionend":
                    return Et && p.locale !== "ko" ? null : p.data;
                default:
                    return null;
            }
        }
        var Ae = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };
        function be(d) {
            var p = d && d.nodeName && d.nodeName.toLowerCase();
            return p === "input" ? !!Ae[d.type] : p === "textarea";
        }
        function L(d, p, w, E) {
            pa(E), p = xg(p, "onChange"), 0 < p.length && (w = new Ao("onChange", "change", null, w, E), d.push({
                event: w,
                listeners: p
            }));
        }
        var V = null, R = null;
        function I(d) {
            $y(d, 0);
        }
        function A(d) {
            var p = J0(d);
            if (Nn(p)) return d;
        }
        function Y(d, p) {
            if (d === "change") return p;
        }
        var te = !1;
        if (s) {
            var se;
            if (s) {
                var de = "oninput" in document;
                if (!de) {
                    var pe = document.createElement("div");
                    pe.setAttribute("oninput", "return;"), de = typeof pe.oninput == "function";
                }
                se = de;
            } else se = !1;
            te = se && (!document.documentMode || 9 < document.documentMode);
        }
        function Se() {
            V && (V.detachEvent("onpropertychange", Le), R = V = null);
        }
        function Le(d) {
            if (d.propertyName === "value" && A(R)) {
                var p = [];
                L(p, R, d, nn(d)), Fn(I, p);
            }
        }
        function Ze(d, p, w) {
            d === "focusin" ? (Se(), V = p, R = w, V.attachEvent("onpropertychange", Le)) : d === "focusout" && Se();
        }
        function gt(d) {
            if (d === "selectionchange" || d === "keyup" || d === "keydown") return A(R);
        }
        function ut(d, p) {
            if (d === "click") return A(p);
        }
        function At(d, p) {
            if (d === "input" || d === "change") return A(p);
        }
        function Nt(d, p) {
            return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
        }
        var Bt = typeof Object.is == "function" ? Object.is : Nt;
        function Wn(d, p) {
            if (Bt(d, p)) return !0;
            if (typeof d != "object" || d === null || typeof p != "object" || p === null) return !1;
            var w = Object.keys(d), E = Object.keys(p);
            if (w.length !== E.length) return !1;
            for(E = 0; E < w.length; E++){
                var O = w[E];
                if (!c.call(p, O) || !Bt(d[O], p[O])) return !1;
            }
            return !0;
        }
        function wr(d) {
            for(; d && d.firstChild;)d = d.firstChild;
            return d;
        }
        function Us(d, p) {
            var w = wr(d);
            d = 0;
            for(var E; w;){
                if (w.nodeType === 3) {
                    if (E = d + w.textContent.length, d <= p && E >= p) return {
                        node: w,
                        offset: p - d
                    };
                    d = E;
                }
                e: {
                    for(; w;){
                        if (w.nextSibling) {
                            w = w.nextSibling;
                            break e;
                        }
                        w = w.parentNode;
                    }
                    w = void 0;
                }
                w = wr(w);
            }
        }
        function xa(d, p) {
            return d && p ? d === p ? !0 : d && d.nodeType === 3 ? !1 : p && p.nodeType === 3 ? xa(d, p.parentNode) : "contains" in d ? d.contains(p) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(p) & 16) : !1 : !1;
        }
        function Ql() {
            for(var d = window, p = zt(); p instanceof d.HTMLIFrameElement;){
                try {
                    var w = typeof p.contentWindow.location.href == "string";
                } catch  {
                    w = !1;
                }
                if (w) d = p.contentWindow;
                else break;
                p = zt(d.document);
            }
            return p;
        }
        function Tc(d) {
            var p = d && d.nodeName && d.nodeName.toLowerCase();
            return p && (p === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || p === "textarea" || d.contentEditable === "true");
        }
        function vg(d) {
            var p = Ql(), w = d.focusedElem, E = d.selectionRange;
            if (p !== w && w && w.ownerDocument && xa(w.ownerDocument.documentElement, w)) {
                if (E !== null && Tc(w)) {
                    if (p = E.start, d = E.end, d === void 0 && (d = p), "selectionStart" in w) w.selectionStart = p, w.selectionEnd = Math.min(d, w.value.length);
                    else if (d = (p = w.ownerDocument || document) && p.defaultView || window, d.getSelection) {
                        d = d.getSelection();
                        var O = w.textContent.length, b = Math.min(E.start, O);
                        E = E.end === void 0 ? b : Math.min(E.end, O), !d.extend && b > E && (O = E, E = b, b = O), O = Us(w, b);
                        var j = Us(w, E);
                        O && j && (d.rangeCount !== 1 || d.anchorNode !== O.node || d.anchorOffset !== O.offset || d.focusNode !== j.node || d.focusOffset !== j.offset) && (p = p.createRange(), p.setStart(O.node, O.offset), d.removeAllRanges(), b > E ? (d.addRange(p), d.extend(j.node, j.offset)) : (p.setEnd(j.node, j.offset), d.addRange(p)));
                    }
                }
                for(p = [], d = w; d = d.parentNode;)d.nodeType === 1 && p.push({
                    element: d,
                    left: d.scrollLeft,
                    top: d.scrollTop
                });
                for(typeof w.focus == "function" && w.focus(), w = 0; w < p.length; w++)d = p[w], d.element.scrollLeft = d.left, d.element.scrollTop = d.top;
            }
        }
        var yg = s && "documentMode" in document && 11 >= document.documentMode, q0 = null, D2 = null, vf = null, _2 = !1;
        function Vy(d, p, w) {
            var E = w.window === w ? w.document : w.nodeType === 9 ? w : w.ownerDocument;
            _2 || q0 == null || q0 !== zt(E) || (E = q0, "selectionStart" in E && Tc(E) ? E = {
                start: E.selectionStart,
                end: E.selectionEnd
            } : (E = (E.ownerDocument && E.ownerDocument.defaultView || window).getSelection(), E = {
                anchorNode: E.anchorNode,
                anchorOffset: E.anchorOffset,
                focusNode: E.focusNode,
                focusOffset: E.focusOffset
            }), vf && Wn(vf, E) || (vf = E, E = xg(D2, "onSelect"), 0 < E.length && (p = new Ao("onSelect", "select", null, p, w), d.push({
                event: p,
                listeners: E
            }), p.target = q0)));
        }
        function Cg(d, p) {
            var w = {};
            return w[d.toLowerCase()] = p.toLowerCase(), w["Webkit" + d] = "webkit" + p, w["Moz" + d] = "moz" + p, w;
        }
        var X0 = {
            animationend: Cg("Animation", "AnimationEnd"),
            animationiteration: Cg("Animation", "AnimationIteration"),
            animationstart: Cg("Animation", "AnimationStart"),
            transitionend: Cg("Transition", "TransitionEnd")
        }, R2 = {}, Ny = {};
        s && (Ny = document.createElement("div").style, "AnimationEvent" in window || (delete X0.animationend.animation, delete X0.animationiteration.animation, delete X0.animationstart.animation), "TransitionEvent" in window || delete X0.transitionend.transition);
        function wg(d) {
            if (R2[d]) return R2[d];
            if (!X0[d]) return d;
            var p = X0[d], w;
            for(w in p)if (p.hasOwnProperty(w) && w in Ny) return R2[d] = p[w];
            return d;
        }
        var Ay = wg("animationend"), ky = wg("animationiteration"), Uy = wg("animationstart"), Fy = wg("transitionend"), By = new Map, Gy = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        function nl(d, p) {
            By.set(d, p), a(p, [
                d
            ]);
        }
        for(var O2 = 0; O2 < Gy.length; O2++){
            var I2 = Gy[O2], DI = I2.toLowerCase(), _I = I2[0].toUpperCase() + I2.slice(1);
            nl(DI, "on" + _I);
        }
        nl(Ay, "onAnimationEnd"), nl(ky, "onAnimationIteration"), nl(Uy, "onAnimationStart"), nl("dblclick", "onDoubleClick"), nl("focusin", "onFocus"), nl("focusout", "onBlur"), nl(Fy, "onTransitionEnd"), o("onMouseEnter", [
            "mouseout",
            "mouseover"
        ]), o("onMouseLeave", [
            "mouseout",
            "mouseover"
        ]), o("onPointerEnter", [
            "pointerout",
            "pointerover"
        ]), o("onPointerLeave", [
            "pointerout",
            "pointerover"
        ]), a("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), a("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), a("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
        ]), a("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), a("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var yf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), RI = new Set("cancel close invalid load scroll toggle".split(" ").concat(yf));
        function Wy(d, p, w) {
            var E = d.type || "unknown-event";
            d.currentTarget = w, no(E, p, void 0, d), d.currentTarget = null;
        }
        function $y(d, p) {
            p = (p & 4) !== 0;
            for(var w = 0; w < d.length; w++){
                var E = d[w], O = E.event;
                E = E.listeners;
                e: {
                    var b = void 0;
                    if (p) for(var j = E.length - 1; 0 <= j; j--){
                        var fe = E[j], ve = fe.instance, Ie = fe.currentTarget;
                        if (fe = fe.listener, ve !== b && O.isPropagationStopped()) break e;
                        Wy(O, fe, Ie), b = ve;
                    }
                    else for(j = 0; j < E.length; j++){
                        if (fe = E[j], ve = fe.instance, Ie = fe.currentTarget, fe = fe.listener, ve !== b && O.isPropagationStopped()) break e;
                        Wy(O, fe, Ie), b = ve;
                    }
                }
            }
            if (Zr) throw d = to, Zr = !1, to = null, d;
        }
        function ar(d, p) {
            var w = p[k2];
            w === void 0 && (w = p[k2] = new Set);
            var E = d + "__bubble";
            w.has(E) || (zy(p, d, 2, !1), w.add(E));
        }
        function M2(d, p, w) {
            var E = 0;
            p && (E |= 4), zy(w, d, E, p);
        }
        var Tg = "_reactListening" + Math.random().toString(36).slice(2);
        function Cf(d) {
            if (!d[Tg]) {
                d[Tg] = !0, r.forEach(function(w) {
                    w !== "selectionchange" && (RI.has(w) || M2(w, !1, d), M2(w, !0, d));
                });
                var p = d.nodeType === 9 ? d : d.ownerDocument;
                p === null || p[Tg] || (p[Tg] = !0, M2("selectionchange", !1, p));
            }
        }
        function zy(d, p, w, E) {
            switch(Lo(p)){
                case 1:
                    var O = hc;
                    break;
                case 4:
                    O = pc;
                    break;
                default:
                    O = Mo;
            }
            w = O.bind(null, p, w, d), O = void 0, !_t || p !== "touchstart" && p !== "touchmove" && p !== "wheel" || (O = !0), E ? O !== void 0 ? d.addEventListener(p, w, {
                capture: !0,
                passive: O
            }) : d.addEventListener(p, w, !0) : O !== void 0 ? d.addEventListener(p, w, {
                passive: O
            }) : d.addEventListener(p, w, !1);
        }
        function b2(d, p, w, E, O) {
            var b = E;
            if ((p & 1) === 0 && (p & 2) === 0 && E !== null) e: for(;;){
                if (E === null) return;
                var j = E.tag;
                if (j === 3 || j === 4) {
                    var fe = E.stateNode.containerInfo;
                    if (fe === O || fe.nodeType === 8 && fe.parentNode === O) break;
                    if (j === 4) for(j = E.return; j !== null;){
                        var ve = j.tag;
                        if ((ve === 3 || ve === 4) && (ve = j.stateNode.containerInfo, ve === O || ve.nodeType === 8 && ve.parentNode === O)) return;
                        j = j.return;
                    }
                    for(; fe !== null;){
                        if (j = e0(fe), j === null) return;
                        if (ve = j.tag, ve === 5 || ve === 6) {
                            E = b = j;
                            continue e;
                        }
                        fe = fe.parentNode;
                    }
                }
                E = E.return;
            }
            Fn(function() {
                var Ie = b, Ye = nn(w), tt = [];
                e: {
                    var qe = By.get(d);
                    if (qe !== void 0) {
                        var dt = Ao, vt = d;
                        switch(d){
                            case "keypress":
                                if (Vo(w) === 0) break e;
                            case "keydown":
                            case "keyup":
                                dt = Uo;
                                break;
                            case "focusin":
                                vt = "focus", dt = rs;
                                break;
                            case "focusout":
                                vt = "blur", dt = rs;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                dt = rs;
                                break;
                            case "click":
                                if (w.button === 2) break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                dt = bs;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                dt = vc;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                dt = ce;
                                break;
                            case Ay:
                            case ky:
                            case Uy:
                                dt = Cc;
                                break;
                            case Fy:
                                dt = Oe;
                                break;
                            case "scroll":
                                dt = mc;
                                break;
                            case "wheel":
                                dt = Ne;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                dt = is;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                dt = W;
                        }
                        var wt = (p & 4) !== 0, jr = !wt && d === "scroll", Ee = wt ? qe !== null ? qe + "Capture" : null : qe;
                        wt = [];
                        for(var we = Ie, Re; we !== null;){
                            Re = we;
                            var at = Re.stateNode;
                            if (Re.tag === 5 && at !== null && (Re = at, Ee !== null && (at = ci(we, Ee), at != null && wt.push(wf(we, at, Re)))), jr) break;
                            we = we.return;
                        }
                        0 < wt.length && (qe = new dt(qe, vt, null, w, Ye), tt.push({
                            event: qe,
                            listeners: wt
                        }));
                    }
                }
                if ((p & 7) === 0) {
                    e: {
                        if (qe = d === "mouseover" || d === "pointerover", dt = d === "mouseout" || d === "pointerout", qe && w !== ft && (vt = w.relatedTarget || w.fromElement) && (e0(vt) || vt[xc])) break e;
                        if ((dt || qe) && (qe = Ye.window === Ye ? Ye : (qe = Ye.ownerDocument) ? qe.defaultView || qe.parentWindow : window, dt ? (vt = w.relatedTarget || w.toElement, dt = Ie, vt = vt ? e0(vt) : null, vt !== null && (jr = xi(vt), vt !== jr || vt.tag !== 5 && vt.tag !== 6) && (vt = null)) : (dt = null, vt = Ie), dt !== vt)) {
                            if (wt = bs, at = "onMouseLeave", Ee = "onMouseEnter", we = "mouse", (d === "pointerout" || d === "pointerover") && (wt = W, at = "onPointerLeave", Ee = "onPointerEnter", we = "pointer"), jr = dt == null ? qe : J0(dt), Re = vt == null ? qe : J0(vt), qe = new wt(at, we + "leave", dt, w, Ye), qe.target = jr, qe.relatedTarget = Re, at = null, e0(Ye) === Ie && (wt = new wt(Ee, we + "enter", vt, w, Ye), wt.target = Re, wt.relatedTarget = jr, at = wt), jr = at, dt && vt) t: {
                                for(wt = dt, Ee = vt, we = 0, Re = wt; Re; Re = Y0(Re))we++;
                                for(Re = 0, at = Ee; at; at = Y0(at))Re++;
                                for(; 0 < we - Re;)wt = Y0(wt), we--;
                                for(; 0 < Re - we;)Ee = Y0(Ee), Re--;
                                for(; we--;){
                                    if (wt === Ee || Ee !== null && wt === Ee.alternate) break t;
                                    wt = Y0(wt), Ee = Y0(Ee);
                                }
                                wt = null;
                            }
                            else wt = null;
                            dt !== null && jy(tt, qe, dt, wt, !1), vt !== null && jr !== null && jy(tt, jr, vt, wt, !0);
                        }
                    }
                    e: {
                        if (qe = Ie ? J0(Ie) : window, dt = qe.nodeName && qe.nodeName.toLowerCase(), dt === "select" || dt === "input" && qe.type === "file") var Dt = Y;
                        else if (be(qe)) if (te) Dt = At;
                        else {
                            Dt = gt;
                            var bt = Ze;
                        }
                        else (dt = qe.nodeName) && dt.toLowerCase() === "input" && (qe.type === "checkbox" || qe.type === "radio") && (Dt = ut);
                        if (Dt && (Dt = Dt(d, Ie))) {
                            L(tt, Dt, w, Ye);
                            break e;
                        }
                        bt && bt(d, qe, Ie), d === "focusout" && (bt = qe._wrapperState) && bt.controlled && qe.type === "number" && Hn(qe, "number", qe.value);
                    }
                    switch(bt = Ie ? J0(Ie) : window, d){
                        case "focusin":
                            (be(bt) || bt.contentEditable === "true") && (q0 = bt, D2 = Ie, vf = null);
                            break;
                        case "focusout":
                            vf = D2 = q0 = null;
                            break;
                        case "mousedown":
                            _2 = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            _2 = !1, Vy(tt, w, Ye);
                            break;
                        case "selectionchange":
                            if (yg) break;
                        case "keydown":
                        case "keyup":
                            Vy(tt, w, Ye);
                    }
                    var Lt;
                    if (ke) e: {
                        switch(d){
                            case "compositionstart":
                                var Ut = "onCompositionStart";
                                break e;
                            case "compositionend":
                                Ut = "onCompositionEnd";
                                break e;
                            case "compositionupdate":
                                Ut = "onCompositionUpdate";
                                break e;
                        }
                        Ut = void 0;
                    }
                    else ye ? k(d, w) && (Ut = "onCompositionEnd") : d === "keydown" && w.keyCode === 229 && (Ut = "onCompositionStart");
                    Ut && (Et && w.locale !== "ko" && (ye || Ut !== "onCompositionStart" ? Ut === "onCompositionEnd" && ye && (Lt = Is()) : (Zi = Ye, ns = "value" in Zi ? Zi.value : Zi.textContent, ye = !0)), bt = xg(Ie, Ut), 0 < bt.length && (Ut = new Ji(Ut, d, null, w, Ye), tt.push({
                        event: Ut,
                        listeners: bt
                    }), Lt ? Ut.data = Lt : (Lt = ee(w), Lt !== null && (Ut.data = Lt)))), (Lt = mt ? _e(d, w) : Be(d, w)) && (Ie = xg(Ie, "onBeforeInput"), 0 < Ie.length && (Ye = new Ji("onBeforeInput", "beforeinput", null, w, Ye), tt.push({
                        event: Ye,
                        listeners: Ie
                    }), Ye.data = Lt));
                }
                $y(tt, p);
            });
        }
        function wf(d, p, w) {
            return {
                instance: d,
                listener: p,
                currentTarget: w
            };
        }
        function xg(d, p) {
            for(var w = p + "Capture", E = []; d !== null;){
                var O = d, b = O.stateNode;
                O.tag === 5 && b !== null && (O = b, b = ci(d, w), b != null && E.unshift(wf(d, b, O)), b = ci(d, p), b != null && E.push(wf(d, b, O))), d = d.return;
            }
            return E;
        }
        function Y0(d) {
            if (d === null) return null;
            do d = d.return;
            while (d && d.tag !== 5);
            return d || null;
        }
        function jy(d, p, w, E, O) {
            for(var b = p._reactName, j = []; w !== null && w !== E;){
                var fe = w, ve = fe.alternate, Ie = fe.stateNode;
                if (ve !== null && ve === E) break;
                fe.tag === 5 && Ie !== null && (fe = Ie, O ? (ve = ci(w, b), ve != null && j.unshift(wf(w, ve, fe))) : O || (ve = ci(w, b), ve != null && j.push(wf(w, ve, fe)))), w = w.return;
            }
            j.length !== 0 && d.push({
                event: p,
                listeners: j
            });
        }
        var OI = /\r\n?/g, II = /\u0000|\uFFFD/g;
        function Hy(d) {
            return (typeof d == "string" ? d : "" + d).replace(OI, `
`).replace(II, "");
        }
        function Sg(d, p, w) {
            if (p = Hy(p), Hy(d) !== p && w) throw Error(n(425));
        }
        function Eg() {}
        var L2 = null, P2 = null;
        function V2(d, p) {
            return d === "textarea" || d === "noscript" || typeof p.children == "string" || typeof p.children == "number" || typeof p.dangerouslySetInnerHTML == "object" && p.dangerouslySetInnerHTML !== null && p.dangerouslySetInnerHTML.__html != null;
        }
        var N2 = typeof setTimeout == "function" ? setTimeout : void 0, MI = typeof clearTimeout == "function" ? clearTimeout : void 0, Ky = typeof Promise == "function" ? Promise : void 0, bI = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ky < "u" ? function(d) {
            return Ky.resolve(null).then(d).catch(LI);
        } : N2;
        function LI(d) {
            setTimeout(function() {
                throw d;
            });
        }
        function A2(d, p) {
            var w = p, E = 0;
            do {
                var O = w.nextSibling;
                if (d.removeChild(w), O && O.nodeType === 8) if (w = O.data, w === "/$") {
                    if (E === 0) {
                        d.removeChild(O), Ui(p);
                        return;
                    }
                    E--;
                } else w !== "$" && w !== "$?" && w !== "$!" || E++;
                w = O;
            }while (w);
            Ui(p);
        }
        function rl(d) {
            for(; d != null; d = d.nextSibling){
                var p = d.nodeType;
                if (p === 1 || p === 3) break;
                if (p === 8) {
                    if (p = d.data, p === "$" || p === "$!" || p === "$?") break;
                    if (p === "/$") return null;
                }
            }
            return d;
        }
        function qy(d) {
            d = d.previousSibling;
            for(var p = 0; d;){
                if (d.nodeType === 8) {
                    var w = d.data;
                    if (w === "$" || w === "$!" || w === "$?") {
                        if (p === 0) return d;
                        p--;
                    } else w === "/$" && p++;
                }
                d = d.previousSibling;
            }
            return null;
        }
        var Z0 = Math.random().toString(36).slice(2), Fs = "__reactFiber$" + Z0, Tf = "__reactProps$" + Z0, xc = "__reactContainer$" + Z0, k2 = "__reactEvents$" + Z0, PI = "__reactListeners$" + Z0, VI = "__reactHandles$" + Z0;
        function e0(d) {
            var p = d[Fs];
            if (p) return p;
            for(var w = d.parentNode; w;){
                if (p = w[xc] || w[Fs]) {
                    if (w = p.alternate, p.child !== null || w !== null && w.child !== null) for(d = qy(d); d !== null;){
                        if (w = d[Fs]) return w;
                        d = qy(d);
                    }
                    return p;
                }
                d = w, w = d.parentNode;
            }
            return null;
        }
        function xf(d) {
            return d = d[Fs] || d[xc], !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d;
        }
        function J0(d) {
            if (d.tag === 5 || d.tag === 6) return d.stateNode;
            throw Error(n(33));
        }
        function Dg(d) {
            return d[Tf] || null;
        }
        var U2 = [], Q0 = -1;
        function il(d) {
            return {
                current: d
            };
        }
        function or(d) {
            0 > Q0 || (d.current = U2[Q0], U2[Q0] = null, Q0--);
        }
        function Yn(d, p) {
            Q0++, U2[Q0] = d.current, d.current = p;
        }
        var al = {}, Qi = il(al), Ga = il(!1), t0 = al;
        function eu(d, p) {
            var w = d.type.contextTypes;
            if (!w) return al;
            var E = d.stateNode;
            if (E && E.__reactInternalMemoizedUnmaskedChildContext === p) return E.__reactInternalMemoizedMaskedChildContext;
            var O = {}, b;
            for(b in w)O[b] = p[b];
            return E && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = p, d.__reactInternalMemoizedMaskedChildContext = O), O;
        }
        function Wa(d) {
            return d = d.childContextTypes, d != null;
        }
        function _g() {
            or(Ga), or(Qi);
        }
        function Xy(d, p, w) {
            if (Qi.current !== al) throw Error(n(168));
            Yn(Qi, p), Yn(Ga, w);
        }
        function Yy(d, p, w) {
            var E = d.stateNode;
            if (p = p.childContextTypes, typeof E.getChildContext != "function") return w;
            E = E.getChildContext();
            for(var O in E)if (!(O in p)) throw Error(n(108, rt(d) || "Unknown", O));
            return re({}, w, E);
        }
        function Rg(d) {
            return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || al, t0 = Qi.current, Yn(Qi, d), Yn(Ga, Ga.current), !0;
        }
        function Zy(d, p, w) {
            var E = d.stateNode;
            if (!E) throw Error(n(169));
            w ? (d = Yy(d, p, t0), E.__reactInternalMemoizedMergedChildContext = d, or(Ga), or(Qi), Yn(Qi, d)) : or(Ga), Yn(Ga, w);
        }
        var Sc = null, Og = !1, F2 = !1;
        function Jy(d) {
            Sc === null ? Sc = [
                d
            ] : Sc.push(d);
        }
        function NI(d) {
            Og = !0, Jy(d);
        }
        function ol() {
            if (!F2 && Sc !== null) {
                F2 = !0;
                var d = 0, p = an;
                try {
                    var w = Sc;
                    for(an = 1; d < w.length; d++){
                        var E = w[d];
                        do E = E(!0);
                        while (E !== null);
                    }
                    Sc = null, Og = !1;
                } catch (O) {
                    throw Sc !== null && (Sc = Sc.slice(d + 1)), Si(ui, ol), O;
                } finally{
                    an = p, F2 = !1;
                }
            }
            return null;
        }
        var tu = [], nu = 0, Ig = null, Mg = 0, Fo = [], Bo = 0, n0 = null, Ec = 1, Dc = "";
        function r0(d, p) {
            tu[nu++] = Mg, tu[nu++] = Ig, Ig = d, Mg = p;
        }
        function Qy(d, p, w) {
            Fo[Bo++] = Ec, Fo[Bo++] = Dc, Fo[Bo++] = n0, n0 = d;
            var E = Ec;
            d = Dc;
            var O = 32 - qn(E) - 1;
            E &= ~(1 << O), w += 1;
            var b = 32 - qn(p) + O;
            if (30 < b) {
                var j = O - O % 5;
                b = (E & (1 << j) - 1).toString(32), E >>= j, O -= j, Ec = 1 << 32 - qn(p) + O | w << O | E, Dc = b + d;
            } else Ec = 1 << b | w << O | E, Dc = d;
        }
        function B2(d) {
            d.return !== null && (r0(d, 1), Qy(d, 1, 0));
        }
        function G2(d) {
            for(; d === Ig;)Ig = tu[--nu], tu[nu] = null, Mg = tu[--nu], tu[nu] = null;
            for(; d === n0;)n0 = Fo[--Bo], Fo[Bo] = null, Dc = Fo[--Bo], Fo[Bo] = null, Ec = Fo[--Bo], Fo[Bo] = null;
        }
        var uo = null, fo = null, hr = !1, os = null;
        function e8(d, p) {
            var w = zo(5, null, null, 0);
            w.elementType = "DELETED", w.stateNode = p, w.return = d, p = d.deletions, p === null ? (d.deletions = [
                w
            ], d.flags |= 16) : p.push(w);
        }
        function t8(d, p) {
            switch(d.tag){
                case 5:
                    var w = d.type;
                    return p = p.nodeType !== 1 || w.toLowerCase() !== p.nodeName.toLowerCase() ? null : p, p !== null ? (d.stateNode = p, uo = d, fo = rl(p.firstChild), !0) : !1;
                case 6:
                    return p = d.pendingProps === "" || p.nodeType !== 3 ? null : p, p !== null ? (d.stateNode = p, uo = d, fo = null, !0) : !1;
                case 13:
                    return p = p.nodeType !== 8 ? null : p, p !== null ? (w = n0 !== null ? {
                        id: Ec,
                        overflow: Dc
                    } : null, d.memoizedState = {
                        dehydrated: p,
                        treeContext: w,
                        retryLane: 1073741824
                    }, w = zo(18, null, null, 0), w.stateNode = p, w.return = d, d.child = w, uo = d, fo = null, !0) : !1;
                default:
                    return !1;
            }
        }
        function W2(d) {
            return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
        }
        function $2(d) {
            if (hr) {
                var p = fo;
                if (p) {
                    var w = p;
                    if (!t8(d, p)) {
                        if (W2(d)) throw Error(n(418));
                        p = rl(w.nextSibling);
                        var E = uo;
                        p && t8(d, p) ? e8(E, w) : (d.flags = d.flags & -4097 | 2, hr = !1, uo = d);
                    }
                } else {
                    if (W2(d)) throw Error(n(418));
                    d.flags = d.flags & -4097 | 2, hr = !1, uo = d;
                }
            }
        }
        function n8(d) {
            for(d = d.return; d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13;)d = d.return;
            uo = d;
        }
        function bg(d) {
            if (d !== uo) return !1;
            if (!hr) return n8(d), hr = !0, !1;
            var p;
            if ((p = d.tag !== 3) && !(p = d.tag !== 5) && (p = d.type, p = p !== "head" && p !== "body" && !V2(d.type, d.memoizedProps)), p && (p = fo)) {
                if (W2(d)) throw r8(), Error(n(418));
                for(; p;)e8(d, p), p = rl(p.nextSibling);
            }
            if (n8(d), d.tag === 13) {
                if (d = d.memoizedState, d = d !== null ? d.dehydrated : null, !d) throw Error(n(317));
                e: {
                    for(d = d.nextSibling, p = 0; d;){
                        if (d.nodeType === 8) {
                            var w = d.data;
                            if (w === "/$") {
                                if (p === 0) {
                                    fo = rl(d.nextSibling);
                                    break e;
                                }
                                p--;
                            } else w !== "$" && w !== "$!" && w !== "$?" || p++;
                        }
                        d = d.nextSibling;
                    }
                    fo = null;
                }
            } else fo = uo ? rl(d.stateNode.nextSibling) : null;
            return !0;
        }
        function r8() {
            for(var d = fo; d;)d = rl(d.nextSibling);
        }
        function ru() {
            fo = uo = null, hr = !1;
        }
        function z2(d) {
            os === null ? os = [
                d
            ] : os.push(d);
        }
        var AI = S.ReactCurrentBatchConfig;
        function Sf(d, p, w) {
            if (d = w.ref, d !== null && typeof d != "function" && typeof d != "object") {
                if (w._owner) {
                    if (w = w._owner, w) {
                        if (w.tag !== 1) throw Error(n(309));
                        var E = w.stateNode;
                    }
                    if (!E) throw Error(n(147, d));
                    var O = E, b = "" + d;
                    return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === b ? p.ref : (p = function(j) {
                        var fe = O.refs;
                        j === null ? delete fe[b] : fe[b] = j;
                    }, p._stringRef = b, p);
                }
                if (typeof d != "string") throw Error(n(284));
                if (!w._owner) throw Error(n(290, d));
            }
            return d;
        }
        function Lg(d, p) {
            throw d = Object.prototype.toString.call(p), Error(n(31, d === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : d));
        }
        function i8(d) {
            var p = d._init;
            return p(d._payload);
        }
        function a8(d) {
            function p(Ee, we) {
                if (d) {
                    var Re = Ee.deletions;
                    Re === null ? (Ee.deletions = [
                        we
                    ], Ee.flags |= 16) : Re.push(we);
                }
            }
            function w(Ee, we) {
                if (!d) return null;
                for(; we !== null;)p(Ee, we), we = we.sibling;
                return null;
            }
            function E(Ee, we) {
                for(Ee = new Map; we !== null;)we.key !== null ? Ee.set(we.key, we) : Ee.set(we.index, we), we = we.sibling;
                return Ee;
            }
            function O(Ee, we) {
                return Ee = hl(Ee, we), Ee.index = 0, Ee.sibling = null, Ee;
            }
            function b(Ee, we, Re) {
                return Ee.index = Re, d ? (Re = Ee.alternate, Re !== null ? (Re = Re.index, Re < we ? (Ee.flags |= 2, we) : Re) : (Ee.flags |= 2, we)) : (Ee.flags |= 1048576, we);
            }
            function j(Ee) {
                return d && Ee.alternate === null && (Ee.flags |= 2), Ee;
            }
            function fe(Ee, we, Re, at) {
                return we === null || we.tag !== 6 ? (we = Nm(Re, Ee.mode, at), we.return = Ee, we) : (we = O(we, Re), we.return = Ee, we);
            }
            function ve(Ee, we, Re, at) {
                var Dt = Re.type;
                return Dt === M ? Ye(Ee, we, Re.props.children, at, Re.key) : we !== null && (we.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === ae && i8(Dt) === we.type) ? (at = O(we, Re.props), at.ref = Sf(Ee, we, Re), at.return = Ee, at) : (at = n1(Re.type, Re.key, Re.props, null, Ee.mode, at), at.ref = Sf(Ee, we, Re), at.return = Ee, at);
            }
            function Ie(Ee, we, Re, at) {
                return we === null || we.tag !== 4 || we.stateNode.containerInfo !== Re.containerInfo || we.stateNode.implementation !== Re.implementation ? (we = Am(Re, Ee.mode, at), we.return = Ee, we) : (we = O(we, Re.children || []), we.return = Ee, we);
            }
            function Ye(Ee, we, Re, at, Dt) {
                return we === null || we.tag !== 7 ? (we = f0(Re, Ee.mode, at, Dt), we.return = Ee, we) : (we = O(we, Re), we.return = Ee, we);
            }
            function tt(Ee, we, Re) {
                if (typeof we == "string" && we !== "" || typeof we == "number") return we = Nm("" + we, Ee.mode, Re), we.return = Ee, we;
                if (typeof we == "object" && we !== null) {
                    switch(we.$$typeof){
                        case D:
                            return Re = n1(we.type, we.key, we.props, null, Ee.mode, Re), Re.ref = Sf(Ee, null, we), Re.return = Ee, Re;
                        case _:
                            return we = Am(we, Ee.mode, Re), we.return = Ee, we;
                        case ae:
                            var at = we._init;
                            return tt(Ee, at(we._payload), Re);
                    }
                    if (Un(we) || oe(we)) return we = f0(we, Ee.mode, Re, null), we.return = Ee, we;
                    Lg(Ee, we);
                }
                return null;
            }
            function qe(Ee, we, Re, at) {
                var Dt = we !== null ? we.key : null;
                if (typeof Re == "string" && Re !== "" || typeof Re == "number") return Dt !== null ? null : fe(Ee, we, "" + Re, at);
                if (typeof Re == "object" && Re !== null) {
                    switch(Re.$$typeof){
                        case D:
                            return Re.key === Dt ? ve(Ee, we, Re, at) : null;
                        case _:
                            return Re.key === Dt ? Ie(Ee, we, Re, at) : null;
                        case ae:
                            return Dt = Re._init, qe(Ee, we, Dt(Re._payload), at);
                    }
                    if (Un(Re) || oe(Re)) return Dt !== null ? null : Ye(Ee, we, Re, at, null);
                    Lg(Ee, Re);
                }
                return null;
            }
            function dt(Ee, we, Re, at, Dt) {
                if (typeof at == "string" && at !== "" || typeof at == "number") return Ee = Ee.get(Re) || null, fe(we, Ee, "" + at, Dt);
                if (typeof at == "object" && at !== null) {
                    switch(at.$$typeof){
                        case D:
                            return Ee = Ee.get(at.key === null ? Re : at.key) || null, ve(we, Ee, at, Dt);
                        case _:
                            return Ee = Ee.get(at.key === null ? Re : at.key) || null, Ie(we, Ee, at, Dt);
                        case ae:
                            var bt = at._init;
                            return dt(Ee, we, Re, bt(at._payload), Dt);
                    }
                    if (Un(at) || oe(at)) return Ee = Ee.get(Re) || null, Ye(we, Ee, at, Dt, null);
                    Lg(we, at);
                }
                return null;
            }
            function vt(Ee, we, Re, at) {
                for(var Dt = null, bt = null, Lt = we, Ut = we = 0, Oi = null; Lt !== null && Ut < Re.length; Ut++){
                    Lt.index > Ut ? (Oi = Lt, Lt = null) : Oi = Lt.sibling;
                    var Dn = qe(Ee, Lt, Re[Ut], at);
                    if (Dn === null) {
                        Lt === null && (Lt = Oi);
                        break;
                    }
                    d && Lt && Dn.alternate === null && p(Ee, Lt), we = b(Dn, we, Ut), bt === null ? Dt = Dn : bt.sibling = Dn, bt = Dn, Lt = Oi;
                }
                if (Ut === Re.length) return w(Ee, Lt), hr && r0(Ee, Ut), Dt;
                if (Lt === null) {
                    for(; Ut < Re.length; Ut++)Lt = tt(Ee, Re[Ut], at), Lt !== null && (we = b(Lt, we, Ut), bt === null ? Dt = Lt : bt.sibling = Lt, bt = Lt);
                    return hr && r0(Ee, Ut), Dt;
                }
                for(Lt = E(Ee, Lt); Ut < Re.length; Ut++)Oi = dt(Lt, Ee, Ut, Re[Ut], at), Oi !== null && (d && Oi.alternate !== null && Lt.delete(Oi.key === null ? Ut : Oi.key), we = b(Oi, we, Ut), bt === null ? Dt = Oi : bt.sibling = Oi, bt = Oi);
                return d && Lt.forEach(function(pl) {
                    return p(Ee, pl);
                }), hr && r0(Ee, Ut), Dt;
            }
            function wt(Ee, we, Re, at) {
                var Dt = oe(Re);
                if (typeof Dt != "function") throw Error(n(150));
                if (Re = Dt.call(Re), Re == null) throw Error(n(151));
                for(var bt = Dt = null, Lt = we, Ut = we = 0, Oi = null, Dn = Re.next(); Lt !== null && !Dn.done; Ut++, Dn = Re.next()){
                    Lt.index > Ut ? (Oi = Lt, Lt = null) : Oi = Lt.sibling;
                    var pl = qe(Ee, Lt, Dn.value, at);
                    if (pl === null) {
                        Lt === null && (Lt = Oi);
                        break;
                    }
                    d && Lt && pl.alternate === null && p(Ee, Lt), we = b(pl, we, Ut), bt === null ? Dt = pl : bt.sibling = pl, bt = pl, Lt = Oi;
                }
                if (Dn.done) return w(Ee, Lt), hr && r0(Ee, Ut), Dt;
                if (Lt === null) {
                    for(; !Dn.done; Ut++, Dn = Re.next())Dn = tt(Ee, Dn.value, at), Dn !== null && (we = b(Dn, we, Ut), bt === null ? Dt = Dn : bt.sibling = Dn, bt = Dn);
                    return hr && r0(Ee, Ut), Dt;
                }
                for(Lt = E(Ee, Lt); !Dn.done; Ut++, Dn = Re.next())Dn = dt(Lt, Ee, Ut, Dn.value, at), Dn !== null && (d && Dn.alternate !== null && Lt.delete(Dn.key === null ? Ut : Dn.key), we = b(Dn, we, Ut), bt === null ? Dt = Dn : bt.sibling = Dn, bt = Dn);
                return d && Lt.forEach(function(pM) {
                    return p(Ee, pM);
                }), hr && r0(Ee, Ut), Dt;
            }
            function jr(Ee, we, Re, at) {
                if (typeof Re == "object" && Re !== null && Re.type === M && Re.key === null && (Re = Re.props.children), typeof Re == "object" && Re !== null) {
                    switch(Re.$$typeof){
                        case D:
                            e: {
                                for(var Dt = Re.key, bt = we; bt !== null;){
                                    if (bt.key === Dt) {
                                        if (Dt = Re.type, Dt === M) {
                                            if (bt.tag === 7) {
                                                w(Ee, bt.sibling), we = O(bt, Re.props.children), we.return = Ee, Ee = we;
                                                break e;
                                            }
                                        } else if (bt.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === ae && i8(Dt) === bt.type) {
                                            w(Ee, bt.sibling), we = O(bt, Re.props), we.ref = Sf(Ee, bt, Re), we.return = Ee, Ee = we;
                                            break e;
                                        }
                                        w(Ee, bt);
                                        break;
                                    } else p(Ee, bt);
                                    bt = bt.sibling;
                                }
                                Re.type === M ? (we = f0(Re.props.children, Ee.mode, at, Re.key), we.return = Ee, Ee = we) : (at = n1(Re.type, Re.key, Re.props, null, Ee.mode, at), at.ref = Sf(Ee, we, Re), at.return = Ee, Ee = at);
                            }
                            return j(Ee);
                        case _:
                            e: {
                                for(bt = Re.key; we !== null;){
                                    if (we.key === bt) if (we.tag === 4 && we.stateNode.containerInfo === Re.containerInfo && we.stateNode.implementation === Re.implementation) {
                                        w(Ee, we.sibling), we = O(we, Re.children || []), we.return = Ee, Ee = we;
                                        break e;
                                    } else {
                                        w(Ee, we);
                                        break;
                                    }
                                    else p(Ee, we);
                                    we = we.sibling;
                                }
                                we = Am(Re, Ee.mode, at), we.return = Ee, Ee = we;
                            }
                            return j(Ee);
                        case ae:
                            return bt = Re._init, jr(Ee, we, bt(Re._payload), at);
                    }
                    if (Un(Re)) return vt(Ee, we, Re, at);
                    if (oe(Re)) return wt(Ee, we, Re, at);
                    Lg(Ee, Re);
                }
                return typeof Re == "string" && Re !== "" || typeof Re == "number" ? (Re = "" + Re, we !== null && we.tag === 6 ? (w(Ee, we.sibling), we = O(we, Re), we.return = Ee, Ee = we) : (w(Ee, we), we = Nm(Re, Ee.mode, at), we.return = Ee, Ee = we), j(Ee)) : w(Ee, we);
            }
            return jr;
        }
        var iu = a8(!0), o8 = a8(!1), Pg = il(null), Vg = null, au = null, j2 = null;
        function H2() {
            j2 = au = Vg = null;
        }
        function K2(d) {
            var p = Pg.current;
            or(Pg), d._currentValue = p;
        }
        function q2(d, p, w) {
            for(; d !== null;){
                var E = d.alternate;
                if ((d.childLanes & p) !== p ? (d.childLanes |= p, E !== null && (E.childLanes |= p)) : E !== null && (E.childLanes & p) !== p && (E.childLanes |= p), d === w) break;
                d = d.return;
            }
        }
        function ou(d, p) {
            Vg = d, j2 = au = null, d = d.dependencies, d !== null && d.firstContext !== null && ((d.lanes & p) !== 0 && ($a = !0), d.firstContext = null);
        }
        function Go(d) {
            var p = d._currentValue;
            if (j2 !== d) if (d = {
                context: d,
                memoizedValue: p,
                next: null
            }, au === null) {
                if (Vg === null) throw Error(n(308));
                au = d, Vg.dependencies = {
                    lanes: 0,
                    firstContext: d
                };
            } else au = au.next = d;
            return p;
        }
        var i0 = null;
        function X2(d) {
            i0 === null ? i0 = [
                d
            ] : i0.push(d);
        }
        function s8(d, p, w, E) {
            var O = p.interleaved;
            return O === null ? (w.next = w, X2(p)) : (w.next = O.next, O.next = w), p.interleaved = w, _c(d, E);
        }
        function _c(d, p) {
            d.lanes |= p;
            var w = d.alternate;
            for(w !== null && (w.lanes |= p), w = d, d = d.return; d !== null;)d.childLanes |= p, w = d.alternate, w !== null && (w.childLanes |= p), w = d, d = d.return;
            return w.tag === 3 ? w.stateNode : null;
        }
        var sl = !1;
        function Y2(d) {
            d.updateQueue = {
                baseState: d.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    interleaved: null,
                    lanes: 0
                },
                effects: null
            };
        }
        function c8(d, p) {
            d = d.updateQueue, p.updateQueue === d && (p.updateQueue = {
                baseState: d.baseState,
                firstBaseUpdate: d.firstBaseUpdate,
                lastBaseUpdate: d.lastBaseUpdate,
                shared: d.shared,
                effects: d.effects
            });
        }
        function Rc(d, p) {
            return {
                eventTime: d,
                lane: p,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function cl(d, p, w) {
            var E = d.updateQueue;
            if (E === null) return null;
            if (E = E.shared, (xn & 2) !== 0) {
                var O = E.pending;
                return O === null ? p.next = p : (p.next = O.next, O.next = p), E.pending = p, _c(d, w);
            }
            return O = E.interleaved, O === null ? (p.next = p, X2(E)) : (p.next = O.next, O.next = p), E.interleaved = p, _c(d, w);
        }
        function Ng(d, p, w) {
            if (p = p.updateQueue, p !== null && (p = p.shared, (w & 4194240) !== 0)) {
                var E = p.lanes;
                E &= d.pendingLanes, w |= E, p.lanes = w, vr(d, w);
            }
        }
        function l8(d, p) {
            var w = d.updateQueue, E = d.alternate;
            if (E !== null && (E = E.updateQueue, w === E)) {
                var O = null, b = null;
                if (w = w.firstBaseUpdate, w !== null) {
                    do {
                        var j = {
                            eventTime: w.eventTime,
                            lane: w.lane,
                            tag: w.tag,
                            payload: w.payload,
                            callback: w.callback,
                            next: null
                        };
                        b === null ? O = b = j : b = b.next = j, w = w.next;
                    }while (w !== null);
                    b === null ? O = b = p : b = b.next = p;
                } else O = b = p;
                w = {
                    baseState: E.baseState,
                    firstBaseUpdate: O,
                    lastBaseUpdate: b,
                    shared: E.shared,
                    effects: E.effects
                }, d.updateQueue = w;
                return;
            }
            d = w.lastBaseUpdate, d === null ? w.firstBaseUpdate = p : d.next = p, w.lastBaseUpdate = p;
        }
        function Ag(d, p, w, E) {
            var O = d.updateQueue;
            sl = !1;
            var b = O.firstBaseUpdate, j = O.lastBaseUpdate, fe = O.shared.pending;
            if (fe !== null) {
                O.shared.pending = null;
                var ve = fe, Ie = ve.next;
                ve.next = null, j === null ? b = Ie : j.next = Ie, j = ve;
                var Ye = d.alternate;
                Ye !== null && (Ye = Ye.updateQueue, fe = Ye.lastBaseUpdate, fe !== j && (fe === null ? Ye.firstBaseUpdate = Ie : fe.next = Ie, Ye.lastBaseUpdate = ve));
            }
            if (b !== null) {
                var tt = O.baseState;
                j = 0, Ye = Ie = ve = null, fe = b;
                do {
                    var qe = fe.lane, dt = fe.eventTime;
                    if ((E & qe) === qe) {
                        Ye !== null && (Ye = Ye.next = {
                            eventTime: dt,
                            lane: 0,
                            tag: fe.tag,
                            payload: fe.payload,
                            callback: fe.callback,
                            next: null
                        });
                        e: {
                            var vt = d, wt = fe;
                            switch(qe = p, dt = w, wt.tag){
                                case 1:
                                    if (vt = wt.payload, typeof vt == "function") {
                                        tt = vt.call(dt, tt, qe);
                                        break e;
                                    }
                                    tt = vt;
                                    break e;
                                case 3:
                                    vt.flags = vt.flags & -65537 | 128;
                                case 0:
                                    if (vt = wt.payload, qe = typeof vt == "function" ? vt.call(dt, tt, qe) : vt, qe == null) break e;
                                    tt = re({}, tt, qe);
                                    break e;
                                case 2:
                                    sl = !0;
                            }
                        }
                        fe.callback !== null && fe.lane !== 0 && (d.flags |= 64, qe = O.effects, qe === null ? O.effects = [
                            fe
                        ] : qe.push(fe));
                    } else dt = {
                        eventTime: dt,
                        lane: qe,
                        tag: fe.tag,
                        payload: fe.payload,
                        callback: fe.callback,
                        next: null
                    }, Ye === null ? (Ie = Ye = dt, ve = tt) : Ye = Ye.next = dt, j |= qe;
                    if (fe = fe.next, fe === null) {
                        if (fe = O.shared.pending, fe === null) break;
                        qe = fe, fe = qe.next, qe.next = null, O.lastBaseUpdate = qe, O.shared.pending = null;
                    }
                }while (!0);
                if (Ye === null && (ve = tt), O.baseState = ve, O.firstBaseUpdate = Ie, O.lastBaseUpdate = Ye, p = O.shared.interleaved, p !== null) {
                    O = p;
                    do j |= O.lane, O = O.next;
                    while (O !== p);
                } else b === null && (O.shared.lanes = 0);
                s0 |= j, d.lanes = j, d.memoizedState = tt;
            }
        }
        function u8(d, p, w) {
            if (d = p.effects, p.effects = null, d !== null) for(p = 0; p < d.length; p++){
                var E = d[p], O = E.callback;
                if (O !== null) {
                    if (E.callback = null, E = w, typeof O != "function") throw Error(n(191, O));
                    O.call(E);
                }
            }
        }
        var Ef = {}, Bs = il(Ef), Df = il(Ef), _f = il(Ef);
        function a0(d) {
            if (d === Ef) throw Error(n(174));
            return d;
        }
        function Z2(d, p) {
            switch(Yn(_f, p), Yn(Df, d), Yn(Bs, Ef), d = p.nodeType, d){
                case 9:
                case 11:
                    p = (p = p.documentElement) ? p.namespaceURI : lt(null, "");
                    break;
                default:
                    d = d === 8 ? p.parentNode : p, p = d.namespaceURI || null, d = d.tagName, p = lt(p, d);
            }
            or(Bs), Yn(Bs, p);
        }
        function su() {
            or(Bs), or(Df), or(_f);
        }
        function f8(d) {
            a0(_f.current);
            var p = a0(Bs.current), w = lt(p, d.type);
            p !== w && (Yn(Df, d), Yn(Bs, w));
        }
        function J2(d) {
            Df.current === d && (or(Bs), or(Df));
        }
        var Tr = il(0);
        function kg(d) {
            for(var p = d; p !== null;){
                if (p.tag === 13) {
                    var w = p.memoizedState;
                    if (w !== null && (w = w.dehydrated, w === null || w.data === "$?" || w.data === "$!")) return p;
                } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
                    if ((p.flags & 128) !== 0) return p;
                } else if (p.child !== null) {
                    p.child.return = p, p = p.child;
                    continue;
                }
                if (p === d) break;
                for(; p.sibling === null;){
                    if (p.return === null || p.return === d) return null;
                    p = p.return;
                }
                p.sibling.return = p.return, p = p.sibling;
            }
            return null;
        }
        var Q2 = [];
        function em() {
            for(var d = 0; d < Q2.length; d++)Q2[d]._workInProgressVersionPrimary = null;
            Q2.length = 0;
        }
        var Ug = S.ReactCurrentDispatcher, tm = S.ReactCurrentBatchConfig, o0 = 0, xr = null, gi = null, _i = null, Fg = !1, Rf = !1, Of = 0, kI = 0;
        function ea() {
            throw Error(n(321));
        }
        function nm(d, p) {
            if (p === null) return !1;
            for(var w = 0; w < p.length && w < d.length; w++)if (!Bt(d[w], p[w])) return !1;
            return !0;
        }
        function rm(d, p, w, E, O, b) {
            if (o0 = b, xr = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, Ug.current = d === null || d.memoizedState === null ? GI : WI, d = w(E, O), Rf) {
                b = 0;
                do {
                    if (Rf = !1, Of = 0, 25 <= b) throw Error(n(301));
                    b += 1, _i = gi = null, p.updateQueue = null, Ug.current = $I, d = w(E, O);
                }while (Rf);
            }
            if (Ug.current = Wg, p = gi !== null && gi.next !== null, o0 = 0, _i = gi = xr = null, Fg = !1, p) throw Error(n(300));
            return d;
        }
        function im() {
            var d = Of !== 0;
            return Of = 0, d;
        }
        function Gs() {
            var d = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            return _i === null ? xr.memoizedState = _i = d : _i = _i.next = d, _i;
        }
        function Wo() {
            if (gi === null) {
                var d = xr.alternate;
                d = d !== null ? d.memoizedState : null;
            } else d = gi.next;
            var p = _i === null ? xr.memoizedState : _i.next;
            if (p !== null) _i = p, gi = d;
            else {
                if (d === null) throw Error(n(310));
                gi = d, d = {
                    memoizedState: gi.memoizedState,
                    baseState: gi.baseState,
                    baseQueue: gi.baseQueue,
                    queue: gi.queue,
                    next: null
                }, _i === null ? xr.memoizedState = _i = d : _i = _i.next = d;
            }
            return _i;
        }
        function If(d, p) {
            return typeof p == "function" ? p(d) : p;
        }
        function am(d) {
            var p = Wo(), w = p.queue;
            if (w === null) throw Error(n(311));
            w.lastRenderedReducer = d;
            var E = gi, O = E.baseQueue, b = w.pending;
            if (b !== null) {
                if (O !== null) {
                    var j = O.next;
                    O.next = b.next, b.next = j;
                }
                E.baseQueue = O = b, w.pending = null;
            }
            if (O !== null) {
                b = O.next, E = E.baseState;
                var fe = j = null, ve = null, Ie = b;
                do {
                    var Ye = Ie.lane;
                    if ((o0 & Ye) === Ye) ve !== null && (ve = ve.next = {
                        lane: 0,
                        action: Ie.action,
                        hasEagerState: Ie.hasEagerState,
                        eagerState: Ie.eagerState,
                        next: null
                    }), E = Ie.hasEagerState ? Ie.eagerState : d(E, Ie.action);
                    else {
                        var tt = {
                            lane: Ye,
                            action: Ie.action,
                            hasEagerState: Ie.hasEagerState,
                            eagerState: Ie.eagerState,
                            next: null
                        };
                        ve === null ? (fe = ve = tt, j = E) : ve = ve.next = tt, xr.lanes |= Ye, s0 |= Ye;
                    }
                    Ie = Ie.next;
                }while (Ie !== null && Ie !== b);
                ve === null ? j = E : ve.next = fe, Bt(E, p.memoizedState) || ($a = !0), p.memoizedState = E, p.baseState = j, p.baseQueue = ve, w.lastRenderedState = E;
            }
            if (d = w.interleaved, d !== null) {
                O = d;
                do b = O.lane, xr.lanes |= b, s0 |= b, O = O.next;
                while (O !== d);
            } else O === null && (w.lanes = 0);
            return [
                p.memoizedState,
                w.dispatch
            ];
        }
        function om(d) {
            var p = Wo(), w = p.queue;
            if (w === null) throw Error(n(311));
            w.lastRenderedReducer = d;
            var E = w.dispatch, O = w.pending, b = p.memoizedState;
            if (O !== null) {
                w.pending = null;
                var j = O = O.next;
                do b = d(b, j.action), j = j.next;
                while (j !== O);
                Bt(b, p.memoizedState) || ($a = !0), p.memoizedState = b, p.baseQueue === null && (p.baseState = b), w.lastRenderedState = b;
            }
            return [
                b,
                E
            ];
        }
        function d8() {}
        function g8(d, p) {
            var w = xr, E = Wo(), O = p(), b = !Bt(E.memoizedState, O);
            if (b && (E.memoizedState = O, $a = !0), E = E.queue, sm(m8.bind(null, w, E, d), [
                d
            ]), E.getSnapshot !== p || b || _i !== null && _i.memoizedState.tag & 1) {
                if (w.flags |= 2048, Mf(9, p8.bind(null, w, E, O, p), void 0, null), Ri === null) throw Error(n(349));
                (o0 & 30) !== 0 || h8(w, p, O);
            }
            return O;
        }
        function h8(d, p, w) {
            d.flags |= 16384, d = {
                getSnapshot: p,
                value: w
            }, p = xr.updateQueue, p === null ? (p = {
                lastEffect: null,
                stores: null
            }, xr.updateQueue = p, p.stores = [
                d
            ]) : (w = p.stores, w === null ? p.stores = [
                d
            ] : w.push(d));
        }
        function p8(d, p, w, E) {
            p.value = w, p.getSnapshot = E, v8(p) && y8(d);
        }
        function m8(d, p, w) {
            return w(function() {
                v8(p) && y8(d);
            });
        }
        function v8(d) {
            var p = d.getSnapshot;
            d = d.value;
            try {
                var w = p();
                return !Bt(d, w);
            } catch  {
                return !0;
            }
        }
        function y8(d) {
            var p = _c(d, 1);
            p !== null && us(p, d, 1, -1);
        }
        function C8(d) {
            var p = Gs();
            return typeof d == "function" && (d = d()), p.memoizedState = p.baseState = d, d = {
                pending: null,
                interleaved: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: If,
                lastRenderedState: d
            }, p.queue = d, d = d.dispatch = BI.bind(null, xr, d), [
                p.memoizedState,
                d
            ];
        }
        function Mf(d, p, w, E) {
            return d = {
                tag: d,
                create: p,
                destroy: w,
                deps: E,
                next: null
            }, p = xr.updateQueue, p === null ? (p = {
                lastEffect: null,
                stores: null
            }, xr.updateQueue = p, p.lastEffect = d.next = d) : (w = p.lastEffect, w === null ? p.lastEffect = d.next = d : (E = w.next, w.next = d, d.next = E, p.lastEffect = d)), d;
        }
        function w8() {
            return Wo().memoizedState;
        }
        function Bg(d, p, w, E) {
            var O = Gs();
            xr.flags |= d, O.memoizedState = Mf(1 | p, w, void 0, E === void 0 ? null : E);
        }
        function Gg(d, p, w, E) {
            var O = Wo();
            E = E === void 0 ? null : E;
            var b = void 0;
            if (gi !== null) {
                var j = gi.memoizedState;
                if (b = j.destroy, E !== null && nm(E, j.deps)) {
                    O.memoizedState = Mf(p, w, b, E);
                    return;
                }
            }
            xr.flags |= d, O.memoizedState = Mf(1 | p, w, b, E);
        }
        function T8(d, p) {
            return Bg(8390656, 8, d, p);
        }
        function sm(d, p) {
            return Gg(2048, 8, d, p);
        }
        function x8(d, p) {
            return Gg(4, 2, d, p);
        }
        function S8(d, p) {
            return Gg(4, 4, d, p);
        }
        function E8(d, p) {
            if (typeof p == "function") return d = d(), p(d), function() {
                p(null);
            };
            if (p != null) return d = d(), p.current = d, function() {
                p.current = null;
            };
        }
        function D8(d, p, w) {
            return w = w != null ? w.concat([
                d
            ]) : null, Gg(4, 4, E8.bind(null, p, d), w);
        }
        function cm() {}
        function _8(d, p) {
            var w = Wo();
            p = p === void 0 ? null : p;
            var E = w.memoizedState;
            return E !== null && p !== null && nm(p, E[1]) ? E[0] : (w.memoizedState = [
                d,
                p
            ], d);
        }
        function R8(d, p) {
            var w = Wo();
            p = p === void 0 ? null : p;
            var E = w.memoizedState;
            return E !== null && p !== null && nm(p, E[1]) ? E[0] : (d = d(), w.memoizedState = [
                d,
                p
            ], d);
        }
        function O8(d, p, w) {
            return (o0 & 21) === 0 ? (d.baseState && (d.baseState = !1, $a = !0), d.memoizedState = w) : (Bt(w, p) || (w = Rs(), xr.lanes |= w, s0 |= w, d.baseState = !0), p);
        }
        function UI(d, p) {
            var w = an;
            an = w !== 0 && 4 > w ? w : 4, d(!0);
            var E = tm.transition;
            tm.transition = {};
            try {
                d(!1), p();
            } finally{
                an = w, tm.transition = E;
            }
        }
        function I8() {
            return Wo().memoizedState;
        }
        function FI(d, p, w) {
            var E = dl(d);
            if (w = {
                lane: E,
                action: w,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, M8(d)) b8(p, w);
            else if (w = s8(d, p, w, E), w !== null) {
                var O = Ea();
                us(w, d, E, O), L8(w, p, E);
            }
        }
        function BI(d, p, w) {
            var E = dl(d), O = {
                lane: E,
                action: w,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
            if (M8(d)) b8(p, O);
            else {
                var b = d.alternate;
                if (d.lanes === 0 && (b === null || b.lanes === 0) && (b = p.lastRenderedReducer, b !== null)) try {
                    var j = p.lastRenderedState, fe = b(j, w);
                    if (O.hasEagerState = !0, O.eagerState = fe, Bt(fe, j)) {
                        var ve = p.interleaved;
                        ve === null ? (O.next = O, X2(p)) : (O.next = ve.next, ve.next = O), p.interleaved = O;
                        return;
                    }
                } catch  {} finally{}
                w = s8(d, p, O, E), w !== null && (O = Ea(), us(w, d, E, O), L8(w, p, E));
            }
        }
        function M8(d) {
            var p = d.alternate;
            return d === xr || p !== null && p === xr;
        }
        function b8(d, p) {
            Rf = Fg = !0;
            var w = d.pending;
            w === null ? p.next = p : (p.next = w.next, w.next = p), d.pending = p;
        }
        function L8(d, p, w) {
            if ((w & 4194240) !== 0) {
                var E = p.lanes;
                E &= d.pendingLanes, w |= E, p.lanes = w, vr(d, w);
            }
        }
        var Wg = {
            readContext: Go,
            useCallback: ea,
            useContext: ea,
            useEffect: ea,
            useImperativeHandle: ea,
            useInsertionEffect: ea,
            useLayoutEffect: ea,
            useMemo: ea,
            useReducer: ea,
            useRef: ea,
            useState: ea,
            useDebugValue: ea,
            useDeferredValue: ea,
            useTransition: ea,
            useMutableSource: ea,
            useSyncExternalStore: ea,
            useId: ea,
            unstable_isNewReconciler: !1
        }, GI = {
            readContext: Go,
            useCallback: function(d, p) {
                return Gs().memoizedState = [
                    d,
                    p === void 0 ? null : p
                ], d;
            },
            useContext: Go,
            useEffect: T8,
            useImperativeHandle: function(d, p, w) {
                return w = w != null ? w.concat([
                    d
                ]) : null, Bg(4194308, 4, E8.bind(null, p, d), w);
            },
            useLayoutEffect: function(d, p) {
                return Bg(4194308, 4, d, p);
            },
            useInsertionEffect: function(d, p) {
                return Bg(4, 2, d, p);
            },
            useMemo: function(d, p) {
                var w = Gs();
                return p = p === void 0 ? null : p, d = d(), w.memoizedState = [
                    d,
                    p
                ], d;
            },
            useReducer: function(d, p, w) {
                var E = Gs();
                return p = w !== void 0 ? w(p) : p, E.memoizedState = E.baseState = p, d = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: d,
                    lastRenderedState: p
                }, E.queue = d, d = d.dispatch = FI.bind(null, xr, d), [
                    E.memoizedState,
                    d
                ];
            },
            useRef: function(d) {
                var p = Gs();
                return d = {
                    current: d
                }, p.memoizedState = d;
            },
            useState: C8,
            useDebugValue: cm,
            useDeferredValue: function(d) {
                return Gs().memoizedState = d;
            },
            useTransition: function() {
                var d = C8(!1), p = d[0];
                return d = UI.bind(null, d[1]), Gs().memoizedState = d, [
                    p,
                    d
                ];
            },
            useMutableSource: function() {},
            useSyncExternalStore: function(d, p, w) {
                var E = xr, O = Gs();
                if (hr) {
                    if (w === void 0) throw Error(n(407));
                    w = w();
                } else {
                    if (w = p(), Ri === null) throw Error(n(349));
                    (o0 & 30) !== 0 || h8(E, p, w);
                }
                O.memoizedState = w;
                var b = {
                    value: w,
                    getSnapshot: p
                };
                return O.queue = b, T8(m8.bind(null, E, b, d), [
                    d
                ]), E.flags |= 2048, Mf(9, p8.bind(null, E, b, w, p), void 0, null), w;
            },
            useId: function() {
                var d = Gs(), p = Ri.identifierPrefix;
                if (hr) {
                    var w = Dc, E = Ec;
                    w = (E & ~(1 << 32 - qn(E) - 1)).toString(32) + w, p = ":" + p + "R" + w, w = Of++, 0 < w && (p += "H" + w.toString(32)), p += ":";
                } else w = kI++, p = ":" + p + "r" + w.toString(32) + ":";
                return d.memoizedState = p;
            },
            unstable_isNewReconciler: !1
        }, WI = {
            readContext: Go,
            useCallback: _8,
            useContext: Go,
            useEffect: sm,
            useImperativeHandle: D8,
            useInsertionEffect: x8,
            useLayoutEffect: S8,
            useMemo: R8,
            useReducer: am,
            useRef: w8,
            useState: function() {
                return am(If);
            },
            useDebugValue: cm,
            useDeferredValue: function(d) {
                var p = Wo();
                return O8(p, gi.memoizedState, d);
            },
            useTransition: function() {
                var d = am(If)[0], p = Wo().memoizedState;
                return [
                    d,
                    p
                ];
            },
            useMutableSource: d8,
            useSyncExternalStore: g8,
            useId: I8,
            unstable_isNewReconciler: !1
        }, $I = {
            readContext: Go,
            useCallback: _8,
            useContext: Go,
            useEffect: sm,
            useImperativeHandle: D8,
            useInsertionEffect: x8,
            useLayoutEffect: S8,
            useMemo: R8,
            useReducer: om,
            useRef: w8,
            useState: function() {
                return om(If);
            },
            useDebugValue: cm,
            useDeferredValue: function(d) {
                var p = Wo();
                return gi === null ? p.memoizedState = d : O8(p, gi.memoizedState, d);
            },
            useTransition: function() {
                var d = om(If)[0], p = Wo().memoizedState;
                return [
                    d,
                    p
                ];
            },
            useMutableSource: d8,
            useSyncExternalStore: g8,
            useId: I8,
            unstable_isNewReconciler: !1
        };
        function ss(d, p) {
            if (d && d.defaultProps) {
                p = re({}, p), d = d.defaultProps;
                for(var w in d)p[w] === void 0 && (p[w] = d[w]);
                return p;
            }
            return p;
        }
        function lm(d, p, w, E) {
            p = d.memoizedState, w = w(E, p), w = w == null ? p : re({}, p, w), d.memoizedState = w, d.lanes === 0 && (d.updateQueue.baseState = w);
        }
        var $g = {
            isMounted: function(d) {
                return (d = d._reactInternals) ? xi(d) === d : !1;
            },
            enqueueSetState: function(d, p, w) {
                d = d._reactInternals;
                var E = Ea(), O = dl(d), b = Rc(E, O);
                b.payload = p, w != null && (b.callback = w), p = cl(d, b, O), p !== null && (us(p, d, O, E), Ng(p, d, O));
            },
            enqueueReplaceState: function(d, p, w) {
                d = d._reactInternals;
                var E = Ea(), O = dl(d), b = Rc(E, O);
                b.tag = 1, b.payload = p, w != null && (b.callback = w), p = cl(d, b, O), p !== null && (us(p, d, O, E), Ng(p, d, O));
            },
            enqueueForceUpdate: function(d, p) {
                d = d._reactInternals;
                var w = Ea(), E = dl(d), O = Rc(w, E);
                O.tag = 2, p != null && (O.callback = p), p = cl(d, O, E), p !== null && (us(p, d, E, w), Ng(p, d, E));
            }
        };
        function P8(d, p, w, E, O, b, j) {
            return d = d.stateNode, typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(E, b, j) : p.prototype && p.prototype.isPureReactComponent ? !Wn(w, E) || !Wn(O, b) : !0;
        }
        function V8(d, p, w) {
            var E = !1, O = al, b = p.contextType;
            return typeof b == "object" && b !== null ? b = Go(b) : (O = Wa(p) ? t0 : Qi.current, E = p.contextTypes, b = (E = E != null) ? eu(d, O) : al), p = new p(w, b), d.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = $g, d.stateNode = p, p._reactInternals = d, E && (d = d.stateNode, d.__reactInternalMemoizedUnmaskedChildContext = O, d.__reactInternalMemoizedMaskedChildContext = b), p;
        }
        function N8(d, p, w, E) {
            d = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(w, E), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(w, E), p.state !== d && $g.enqueueReplaceState(p, p.state, null);
        }
        function um(d, p, w, E) {
            var O = d.stateNode;
            O.props = w, O.state = d.memoizedState, O.refs = {}, Y2(d);
            var b = p.contextType;
            typeof b == "object" && b !== null ? O.context = Go(b) : (b = Wa(p) ? t0 : Qi.current, O.context = eu(d, b)), O.state = d.memoizedState, b = p.getDerivedStateFromProps, typeof b == "function" && (lm(d, p, b, w), O.state = d.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof O.getSnapshotBeforeUpdate == "function" || typeof O.UNSAFE_componentWillMount != "function" && typeof O.componentWillMount != "function" || (p = O.state, typeof O.componentWillMount == "function" && O.componentWillMount(), typeof O.UNSAFE_componentWillMount == "function" && O.UNSAFE_componentWillMount(), p !== O.state && $g.enqueueReplaceState(O, O.state, null), Ag(d, w, O, E), O.state = d.memoizedState), typeof O.componentDidMount == "function" && (d.flags |= 4194308);
        }
        function cu(d, p) {
            try {
                var w = "", E = p;
                do w += je(E), E = E.return;
                while (E);
                var O = w;
            } catch (b) {
                O = `
Error generating stack: ` + b.message + `
` + b.stack;
            }
            return {
                value: d,
                source: p,
                stack: O,
                digest: null
            };
        }
        function fm(d, p, w) {
            return {
                value: d,
                source: null,
                stack: w ?? null,
                digest: p ?? null
            };
        }
        function dm(d, p) {
            try {
                console.error(p.value);
            } catch (w) {
                setTimeout(function() {
                    throw w;
                });
            }
        }
        var zI = typeof WeakMap == "function" ? WeakMap : Map;
        function A8(d, p, w) {
            w = Rc(-1, w), w.tag = 3, w.payload = {
                element: null
            };
            var E = p.value;
            return w.callback = function() {
                Yg || (Yg = !0, Rm = E), dm(d, p);
            }, w;
        }
        function k8(d, p, w) {
            w = Rc(-1, w), w.tag = 3;
            var E = d.type.getDerivedStateFromError;
            if (typeof E == "function") {
                var O = p.value;
                w.payload = function() {
                    return E(O);
                }, w.callback = function() {
                    dm(d, p);
                };
            }
            var b = d.stateNode;
            return b !== null && typeof b.componentDidCatch == "function" && (w.callback = function() {
                dm(d, p), typeof E != "function" && (ul === null ? ul = new Set([
                    this
                ]) : ul.add(this));
                var j = p.stack;
                this.componentDidCatch(p.value, {
                    componentStack: j !== null ? j : ""
                });
            }), w;
        }
        function U8(d, p, w) {
            var E = d.pingCache;
            if (E === null) {
                E = d.pingCache = new zI;
                var O = new Set;
                E.set(p, O);
            } else O = E.get(p), O === void 0 && (O = new Set, E.set(p, O));
            O.has(w) || (O.add(w), d = iM.bind(null, d, p, w), p.then(d, d));
        }
        function F8(d) {
            do {
                var p;
                if ((p = d.tag === 13) && (p = d.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p) return d;
                d = d.return;
            }while (d !== null);
            return null;
        }
        function B8(d, p, w, E, O) {
            return (d.mode & 1) === 0 ? (d === p ? d.flags |= 65536 : (d.flags |= 128, w.flags |= 131072, w.flags &= -52805, w.tag === 1 && (w.alternate === null ? w.tag = 17 : (p = Rc(-1, 1), p.tag = 2, cl(w, p, 1))), w.lanes |= 1), d) : (d.flags |= 65536, d.lanes = O, d);
        }
        var jI = S.ReactCurrentOwner, $a = !1;
        function Sa(d, p, w, E) {
            p.child = d === null ? o8(p, null, w, E) : iu(p, d.child, w, E);
        }
        function G8(d, p, w, E, O) {
            w = w.render;
            var b = p.ref;
            return ou(p, O), E = rm(d, p, w, E, b, O), w = im(), d !== null && !$a ? (p.updateQueue = d.updateQueue, p.flags &= -2053, d.lanes &= ~O, Oc(d, p, O)) : (hr && w && B2(p), p.flags |= 1, Sa(d, p, E, O), p.child);
        }
        function W8(d, p, w, E, O) {
            if (d === null) {
                var b = w.type;
                return typeof b == "function" && !Vm(b) && b.defaultProps === void 0 && w.compare === null && w.defaultProps === void 0 ? (p.tag = 15, p.type = b, $8(d, p, b, E, O)) : (d = n1(w.type, null, E, p, p.mode, O), d.ref = p.ref, d.return = p, p.child = d);
            }
            if (b = d.child, (d.lanes & O) === 0) {
                var j = b.memoizedProps;
                if (w = w.compare, w = w !== null ? w : Wn, w(j, E) && d.ref === p.ref) return Oc(d, p, O);
            }
            return p.flags |= 1, d = hl(b, E), d.ref = p.ref, d.return = p, p.child = d;
        }
        function $8(d, p, w, E, O) {
            if (d !== null) {
                var b = d.memoizedProps;
                if (Wn(b, E) && d.ref === p.ref) if ($a = !1, p.pendingProps = E = b, (d.lanes & O) !== 0) (d.flags & 131072) !== 0 && ($a = !0);
                else return p.lanes = d.lanes, Oc(d, p, O);
            }
            return gm(d, p, w, E, O);
        }
        function z8(d, p, w) {
            var E = p.pendingProps, O = E.children, b = d !== null ? d.memoizedState : null;
            if (E.mode === "hidden") if ((p.mode & 1) === 0) p.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            }, Yn(uu, go), go |= w;
            else {
                if ((w & 1073741824) === 0) return d = b !== null ? b.baseLanes | w : w, p.lanes = p.childLanes = 1073741824, p.memoizedState = {
                    baseLanes: d,
                    cachePool: null,
                    transitions: null
                }, p.updateQueue = null, Yn(uu, go), go |= d, null;
                p.memoizedState = {
                    baseLanes: 0,
                    cachePool: null,
                    transitions: null
                }, E = b !== null ? b.baseLanes : w, Yn(uu, go), go |= E;
            }
            else b !== null ? (E = b.baseLanes | w, p.memoizedState = null) : E = w, Yn(uu, go), go |= E;
            return Sa(d, p, O, w), p.child;
        }
        function j8(d, p) {
            var w = p.ref;
            (d === null && w !== null || d !== null && d.ref !== w) && (p.flags |= 512, p.flags |= 2097152);
        }
        function gm(d, p, w, E, O) {
            var b = Wa(w) ? t0 : Qi.current;
            return b = eu(p, b), ou(p, O), w = rm(d, p, w, E, b, O), E = im(), d !== null && !$a ? (p.updateQueue = d.updateQueue, p.flags &= -2053, d.lanes &= ~O, Oc(d, p, O)) : (hr && E && B2(p), p.flags |= 1, Sa(d, p, w, O), p.child);
        }
        function H8(d, p, w, E, O) {
            if (Wa(w)) {
                var b = !0;
                Rg(p);
            } else b = !1;
            if (ou(p, O), p.stateNode === null) jg(d, p), V8(p, w, E), um(p, w, E, O), E = !0;
            else if (d === null) {
                var j = p.stateNode, fe = p.memoizedProps;
                j.props = fe;
                var ve = j.context, Ie = w.contextType;
                typeof Ie == "object" && Ie !== null ? Ie = Go(Ie) : (Ie = Wa(w) ? t0 : Qi.current, Ie = eu(p, Ie));
                var Ye = w.getDerivedStateFromProps, tt = typeof Ye == "function" || typeof j.getSnapshotBeforeUpdate == "function";
                tt || typeof j.UNSAFE_componentWillReceiveProps != "function" && typeof j.componentWillReceiveProps != "function" || (fe !== E || ve !== Ie) && N8(p, j, E, Ie), sl = !1;
                var qe = p.memoizedState;
                j.state = qe, Ag(p, E, j, O), ve = p.memoizedState, fe !== E || qe !== ve || Ga.current || sl ? (typeof Ye == "function" && (lm(p, w, Ye, E), ve = p.memoizedState), (fe = sl || P8(p, w, fe, E, qe, ve, Ie)) ? (tt || typeof j.UNSAFE_componentWillMount != "function" && typeof j.componentWillMount != "function" || (typeof j.componentWillMount == "function" && j.componentWillMount(), typeof j.UNSAFE_componentWillMount == "function" && j.UNSAFE_componentWillMount()), typeof j.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof j.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = E, p.memoizedState = ve), j.props = E, j.state = ve, j.context = Ie, E = fe) : (typeof j.componentDidMount == "function" && (p.flags |= 4194308), E = !1);
            } else {
                j = p.stateNode, c8(d, p), fe = p.memoizedProps, Ie = p.type === p.elementType ? fe : ss(p.type, fe), j.props = Ie, tt = p.pendingProps, qe = j.context, ve = w.contextType, typeof ve == "object" && ve !== null ? ve = Go(ve) : (ve = Wa(w) ? t0 : Qi.current, ve = eu(p, ve));
                var dt = w.getDerivedStateFromProps;
                (Ye = typeof dt == "function" || typeof j.getSnapshotBeforeUpdate == "function") || typeof j.UNSAFE_componentWillReceiveProps != "function" && typeof j.componentWillReceiveProps != "function" || (fe !== tt || qe !== ve) && N8(p, j, E, ve), sl = !1, qe = p.memoizedState, j.state = qe, Ag(p, E, j, O);
                var vt = p.memoizedState;
                fe !== tt || qe !== vt || Ga.current || sl ? (typeof dt == "function" && (lm(p, w, dt, E), vt = p.memoizedState), (Ie = sl || P8(p, w, Ie, E, qe, vt, ve) || !1) ? (Ye || typeof j.UNSAFE_componentWillUpdate != "function" && typeof j.componentWillUpdate != "function" || (typeof j.componentWillUpdate == "function" && j.componentWillUpdate(E, vt, ve), typeof j.UNSAFE_componentWillUpdate == "function" && j.UNSAFE_componentWillUpdate(E, vt, ve)), typeof j.componentDidUpdate == "function" && (p.flags |= 4), typeof j.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof j.componentDidUpdate != "function" || fe === d.memoizedProps && qe === d.memoizedState || (p.flags |= 4), typeof j.getSnapshotBeforeUpdate != "function" || fe === d.memoizedProps && qe === d.memoizedState || (p.flags |= 1024), p.memoizedProps = E, p.memoizedState = vt), j.props = E, j.state = vt, j.context = ve, E = Ie) : (typeof j.componentDidUpdate != "function" || fe === d.memoizedProps && qe === d.memoizedState || (p.flags |= 4), typeof j.getSnapshotBeforeUpdate != "function" || fe === d.memoizedProps && qe === d.memoizedState || (p.flags |= 1024), E = !1);
            }
            return hm(d, p, w, E, b, O);
        }
        function hm(d, p, w, E, O, b) {
            j8(d, p);
            var j = (p.flags & 128) !== 0;
            if (!E && !j) return O && Zy(p, w, !1), Oc(d, p, b);
            E = p.stateNode, jI.current = p;
            var fe = j && typeof w.getDerivedStateFromError != "function" ? null : E.render();
            return p.flags |= 1, d !== null && j ? (p.child = iu(p, d.child, null, b), p.child = iu(p, null, fe, b)) : Sa(d, p, fe, b), p.memoizedState = E.state, O && Zy(p, w, !0), p.child;
        }
        function K8(d) {
            var p = d.stateNode;
            p.pendingContext ? Xy(d, p.pendingContext, p.pendingContext !== p.context) : p.context && Xy(d, p.context, !1), Z2(d, p.containerInfo);
        }
        function q8(d, p, w, E, O) {
            return ru(), z2(O), p.flags |= 256, Sa(d, p, w, E), p.child;
        }
        var pm = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0
        };
        function mm(d) {
            return {
                baseLanes: d,
                cachePool: null,
                transitions: null
            };
        }
        function X8(d, p, w) {
            var E = p.pendingProps, O = Tr.current, b = !1, j = (p.flags & 128) !== 0, fe;
            if ((fe = j) || (fe = d !== null && d.memoizedState === null ? !1 : (O & 2) !== 0), fe ? (b = !0, p.flags &= -129) : (d === null || d.memoizedState !== null) && (O |= 1), Yn(Tr, O & 1), d === null) return $2(p), d = p.memoizedState, d !== null && (d = d.dehydrated, d !== null) ? ((p.mode & 1) === 0 ? p.lanes = 1 : d.data === "$!" ? p.lanes = 8 : p.lanes = 1073741824, null) : (j = E.children, d = E.fallback, b ? (E = p.mode, b = p.child, j = {
                mode: "hidden",
                children: j
            }, (E & 1) === 0 && b !== null ? (b.childLanes = 0, b.pendingProps = j) : b = r1(j, E, 0, null), d = f0(d, E, w, null), b.return = p, d.return = p, b.sibling = d, p.child = b, p.child.memoizedState = mm(w), p.memoizedState = pm, d) : vm(p, j));
            if (O = d.memoizedState, O !== null && (fe = O.dehydrated, fe !== null)) return HI(d, p, j, E, fe, O, w);
            if (b) {
                b = E.fallback, j = p.mode, O = d.child, fe = O.sibling;
                var ve = {
                    mode: "hidden",
                    children: E.children
                };
                return (j & 1) === 0 && p.child !== O ? (E = p.child, E.childLanes = 0, E.pendingProps = ve, p.deletions = null) : (E = hl(O, ve), E.subtreeFlags = O.subtreeFlags & 14680064), fe !== null ? b = hl(fe, b) : (b = f0(b, j, w, null), b.flags |= 2), b.return = p, E.return = p, E.sibling = b, p.child = E, E = b, b = p.child, j = d.child.memoizedState, j = j === null ? mm(w) : {
                    baseLanes: j.baseLanes | w,
                    cachePool: null,
                    transitions: j.transitions
                }, b.memoizedState = j, b.childLanes = d.childLanes & ~w, p.memoizedState = pm, E;
            }
            return b = d.child, d = b.sibling, E = hl(b, {
                mode: "visible",
                children: E.children
            }), (p.mode & 1) === 0 && (E.lanes = w), E.return = p, E.sibling = null, d !== null && (w = p.deletions, w === null ? (p.deletions = [
                d
            ], p.flags |= 16) : w.push(d)), p.child = E, p.memoizedState = null, E;
        }
        function vm(d, p) {
            return p = r1({
                mode: "visible",
                children: p
            }, d.mode, 0, null), p.return = d, d.child = p;
        }
        function zg(d, p, w, E) {
            return E !== null && z2(E), iu(p, d.child, null, w), d = vm(p, p.pendingProps.children), d.flags |= 2, p.memoizedState = null, d;
        }
        function HI(d, p, w, E, O, b, j) {
            if (w) return p.flags & 256 ? (p.flags &= -257, E = fm(Error(n(422))), zg(d, p, j, E)) : p.memoizedState !== null ? (p.child = d.child, p.flags |= 128, null) : (b = E.fallback, O = p.mode, E = r1({
                mode: "visible",
                children: E.children
            }, O, 0, null), b = f0(b, O, j, null), b.flags |= 2, E.return = p, b.return = p, E.sibling = b, p.child = E, (p.mode & 1) !== 0 && iu(p, d.child, null, j), p.child.memoizedState = mm(j), p.memoizedState = pm, b);
            if ((p.mode & 1) === 0) return zg(d, p, j, null);
            if (O.data === "$!") {
                if (E = O.nextSibling && O.nextSibling.dataset, E) var fe = E.dgst;
                return E = fe, b = Error(n(419)), E = fm(b, E, void 0), zg(d, p, j, E);
            }
            if (fe = (j & d.childLanes) !== 0, $a || fe) {
                if (E = Ri, E !== null) {
                    switch(j & -j){
                        case 4:
                            O = 2;
                            break;
                        case 16:
                            O = 8;
                            break;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            O = 32;
                            break;
                        case 536870912:
                            O = 268435456;
                            break;
                        default:
                            O = 0;
                    }
                    O = (O & (E.suspendedLanes | j)) !== 0 ? 0 : O, O !== 0 && O !== b.retryLane && (b.retryLane = O, _c(d, O), us(E, d, O, -1));
                }
                return Pm(), E = fm(Error(n(421))), zg(d, p, j, E);
            }
            return O.data === "$?" ? (p.flags |= 128, p.child = d.child, p = aM.bind(null, d), O._reactRetry = p, null) : (d = b.treeContext, fo = rl(O.nextSibling), uo = p, hr = !0, os = null, d !== null && (Fo[Bo++] = Ec, Fo[Bo++] = Dc, Fo[Bo++] = n0, Ec = d.id, Dc = d.overflow, n0 = p), p = vm(p, E.children), p.flags |= 4096, p);
        }
        function Y8(d, p, w) {
            d.lanes |= p;
            var E = d.alternate;
            E !== null && (E.lanes |= p), q2(d.return, p, w);
        }
        function ym(d, p, w, E, O) {
            var b = d.memoizedState;
            b === null ? d.memoizedState = {
                isBackwards: p,
                rendering: null,
                renderingStartTime: 0,
                last: E,
                tail: w,
                tailMode: O
            } : (b.isBackwards = p, b.rendering = null, b.renderingStartTime = 0, b.last = E, b.tail = w, b.tailMode = O);
        }
        function Z8(d, p, w) {
            var E = p.pendingProps, O = E.revealOrder, b = E.tail;
            if (Sa(d, p, E.children, w), E = Tr.current, (E & 2) !== 0) E = E & 1 | 2, p.flags |= 128;
            else {
                if (d !== null && (d.flags & 128) !== 0) e: for(d = p.child; d !== null;){
                    if (d.tag === 13) d.memoizedState !== null && Y8(d, w, p);
                    else if (d.tag === 19) Y8(d, w, p);
                    else if (d.child !== null) {
                        d.child.return = d, d = d.child;
                        continue;
                    }
                    if (d === p) break e;
                    for(; d.sibling === null;){
                        if (d.return === null || d.return === p) break e;
                        d = d.return;
                    }
                    d.sibling.return = d.return, d = d.sibling;
                }
                E &= 1;
            }
            if (Yn(Tr, E), (p.mode & 1) === 0) p.memoizedState = null;
            else switch(O){
                case "forwards":
                    for(w = p.child, O = null; w !== null;)d = w.alternate, d !== null && kg(d) === null && (O = w), w = w.sibling;
                    w = O, w === null ? (O = p.child, p.child = null) : (O = w.sibling, w.sibling = null), ym(p, !1, O, w, b);
                    break;
                case "backwards":
                    for(w = null, O = p.child, p.child = null; O !== null;){
                        if (d = O.alternate, d !== null && kg(d) === null) {
                            p.child = O;
                            break;
                        }
                        d = O.sibling, O.sibling = w, w = O, O = d;
                    }
                    ym(p, !0, w, null, b);
                    break;
                case "together":
                    ym(p, !1, null, null, void 0);
                    break;
                default:
                    p.memoizedState = null;
            }
            return p.child;
        }
        function jg(d, p) {
            (p.mode & 1) === 0 && d !== null && (d.alternate = null, p.alternate = null, p.flags |= 2);
        }
        function Oc(d, p, w) {
            if (d !== null && (p.dependencies = d.dependencies), s0 |= p.lanes, (w & p.childLanes) === 0) return null;
            if (d !== null && p.child !== d.child) throw Error(n(153));
            if (p.child !== null) {
                for(d = p.child, w = hl(d, d.pendingProps), p.child = w, w.return = p; d.sibling !== null;)d = d.sibling, w = w.sibling = hl(d, d.pendingProps), w.return = p;
                w.sibling = null;
            }
            return p.child;
        }
        function KI(d, p, w) {
            switch(p.tag){
                case 3:
                    K8(p), ru();
                    break;
                case 5:
                    f8(p);
                    break;
                case 1:
                    Wa(p.type) && Rg(p);
                    break;
                case 4:
                    Z2(p, p.stateNode.containerInfo);
                    break;
                case 10:
                    var E = p.type._context, O = p.memoizedProps.value;
                    Yn(Pg, E._currentValue), E._currentValue = O;
                    break;
                case 13:
                    if (E = p.memoizedState, E !== null) return E.dehydrated !== null ? (Yn(Tr, Tr.current & 1), p.flags |= 128, null) : (w & p.child.childLanes) !== 0 ? X8(d, p, w) : (Yn(Tr, Tr.current & 1), d = Oc(d, p, w), d !== null ? d.sibling : null);
                    Yn(Tr, Tr.current & 1);
                    break;
                case 19:
                    if (E = (w & p.childLanes) !== 0, (d.flags & 128) !== 0) {
                        if (E) return Z8(d, p, w);
                        p.flags |= 128;
                    }
                    if (O = p.memoizedState, O !== null && (O.rendering = null, O.tail = null, O.lastEffect = null), Yn(Tr, Tr.current), E) break;
                    return null;
                case 22:
                case 23:
                    return p.lanes = 0, z8(d, p, w);
            }
            return Oc(d, p, w);
        }
        var J8, Cm, Q8, e6;
        J8 = function(d, p) {
            for(var w = p.child; w !== null;){
                if (w.tag === 5 || w.tag === 6) d.appendChild(w.stateNode);
                else if (w.tag !== 4 && w.child !== null) {
                    w.child.return = w, w = w.child;
                    continue;
                }
                if (w === p) break;
                for(; w.sibling === null;){
                    if (w.return === null || w.return === p) return;
                    w = w.return;
                }
                w.sibling.return = w.return, w = w.sibling;
            }
        }, Cm = function() {}, Q8 = function(d, p, w, E) {
            var O = d.memoizedProps;
            if (O !== E) {
                d = p.stateNode, a0(Bs.current);
                var b = null;
                switch(w){
                    case "input":
                        O = Pe(d, O), E = Pe(d, E), b = [];
                        break;
                    case "select":
                        O = re({}, O, {
                            value: void 0
                        }), E = re({}, E, {
                            value: void 0
                        }), b = [];
                        break;
                    case "textarea":
                        O = Q(d, O), E = Q(d, E), b = [];
                        break;
                    default:
                        typeof O.onClick != "function" && typeof E.onClick == "function" && (d.onclick = Eg);
                }
                De(w, E);
                var j;
                w = null;
                for(Ie in O)if (!E.hasOwnProperty(Ie) && O.hasOwnProperty(Ie) && O[Ie] != null) if (Ie === "style") {
                    var fe = O[Ie];
                    for(j in fe)fe.hasOwnProperty(j) && (w || (w = {}), w[j] = "");
                } else Ie !== "dangerouslySetInnerHTML" && Ie !== "children" && Ie !== "suppressContentEditableWarning" && Ie !== "suppressHydrationWarning" && Ie !== "autoFocus" && (i.hasOwnProperty(Ie) ? b || (b = []) : (b = b || []).push(Ie, null));
                for(Ie in E){
                    var ve = E[Ie];
                    if (fe = O?.[Ie], E.hasOwnProperty(Ie) && ve !== fe && (ve != null || fe != null)) if (Ie === "style") if (fe) {
                        for(j in fe)!fe.hasOwnProperty(j) || ve && ve.hasOwnProperty(j) || (w || (w = {}), w[j] = "");
                        for(j in ve)ve.hasOwnProperty(j) && fe[j] !== ve[j] && (w || (w = {}), w[j] = ve[j]);
                    } else w || (b || (b = []), b.push(Ie, w)), w = ve;
                    else Ie === "dangerouslySetInnerHTML" ? (ve = ve ? ve.__html : void 0, fe = fe ? fe.__html : void 0, ve != null && fe !== ve && (b = b || []).push(Ie, ve)) : Ie === "children" ? typeof ve != "string" && typeof ve != "number" || (b = b || []).push(Ie, "" + ve) : Ie !== "suppressContentEditableWarning" && Ie !== "suppressHydrationWarning" && (i.hasOwnProperty(Ie) ? (ve != null && Ie === "onScroll" && ar("scroll", d), b || fe === ve || (b = [])) : (b = b || []).push(Ie, ve));
                }
                w && (b = b || []).push("style", w);
                var Ie = b;
                (p.updateQueue = Ie) && (p.flags |= 4);
            }
        }, e6 = function(d, p, w, E) {
            w !== E && (p.flags |= 4);
        };
        function bf(d, p) {
            if (!hr) switch(d.tailMode){
                case "hidden":
                    p = d.tail;
                    for(var w = null; p !== null;)p.alternate !== null && (w = p), p = p.sibling;
                    w === null ? d.tail = null : w.sibling = null;
                    break;
                case "collapsed":
                    w = d.tail;
                    for(var E = null; w !== null;)w.alternate !== null && (E = w), w = w.sibling;
                    E === null ? p || d.tail === null ? d.tail = null : d.tail.sibling = null : E.sibling = null;
            }
        }
        function ta(d) {
            var p = d.alternate !== null && d.alternate.child === d.child, w = 0, E = 0;
            if (p) for(var O = d.child; O !== null;)w |= O.lanes | O.childLanes, E |= O.subtreeFlags & 14680064, E |= O.flags & 14680064, O.return = d, O = O.sibling;
            else for(O = d.child; O !== null;)w |= O.lanes | O.childLanes, E |= O.subtreeFlags, E |= O.flags, O.return = d, O = O.sibling;
            return d.subtreeFlags |= E, d.childLanes = w, p;
        }
        function qI(d, p, w) {
            var E = p.pendingProps;
            switch(G2(p), p.tag){
                case 2:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return ta(p), null;
                case 1:
                    return Wa(p.type) && _g(), ta(p), null;
                case 3:
                    return E = p.stateNode, su(), or(Ga), or(Qi), em(), E.pendingContext && (E.context = E.pendingContext, E.pendingContext = null), (d === null || d.child === null) && (bg(p) ? p.flags |= 4 : d === null || d.memoizedState.isDehydrated && (p.flags & 256) === 0 || (p.flags |= 1024, os !== null && (Mm(os), os = null))), Cm(d, p), ta(p), null;
                case 5:
                    J2(p);
                    var O = a0(_f.current);
                    if (w = p.type, d !== null && p.stateNode != null) Q8(d, p, w, E, O), d.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
                    else {
                        if (!E) {
                            if (p.stateNode === null) throw Error(n(166));
                            return ta(p), null;
                        }
                        if (d = a0(Bs.current), bg(p)) {
                            E = p.stateNode, w = p.type;
                            var b = p.memoizedProps;
                            switch(E[Fs] = p, E[Tf] = b, d = (p.mode & 1) !== 0, w){
                                case "dialog":
                                    ar("cancel", E), ar("close", E);
                                    break;
                                case "iframe":
                                case "object":
                                case "embed":
                                    ar("load", E);
                                    break;
                                case "video":
                                case "audio":
                                    for(O = 0; O < yf.length; O++)ar(yf[O], E);
                                    break;
                                case "source":
                                    ar("error", E);
                                    break;
                                case "img":
                                case "image":
                                case "link":
                                    ar("error", E), ar("load", E);
                                    break;
                                case "details":
                                    ar("toggle", E);
                                    break;
                                case "input":
                                    Ct(E, b), ar("invalid", E);
                                    break;
                                case "select":
                                    E._wrapperState = {
                                        wasMultiple: !!b.multiple
                                    }, ar("invalid", E);
                                    break;
                                case "textarea":
                                    me(E, b), ar("invalid", E);
                            }
                            De(w, b), O = null;
                            for(var j in b)if (b.hasOwnProperty(j)) {
                                var fe = b[j];
                                j === "children" ? typeof fe == "string" ? E.textContent !== fe && (b.suppressHydrationWarning !== !0 && Sg(E.textContent, fe, d), O = [
                                    "children",
                                    fe
                                ]) : typeof fe == "number" && E.textContent !== "" + fe && (b.suppressHydrationWarning !== !0 && Sg(E.textContent, fe, d), O = [
                                    "children",
                                    "" + fe
                                ]) : i.hasOwnProperty(j) && fe != null && j === "onScroll" && ar("scroll", E);
                            }
                            switch(w){
                                case "input":
                                    Ln(E), ln(E, b, !0);
                                    break;
                                case "textarea":
                                    Ln(E), Ce(E);
                                    break;
                                case "select":
                                case "option":
                                    break;
                                default:
                                    typeof b.onClick == "function" && (E.onclick = Eg);
                            }
                            E = O, p.updateQueue = E, E !== null && (p.flags |= 4);
                        } else {
                            j = O.nodeType === 9 ? O : O.ownerDocument, d === "http://www.w3.org/1999/xhtml" && (d = Ue(w)), d === "http://www.w3.org/1999/xhtml" ? w === "script" ? (d = j.createElement("div"), d.innerHTML = "<script><\/script>", d = d.removeChild(d.firstChild)) : typeof E.is == "string" ? d = j.createElement(w, {
                                is: E.is
                            }) : (d = j.createElement(w), w === "select" && (j = d, E.multiple ? j.multiple = !0 : E.size && (j.size = E.size))) : d = j.createElementNS(d, w), d[Fs] = p, d[Tf] = E, J8(d, p, !1, !1), p.stateNode = d;
                            e: {
                                switch(j = ze(w, E), w){
                                    case "dialog":
                                        ar("cancel", d), ar("close", d), O = E;
                                        break;
                                    case "iframe":
                                    case "object":
                                    case "embed":
                                        ar("load", d), O = E;
                                        break;
                                    case "video":
                                    case "audio":
                                        for(O = 0; O < yf.length; O++)ar(yf[O], d);
                                        O = E;
                                        break;
                                    case "source":
                                        ar("error", d), O = E;
                                        break;
                                    case "img":
                                    case "image":
                                    case "link":
                                        ar("error", d), ar("load", d), O = E;
                                        break;
                                    case "details":
                                        ar("toggle", d), O = E;
                                        break;
                                    case "input":
                                        Ct(d, E), O = Pe(d, E), ar("invalid", d);
                                        break;
                                    case "option":
                                        O = E;
                                        break;
                                    case "select":
                                        d._wrapperState = {
                                            wasMultiple: !!E.multiple
                                        }, O = re({}, E, {
                                            value: void 0
                                        }), ar("invalid", d);
                                        break;
                                    case "textarea":
                                        me(d, E), O = Q(d, E), ar("invalid", d);
                                        break;
                                    default:
                                        O = E;
                                }
                                De(w, O), fe = O;
                                for(b in fe)if (fe.hasOwnProperty(b)) {
                                    var ve = fe[b];
                                    b === "style" ? mn(d, ve) : b === "dangerouslySetInnerHTML" ? (ve = ve ? ve.__html : void 0, ve != null && jt(d, ve)) : b === "children" ? typeof ve == "string" ? (w !== "textarea" || ve !== "") && Cn(d, ve) : typeof ve == "number" && Cn(d, "" + ve) : b !== "suppressContentEditableWarning" && b !== "suppressHydrationWarning" && b !== "autoFocus" && (i.hasOwnProperty(b) ? ve != null && b === "onScroll" && ar("scroll", d) : ve != null && x(d, b, ve, j));
                                }
                                switch(w){
                                    case "input":
                                        Ln(d), ln(d, E, !1);
                                        break;
                                    case "textarea":
                                        Ln(d), Ce(d);
                                        break;
                                    case "option":
                                        E.value != null && d.setAttribute("value", "" + Qe(E.value));
                                        break;
                                    case "select":
                                        d.multiple = !!E.multiple, b = E.value, b != null ? q(d, !!E.multiple, b, !1) : E.defaultValue != null && q(d, !!E.multiple, E.defaultValue, !0);
                                        break;
                                    default:
                                        typeof O.onClick == "function" && (d.onclick = Eg);
                                }
                                switch(w){
                                    case "button":
                                    case "input":
                                    case "select":
                                    case "textarea":
                                        E = !!E.autoFocus;
                                        break e;
                                    case "img":
                                        E = !0;
                                        break e;
                                    default:
                                        E = !1;
                                }
                            }
                            E && (p.flags |= 4);
                        }
                        p.ref !== null && (p.flags |= 512, p.flags |= 2097152);
                    }
                    return ta(p), null;
                case 6:
                    if (d && p.stateNode != null) e6(d, p, d.memoizedProps, E);
                    else {
                        if (typeof E != "string" && p.stateNode === null) throw Error(n(166));
                        if (w = a0(_f.current), a0(Bs.current), bg(p)) {
                            if (E = p.stateNode, w = p.memoizedProps, E[Fs] = p, (b = E.nodeValue !== w) && (d = uo, d !== null)) switch(d.tag){
                                case 3:
                                    Sg(E.nodeValue, w, (d.mode & 1) !== 0);
                                    break;
                                case 5:
                                    d.memoizedProps.suppressHydrationWarning !== !0 && Sg(E.nodeValue, w, (d.mode & 1) !== 0);
                            }
                            b && (p.flags |= 4);
                        } else E = (w.nodeType === 9 ? w : w.ownerDocument).createTextNode(E), E[Fs] = p, p.stateNode = E;
                    }
                    return ta(p), null;
                case 13:
                    if (or(Tr), E = p.memoizedState, d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
                        if (hr && fo !== null && (p.mode & 1) !== 0 && (p.flags & 128) === 0) r8(), ru(), p.flags |= 98560, b = !1;
                        else if (b = bg(p), E !== null && E.dehydrated !== null) {
                            if (d === null) {
                                if (!b) throw Error(n(318));
                                if (b = p.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(n(317));
                                b[Fs] = p;
                            } else ru(), (p.flags & 128) === 0 && (p.memoizedState = null), p.flags |= 4;
                            ta(p), b = !1;
                        } else os !== null && (Mm(os), os = null), b = !0;
                        if (!b) return p.flags & 65536 ? p : null;
                    }
                    return (p.flags & 128) !== 0 ? (p.lanes = w, p) : (E = E !== null, E !== (d !== null && d.memoizedState !== null) && E && (p.child.flags |= 8192, (p.mode & 1) !== 0 && (d === null || (Tr.current & 1) !== 0 ? hi === 0 && (hi = 3) : Pm())), p.updateQueue !== null && (p.flags |= 4), ta(p), null);
                case 4:
                    return su(), Cm(d, p), d === null && Cf(p.stateNode.containerInfo), ta(p), null;
                case 10:
                    return K2(p.type._context), ta(p), null;
                case 17:
                    return Wa(p.type) && _g(), ta(p), null;
                case 19:
                    if (or(Tr), b = p.memoizedState, b === null) return ta(p), null;
                    if (E = (p.flags & 128) !== 0, j = b.rendering, j === null) if (E) bf(b, !1);
                    else {
                        if (hi !== 0 || d !== null && (d.flags & 128) !== 0) for(d = p.child; d !== null;){
                            if (j = kg(d), j !== null) {
                                for(p.flags |= 128, bf(b, !1), E = j.updateQueue, E !== null && (p.updateQueue = E, p.flags |= 4), p.subtreeFlags = 0, E = w, w = p.child; w !== null;)b = w, d = E, b.flags &= 14680066, j = b.alternate, j === null ? (b.childLanes = 0, b.lanes = d, b.child = null, b.subtreeFlags = 0, b.memoizedProps = null, b.memoizedState = null, b.updateQueue = null, b.dependencies = null, b.stateNode = null) : (b.childLanes = j.childLanes, b.lanes = j.lanes, b.child = j.child, b.subtreeFlags = 0, b.deletions = null, b.memoizedProps = j.memoizedProps, b.memoizedState = j.memoizedState, b.updateQueue = j.updateQueue, b.type = j.type, d = j.dependencies, b.dependencies = d === null ? null : {
                                    lanes: d.lanes,
                                    firstContext: d.firstContext
                                }), w = w.sibling;
                                return Yn(Tr, Tr.current & 1 | 2), p.child;
                            }
                            d = d.sibling;
                        }
                        b.tail !== null && Pn() > fu && (p.flags |= 128, E = !0, bf(b, !1), p.lanes = 4194304);
                    }
                    else {
                        if (!E) if (d = kg(j), d !== null) {
                            if (p.flags |= 128, E = !0, w = d.updateQueue, w !== null && (p.updateQueue = w, p.flags |= 4), bf(b, !0), b.tail === null && b.tailMode === "hidden" && !j.alternate && !hr) return ta(p), null;
                        } else 2 * Pn() - b.renderingStartTime > fu && w !== 1073741824 && (p.flags |= 128, E = !0, bf(b, !1), p.lanes = 4194304);
                        b.isBackwards ? (j.sibling = p.child, p.child = j) : (w = b.last, w !== null ? w.sibling = j : p.child = j, b.last = j);
                    }
                    return b.tail !== null ? (p = b.tail, b.rendering = p, b.tail = p.sibling, b.renderingStartTime = Pn(), p.sibling = null, w = Tr.current, Yn(Tr, E ? w & 1 | 2 : w & 1), p) : (ta(p), null);
                case 22:
                case 23:
                    return Lm(), E = p.memoizedState !== null, d !== null && d.memoizedState !== null !== E && (p.flags |= 8192), E && (p.mode & 1) !== 0 ? (go & 1073741824) !== 0 && (ta(p), p.subtreeFlags & 6 && (p.flags |= 8192)) : ta(p), null;
                case 24:
                    return null;
                case 25:
                    return null;
            }
            throw Error(n(156, p.tag));
        }
        function XI(d, p) {
            switch(G2(p), p.tag){
                case 1:
                    return Wa(p.type) && _g(), d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
                case 3:
                    return su(), or(Ga), or(Qi), em(), d = p.flags, (d & 65536) !== 0 && (d & 128) === 0 ? (p.flags = d & -65537 | 128, p) : null;
                case 5:
                    return J2(p), null;
                case 13:
                    if (or(Tr), d = p.memoizedState, d !== null && d.dehydrated !== null) {
                        if (p.alternate === null) throw Error(n(340));
                        ru();
                    }
                    return d = p.flags, d & 65536 ? (p.flags = d & -65537 | 128, p) : null;
                case 19:
                    return or(Tr), null;
                case 4:
                    return su(), null;
                case 10:
                    return K2(p.type._context), null;
                case 22:
                case 23:
                    return Lm(), null;
                case 24:
                    return null;
                default:
                    return null;
            }
        }
        var Hg = !1, na = !1, YI = typeof WeakSet == "function" ? WeakSet : Set, pt = null;
        function lu(d, p) {
            var w = d.ref;
            if (w !== null) if (typeof w == "function") try {
                w(null);
            } catch (E) {
                Nr(d, p, E);
            }
            else w.current = null;
        }
        function wm(d, p, w) {
            try {
                w();
            } catch (E) {
                Nr(d, p, E);
            }
        }
        var t6 = !1;
        function ZI(d, p) {
            if (L2 = so, d = Ql(), Tc(d)) {
                if ("selectionStart" in d) var w = {
                    start: d.selectionStart,
                    end: d.selectionEnd
                };
                else e: {
                    w = (w = d.ownerDocument) && w.defaultView || window;
                    var E = w.getSelection && w.getSelection();
                    if (E && E.rangeCount !== 0) {
                        w = E.anchorNode;
                        var O = E.anchorOffset, b = E.focusNode;
                        E = E.focusOffset;
                        try {
                            w.nodeType, b.nodeType;
                        } catch  {
                            w = null;
                            break e;
                        }
                        var j = 0, fe = -1, ve = -1, Ie = 0, Ye = 0, tt = d, qe = null;
                        t: for(;;){
                            for(var dt; tt !== w || O !== 0 && tt.nodeType !== 3 || (fe = j + O), tt !== b || E !== 0 && tt.nodeType !== 3 || (ve = j + E), tt.nodeType === 3 && (j += tt.nodeValue.length), (dt = tt.firstChild) !== null;)qe = tt, tt = dt;
                            for(;;){
                                if (tt === d) break t;
                                if (qe === w && ++Ie === O && (fe = j), qe === b && ++Ye === E && (ve = j), (dt = tt.nextSibling) !== null) break;
                                tt = qe, qe = tt.parentNode;
                            }
                            tt = dt;
                        }
                        w = fe === -1 || ve === -1 ? null : {
                            start: fe,
                            end: ve
                        };
                    } else w = null;
                }
                w = w || {
                    start: 0,
                    end: 0
                };
            } else w = null;
            for(P2 = {
                focusedElem: d,
                selectionRange: w
            }, so = !1, pt = p; pt !== null;)if (p = pt, d = p.child, (p.subtreeFlags & 1028) !== 0 && d !== null) d.return = p, pt = d;
            else for(; pt !== null;){
                p = pt;
                try {
                    var vt = p.alternate;
                    if ((p.flags & 1024) !== 0) switch(p.tag){
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (vt !== null) {
                                var wt = vt.memoizedProps, jr = vt.memoizedState, Ee = p.stateNode, we = Ee.getSnapshotBeforeUpdate(p.elementType === p.type ? wt : ss(p.type, wt), jr);
                                Ee.__reactInternalSnapshotBeforeUpdate = we;
                            }
                            break;
                        case 3:
                            var Re = p.stateNode.containerInfo;
                            Re.nodeType === 1 ? Re.textContent = "" : Re.nodeType === 9 && Re.documentElement && Re.removeChild(Re.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(n(163));
                    }
                } catch (at) {
                    Nr(p, p.return, at);
                }
                if (d = p.sibling, d !== null) {
                    d.return = p.return, pt = d;
                    break;
                }
                pt = p.return;
            }
            return vt = t6, t6 = !1, vt;
        }
        function Lf(d, p, w) {
            var E = p.updateQueue;
            if (E = E !== null ? E.lastEffect : null, E !== null) {
                var O = E = E.next;
                do {
                    if ((O.tag & d) === d) {
                        var b = O.destroy;
                        O.destroy = void 0, b !== void 0 && wm(p, w, b);
                    }
                    O = O.next;
                }while (O !== E);
            }
        }
        function Kg(d, p) {
            if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) {
                var w = p = p.next;
                do {
                    if ((w.tag & d) === d) {
                        var E = w.create;
                        w.destroy = E();
                    }
                    w = w.next;
                }while (w !== p);
            }
        }
        function Tm(d) {
            var p = d.ref;
            if (p !== null) {
                var w = d.stateNode;
                switch(d.tag){
                    case 5:
                        d = w;
                        break;
                    default:
                        d = w;
                }
                typeof p == "function" ? p(d) : p.current = d;
            }
        }
        function n6(d) {
            var p = d.alternate;
            p !== null && (d.alternate = null, n6(p)), d.child = null, d.deletions = null, d.sibling = null, d.tag === 5 && (p = d.stateNode, p !== null && (delete p[Fs], delete p[Tf], delete p[k2], delete p[PI], delete p[VI])), d.stateNode = null, d.return = null, d.dependencies = null, d.memoizedProps = null, d.memoizedState = null, d.pendingProps = null, d.stateNode = null, d.updateQueue = null;
        }
        function r6(d) {
            return d.tag === 5 || d.tag === 3 || d.tag === 4;
        }
        function i6(d) {
            e: for(;;){
                for(; d.sibling === null;){
                    if (d.return === null || r6(d.return)) return null;
                    d = d.return;
                }
                for(d.sibling.return = d.return, d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18;){
                    if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
                    d.child.return = d, d = d.child;
                }
                if (!(d.flags & 2)) return d.stateNode;
            }
        }
        function xm(d, p, w) {
            var E = d.tag;
            if (E === 5 || E === 6) d = d.stateNode, p ? w.nodeType === 8 ? w.parentNode.insertBefore(d, p) : w.insertBefore(d, p) : (w.nodeType === 8 ? (p = w.parentNode, p.insertBefore(d, w)) : (p = w, p.appendChild(d)), w = w._reactRootContainer, w != null || p.onclick !== null || (p.onclick = Eg));
            else if (E !== 4 && (d = d.child, d !== null)) for(xm(d, p, w), d = d.sibling; d !== null;)xm(d, p, w), d = d.sibling;
        }
        function Sm(d, p, w) {
            var E = d.tag;
            if (E === 5 || E === 6) d = d.stateNode, p ? w.insertBefore(d, p) : w.appendChild(d);
            else if (E !== 4 && (d = d.child, d !== null)) for(Sm(d, p, w), d = d.sibling; d !== null;)Sm(d, p, w), d = d.sibling;
        }
        var Bi = null, cs = !1;
        function ll(d, p, w) {
            for(w = w.child; w !== null;)a6(d, p, w), w = w.sibling;
        }
        function a6(d, p, w) {
            if (ei && typeof ei.onCommitFiberUnmount == "function") try {
                ei.onCommitFiberUnmount(Qr, w);
            } catch  {}
            switch(w.tag){
                case 5:
                    na || lu(w, p);
                case 6:
                    var E = Bi, O = cs;
                    Bi = null, ll(d, p, w), Bi = E, cs = O, Bi !== null && (cs ? (d = Bi, w = w.stateNode, d.nodeType === 8 ? d.parentNode.removeChild(w) : d.removeChild(w)) : Bi.removeChild(w.stateNode));
                    break;
                case 18:
                    Bi !== null && (cs ? (d = Bi, w = w.stateNode, d.nodeType === 8 ? A2(d.parentNode, w) : d.nodeType === 1 && A2(d, w), Ui(d)) : A2(Bi, w.stateNode));
                    break;
                case 4:
                    E = Bi, O = cs, Bi = w.stateNode.containerInfo, cs = !0, ll(d, p, w), Bi = E, cs = O;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    if (!na && (E = w.updateQueue, E !== null && (E = E.lastEffect, E !== null))) {
                        O = E = E.next;
                        do {
                            var b = O, j = b.destroy;
                            b = b.tag, j !== void 0 && ((b & 2) !== 0 || (b & 4) !== 0) && wm(w, p, j), O = O.next;
                        }while (O !== E);
                    }
                    ll(d, p, w);
                    break;
                case 1:
                    if (!na && (lu(w, p), E = w.stateNode, typeof E.componentWillUnmount == "function")) try {
                        E.props = w.memoizedProps, E.state = w.memoizedState, E.componentWillUnmount();
                    } catch (fe) {
                        Nr(w, p, fe);
                    }
                    ll(d, p, w);
                    break;
                case 21:
                    ll(d, p, w);
                    break;
                case 22:
                    w.mode & 1 ? (na = (E = na) || w.memoizedState !== null, ll(d, p, w), na = E) : ll(d, p, w);
                    break;
                default:
                    ll(d, p, w);
            }
        }
        function o6(d) {
            var p = d.updateQueue;
            if (p !== null) {
                d.updateQueue = null;
                var w = d.stateNode;
                w === null && (w = d.stateNode = new YI), p.forEach(function(E) {
                    var O = oM.bind(null, d, E);
                    w.has(E) || (w.add(E), E.then(O, O));
                });
            }
        }
        function ls(d, p) {
            var w = p.deletions;
            if (w !== null) for(var E = 0; E < w.length; E++){
                var O = w[E];
                try {
                    var b = d, j = p, fe = j;
                    e: for(; fe !== null;){
                        switch(fe.tag){
                            case 5:
                                Bi = fe.stateNode, cs = !1;
                                break e;
                            case 3:
                                Bi = fe.stateNode.containerInfo, cs = !0;
                                break e;
                            case 4:
                                Bi = fe.stateNode.containerInfo, cs = !0;
                                break e;
                        }
                        fe = fe.return;
                    }
                    if (Bi === null) throw Error(n(160));
                    a6(b, j, O), Bi = null, cs = !1;
                    var ve = O.alternate;
                    ve !== null && (ve.return = null), O.return = null;
                } catch (Ie) {
                    Nr(O, p, Ie);
                }
            }
            if (p.subtreeFlags & 12854) for(p = p.child; p !== null;)s6(p, d), p = p.sibling;
        }
        function s6(d, p) {
            var w = d.alternate, E = d.flags;
            switch(d.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    if (ls(p, d), Ws(d), E & 4) {
                        try {
                            Lf(3, d, d.return), Kg(3, d);
                        } catch (wt) {
                            Nr(d, d.return, wt);
                        }
                        try {
                            Lf(5, d, d.return);
                        } catch (wt) {
                            Nr(d, d.return, wt);
                        }
                    }
                    break;
                case 1:
                    ls(p, d), Ws(d), E & 512 && w !== null && lu(w, w.return);
                    break;
                case 5:
                    if (ls(p, d), Ws(d), E & 512 && w !== null && lu(w, w.return), d.flags & 32) {
                        var O = d.stateNode;
                        try {
                            Cn(O, "");
                        } catch (wt) {
                            Nr(d, d.return, wt);
                        }
                    }
                    if (E & 4 && (O = d.stateNode, O != null)) {
                        var b = d.memoizedProps, j = w !== null ? w.memoizedProps : b, fe = d.type, ve = d.updateQueue;
                        if (d.updateQueue = null, ve !== null) try {
                            fe === "input" && b.type === "radio" && b.name != null && yt(O, b), ze(fe, j);
                            var Ie = ze(fe, b);
                            for(j = 0; j < ve.length; j += 2){
                                var Ye = ve[j], tt = ve[j + 1];
                                Ye === "style" ? mn(O, tt) : Ye === "dangerouslySetInnerHTML" ? jt(O, tt) : Ye === "children" ? Cn(O, tt) : x(O, Ye, tt, Ie);
                            }
                            switch(fe){
                                case "input":
                                    En(O, b);
                                    break;
                                case "textarea":
                                    J(O, b);
                                    break;
                                case "select":
                                    var qe = O._wrapperState.wasMultiple;
                                    O._wrapperState.wasMultiple = !!b.multiple;
                                    var dt = b.value;
                                    dt != null ? q(O, !!b.multiple, dt, !1) : qe !== !!b.multiple && (b.defaultValue != null ? q(O, !!b.multiple, b.defaultValue, !0) : q(O, !!b.multiple, b.multiple ? [] : "", !1));
                            }
                            O[Tf] = b;
                        } catch (wt) {
                            Nr(d, d.return, wt);
                        }
                    }
                    break;
                case 6:
                    if (ls(p, d), Ws(d), E & 4) {
                        if (d.stateNode === null) throw Error(n(162));
                        O = d.stateNode, b = d.memoizedProps;
                        try {
                            O.nodeValue = b;
                        } catch (wt) {
                            Nr(d, d.return, wt);
                        }
                    }
                    break;
                case 3:
                    if (ls(p, d), Ws(d), E & 4 && w !== null && w.memoizedState.isDehydrated) try {
                        Ui(p.containerInfo);
                    } catch (wt) {
                        Nr(d, d.return, wt);
                    }
                    break;
                case 4:
                    ls(p, d), Ws(d);
                    break;
                case 13:
                    ls(p, d), Ws(d), O = d.child, O.flags & 8192 && (b = O.memoizedState !== null, O.stateNode.isHidden = b, !b || O.alternate !== null && O.alternate.memoizedState !== null || (_m = Pn())), E & 4 && o6(d);
                    break;
                case 22:
                    if (Ye = w !== null && w.memoizedState !== null, d.mode & 1 ? (na = (Ie = na) || Ye, ls(p, d), na = Ie) : ls(p, d), Ws(d), E & 8192) {
                        if (Ie = d.memoizedState !== null, (d.stateNode.isHidden = Ie) && !Ye && (d.mode & 1) !== 0) for(pt = d, Ye = d.child; Ye !== null;){
                            for(tt = pt = Ye; pt !== null;){
                                switch(qe = pt, dt = qe.child, qe.tag){
                                    case 0:
                                    case 11:
                                    case 14:
                                    case 15:
                                        Lf(4, qe, qe.return);
                                        break;
                                    case 1:
                                        lu(qe, qe.return);
                                        var vt = qe.stateNode;
                                        if (typeof vt.componentWillUnmount == "function") {
                                            E = qe, w = qe.return;
                                            try {
                                                p = E, vt.props = p.memoizedProps, vt.state = p.memoizedState, vt.componentWillUnmount();
                                            } catch (wt) {
                                                Nr(E, w, wt);
                                            }
                                        }
                                        break;
                                    case 5:
                                        lu(qe, qe.return);
                                        break;
                                    case 22:
                                        if (qe.memoizedState !== null) {
                                            u6(tt);
                                            continue;
                                        }
                                }
                                dt !== null ? (dt.return = qe, pt = dt) : u6(tt);
                            }
                            Ye = Ye.sibling;
                        }
                        e: for(Ye = null, tt = d;;){
                            if (tt.tag === 5) {
                                if (Ye === null) {
                                    Ye = tt;
                                    try {
                                        O = tt.stateNode, Ie ? (b = O.style, typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none") : (fe = tt.stateNode, ve = tt.memoizedProps.style, j = ve != null && ve.hasOwnProperty("display") ? ve.display : null, fe.style.display = Yt("display", j));
                                    } catch (wt) {
                                        Nr(d, d.return, wt);
                                    }
                                }
                            } else if (tt.tag === 6) {
                                if (Ye === null) try {
                                    tt.stateNode.nodeValue = Ie ? "" : tt.memoizedProps;
                                } catch (wt) {
                                    Nr(d, d.return, wt);
                                }
                            } else if ((tt.tag !== 22 && tt.tag !== 23 || tt.memoizedState === null || tt === d) && tt.child !== null) {
                                tt.child.return = tt, tt = tt.child;
                                continue;
                            }
                            if (tt === d) break e;
                            for(; tt.sibling === null;){
                                if (tt.return === null || tt.return === d) break e;
                                Ye === tt && (Ye = null), tt = tt.return;
                            }
                            Ye === tt && (Ye = null), tt.sibling.return = tt.return, tt = tt.sibling;
                        }
                    }
                    break;
                case 19:
                    ls(p, d), Ws(d), E & 4 && o6(d);
                    break;
                case 21:
                    break;
                default:
                    ls(p, d), Ws(d);
            }
        }
        function Ws(d) {
            var p = d.flags;
            if (p & 2) {
                try {
                    e: {
                        for(var w = d.return; w !== null;){
                            if (r6(w)) {
                                var E = w;
                                break e;
                            }
                            w = w.return;
                        }
                        throw Error(n(160));
                    }
                    switch(E.tag){
                        case 5:
                            var O = E.stateNode;
                            E.flags & 32 && (Cn(O, ""), E.flags &= -33);
                            var b = i6(d);
                            Sm(d, b, O);
                            break;
                        case 3:
                        case 4:
                            var j = E.stateNode.containerInfo, fe = i6(d);
                            xm(d, fe, j);
                            break;
                        default:
                            throw Error(n(161));
                    }
                } catch (ve) {
                    Nr(d, d.return, ve);
                }
                d.flags &= -3;
            }
            p & 4096 && (d.flags &= -4097);
        }
        function JI(d, p, w) {
            pt = d, c6(d);
        }
        function c6(d, p, w) {
            for(var E = (d.mode & 1) !== 0; pt !== null;){
                var O = pt, b = O.child;
                if (O.tag === 22 && E) {
                    var j = O.memoizedState !== null || Hg;
                    if (!j) {
                        var fe = O.alternate, ve = fe !== null && fe.memoizedState !== null || na;
                        fe = Hg;
                        var Ie = na;
                        if (Hg = j, (na = ve) && !Ie) for(pt = O; pt !== null;)j = pt, ve = j.child, j.tag === 22 && j.memoizedState !== null ? f6(O) : ve !== null ? (ve.return = j, pt = ve) : f6(O);
                        for(; b !== null;)pt = b, c6(b), b = b.sibling;
                        pt = O, Hg = fe, na = Ie;
                    }
                    l6(d);
                } else (O.subtreeFlags & 8772) !== 0 && b !== null ? (b.return = O, pt = b) : l6(d);
            }
        }
        function l6(d) {
            for(; pt !== null;){
                var p = pt;
                if ((p.flags & 8772) !== 0) {
                    var w = p.alternate;
                    try {
                        if ((p.flags & 8772) !== 0) switch(p.tag){
                            case 0:
                            case 11:
                            case 15:
                                na || Kg(5, p);
                                break;
                            case 1:
                                var E = p.stateNode;
                                if (p.flags & 4 && !na) if (w === null) E.componentDidMount();
                                else {
                                    var O = p.elementType === p.type ? w.memoizedProps : ss(p.type, w.memoizedProps);
                                    E.componentDidUpdate(O, w.memoizedState, E.__reactInternalSnapshotBeforeUpdate);
                                }
                                var b = p.updateQueue;
                                b !== null && u8(p, b, E);
                                break;
                            case 3:
                                var j = p.updateQueue;
                                if (j !== null) {
                                    if (w = null, p.child !== null) switch(p.child.tag){
                                        case 5:
                                            w = p.child.stateNode;
                                            break;
                                        case 1:
                                            w = p.child.stateNode;
                                    }
                                    u8(p, j, w);
                                }
                                break;
                            case 5:
                                var fe = p.stateNode;
                                if (w === null && p.flags & 4) {
                                    w = fe;
                                    var ve = p.memoizedProps;
                                    switch(p.type){
                                        case "button":
                                        case "input":
                                        case "select":
                                        case "textarea":
                                            ve.autoFocus && w.focus();
                                            break;
                                        case "img":
                                            ve.src && (w.src = ve.src);
                                    }
                                }
                                break;
                            case 6:
                                break;
                            case 4:
                                break;
                            case 12:
                                break;
                            case 13:
                                if (p.memoizedState === null) {
                                    var Ie = p.alternate;
                                    if (Ie !== null) {
                                        var Ye = Ie.memoizedState;
                                        if (Ye !== null) {
                                            var tt = Ye.dehydrated;
                                            tt !== null && Ui(tt);
                                        }
                                    }
                                }
                                break;
                            case 19:
                            case 17:
                            case 21:
                            case 22:
                            case 23:
                            case 25:
                                break;
                            default:
                                throw Error(n(163));
                        }
                        na || p.flags & 512 && Tm(p);
                    } catch (qe) {
                        Nr(p, p.return, qe);
                    }
                }
                if (p === d) {
                    pt = null;
                    break;
                }
                if (w = p.sibling, w !== null) {
                    w.return = p.return, pt = w;
                    break;
                }
                pt = p.return;
            }
        }
        function u6(d) {
            for(; pt !== null;){
                var p = pt;
                if (p === d) {
                    pt = null;
                    break;
                }
                var w = p.sibling;
                if (w !== null) {
                    w.return = p.return, pt = w;
                    break;
                }
                pt = p.return;
            }
        }
        function f6(d) {
            for(; pt !== null;){
                var p = pt;
                try {
                    switch(p.tag){
                        case 0:
                        case 11:
                        case 15:
                            var w = p.return;
                            try {
                                Kg(4, p);
                            } catch (ve) {
                                Nr(p, w, ve);
                            }
                            break;
                        case 1:
                            var E = p.stateNode;
                            if (typeof E.componentDidMount == "function") {
                                var O = p.return;
                                try {
                                    E.componentDidMount();
                                } catch (ve) {
                                    Nr(p, O, ve);
                                }
                            }
                            var b = p.return;
                            try {
                                Tm(p);
                            } catch (ve) {
                                Nr(p, b, ve);
                            }
                            break;
                        case 5:
                            var j = p.return;
                            try {
                                Tm(p);
                            } catch (ve) {
                                Nr(p, j, ve);
                            }
                    }
                } catch (ve) {
                    Nr(p, p.return, ve);
                }
                if (p === d) {
                    pt = null;
                    break;
                }
                var fe = p.sibling;
                if (fe !== null) {
                    fe.return = p.return, pt = fe;
                    break;
                }
                pt = p.return;
            }
        }
        var QI = Math.ceil, qg = S.ReactCurrentDispatcher, Em = S.ReactCurrentOwner, $o = S.ReactCurrentBatchConfig, xn = 0, Ri = null, ri = null, Gi = 0, go = 0, uu = il(0), hi = 0, Pf = null, s0 = 0, Xg = 0, Dm = 0, Vf = null, za = null, _m = 0, fu = 1 / 0, Ic = null, Yg = !1, Rm = null, ul = null, Zg = !1, fl = null, Jg = 0, Nf = 0, Om = null, Qg = -1, e1 = 0;
        function Ea() {
            return (xn & 6) !== 0 ? Pn() : Qg !== -1 ? Qg : Qg = Pn();
        }
        function dl(d) {
            return (d.mode & 1) === 0 ? 1 : (xn & 2) !== 0 && Gi !== 0 ? Gi & -Gi : AI.transition !== null ? (e1 === 0 && (e1 = Rs()), e1) : (d = an, d !== 0 || (d = window.event, d = d === void 0 ? 16 : Lo(d.type)), d);
        }
        function us(d, p, w, E) {
            if (50 < Nf) throw Nf = 0, Om = null, Error(n(185));
            $r(d, w, E), ((xn & 2) === 0 || d !== Ri) && (d === Ri && ((xn & 2) === 0 && (Xg |= w), hi === 4 && gl(d, Gi)), ja(d, E), w === 1 && xn === 0 && (p.mode & 1) === 0 && (fu = Pn() + 500, Og && ol()));
        }
        function ja(d, p) {
            var w = d.callbackNode;
            gc(d, p);
            var E = Ei(d, d === Ri ? Gi : 0);
            if (E === 0) w !== null && Ki(w), d.callbackNode = null, d.callbackPriority = 0;
            else if (p = E & -E, d.callbackPriority !== p) {
                if (w != null && Ki(w), p === 1) d.tag === 0 ? NI(g6.bind(null, d)) : Jy(g6.bind(null, d)), bI(function() {
                    (xn & 6) === 0 && ol();
                }), w = null;
                else {
                    switch(wa(E)){
                        case 1:
                            w = ui;
                            break;
                        case 4:
                            w = Qo;
                            break;
                        case 16:
                            w = Jr;
                            break;
                        case 536870912:
                            w = Pa;
                            break;
                        default:
                            w = Jr;
                    }
                    w = T6(w, d6.bind(null, d));
                }
                d.callbackPriority = p, d.callbackNode = w;
            }
        }
        function d6(d, p) {
            if (Qg = -1, e1 = 0, (xn & 6) !== 0) throw Error(n(327));
            var w = d.callbackNode;
            if (du() && d.callbackNode !== w) return null;
            var E = Ei(d, d === Ri ? Gi : 0);
            if (E === 0) return null;
            if ((E & 30) !== 0 || (E & d.expiredLanes) !== 0 || p) p = t1(d, E);
            else {
                p = E;
                var O = xn;
                xn |= 2;
                var b = p6();
                (Ri !== d || Gi !== p) && (Ic = null, fu = Pn() + 500, l0(d, p));
                do try {
                    nM();
                    break;
                } catch (fe) {
                    h6(d, fe);
                }
                while (!0);
                H2(), qg.current = b, xn = O, ri !== null ? p = 0 : (Ri = null, Gi = 0, p = hi);
            }
            if (p !== 0) {
                if (p === 2 && (O = es(d), O !== 0 && (E = O, p = Im(d, O))), p === 1) throw w = Pf, l0(d, 0), gl(d, E), ja(d, Pn()), w;
                if (p === 6) gl(d, E);
                else {
                    if (O = d.current.alternate, (E & 30) === 0 && !eM(O) && (p = t1(d, E), p === 2 && (b = es(d), b !== 0 && (E = b, p = Im(d, b))), p === 1)) throw w = Pf, l0(d, 0), gl(d, E), ja(d, Pn()), w;
                    switch(d.finishedWork = O, d.finishedLanes = E, p){
                        case 0:
                        case 1:
                            throw Error(n(345));
                        case 2:
                            u0(d, za, Ic);
                            break;
                        case 3:
                            if (gl(d, E), (E & 130023424) === E && (p = _m + 500 - Pn(), 10 < p)) {
                                if (Ei(d, 0) !== 0) break;
                                if (O = d.suspendedLanes, (O & E) !== E) {
                                    Ea(), d.pingedLanes |= d.suspendedLanes & O;
                                    break;
                                }
                                d.timeoutHandle = N2(u0.bind(null, d, za, Ic), p);
                                break;
                            }
                            u0(d, za, Ic);
                            break;
                        case 4:
                            if (gl(d, E), (E & 4194240) === E) break;
                            for(p = d.eventTimes, O = -1; 0 < E;){
                                var j = 31 - qn(E);
                                b = 1 << j, j = p[j], j > O && (O = j), E &= ~b;
                            }
                            if (E = O, E = Pn() - E, E = (120 > E ? 120 : 480 > E ? 480 : 1080 > E ? 1080 : 1920 > E ? 1920 : 3e3 > E ? 3e3 : 4320 > E ? 4320 : 1960 * QI(E / 1960)) - E, 10 < E) {
                                d.timeoutHandle = N2(u0.bind(null, d, za, Ic), E);
                                break;
                            }
                            u0(d, za, Ic);
                            break;
                        case 5:
                            u0(d, za, Ic);
                            break;
                        default:
                            throw Error(n(329));
                    }
                }
            }
            return ja(d, Pn()), d.callbackNode === w ? d6.bind(null, d) : null;
        }
        function Im(d, p) {
            var w = Vf;
            return d.current.memoizedState.isDehydrated && (l0(d, p).flags |= 256), d = t1(d, p), d !== 2 && (p = za, za = w, p !== null && Mm(p)), d;
        }
        function Mm(d) {
            za === null ? za = d : za.push.apply(za, d);
        }
        function eM(d) {
            for(var p = d;;){
                if (p.flags & 16384) {
                    var w = p.updateQueue;
                    if (w !== null && (w = w.stores, w !== null)) for(var E = 0; E < w.length; E++){
                        var O = w[E], b = O.getSnapshot;
                        O = O.value;
                        try {
                            if (!Bt(b(), O)) return !1;
                        } catch  {
                            return !1;
                        }
                    }
                }
                if (w = p.child, p.subtreeFlags & 16384 && w !== null) w.return = p, p = w;
                else {
                    if (p === d) break;
                    for(; p.sibling === null;){
                        if (p.return === null || p.return === d) return !0;
                        p = p.return;
                    }
                    p.sibling.return = p.return, p = p.sibling;
                }
            }
            return !0;
        }
        function gl(d, p) {
            for(p &= ~Dm, p &= ~Xg, d.suspendedLanes |= p, d.pingedLanes &= ~p, d = d.expirationTimes; 0 < p;){
                var w = 31 - qn(p), E = 1 << w;
                d[w] = -1, p &= ~E;
            }
        }
        function g6(d) {
            if ((xn & 6) !== 0) throw Error(n(327));
            du();
            var p = Ei(d, 0);
            if ((p & 1) === 0) return ja(d, Pn()), null;
            var w = t1(d, p);
            if (d.tag !== 0 && w === 2) {
                var E = es(d);
                E !== 0 && (p = E, w = Im(d, E));
            }
            if (w === 1) throw w = Pf, l0(d, 0), gl(d, p), ja(d, Pn()), w;
            if (w === 6) throw Error(n(345));
            return d.finishedWork = d.current.alternate, d.finishedLanes = p, u0(d, za, Ic), ja(d, Pn()), null;
        }
        function bm(d, p) {
            var w = xn;
            xn |= 1;
            try {
                return d(p);
            } finally{
                xn = w, xn === 0 && (fu = Pn() + 500, Og && ol());
            }
        }
        function c0(d) {
            fl !== null && fl.tag === 0 && (xn & 6) === 0 && du();
            var p = xn;
            xn |= 1;
            var w = $o.transition, E = an;
            try {
                if ($o.transition = null, an = 1, d) return d();
            } finally{
                an = E, $o.transition = w, xn = p, (xn & 6) === 0 && ol();
            }
        }
        function Lm() {
            go = uu.current, or(uu);
        }
        function l0(d, p) {
            d.finishedWork = null, d.finishedLanes = 0;
            var w = d.timeoutHandle;
            if (w !== -1 && (d.timeoutHandle = -1, MI(w)), ri !== null) for(w = ri.return; w !== null;){
                var E = w;
                switch(G2(E), E.tag){
                    case 1:
                        E = E.type.childContextTypes, E != null && _g();
                        break;
                    case 3:
                        su(), or(Ga), or(Qi), em();
                        break;
                    case 5:
                        J2(E);
                        break;
                    case 4:
                        su();
                        break;
                    case 13:
                        or(Tr);
                        break;
                    case 19:
                        or(Tr);
                        break;
                    case 10:
                        K2(E.type._context);
                        break;
                    case 22:
                    case 23:
                        Lm();
                }
                w = w.return;
            }
            if (Ri = d, ri = d = hl(d.current, null), Gi = go = p, hi = 0, Pf = null, Dm = Xg = s0 = 0, za = Vf = null, i0 !== null) {
                for(p = 0; p < i0.length; p++)if (w = i0[p], E = w.interleaved, E !== null) {
                    w.interleaved = null;
                    var O = E.next, b = w.pending;
                    if (b !== null) {
                        var j = b.next;
                        b.next = O, E.next = j;
                    }
                    w.pending = E;
                }
                i0 = null;
            }
            return d;
        }
        function h6(d, p) {
            do {
                var w = ri;
                try {
                    if (H2(), Ug.current = Wg, Fg) {
                        for(var E = xr.memoizedState; E !== null;){
                            var O = E.queue;
                            O !== null && (O.pending = null), E = E.next;
                        }
                        Fg = !1;
                    }
                    if (o0 = 0, _i = gi = xr = null, Rf = !1, Of = 0, Em.current = null, w === null || w.return === null) {
                        hi = 1, Pf = p, ri = null;
                        break;
                    }
                    e: {
                        var b = d, j = w.return, fe = w, ve = p;
                        if (p = Gi, fe.flags |= 32768, ve !== null && typeof ve == "object" && typeof ve.then == "function") {
                            var Ie = ve, Ye = fe, tt = Ye.tag;
                            if ((Ye.mode & 1) === 0 && (tt === 0 || tt === 11 || tt === 15)) {
                                var qe = Ye.alternate;
                                qe ? (Ye.updateQueue = qe.updateQueue, Ye.memoizedState = qe.memoizedState, Ye.lanes = qe.lanes) : (Ye.updateQueue = null, Ye.memoizedState = null);
                            }
                            var dt = F8(j);
                            if (dt !== null) {
                                dt.flags &= -257, B8(dt, j, fe, b, p), dt.mode & 1 && U8(b, Ie, p), p = dt, ve = Ie;
                                var vt = p.updateQueue;
                                if (vt === null) {
                                    var wt = new Set;
                                    wt.add(ve), p.updateQueue = wt;
                                } else vt.add(ve);
                                break e;
                            } else {
                                if ((p & 1) === 0) {
                                    U8(b, Ie, p), Pm();
                                    break e;
                                }
                                ve = Error(n(426));
                            }
                        } else if (hr && fe.mode & 1) {
                            var jr = F8(j);
                            if (jr !== null) {
                                (jr.flags & 65536) === 0 && (jr.flags |= 256), B8(jr, j, fe, b, p), z2(cu(ve, fe));
                                break e;
                            }
                        }
                        b = ve = cu(ve, fe), hi !== 4 && (hi = 2), Vf === null ? Vf = [
                            b
                        ] : Vf.push(b), b = j;
                        do {
                            switch(b.tag){
                                case 3:
                                    b.flags |= 65536, p &= -p, b.lanes |= p;
                                    var Ee = A8(b, ve, p);
                                    l8(b, Ee);
                                    break e;
                                case 1:
                                    fe = ve;
                                    var we = b.type, Re = b.stateNode;
                                    if ((b.flags & 128) === 0 && (typeof we.getDerivedStateFromError == "function" || Re !== null && typeof Re.componentDidCatch == "function" && (ul === null || !ul.has(Re)))) {
                                        b.flags |= 65536, p &= -p, b.lanes |= p;
                                        var at = k8(b, fe, p);
                                        l8(b, at);
                                        break e;
                                    }
                            }
                            b = b.return;
                        }while (b !== null);
                    }
                    v6(w);
                } catch (Dt) {
                    p = Dt, ri === w && w !== null && (ri = w = w.return);
                    continue;
                }
                break;
            }while (!0);
        }
        function p6() {
            var d = qg.current;
            return qg.current = Wg, d === null ? Wg : d;
        }
        function Pm() {
            (hi === 0 || hi === 3 || hi === 2) && (hi = 4), Ri === null || (s0 & 268435455) === 0 && (Xg & 268435455) === 0 || gl(Ri, Gi);
        }
        function t1(d, p) {
            var w = xn;
            xn |= 2;
            var E = p6();
            (Ri !== d || Gi !== p) && (Ic = null, l0(d, p));
            do try {
                tM();
                break;
            } catch (O) {
                h6(d, O);
            }
            while (!0);
            if (H2(), xn = w, qg.current = E, ri !== null) throw Error(n(261));
            return Ri = null, Gi = 0, hi;
        }
        function tM() {
            for(; ri !== null;)m6(ri);
        }
        function nM() {
            for(; ri !== null && !Vi();)m6(ri);
        }
        function m6(d) {
            var p = w6(d.alternate, d, go);
            d.memoizedProps = d.pendingProps, p === null ? v6(d) : ri = p, Em.current = null;
        }
        function v6(d) {
            var p = d;
            do {
                var w = p.alternate;
                if (d = p.return, (p.flags & 32768) === 0) {
                    if (w = qI(w, p, go), w !== null) {
                        ri = w;
                        return;
                    }
                } else {
                    if (w = XI(w, p), w !== null) {
                        w.flags &= 32767, ri = w;
                        return;
                    }
                    if (d !== null) d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null;
                    else {
                        hi = 6, ri = null;
                        return;
                    }
                }
                if (p = p.sibling, p !== null) {
                    ri = p;
                    return;
                }
                ri = p = d;
            }while (p !== null);
            hi === 0 && (hi = 5);
        }
        function u0(d, p, w) {
            var E = an, O = $o.transition;
            try {
                $o.transition = null, an = 1, rM(d, p, w, E);
            } finally{
                $o.transition = O, an = E;
            }
            return null;
        }
        function rM(d, p, w, E) {
            do du();
            while (fl !== null);
            if ((xn & 6) !== 0) throw Error(n(327));
            w = d.finishedWork;
            var O = d.finishedLanes;
            if (w === null) return null;
            if (d.finishedWork = null, d.finishedLanes = 0, w === d.current) throw Error(n(177));
            d.callbackNode = null, d.callbackPriority = 0;
            var b = w.lanes | w.childLanes;
            if (Di(d, b), d === Ri && (ri = Ri = null, Gi = 0), (w.subtreeFlags & 2064) === 0 && (w.flags & 2064) === 0 || Zg || (Zg = !0, T6(Jr, function() {
                return du(), null;
            })), b = (w.flags & 15990) !== 0, (w.subtreeFlags & 15990) !== 0 || b) {
                b = $o.transition, $o.transition = null;
                var j = an;
                an = 1;
                var fe = xn;
                xn |= 4, Em.current = null, ZI(d, w), s6(w, d), vg(P2), so = !!L2, P2 = L2 = null, d.current = w, JI(w), li(), xn = fe, an = j, $o.transition = b;
            } else d.current = w;
            if (Zg && (Zg = !1, fl = d, Jg = O), b = d.pendingLanes, b === 0 && (ul = null), io(w.stateNode), ja(d, Pn()), p !== null) for(E = d.onRecoverableError, w = 0; w < p.length; w++)O = p[w], E(O.value, {
                componentStack: O.stack,
                digest: O.digest
            });
            if (Yg) throw Yg = !1, d = Rm, Rm = null, d;
            return (Jg & 1) !== 0 && d.tag !== 0 && du(), b = d.pendingLanes, (b & 1) !== 0 ? d === Om ? Nf++ : (Nf = 0, Om = d) : Nf = 0, ol(), null;
        }
        function du() {
            if (fl !== null) {
                var d = wa(Jg), p = $o.transition, w = an;
                try {
                    if ($o.transition = null, an = 16 > d ? 16 : d, fl === null) var E = !1;
                    else {
                        if (d = fl, fl = null, Jg = 0, (xn & 6) !== 0) throw Error(n(331));
                        var O = xn;
                        for(xn |= 4, pt = d.current; pt !== null;){
                            var b = pt, j = b.child;
                            if ((pt.flags & 16) !== 0) {
                                var fe = b.deletions;
                                if (fe !== null) {
                                    for(var ve = 0; ve < fe.length; ve++){
                                        var Ie = fe[ve];
                                        for(pt = Ie; pt !== null;){
                                            var Ye = pt;
                                            switch(Ye.tag){
                                                case 0:
                                                case 11:
                                                case 15:
                                                    Lf(8, Ye, b);
                                            }
                                            var tt = Ye.child;
                                            if (tt !== null) tt.return = Ye, pt = tt;
                                            else for(; pt !== null;){
                                                Ye = pt;
                                                var qe = Ye.sibling, dt = Ye.return;
                                                if (n6(Ye), Ye === Ie) {
                                                    pt = null;
                                                    break;
                                                }
                                                if (qe !== null) {
                                                    qe.return = dt, pt = qe;
                                                    break;
                                                }
                                                pt = dt;
                                            }
                                        }
                                    }
                                    var vt = b.alternate;
                                    if (vt !== null) {
                                        var wt = vt.child;
                                        if (wt !== null) {
                                            vt.child = null;
                                            do {
                                                var jr = wt.sibling;
                                                wt.sibling = null, wt = jr;
                                            }while (wt !== null);
                                        }
                                    }
                                    pt = b;
                                }
                            }
                            if ((b.subtreeFlags & 2064) !== 0 && j !== null) j.return = b, pt = j;
                            else e: for(; pt !== null;){
                                if (b = pt, (b.flags & 2048) !== 0) switch(b.tag){
                                    case 0:
                                    case 11:
                                    case 15:
                                        Lf(9, b, b.return);
                                }
                                var Ee = b.sibling;
                                if (Ee !== null) {
                                    Ee.return = b.return, pt = Ee;
                                    break e;
                                }
                                pt = b.return;
                            }
                        }
                        var we = d.current;
                        for(pt = we; pt !== null;){
                            j = pt;
                            var Re = j.child;
                            if ((j.subtreeFlags & 2064) !== 0 && Re !== null) Re.return = j, pt = Re;
                            else e: for(j = we; pt !== null;){
                                if (fe = pt, (fe.flags & 2048) !== 0) try {
                                    switch(fe.tag){
                                        case 0:
                                        case 11:
                                        case 15:
                                            Kg(9, fe);
                                    }
                                } catch (Dt) {
                                    Nr(fe, fe.return, Dt);
                                }
                                if (fe === j) {
                                    pt = null;
                                    break e;
                                }
                                var at = fe.sibling;
                                if (at !== null) {
                                    at.return = fe.return, pt = at;
                                    break e;
                                }
                                pt = fe.return;
                            }
                        }
                        if (xn = O, ol(), ei && typeof ei.onPostCommitFiberRoot == "function") try {
                            ei.onPostCommitFiberRoot(Qr, d);
                        } catch  {}
                        E = !0;
                    }
                    return E;
                } finally{
                    an = w, $o.transition = p;
                }
            }
            return !1;
        }
        function y6(d, p, w) {
            p = cu(w, p), p = A8(d, p, 1), d = cl(d, p, 1), p = Ea(), d !== null && ($r(d, 1, p), ja(d, p));
        }
        function Nr(d, p, w) {
            if (d.tag === 3) y6(d, d, w);
            else for(; p !== null;){
                if (p.tag === 3) {
                    y6(p, d, w);
                    break;
                } else if (p.tag === 1) {
                    var E = p.stateNode;
                    if (typeof p.type.getDerivedStateFromError == "function" || typeof E.componentDidCatch == "function" && (ul === null || !ul.has(E))) {
                        d = cu(w, d), d = k8(p, d, 1), p = cl(p, d, 1), d = Ea(), p !== null && ($r(p, 1, d), ja(p, d));
                        break;
                    }
                }
                p = p.return;
            }
        }
        function iM(d, p, w) {
            var E = d.pingCache;
            E !== null && E.delete(p), p = Ea(), d.pingedLanes |= d.suspendedLanes & w, Ri === d && (Gi & w) === w && (hi === 4 || hi === 3 && (Gi & 130023424) === Gi && 500 > Pn() - _m ? l0(d, 0) : Dm |= w), ja(d, p);
        }
        function C6(d, p) {
            p === 0 && ((d.mode & 1) === 0 ? p = 1 : (p = ya, ya <<= 1, (ya & 130023424) === 0 && (ya = 4194304)));
            var w = Ea();
            d = _c(d, p), d !== null && ($r(d, p, w), ja(d, w));
        }
        function aM(d) {
            var p = d.memoizedState, w = 0;
            p !== null && (w = p.retryLane), C6(d, w);
        }
        function oM(d, p) {
            var w = 0;
            switch(d.tag){
                case 13:
                    var E = d.stateNode, O = d.memoizedState;
                    O !== null && (w = O.retryLane);
                    break;
                case 19:
                    E = d.stateNode;
                    break;
                default:
                    throw Error(n(314));
            }
            E !== null && E.delete(p), C6(d, w);
        }
        var w6;
        w6 = function(d, p, w) {
            if (d !== null) if (d.memoizedProps !== p.pendingProps || Ga.current) $a = !0;
            else {
                if ((d.lanes & w) === 0 && (p.flags & 128) === 0) return $a = !1, KI(d, p, w);
                $a = (d.flags & 131072) !== 0;
            }
            else $a = !1, hr && (p.flags & 1048576) !== 0 && Qy(p, Mg, p.index);
            switch(p.lanes = 0, p.tag){
                case 2:
                    var E = p.type;
                    jg(d, p), d = p.pendingProps;
                    var O = eu(p, Qi.current);
                    ou(p, w), O = rm(null, p, E, d, O, w);
                    var b = im();
                    return p.flags |= 1, typeof O == "object" && O !== null && typeof O.render == "function" && O.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, Wa(E) ? (b = !0, Rg(p)) : b = !1, p.memoizedState = O.state !== null && O.state !== void 0 ? O.state : null, Y2(p), O.updater = $g, p.stateNode = O, O._reactInternals = p, um(p, E, d, w), p = hm(null, p, E, !0, b, w)) : (p.tag = 0, hr && b && B2(p), Sa(null, p, O, w), p = p.child), p;
                case 16:
                    E = p.elementType;
                    e: {
                        switch(jg(d, p), d = p.pendingProps, O = E._init, E = O(E._payload), p.type = E, O = p.tag = cM(E), d = ss(E, d), O){
                            case 0:
                                p = gm(null, p, E, d, w);
                                break e;
                            case 1:
                                p = H8(null, p, E, d, w);
                                break e;
                            case 11:
                                p = G8(null, p, E, d, w);
                                break e;
                            case 14:
                                p = W8(null, p, E, ss(E.type, d), w);
                                break e;
                        }
                        throw Error(n(306, E, ""));
                    }
                    return p;
                case 0:
                    return E = p.type, O = p.pendingProps, O = p.elementType === E ? O : ss(E, O), gm(d, p, E, O, w);
                case 1:
                    return E = p.type, O = p.pendingProps, O = p.elementType === E ? O : ss(E, O), H8(d, p, E, O, w);
                case 3:
                    e: {
                        if (K8(p), d === null) throw Error(n(387));
                        E = p.pendingProps, b = p.memoizedState, O = b.element, c8(d, p), Ag(p, E, null, w);
                        var j = p.memoizedState;
                        if (E = j.element, b.isDehydrated) if (b = {
                            element: E,
                            isDehydrated: !1,
                            cache: j.cache,
                            pendingSuspenseBoundaries: j.pendingSuspenseBoundaries,
                            transitions: j.transitions
                        }, p.updateQueue.baseState = b, p.memoizedState = b, p.flags & 256) {
                            O = cu(Error(n(423)), p), p = q8(d, p, E, w, O);
                            break e;
                        } else if (E !== O) {
                            O = cu(Error(n(424)), p), p = q8(d, p, E, w, O);
                            break e;
                        } else for(fo = rl(p.stateNode.containerInfo.firstChild), uo = p, hr = !0, os = null, w = o8(p, null, E, w), p.child = w; w;)w.flags = w.flags & -3 | 4096, w = w.sibling;
                        else {
                            if (ru(), E === O) {
                                p = Oc(d, p, w);
                                break e;
                            }
                            Sa(d, p, E, w);
                        }
                        p = p.child;
                    }
                    return p;
                case 5:
                    return f8(p), d === null && $2(p), E = p.type, O = p.pendingProps, b = d !== null ? d.memoizedProps : null, j = O.children, V2(E, O) ? j = null : b !== null && V2(E, b) && (p.flags |= 32), j8(d, p), Sa(d, p, j, w), p.child;
                case 6:
                    return d === null && $2(p), null;
                case 13:
                    return X8(d, p, w);
                case 4:
                    return Z2(p, p.stateNode.containerInfo), E = p.pendingProps, d === null ? p.child = iu(p, null, E, w) : Sa(d, p, E, w), p.child;
                case 11:
                    return E = p.type, O = p.pendingProps, O = p.elementType === E ? O : ss(E, O), G8(d, p, E, O, w);
                case 7:
                    return Sa(d, p, p.pendingProps, w), p.child;
                case 8:
                    return Sa(d, p, p.pendingProps.children, w), p.child;
                case 12:
                    return Sa(d, p, p.pendingProps.children, w), p.child;
                case 10:
                    e: {
                        if (E = p.type._context, O = p.pendingProps, b = p.memoizedProps, j = O.value, Yn(Pg, E._currentValue), E._currentValue = j, b !== null) if (Bt(b.value, j)) {
                            if (b.children === O.children && !Ga.current) {
                                p = Oc(d, p, w);
                                break e;
                            }
                        } else for(b = p.child, b !== null && (b.return = p); b !== null;){
                            var fe = b.dependencies;
                            if (fe !== null) {
                                j = b.child;
                                for(var ve = fe.firstContext; ve !== null;){
                                    if (ve.context === E) {
                                        if (b.tag === 1) {
                                            ve = Rc(-1, w & -w), ve.tag = 2;
                                            var Ie = b.updateQueue;
                                            if (Ie !== null) {
                                                Ie = Ie.shared;
                                                var Ye = Ie.pending;
                                                Ye === null ? ve.next = ve : (ve.next = Ye.next, Ye.next = ve), Ie.pending = ve;
                                            }
                                        }
                                        b.lanes |= w, ve = b.alternate, ve !== null && (ve.lanes |= w), q2(b.return, w, p), fe.lanes |= w;
                                        break;
                                    }
                                    ve = ve.next;
                                }
                            } else if (b.tag === 10) j = b.type === p.type ? null : b.child;
                            else if (b.tag === 18) {
                                if (j = b.return, j === null) throw Error(n(341));
                                j.lanes |= w, fe = j.alternate, fe !== null && (fe.lanes |= w), q2(j, w, p), j = b.sibling;
                            } else j = b.child;
                            if (j !== null) j.return = b;
                            else for(j = b; j !== null;){
                                if (j === p) {
                                    j = null;
                                    break;
                                }
                                if (b = j.sibling, b !== null) {
                                    b.return = j.return, j = b;
                                    break;
                                }
                                j = j.return;
                            }
                            b = j;
                        }
                        Sa(d, p, O.children, w), p = p.child;
                    }
                    return p;
                case 9:
                    return O = p.type, E = p.pendingProps.children, ou(p, w), O = Go(O), E = E(O), p.flags |= 1, Sa(d, p, E, w), p.child;
                case 14:
                    return E = p.type, O = ss(E, p.pendingProps), O = ss(E.type, O), W8(d, p, E, O, w);
                case 15:
                    return $8(d, p, p.type, p.pendingProps, w);
                case 17:
                    return E = p.type, O = p.pendingProps, O = p.elementType === E ? O : ss(E, O), jg(d, p), p.tag = 1, Wa(E) ? (d = !0, Rg(p)) : d = !1, ou(p, w), V8(p, E, O), um(p, E, O, w), hm(null, p, E, !0, d, w);
                case 19:
                    return Z8(d, p, w);
                case 22:
                    return z8(d, p, w);
            }
            throw Error(n(156, p.tag));
        };
        function T6(d, p) {
            return Si(d, p);
        }
        function sM(d, p, w, E) {
            this.tag = d, this.key = w, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = E, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
        }
        function zo(d, p, w, E) {
            return new sM(d, p, w, E);
        }
        function Vm(d) {
            return d = d.prototype, !(!d || !d.isReactComponent);
        }
        function cM(d) {
            if (typeof d == "function") return Vm(d) ? 1 : 0;
            if (d != null) {
                if (d = d.$$typeof, d === G) return 11;
                if (d === ne) return 14;
            }
            return 2;
        }
        function hl(d, p) {
            var w = d.alternate;
            return w === null ? (w = zo(d.tag, p, d.key, d.mode), w.elementType = d.elementType, w.type = d.type, w.stateNode = d.stateNode, w.alternate = d, d.alternate = w) : (w.pendingProps = p, w.type = d.type, w.flags = 0, w.subtreeFlags = 0, w.deletions = null), w.flags = d.flags & 14680064, w.childLanes = d.childLanes, w.lanes = d.lanes, w.child = d.child, w.memoizedProps = d.memoizedProps, w.memoizedState = d.memoizedState, w.updateQueue = d.updateQueue, p = d.dependencies, w.dependencies = p === null ? null : {
                lanes: p.lanes,
                firstContext: p.firstContext
            }, w.sibling = d.sibling, w.index = d.index, w.ref = d.ref, w;
        }
        function n1(d, p, w, E, O, b) {
            var j = 2;
            if (E = d, typeof d == "function") Vm(d) && (j = 1);
            else if (typeof d == "string") j = 5;
            else e: switch(d){
                case M:
                    return f0(w.children, O, b, p);
                case P:
                    j = 8, O |= 8;
                    break;
                case F:
                    return d = zo(12, w, p, O | 2), d.elementType = F, d.lanes = b, d;
                case Z:
                    return d = zo(13, w, p, O), d.elementType = Z, d.lanes = b, d;
                case H:
                    return d = zo(19, w, p, O), d.elementType = H, d.lanes = b, d;
                case ue:
                    return r1(w, O, b, p);
                default:
                    if (typeof d == "object" && d !== null) switch(d.$$typeof){
                        case N:
                            j = 10;
                            break e;
                        case B:
                            j = 9;
                            break e;
                        case G:
                            j = 11;
                            break e;
                        case ne:
                            j = 14;
                            break e;
                        case ae:
                            j = 16, E = null;
                            break e;
                    }
                    throw Error(n(130, d == null ? d : typeof d, ""));
            }
            return p = zo(j, w, p, O), p.elementType = d, p.type = E, p.lanes = b, p;
        }
        function f0(d, p, w, E) {
            return d = zo(7, d, E, p), d.lanes = w, d;
        }
        function r1(d, p, w, E) {
            return d = zo(22, d, E, p), d.elementType = ue, d.lanes = w, d.stateNode = {
                isHidden: !1
            }, d;
        }
        function Nm(d, p, w) {
            return d = zo(6, d, null, p), d.lanes = w, d;
        }
        function Am(d, p, w) {
            return p = zo(4, d.children !== null ? d.children : [], d.key, p), p.lanes = w, p.stateNode = {
                containerInfo: d.containerInfo,
                pendingChildren: null,
                implementation: d.implementation
            }, p;
        }
        function lM(d, p, w, E, O) {
            this.tag = p, this.containerInfo = d, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = fi(0), this.expirationTimes = fi(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fi(0), this.identifierPrefix = E, this.onRecoverableError = O, this.mutableSourceEagerHydrationData = null;
        }
        function km(d, p, w, E, O, b, j, fe, ve) {
            return d = new lM(d, p, w, fe, ve), p === 1 ? (p = 1, b === !0 && (p |= 8)) : p = 0, b = zo(3, null, null, p), d.current = b, b.stateNode = d, b.memoizedState = {
                element: E,
                isDehydrated: w,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
            }, Y2(b), d;
        }
        function uM(d, p, w) {
            var E = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
                $$typeof: _,
                key: E == null ? null : "" + E,
                children: d,
                containerInfo: p,
                implementation: w
            };
        }
        function x6(d) {
            if (!d) return al;
            d = d._reactInternals;
            e: {
                if (xi(d) !== d || d.tag !== 1) throw Error(n(170));
                var p = d;
                do {
                    switch(p.tag){
                        case 3:
                            p = p.stateNode.context;
                            break e;
                        case 1:
                            if (Wa(p.type)) {
                                p = p.stateNode.__reactInternalMemoizedMergedChildContext;
                                break e;
                            }
                    }
                    p = p.return;
                }while (p !== null);
                throw Error(n(171));
            }
            if (d.tag === 1) {
                var w = d.type;
                if (Wa(w)) return Yy(d, w, p);
            }
            return p;
        }
        function S6(d, p, w, E, O, b, j, fe, ve) {
            return d = km(w, E, !0, d, O, b, j, fe, ve), d.context = x6(null), w = d.current, E = Ea(), O = dl(w), b = Rc(E, O), b.callback = p ?? null, cl(w, b, O), d.current.lanes = O, $r(d, O, E), ja(d, E), d;
        }
        function i1(d, p, w, E) {
            var O = p.current, b = Ea(), j = dl(O);
            return w = x6(w), p.context === null ? p.context = w : p.pendingContext = w, p = Rc(b, j), p.payload = {
                element: d
            }, E = E === void 0 ? null : E, E !== null && (p.callback = E), d = cl(O, p, j), d !== null && (us(d, O, j, b), Ng(d, O, j)), j;
        }
        function a1(d) {
            if (d = d.current, !d.child) return null;
            switch(d.child.tag){
                case 5:
                    return d.child.stateNode;
                default:
                    return d.child.stateNode;
            }
        }
        function E6(d, p) {
            if (d = d.memoizedState, d !== null && d.dehydrated !== null) {
                var w = d.retryLane;
                d.retryLane = w !== 0 && w < p ? w : p;
            }
        }
        function Um(d, p) {
            E6(d, p), (d = d.alternate) && E6(d, p);
        }
        function fM() {
            return null;
        }
        var D6 = typeof reportError == "function" ? reportError : function(d) {
            console.error(d);
        };
        function Fm(d) {
            this._internalRoot = d;
        }
        o1.prototype.render = Fm.prototype.render = function(d) {
            var p = this._internalRoot;
            if (p === null) throw Error(n(409));
            i1(d, p, null, null);
        }, o1.prototype.unmount = Fm.prototype.unmount = function() {
            var d = this._internalRoot;
            if (d !== null) {
                this._internalRoot = null;
                var p = d.containerInfo;
                c0(function() {
                    i1(null, d, null, null);
                }), p[xc] = null;
            }
        };
        function o1(d) {
            this._internalRoot = d;
        }
        o1.prototype.unstable_scheduleHydration = function(d) {
            if (d) {
                var p = ti();
                d = {
                    blockedOn: null,
                    target: d,
                    priority: p
                };
                for(var w = 0; w < un.length && p !== 0 && p < un[w].priority; w++);
                un.splice(w, 0, d), w === 0 && di(d);
            }
        };
        function Bm(d) {
            return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11);
        }
        function s1(d) {
            return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11 && (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "));
        }
        function _6() {}
        function dM(d, p, w, E, O) {
            if (O) {
                if (typeof E == "function") {
                    var b = E;
                    E = function() {
                        var Ie = a1(j);
                        b.call(Ie);
                    };
                }
                var j = S6(p, E, d, 0, null, !1, !1, "", _6);
                return d._reactRootContainer = j, d[xc] = j.current, Cf(d.nodeType === 8 ? d.parentNode : d), c0(), j;
            }
            for(; O = d.lastChild;)d.removeChild(O);
            if (typeof E == "function") {
                var fe = E;
                E = function() {
                    var Ie = a1(ve);
                    fe.call(Ie);
                };
            }
            var ve = km(d, 0, !1, null, null, !1, !1, "", _6);
            return d._reactRootContainer = ve, d[xc] = ve.current, Cf(d.nodeType === 8 ? d.parentNode : d), c0(function() {
                i1(p, ve, w, E);
            }), ve;
        }
        function c1(d, p, w, E, O) {
            var b = w._reactRootContainer;
            if (b) {
                var j = b;
                if (typeof O == "function") {
                    var fe = O;
                    O = function() {
                        var ve = a1(j);
                        fe.call(ve);
                    };
                }
                i1(p, j, d, O);
            } else j = dM(w, p, d, O, E);
            return a1(j);
        }
        Va = function(d) {
            switch(d.tag){
                case 3:
                    var p = d.stateNode;
                    if (p.current.memoizedState.isDehydrated) {
                        var w = Ca(p.pendingLanes);
                        w !== 0 && (vr(p, w | 1), ja(p, Pn()), (xn & 6) === 0 && (fu = Pn() + 500, ol()));
                    }
                    break;
                case 13:
                    c0(function() {
                        var E = _c(d, 1);
                        if (E !== null) {
                            var O = Ea();
                            us(E, d, 1, O);
                        }
                    }), Um(d, 1);
            }
        }, Bn = function(d) {
            if (d.tag === 13) {
                var p = _c(d, 134217728);
                if (p !== null) {
                    var w = Ea();
                    us(p, d, 134217728, w);
                }
                Um(d, 134217728);
            }
        }, ts = function(d) {
            if (d.tag === 13) {
                var p = dl(d), w = _c(d, p);
                if (w !== null) {
                    var E = Ea();
                    us(w, d, p, E);
                }
                Um(d, p);
            }
        }, ti = function() {
            return an;
        }, yr = function(d, p) {
            var w = an;
            try {
                return an = d, p();
            } finally{
                an = w;
            }
        }, Gr = function(d, p, w) {
            switch(p){
                case "input":
                    if (En(d, w), p = w.name, w.type === "radio" && p != null) {
                        for(w = d; w.parentNode;)w = w.parentNode;
                        for(w = w.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), p = 0; p < w.length; p++){
                            var E = w[p];
                            if (E !== d && E.form === d.form) {
                                var O = Dg(E);
                                if (!O) throw Error(n(90));
                                Nn(E), En(E, O);
                            }
                        }
                    }
                    break;
                case "textarea":
                    J(d, w);
                    break;
                case "select":
                    p = w.value, p != null && q(d, !!w.multiple, p, !1);
            }
        }, Pr = bm, Hi = c0;
        var gM = {
            usingClientEntryPoint: !1,
            Events: [
                xf,
                J0,
                Dg,
                pa,
                Lr,
                bm
            ]
        }, Af = {
            findFiberByHostInstance: e0,
            bundleType: 0,
            version: "18.3.1",
            rendererPackageName: "react-dom"
        }, hM = {
            bundleType: Af.bundleType,
            version: Af.version,
            rendererPackageName: Af.rendererPackageName,
            rendererConfig: Af.rendererConfig,
            overrideHookState: null,
            overrideHookStateDeletePath: null,
            overrideHookStateRenamePath: null,
            overrideProps: null,
            overridePropsDeletePath: null,
            overridePropsRenamePath: null,
            setErrorHandler: null,
            setSuspenseHandler: null,
            scheduleUpdate: null,
            currentDispatcherRef: S.ReactCurrentDispatcher,
            findHostInstanceByFiber: function(d) {
                return d = mr(d), d === null ? null : d.stateNode;
            },
            findFiberByHostInstance: Af.findFiberByHostInstance || fM,
            findHostInstancesForRefresh: null,
            scheduleRefresh: null,
            scheduleRoot: null,
            setRefreshHandler: null,
            getCurrentFiber: null,
            reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
            var l1 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!l1.isDisabled && l1.supportsFiber) try {
                Qr = l1.inject(hM), ei = l1;
            } catch  {}
        }
        return Ha.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gM, Ha.createPortal = function(d, p) {
            var w = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
            if (!Bm(p)) throw Error(n(200));
            return uM(d, p, null, w);
        }, Ha.createRoot = function(d, p) {
            if (!Bm(d)) throw Error(n(299));
            var w = !1, E = "", O = D6;
            return p != null && (p.unstable_strictMode === !0 && (w = !0), p.identifierPrefix !== void 0 && (E = p.identifierPrefix), p.onRecoverableError !== void 0 && (O = p.onRecoverableError)), p = km(d, 1, !1, null, null, w, !1, E, O), d[xc] = p.current, Cf(d.nodeType === 8 ? d.parentNode : d), new Fm(p);
        }, Ha.findDOMNode = function(d) {
            if (d == null) return null;
            if (d.nodeType === 1) return d;
            var p = d._reactInternals;
            if (p === void 0) throw typeof d.render == "function" ? Error(n(188)) : (d = Object.keys(d).join(","), Error(n(268, d)));
            return d = mr(p), d = d === null ? null : d.stateNode, d;
        }, Ha.flushSync = function(d) {
            return c0(d);
        }, Ha.hydrate = function(d, p, w) {
            if (!s1(p)) throw Error(n(200));
            return c1(null, d, p, !0, w);
        }, Ha.hydrateRoot = function(d, p, w) {
            if (!Bm(d)) throw Error(n(405));
            var E = w != null && w.hydratedSources || null, O = !1, b = "", j = D6;
            if (w != null && (w.unstable_strictMode === !0 && (O = !0), w.identifierPrefix !== void 0 && (b = w.identifierPrefix), w.onRecoverableError !== void 0 && (j = w.onRecoverableError)), p = S6(p, null, d, 1, w ?? null, O, !1, b, j), d[xc] = p.current, Cf(d), E) for(d = 0; d < E.length; d++)w = E[d], O = w._getVersion, O = O(w._source), p.mutableSourceEagerHydrationData == null ? p.mutableSourceEagerHydrationData = [
                w,
                O
            ] : p.mutableSourceEagerHydrationData.push(w, O);
            return new o1(p);
        }, Ha.render = function(d, p, w) {
            if (!s1(p)) throw Error(n(200));
            return c1(null, d, p, !1, w);
        }, Ha.unmountComponentAtNode = function(d) {
            if (!s1(d)) throw Error(n(40));
            return d._reactRootContainer ? (c0(function() {
                c1(null, null, d, !1, function() {
                    d._reactRootContainer = null, d[xc] = null;
                });
            }), !0) : !1;
        }, Ha.unstable_batchedUpdates = bm, Ha.unstable_renderSubtreeIntoContainer = function(d, p, w, E) {
            if (!s1(w)) throw Error(n(200));
            if (d == null || d._reactInternals === void 0) throw Error(n(38));
            return c1(d, p, w, !1, E);
        }, Ha.version = "18.3.1-next-f1338f8080-20240426", Ha;
    }
    var V6;
    function SM() {
        if (V6) return $m.exports;
        V6 = 1;
        function t() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t);
            } catch (e) {
                console.error(e);
            }
        }
        return t(), $m.exports = xM(), $m.exports;
    }
    var N6;
    function EM() {
        if (N6) return u1;
        N6 = 1;
        var t = SM();
        return u1.createRoot = t.createRoot, u1.hydrateRoot = t.hydrateRoot, u1;
    }
    var DM = EM();
    const _M = Qa(DM);
    const RM = (t)=>t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), B7 = (...t)=>t.filter((e, n, r)=>!!e && r.indexOf(e) === n).join(" ");
    var OM = {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round"
    };
    const IM = _n.forwardRef(({ color: t = "currentColor", size: e = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: i = "", children: a, iconNode: o, ...s }, c)=>_n.createElement("svg", {
            ref: c,
            ...OM,
            width: e,
            height: e,
            stroke: t,
            strokeWidth: r ? Number(n) * 24 / Number(e) : n,
            className: B7("lucide", i),
            ...s
        }, [
            ...o.map(([l, f])=>_n.createElement(l, f)),
            ...Array.isArray(a) ? a : [
                a
            ]
        ]));
    const rr = (t, e)=>{
        const n = _n.forwardRef(({ className: r, ...i }, a)=>_n.createElement(IM, {
                ref: a,
                iconNode: e,
                className: B7(`lucide-${RM(t)}`, r),
                ...i
            }));
        return n.displayName = `${t}`, n;
    };
    const MM = rr("ArrowUpRight", [
        [
            "path",
            {
                d: "M7 7h10v10",
                key: "1tivn9"
            }
        ],
        [
            "path",
            {
                d: "M7 17 17 7",
                key: "1vkiza"
            }
        ]
    ]);
    const bM = rr("Brush", [
        [
            "path",
            {
                d: "m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08",
                key: "1styjt"
            }
        ],
        [
            "path",
            {
                d: "M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2 2.02 1.08 1.1 2.49 2.02 4 2.02 2.2 0 4-1.8 4-4.04a3.01 3.01 0 0 0-3-3.02z",
                key: "z0l1mu"
            }
        ]
    ]);
    const LM = rr("Camera", [
        [
            "path",
            {
                d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",
                key: "1tc9qg"
            }
        ],
        [
            "circle",
            {
                cx: "12",
                cy: "13",
                r: "3",
                key: "1vg3eu"
            }
        ]
    ]);
    const PM = rr("CircleEllipsis", [
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "10",
                key: "1mglay"
            }
        ],
        [
            "path",
            {
                d: "M17 12h.01",
                key: "1m0b6t"
            }
        ],
        [
            "path",
            {
                d: "M12 12h.01",
                key: "1mp3jc"
            }
        ],
        [
            "path",
            {
                d: "M7 12h.01",
                key: "eqddd0"
            }
        ]
    ]);
    const VM = rr("Circle", [
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "10",
                key: "1mglay"
            }
        ]
    ]);
    const NM = rr("Contrast", [
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "10",
                key: "1mglay"
            }
        ],
        [
            "path",
            {
                d: "M12 18a6 6 0 0 0 0-12v12z",
                key: "j4l70d"
            }
        ]
    ]);
    const AM = rr("Copy", [
        [
            "rect",
            {
                width: "14",
                height: "14",
                x: "8",
                y: "8",
                rx: "2",
                ry: "2",
                key: "17jyea"
            }
        ],
        [
            "path",
            {
                d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
                key: "zix9uf"
            }
        ]
    ]);
    const Oh = rr("FileText", [
        [
            "path",
            {
                d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
                key: "1rqfz7"
            }
        ],
        [
            "path",
            {
                d: "M14 2v4a2 2 0 0 0 2 2h4",
                key: "tnqrlb"
            }
        ],
        [
            "path",
            {
                d: "M10 9H8",
                key: "b1mrlr"
            }
        ],
        [
            "path",
            {
                d: "M16 13H8",
                key: "t4e002"
            }
        ],
        [
            "path",
            {
                d: "M16 17H8",
                key: "z1uh3a"
            }
        ]
    ]);
    const kM = rr("FlipHorizontal", [
        [
            "path",
            {
                d: "M8 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h3",
                key: "1i73f7"
            }
        ],
        [
            "path",
            {
                d: "M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3",
                key: "saxlbk"
            }
        ],
        [
            "path",
            {
                d: "M12 20v2",
                key: "1lh1kg"
            }
        ],
        [
            "path",
            {
                d: "M12 14v2",
                key: "8jcxud"
            }
        ],
        [
            "path",
            {
                d: "M12 8v2",
                key: "1woqiv"
            }
        ],
        [
            "path",
            {
                d: "M12 2v2",
                key: "tus03m"
            }
        ]
    ]);
    const UM = rr("FlipVertical", [
        [
            "path",
            {
                d: "M21 8V5a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v3",
                key: "14bfxa"
            }
        ],
        [
            "path",
            {
                d: "M21 16v3a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-3",
                key: "14rx03"
            }
        ],
        [
            "path",
            {
                d: "M4 12H2",
                key: "rhcxmi"
            }
        ],
        [
            "path",
            {
                d: "M10 12H8",
                key: "s88cx1"
            }
        ],
        [
            "path",
            {
                d: "M16 12h-2",
                key: "10asgb"
            }
        ],
        [
            "path",
            {
                d: "M22 12h-2",
                key: "14jgyd"
            }
        ]
    ]);
    const FM = rr("MousePointer", [
        [
            "path",
            {
                d: "m3 3 7.07 16.97 2.51-7.39 7.39-2.51L3 3z",
                key: "y2ucgo"
            }
        ],
        [
            "path",
            {
                d: "m13 13 6 6",
                key: "1nhxnf"
            }
        ]
    ]);
    const BM = rr("Move3d", [
        [
            "path",
            {
                d: "M5 3v16h16",
                key: "1mqmf9"
            }
        ],
        [
            "path",
            {
                d: "m5 19 6-6",
                key: "jh6hbb"
            }
        ],
        [
            "path",
            {
                d: "m2 6 3-3 3 3",
                key: "tkyvxa"
            }
        ],
        [
            "path",
            {
                d: "m18 16 3 3-3 3",
                key: "1d4glt"
            }
        ]
    ]);
    const GM = rr("Navigation", [
        [
            "polygon",
            {
                points: "3 11 22 2 13 21 11 13 3 11",
                key: "1ltx0t"
            }
        ]
    ]);
    const Hm = rr("PanelsTopLeft", [
        [
            "rect",
            {
                width: "18",
                height: "18",
                x: "3",
                y: "3",
                rx: "2",
                key: "afitv7"
            }
        ],
        [
            "path",
            {
                d: "M3 9h18",
                key: "1pudct"
            }
        ],
        [
            "path",
            {
                d: "M9 21V9",
                key: "1oto5p"
            }
        ]
    ]);
    const A6 = rr("RotateCcw", [
        [
            "path",
            {
                d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
                key: "1357e3"
            }
        ],
        [
            "path",
            {
                d: "M3 3v5h5",
                key: "1xhq8a"
            }
        ]
    ]);
    const WM = rr("RotateCw", [
        [
            "path",
            {
                d: "M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8",
                key: "1p45f6"
            }
        ],
        [
            "path",
            {
                d: "M21 3v5h-5",
                key: "1q7to0"
            }
        ]
    ]);
    const $M = rr("Ruler", [
        [
            "path",
            {
                d: "M21.3 15.3a2.4 2.4 0 0 1 0 3.4l-2.6 2.6a2.4 2.4 0 0 1-3.4 0L2.7 8.7a2.41 2.41 0 0 1 0-3.4l2.6-2.6a2.41 2.41 0 0 1 3.4 0Z",
                key: "icamh8"
            }
        ],
        [
            "path",
            {
                d: "m14.5 12.5 2-2",
                key: "inckbg"
            }
        ],
        [
            "path",
            {
                d: "m11.5 9.5 2-2",
                key: "fmmyf7"
            }
        ],
        [
            "path",
            {
                d: "m8.5 6.5 2-2",
                key: "vc6u1g"
            }
        ],
        [
            "path",
            {
                d: "m17.5 15.5 2-2",
                key: "wo5hmg"
            }
        ]
    ]);
    const G7 = rr("Search", [
        [
            "circle",
            {
                cx: "11",
                cy: "11",
                r: "8",
                key: "4ej97u"
            }
        ],
        [
            "path",
            {
                d: "m21 21-4.3-4.3",
                key: "1qie3q"
            }
        ]
    ]);
    const zM = rr("Spline", [
        [
            "circle",
            {
                cx: "19",
                cy: "5",
                r: "2",
                key: "mhkx31"
            }
        ],
        [
            "circle",
            {
                cx: "5",
                cy: "19",
                r: "2",
                key: "v8kfzx"
            }
        ],
        [
            "path",
            {
                d: "M5 17A12 12 0 0 1 17 5",
                key: "1okkup"
            }
        ]
    ]);
    const jM = rr("Square", [
        [
            "rect",
            {
                width: "18",
                height: "18",
                x: "3",
                y: "3",
                rx: "2",
                key: "afitv7"
            }
        ]
    ]);
    const HM = rr("Tag", [
        [
            "path",
            {
                d: "M12.586 2.586A2 2 0 0 0 11.172 2H4a2 2 0 0 0-2 2v7.172a2 2 0 0 0 .586 1.414l8.704 8.704a2.426 2.426 0 0 0 3.42 0l6.58-6.58a2.426 2.426 0 0 0 0-3.42z",
                key: "vktsd0"
            }
        ],
        [
            "circle",
            {
                cx: "7.5",
                cy: "7.5",
                r: ".5",
                fill: "currentColor",
                key: "kqv944"
            }
        ]
    ]);
    const KM = rr("Target", [
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "10",
                key: "1mglay"
            }
        ],
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "6",
                key: "1vlfrh"
            }
        ],
        [
            "circle",
            {
                cx: "12",
                cy: "12",
                r: "2",
                key: "1c9p78"
            }
        ]
    ]);
    const qM = rr("Triangle", [
        [
            "path",
            {
                d: "M13.73 4a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z",
                key: "14u9p9"
            }
        ]
    ]);
    const k6 = rr("Upload", [
        [
            "path",
            {
                d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
                key: "ih7n3h"
            }
        ],
        [
            "polyline",
            {
                points: "17 8 12 3 7 8",
                key: "t8dd8p"
            }
        ],
        [
            "line",
            {
                x1: "12",
                x2: "12",
                y1: "3",
                y2: "15",
                key: "widbto"
            }
        ]
    ]);
    const l3 = rr("X", [
        [
            "path",
            {
                d: "M18 6 6 18",
                key: "1bl5f8"
            }
        ],
        [
            "path",
            {
                d: "m6 6 12 12",
                key: "d8bk6v"
            }
        ]
    ]);
    const XM = rr("ZoomIn", [
        [
            "circle",
            {
                cx: "11",
                cy: "11",
                r: "8",
                key: "4ej97u"
            }
        ],
        [
            "line",
            {
                x1: "21",
                x2: "16.65",
                y1: "21",
                y2: "16.65",
                key: "13gj7c"
            }
        ],
        [
            "line",
            {
                x1: "11",
                x2: "11",
                y1: "8",
                y2: "14",
                key: "1vmskp"
            }
        ],
        [
            "line",
            {
                x1: "8",
                x2: "14",
                y1: "11",
                y2: "11",
                key: "durymu"
            }
        ]
    ]);
    (function(t) {
        t.ERROR_EVENT = "CORNERSTONE_ERROR", t.CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED", t.IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR", t.CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED", t.CAMERA_RESET = "CORNERSTONE_CAMERA_RESET", t.VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED", t.PRESET_MODIFIED = "CORNERSTONE_VIEWPORT_RENDERING_PRESET_MODIFIED", t.DISPLAY_AREA_MODIFIED = "CORNERSTONE_DISPLAY_AREA_MODIFIED", t.ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED", t.ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED", t.IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED", t.IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED", t.IMAGE_VOLUME_LOADING_COMPLETED = "CORNERSTONE_IMAGE_VOLUME_LOADING_COMPLETED", t.IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED", t.IMAGE_RETRIEVAL_STAGE = "CORNERSTONE_IMAGE_RETRIEVAL_STAGE", t.IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED", t.VOLUME_VIEWPORT_NEW_VOLUME = "CORNERSTONE_VOLUME_VIEWPORT_NEW_VOLUME", t.VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED", t.VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED", t.IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED", t.IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED", t.VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED", t.VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED", t.STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE", t.VOLUME_NEW_IMAGE = "CORNERSTONE_VOLUME_NEW_IMAGE", t.PRE_STACK_NEW_IMAGE = "CORNERSTONE_PRE_STACK_NEW_IMAGE", t.IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED", t.VIEWPORT_NEW_IMAGE_SET = "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET", t.STACK_VIEWPORT_SCROLL = "CORNERSTONE_STACK_VIEWPORT_SCROLL", t.STACK_SCROLL_OUT_OF_BOUNDS = "STACK_SCROLL_OUT_OF_BOUNDS", t.GEOMETRY_CACHE_GEOMETRY_ADDED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_ADDED", t.GEOMETRY_CACHE_GEOMETRY_REMOVED = "CORNERSTONE_GEOMETRY_CACHE_GEOMETRY_REMOVED", t.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS = "VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS", t.VOLUME_VIEWPORT_SCROLL = "VOLUME_VIEWPORT_SCROLL", t.CLIPPING_PLANES_UPDATED = "CORNERSTONE_CLIPPING_PLANES_UPDATED", t.WEB_WORKER_PROGRESS = "CORNERSTONE_WEB_WORKER_PROGRESS", t.COLORMAP_MODIFIED = "CORNERSTONE_COLORMAP_MODIFIED", t.DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED = "DYNAMIC_VOLUME_DIMENSION_GROUP_CHANGED", t.DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED = "DYNAMIC_VOLUME_TIME_POINT_INDEX_CHANGED", t.DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED = "DYNAMIC_VOLUME_DIMENSION_GROUP_LOADED", t.DYNAMIC_VOLUME_TIME_POINT_LOADED = "DYNAMIC_VOLUME_TIME_POINT_LOADED", t.GEOMETRY_LOADED = "GEOMETRY_LOADED", t.GEOMETRY_LOAD_PROGRESS = "GEOMETRY_LOAD_PROGRESS", t.GEOMETRY_LOADED_FAILED = "GEOMETRY_LOADED_FAILED", t.ACTORS_CHANGED = "CORNERSTONE_ACTORS_CHANGED";
    })(Ge || (Ge = {}));
    var Gt;
    (function(t) {
        t.Interaction = "interaction", t.Thumbnail = "thumbnail", t.Prefetch = "prefetch", t.Compute = "compute";
    })(Gt || (Gt = {}));
    var On;
    (function(t) {
        t.STACK = "stack", t.ORTHOGRAPHIC = "orthographic", t.PERSPECTIVE = "perspective", t.VOLUME_3D = "volume3d", t.VIDEO = "video", t.WHOLE_SLIDE = "wholeSlide";
    })(On || (On = {}));
    var Wc;
    (function(t) {
        t[t.NEAREST = 0] = "NEAREST", t[t.LINEAR = 1] = "LINEAR", t[t.FAST_LINEAR = 2] = "FAST_LINEAR";
    })(Wc || (Wc = {}));
    const H1 = {
        COMPOSITE_BLEND: 0,
        MAXIMUM_INTENSITY_BLEND: 1,
        MINIMUM_INTENSITY_BLEND: 2,
        AVERAGE_INTENSITY_BLEND: 3,
        ADDITIVE_INTENSITY_BLEND: 4,
        RADON_TRANSFORM_BLEND: 5,
        LABELMAP_EDGE_PROJECTION_BLEND: 6
    }, YM = {
        OFF: 0,
        NORMALIZED: 1,
        RAW: 2
    };
    var W7 = {
        BlendMode: H1,
        FilterMode: YM
    };
    const { BlendMode: Uf } = W7;
    var Al;
    (function(t) {
        t[t.COMPOSITE = Uf.COMPOSITE_BLEND] = "COMPOSITE", t[t.MAXIMUM_INTENSITY_BLEND = Uf.MAXIMUM_INTENSITY_BLEND] = "MAXIMUM_INTENSITY_BLEND", t[t.MINIMUM_INTENSITY_BLEND = Uf.MINIMUM_INTENSITY_BLEND] = "MINIMUM_INTENSITY_BLEND", t[t.AVERAGE_INTENSITY_BLEND = Uf.AVERAGE_INTENSITY_BLEND] = "AVERAGE_INTENSITY_BLEND", t[t.LABELMAP_EDGE_PROJECTION_BLEND = Uf.LABELMAP_EDGE_PROJECTION_BLEND] = "LABELMAP_EDGE_PROJECTION_BLEND";
    })(Al || (Al = {}));
    var kl;
    (function(t) {
        t.AXIAL = "axial", t.CORONAL = "coronal", t.SAGITTAL = "sagittal", t.ACQUISITION = "acquisition", t.AXIAL_REFORMAT = "axial_reformat", t.CORONAL_REFORMAT = "coronal_reformat", t.SAGITTAL_REFORMAT = "sagittal_reformat", t.REFORMAT = "reformat";
    })(kl || (kl = {}));
    (function(t) {
        t.CONTOUR = "CONTOUR", t.SURFACE = "SURFACE", t.MESH = "MESH";
    })(Ih || (Ih = {}));
    var cv;
    (function(t) {
        t.CLOSED_PLANAR = "CLOSED_PLANAR", t.OPEN_PLANAR = "OPEN_PLANAR";
    })(cv || (cv = {}));
    const ZM = cv;
    (function(t) {
        t.PLY = "PLY", t.STL = "STL", t.OBJ = "OBJ", t.VTP = "VTP";
    })(lv || (lv = {}));
    var zi;
    (function(t) {
        t.LINEAR = "LINEAR", t.SAMPLED_SIGMOID = "SIGMOID", t.LINEAR_EXACT = "LINEAR_EXACT";
    })(zi || (zi = {}));
    var uv;
    (function(t) {
        t.SUM = "SUM", t.AVERAGE = "AVERAGE", t.SUBTRACT = "SUBTRACT";
    })(uv || (uv = {}));
    const JM = uv;
    var Ks;
    (function(t) {
        t.NOT_APPLICABLE = "", t.ERMF = "ERMF", t.USER = "User", t.PROJECTION = "Proj", t.REGION = "Region", t.ERROR = "Error", t.UNCALIBRATED = "Uncalibrated", t.CALIBRATED = "Calibrated", t.UNKNOWN = "Unknown";
    })(Ks || (Ks = {}));
    var sa;
    (function(t) {
        t.NO_DATA = "noData", t.LOADING = "loading", t.PRE_RENDER = "preRender", t.RESIZE = "resize", t.RENDERED = "rendered";
    })(sa || (sa = {}));
    (function(t) {
        t[t.FAR_REPLICATE = 1] = "FAR_REPLICATE", t[t.ADJACENT_REPLICATE = 3] = "ADJACENT_REPLICATE", t[t.SUBRESOLUTION = 6] = "SUBRESOLUTION", t[t.LOSSY = 7] = "LOSSY", t[t.FULL_RESOLUTION = 8] = "FULL_RESOLUTION";
    })(To || (To = {}));
    var _d;
    (function(t) {
        t.FRAME = "f", t.SECOND = "s";
    })(_d || (_d = {}));
    const QM = Object.freeze(Object.defineProperty({
        __proto__: null,
        get SpeedUnit () {
            return _d;
        }
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    var Ia;
    (function(t) {
        t.CALIBRATION = "calibrationModule", t.CINE = "cineModule", t.GENERAL_IMAGE = "generalImageModule", t.GENERAL_SERIES = "generalSeriesModule", t.GENERAL_STUDY = "generalStudyModule", t.IMAGE_PIXEL = "imagePixelModule", t.IMAGE_PLANE = "imagePlaneModule", t.IMAGE_URL = "imageUrlModule", t.MODALITY_LUT = "modalityLutModule", t.MULTIFRAME = "multiframeModule", t.NM_MULTIFRAME_GEOMETRY = "nmMultiframeGeometryModule", t.OVERLAY_PLANE = "overlayPlaneModule", t.PATIENT = "patientModule", t.PATIENT_STUDY = "patientStudyModule", t.PET_IMAGE = "petImageModule", t.PET_ISOTOPE = "petIsotopeModule", t.PET_SERIES = "petSeriesModule", t.SOP_COMMON = "sopCommonModule", t.ULTRASOUND_ENHANCED_REGION = "ultrasoundEnhancedRegionModule", t.VOI_LUT = "voiLutModule", t.WADO_WEB_CLIENT = "wadoWebClient";
    })(Ia || (Ia = {}));
    var fv;
    (function(t) {
        t.SUM = "SUM", t.SUBTRACT = "SUBTRACT", t.AVERAGE = "AVERAGE";
    })(fv || (fv = {}));
    var Mh;
    (function(t) {
        t.RLE = "RLE", t.Volume = "Volume";
    })(Mh || (Mh = {}));
    var k0;
    (function(t) {
        t.Tiled = "tiled", t.ContextPool = "contextPool";
    })(k0 || (k0 = {}));
    let dv, Er;
    sc = Object.freeze(Object.defineProperty({
        __proto__: null,
        BlendModes: Al,
        CalibrationTypes: Ks,
        ContourType: ZM,
        DynamicOperatorType: JM,
        Events: Ge,
        get GenerateImageType () {
            return fv;
        },
        GeometryType: Ih,
        ImageQualityStatus: To,
        InterpolationType: Wc,
        MeshType: lv,
        MetadataModules: Ia,
        OrientationAxis: kl,
        RenderingEngineModeEnum: k0,
        RequestType: Gt,
        VOILUTFunctionType: zi,
        VideoEnums: QM,
        ViewportStatus: sa,
        ViewportType: On,
        VoxelManagerEnum: Mh
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    dv = {
        hotIron: {
            name: "Hot Iron",
            numOfColors: 256,
            colors: [
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    2,
                    0,
                    0,
                    255
                ],
                [
                    4,
                    0,
                    0,
                    255
                ],
                [
                    6,
                    0,
                    0,
                    255
                ],
                [
                    8,
                    0,
                    0,
                    255
                ],
                [
                    10,
                    0,
                    0,
                    255
                ],
                [
                    12,
                    0,
                    0,
                    255
                ],
                [
                    14,
                    0,
                    0,
                    255
                ],
                [
                    16,
                    0,
                    0,
                    255
                ],
                [
                    18,
                    0,
                    0,
                    255
                ],
                [
                    20,
                    0,
                    0,
                    255
                ],
                [
                    22,
                    0,
                    0,
                    255
                ],
                [
                    24,
                    0,
                    0,
                    255
                ],
                [
                    26,
                    0,
                    0,
                    255
                ],
                [
                    28,
                    0,
                    0,
                    255
                ],
                [
                    30,
                    0,
                    0,
                    255
                ],
                [
                    32,
                    0,
                    0,
                    255
                ],
                [
                    34,
                    0,
                    0,
                    255
                ],
                [
                    36,
                    0,
                    0,
                    255
                ],
                [
                    38,
                    0,
                    0,
                    255
                ],
                [
                    40,
                    0,
                    0,
                    255
                ],
                [
                    42,
                    0,
                    0,
                    255
                ],
                [
                    44,
                    0,
                    0,
                    255
                ],
                [
                    46,
                    0,
                    0,
                    255
                ],
                [
                    48,
                    0,
                    0,
                    255
                ],
                [
                    50,
                    0,
                    0,
                    255
                ],
                [
                    52,
                    0,
                    0,
                    255
                ],
                [
                    54,
                    0,
                    0,
                    255
                ],
                [
                    56,
                    0,
                    0,
                    255
                ],
                [
                    58,
                    0,
                    0,
                    255
                ],
                [
                    60,
                    0,
                    0,
                    255
                ],
                [
                    62,
                    0,
                    0,
                    255
                ],
                [
                    64,
                    0,
                    0,
                    255
                ],
                [
                    66,
                    0,
                    0,
                    255
                ],
                [
                    68,
                    0,
                    0,
                    255
                ],
                [
                    70,
                    0,
                    0,
                    255
                ],
                [
                    72,
                    0,
                    0,
                    255
                ],
                [
                    74,
                    0,
                    0,
                    255
                ],
                [
                    76,
                    0,
                    0,
                    255
                ],
                [
                    78,
                    0,
                    0,
                    255
                ],
                [
                    80,
                    0,
                    0,
                    255
                ],
                [
                    82,
                    0,
                    0,
                    255
                ],
                [
                    84,
                    0,
                    0,
                    255
                ],
                [
                    86,
                    0,
                    0,
                    255
                ],
                [
                    88,
                    0,
                    0,
                    255
                ],
                [
                    90,
                    0,
                    0,
                    255
                ],
                [
                    92,
                    0,
                    0,
                    255
                ],
                [
                    94,
                    0,
                    0,
                    255
                ],
                [
                    96,
                    0,
                    0,
                    255
                ],
                [
                    98,
                    0,
                    0,
                    255
                ],
                [
                    100,
                    0,
                    0,
                    255
                ],
                [
                    102,
                    0,
                    0,
                    255
                ],
                [
                    104,
                    0,
                    0,
                    255
                ],
                [
                    106,
                    0,
                    0,
                    255
                ],
                [
                    108,
                    0,
                    0,
                    255
                ],
                [
                    110,
                    0,
                    0,
                    255
                ],
                [
                    112,
                    0,
                    0,
                    255
                ],
                [
                    114,
                    0,
                    0,
                    255
                ],
                [
                    116,
                    0,
                    0,
                    255
                ],
                [
                    118,
                    0,
                    0,
                    255
                ],
                [
                    120,
                    0,
                    0,
                    255
                ],
                [
                    122,
                    0,
                    0,
                    255
                ],
                [
                    124,
                    0,
                    0,
                    255
                ],
                [
                    126,
                    0,
                    0,
                    255
                ],
                [
                    128,
                    0,
                    0,
                    255
                ],
                [
                    130,
                    0,
                    0,
                    255
                ],
                [
                    132,
                    0,
                    0,
                    255
                ],
                [
                    134,
                    0,
                    0,
                    255
                ],
                [
                    136,
                    0,
                    0,
                    255
                ],
                [
                    138,
                    0,
                    0,
                    255
                ],
                [
                    140,
                    0,
                    0,
                    255
                ],
                [
                    142,
                    0,
                    0,
                    255
                ],
                [
                    144,
                    0,
                    0,
                    255
                ],
                [
                    146,
                    0,
                    0,
                    255
                ],
                [
                    148,
                    0,
                    0,
                    255
                ],
                [
                    150,
                    0,
                    0,
                    255
                ],
                [
                    152,
                    0,
                    0,
                    255
                ],
                [
                    154,
                    0,
                    0,
                    255
                ],
                [
                    156,
                    0,
                    0,
                    255
                ],
                [
                    158,
                    0,
                    0,
                    255
                ],
                [
                    160,
                    0,
                    0,
                    255
                ],
                [
                    162,
                    0,
                    0,
                    255
                ],
                [
                    164,
                    0,
                    0,
                    255
                ],
                [
                    166,
                    0,
                    0,
                    255
                ],
                [
                    168,
                    0,
                    0,
                    255
                ],
                [
                    170,
                    0,
                    0,
                    255
                ],
                [
                    172,
                    0,
                    0,
                    255
                ],
                [
                    174,
                    0,
                    0,
                    255
                ],
                [
                    176,
                    0,
                    0,
                    255
                ],
                [
                    178,
                    0,
                    0,
                    255
                ],
                [
                    180,
                    0,
                    0,
                    255
                ],
                [
                    182,
                    0,
                    0,
                    255
                ],
                [
                    184,
                    0,
                    0,
                    255
                ],
                [
                    186,
                    0,
                    0,
                    255
                ],
                [
                    188,
                    0,
                    0,
                    255
                ],
                [
                    190,
                    0,
                    0,
                    255
                ],
                [
                    192,
                    0,
                    0,
                    255
                ],
                [
                    194,
                    0,
                    0,
                    255
                ],
                [
                    196,
                    0,
                    0,
                    255
                ],
                [
                    198,
                    0,
                    0,
                    255
                ],
                [
                    200,
                    0,
                    0,
                    255
                ],
                [
                    202,
                    0,
                    0,
                    255
                ],
                [
                    204,
                    0,
                    0,
                    255
                ],
                [
                    206,
                    0,
                    0,
                    255
                ],
                [
                    208,
                    0,
                    0,
                    255
                ],
                [
                    210,
                    0,
                    0,
                    255
                ],
                [
                    212,
                    0,
                    0,
                    255
                ],
                [
                    214,
                    0,
                    0,
                    255
                ],
                [
                    216,
                    0,
                    0,
                    255
                ],
                [
                    218,
                    0,
                    0,
                    255
                ],
                [
                    220,
                    0,
                    0,
                    255
                ],
                [
                    222,
                    0,
                    0,
                    255
                ],
                [
                    224,
                    0,
                    0,
                    255
                ],
                [
                    226,
                    0,
                    0,
                    255
                ],
                [
                    228,
                    0,
                    0,
                    255
                ],
                [
                    230,
                    0,
                    0,
                    255
                ],
                [
                    232,
                    0,
                    0,
                    255
                ],
                [
                    234,
                    0,
                    0,
                    255
                ],
                [
                    236,
                    0,
                    0,
                    255
                ],
                [
                    238,
                    0,
                    0,
                    255
                ],
                [
                    240,
                    0,
                    0,
                    255
                ],
                [
                    242,
                    0,
                    0,
                    255
                ],
                [
                    244,
                    0,
                    0,
                    255
                ],
                [
                    246,
                    0,
                    0,
                    255
                ],
                [
                    248,
                    0,
                    0,
                    255
                ],
                [
                    250,
                    0,
                    0,
                    255
                ],
                [
                    252,
                    0,
                    0,
                    255
                ],
                [
                    254,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    2,
                    0,
                    255
                ],
                [
                    255,
                    4,
                    0,
                    255
                ],
                [
                    255,
                    6,
                    0,
                    255
                ],
                [
                    255,
                    8,
                    0,
                    255
                ],
                [
                    255,
                    10,
                    0,
                    255
                ],
                [
                    255,
                    12,
                    0,
                    255
                ],
                [
                    255,
                    14,
                    0,
                    255
                ],
                [
                    255,
                    16,
                    0,
                    255
                ],
                [
                    255,
                    18,
                    0,
                    255
                ],
                [
                    255,
                    20,
                    0,
                    255
                ],
                [
                    255,
                    22,
                    0,
                    255
                ],
                [
                    255,
                    24,
                    0,
                    255
                ],
                [
                    255,
                    26,
                    0,
                    255
                ],
                [
                    255,
                    28,
                    0,
                    255
                ],
                [
                    255,
                    30,
                    0,
                    255
                ],
                [
                    255,
                    32,
                    0,
                    255
                ],
                [
                    255,
                    34,
                    0,
                    255
                ],
                [
                    255,
                    36,
                    0,
                    255
                ],
                [
                    255,
                    38,
                    0,
                    255
                ],
                [
                    255,
                    40,
                    0,
                    255
                ],
                [
                    255,
                    42,
                    0,
                    255
                ],
                [
                    255,
                    44,
                    0,
                    255
                ],
                [
                    255,
                    46,
                    0,
                    255
                ],
                [
                    255,
                    48,
                    0,
                    255
                ],
                [
                    255,
                    50,
                    0,
                    255
                ],
                [
                    255,
                    52,
                    0,
                    255
                ],
                [
                    255,
                    54,
                    0,
                    255
                ],
                [
                    255,
                    56,
                    0,
                    255
                ],
                [
                    255,
                    58,
                    0,
                    255
                ],
                [
                    255,
                    60,
                    0,
                    255
                ],
                [
                    255,
                    62,
                    0,
                    255
                ],
                [
                    255,
                    64,
                    0,
                    255
                ],
                [
                    255,
                    66,
                    0,
                    255
                ],
                [
                    255,
                    68,
                    0,
                    255
                ],
                [
                    255,
                    70,
                    0,
                    255
                ],
                [
                    255,
                    72,
                    0,
                    255
                ],
                [
                    255,
                    74,
                    0,
                    255
                ],
                [
                    255,
                    76,
                    0,
                    255
                ],
                [
                    255,
                    78,
                    0,
                    255
                ],
                [
                    255,
                    80,
                    0,
                    255
                ],
                [
                    255,
                    82,
                    0,
                    255
                ],
                [
                    255,
                    84,
                    0,
                    255
                ],
                [
                    255,
                    86,
                    0,
                    255
                ],
                [
                    255,
                    88,
                    0,
                    255
                ],
                [
                    255,
                    90,
                    0,
                    255
                ],
                [
                    255,
                    92,
                    0,
                    255
                ],
                [
                    255,
                    94,
                    0,
                    255
                ],
                [
                    255,
                    96,
                    0,
                    255
                ],
                [
                    255,
                    98,
                    0,
                    255
                ],
                [
                    255,
                    100,
                    0,
                    255
                ],
                [
                    255,
                    102,
                    0,
                    255
                ],
                [
                    255,
                    104,
                    0,
                    255
                ],
                [
                    255,
                    106,
                    0,
                    255
                ],
                [
                    255,
                    108,
                    0,
                    255
                ],
                [
                    255,
                    110,
                    0,
                    255
                ],
                [
                    255,
                    112,
                    0,
                    255
                ],
                [
                    255,
                    114,
                    0,
                    255
                ],
                [
                    255,
                    116,
                    0,
                    255
                ],
                [
                    255,
                    118,
                    0,
                    255
                ],
                [
                    255,
                    120,
                    0,
                    255
                ],
                [
                    255,
                    122,
                    0,
                    255
                ],
                [
                    255,
                    124,
                    0,
                    255
                ],
                [
                    255,
                    126,
                    0,
                    255
                ],
                [
                    255,
                    128,
                    4,
                    255
                ],
                [
                    255,
                    130,
                    8,
                    255
                ],
                [
                    255,
                    132,
                    12,
                    255
                ],
                [
                    255,
                    134,
                    16,
                    255
                ],
                [
                    255,
                    136,
                    20,
                    255
                ],
                [
                    255,
                    138,
                    24,
                    255
                ],
                [
                    255,
                    140,
                    28,
                    255
                ],
                [
                    255,
                    142,
                    32,
                    255
                ],
                [
                    255,
                    144,
                    36,
                    255
                ],
                [
                    255,
                    146,
                    40,
                    255
                ],
                [
                    255,
                    148,
                    44,
                    255
                ],
                [
                    255,
                    150,
                    48,
                    255
                ],
                [
                    255,
                    152,
                    52,
                    255
                ],
                [
                    255,
                    154,
                    56,
                    255
                ],
                [
                    255,
                    156,
                    60,
                    255
                ],
                [
                    255,
                    158,
                    64,
                    255
                ],
                [
                    255,
                    160,
                    68,
                    255
                ],
                [
                    255,
                    162,
                    72,
                    255
                ],
                [
                    255,
                    164,
                    76,
                    255
                ],
                [
                    255,
                    166,
                    80,
                    255
                ],
                [
                    255,
                    168,
                    84,
                    255
                ],
                [
                    255,
                    170,
                    88,
                    255
                ],
                [
                    255,
                    172,
                    92,
                    255
                ],
                [
                    255,
                    174,
                    96,
                    255
                ],
                [
                    255,
                    176,
                    100,
                    255
                ],
                [
                    255,
                    178,
                    104,
                    255
                ],
                [
                    255,
                    180,
                    108,
                    255
                ],
                [
                    255,
                    182,
                    112,
                    255
                ],
                [
                    255,
                    184,
                    116,
                    255
                ],
                [
                    255,
                    186,
                    120,
                    255
                ],
                [
                    255,
                    188,
                    124,
                    255
                ],
                [
                    255,
                    190,
                    128,
                    255
                ],
                [
                    255,
                    192,
                    132,
                    255
                ],
                [
                    255,
                    194,
                    136,
                    255
                ],
                [
                    255,
                    196,
                    140,
                    255
                ],
                [
                    255,
                    198,
                    144,
                    255
                ],
                [
                    255,
                    200,
                    148,
                    255
                ],
                [
                    255,
                    202,
                    152,
                    255
                ],
                [
                    255,
                    204,
                    156,
                    255
                ],
                [
                    255,
                    206,
                    160,
                    255
                ],
                [
                    255,
                    208,
                    164,
                    255
                ],
                [
                    255,
                    210,
                    168,
                    255
                ],
                [
                    255,
                    212,
                    172,
                    255
                ],
                [
                    255,
                    214,
                    176,
                    255
                ],
                [
                    255,
                    216,
                    180,
                    255
                ],
                [
                    255,
                    218,
                    184,
                    255
                ],
                [
                    255,
                    220,
                    188,
                    255
                ],
                [
                    255,
                    222,
                    192,
                    255
                ],
                [
                    255,
                    224,
                    196,
                    255
                ],
                [
                    255,
                    226,
                    200,
                    255
                ],
                [
                    255,
                    228,
                    204,
                    255
                ],
                [
                    255,
                    230,
                    208,
                    255
                ],
                [
                    255,
                    232,
                    212,
                    255
                ],
                [
                    255,
                    234,
                    216,
                    255
                ],
                [
                    255,
                    236,
                    220,
                    255
                ],
                [
                    255,
                    238,
                    224,
                    255
                ],
                [
                    255,
                    240,
                    228,
                    255
                ],
                [
                    255,
                    242,
                    232,
                    255
                ],
                [
                    255,
                    244,
                    236,
                    255
                ],
                [
                    255,
                    246,
                    240,
                    255
                ],
                [
                    255,
                    248,
                    244,
                    255
                ],
                [
                    255,
                    250,
                    248,
                    255
                ],
                [
                    255,
                    252,
                    252,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ]
            ]
        },
        pet: {
            name: "PET",
            numColors: 256,
            colors: [
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    2,
                    1,
                    255
                ],
                [
                    0,
                    4,
                    3,
                    255
                ],
                [
                    0,
                    6,
                    5,
                    255
                ],
                [
                    0,
                    8,
                    7,
                    255
                ],
                [
                    0,
                    10,
                    9,
                    255
                ],
                [
                    0,
                    12,
                    11,
                    255
                ],
                [
                    0,
                    14,
                    13,
                    255
                ],
                [
                    0,
                    16,
                    15,
                    255
                ],
                [
                    0,
                    18,
                    17,
                    255
                ],
                [
                    0,
                    20,
                    19,
                    255
                ],
                [
                    0,
                    22,
                    21,
                    255
                ],
                [
                    0,
                    24,
                    23,
                    255
                ],
                [
                    0,
                    26,
                    25,
                    255
                ],
                [
                    0,
                    28,
                    27,
                    255
                ],
                [
                    0,
                    30,
                    29,
                    255
                ],
                [
                    0,
                    32,
                    31,
                    255
                ],
                [
                    0,
                    34,
                    33,
                    255
                ],
                [
                    0,
                    36,
                    35,
                    255
                ],
                [
                    0,
                    38,
                    37,
                    255
                ],
                [
                    0,
                    40,
                    39,
                    255
                ],
                [
                    0,
                    42,
                    41,
                    255
                ],
                [
                    0,
                    44,
                    43,
                    255
                ],
                [
                    0,
                    46,
                    45,
                    255
                ],
                [
                    0,
                    48,
                    47,
                    255
                ],
                [
                    0,
                    50,
                    49,
                    255
                ],
                [
                    0,
                    52,
                    51,
                    255
                ],
                [
                    0,
                    54,
                    53,
                    255
                ],
                [
                    0,
                    56,
                    55,
                    255
                ],
                [
                    0,
                    58,
                    57,
                    255
                ],
                [
                    0,
                    60,
                    59,
                    255
                ],
                [
                    0,
                    62,
                    61,
                    255
                ],
                [
                    0,
                    65,
                    63,
                    255
                ],
                [
                    0,
                    67,
                    65,
                    255
                ],
                [
                    0,
                    69,
                    67,
                    255
                ],
                [
                    0,
                    71,
                    69,
                    255
                ],
                [
                    0,
                    73,
                    71,
                    255
                ],
                [
                    0,
                    75,
                    73,
                    255
                ],
                [
                    0,
                    77,
                    75,
                    255
                ],
                [
                    0,
                    79,
                    77,
                    255
                ],
                [
                    0,
                    81,
                    79,
                    255
                ],
                [
                    0,
                    83,
                    81,
                    255
                ],
                [
                    0,
                    85,
                    83,
                    255
                ],
                [
                    0,
                    87,
                    85,
                    255
                ],
                [
                    0,
                    89,
                    87,
                    255
                ],
                [
                    0,
                    91,
                    89,
                    255
                ],
                [
                    0,
                    93,
                    91,
                    255
                ],
                [
                    0,
                    95,
                    93,
                    255
                ],
                [
                    0,
                    97,
                    95,
                    255
                ],
                [
                    0,
                    99,
                    97,
                    255
                ],
                [
                    0,
                    101,
                    99,
                    255
                ],
                [
                    0,
                    103,
                    101,
                    255
                ],
                [
                    0,
                    105,
                    103,
                    255
                ],
                [
                    0,
                    107,
                    105,
                    255
                ],
                [
                    0,
                    109,
                    107,
                    255
                ],
                [
                    0,
                    111,
                    109,
                    255
                ],
                [
                    0,
                    113,
                    111,
                    255
                ],
                [
                    0,
                    115,
                    113,
                    255
                ],
                [
                    0,
                    117,
                    115,
                    255
                ],
                [
                    0,
                    119,
                    117,
                    255
                ],
                [
                    0,
                    121,
                    119,
                    255
                ],
                [
                    0,
                    123,
                    121,
                    255
                ],
                [
                    0,
                    125,
                    123,
                    255
                ],
                [
                    0,
                    128,
                    125,
                    255
                ],
                [
                    1,
                    126,
                    127,
                    255
                ],
                [
                    3,
                    124,
                    129,
                    255
                ],
                [
                    5,
                    122,
                    131,
                    255
                ],
                [
                    7,
                    120,
                    133,
                    255
                ],
                [
                    9,
                    118,
                    135,
                    255
                ],
                [
                    11,
                    116,
                    137,
                    255
                ],
                [
                    13,
                    114,
                    139,
                    255
                ],
                [
                    15,
                    112,
                    141,
                    255
                ],
                [
                    17,
                    110,
                    143,
                    255
                ],
                [
                    19,
                    108,
                    145,
                    255
                ],
                [
                    21,
                    106,
                    147,
                    255
                ],
                [
                    23,
                    104,
                    149,
                    255
                ],
                [
                    25,
                    102,
                    151,
                    255
                ],
                [
                    27,
                    100,
                    153,
                    255
                ],
                [
                    29,
                    98,
                    155,
                    255
                ],
                [
                    31,
                    96,
                    157,
                    255
                ],
                [
                    33,
                    94,
                    159,
                    255
                ],
                [
                    35,
                    92,
                    161,
                    255
                ],
                [
                    37,
                    90,
                    163,
                    255
                ],
                [
                    39,
                    88,
                    165,
                    255
                ],
                [
                    41,
                    86,
                    167,
                    255
                ],
                [
                    43,
                    84,
                    169,
                    255
                ],
                [
                    45,
                    82,
                    171,
                    255
                ],
                [
                    47,
                    80,
                    173,
                    255
                ],
                [
                    49,
                    78,
                    175,
                    255
                ],
                [
                    51,
                    76,
                    177,
                    255
                ],
                [
                    53,
                    74,
                    179,
                    255
                ],
                [
                    55,
                    72,
                    181,
                    255
                ],
                [
                    57,
                    70,
                    183,
                    255
                ],
                [
                    59,
                    68,
                    185,
                    255
                ],
                [
                    61,
                    66,
                    187,
                    255
                ],
                [
                    63,
                    64,
                    189,
                    255
                ],
                [
                    65,
                    63,
                    191,
                    255
                ],
                [
                    67,
                    61,
                    193,
                    255
                ],
                [
                    69,
                    59,
                    195,
                    255
                ],
                [
                    71,
                    57,
                    197,
                    255
                ],
                [
                    73,
                    55,
                    199,
                    255
                ],
                [
                    75,
                    53,
                    201,
                    255
                ],
                [
                    77,
                    51,
                    203,
                    255
                ],
                [
                    79,
                    49,
                    205,
                    255
                ],
                [
                    81,
                    47,
                    207,
                    255
                ],
                [
                    83,
                    45,
                    209,
                    255
                ],
                [
                    85,
                    43,
                    211,
                    255
                ],
                [
                    86,
                    41,
                    213,
                    255
                ],
                [
                    88,
                    39,
                    215,
                    255
                ],
                [
                    90,
                    37,
                    217,
                    255
                ],
                [
                    92,
                    35,
                    219,
                    255
                ],
                [
                    94,
                    33,
                    221,
                    255
                ],
                [
                    96,
                    31,
                    223,
                    255
                ],
                [
                    98,
                    29,
                    225,
                    255
                ],
                [
                    100,
                    27,
                    227,
                    255
                ],
                [
                    102,
                    25,
                    229,
                    255
                ],
                [
                    104,
                    23,
                    231,
                    255
                ],
                [
                    106,
                    21,
                    233,
                    255
                ],
                [
                    108,
                    19,
                    235,
                    255
                ],
                [
                    110,
                    17,
                    237,
                    255
                ],
                [
                    112,
                    15,
                    239,
                    255
                ],
                [
                    114,
                    13,
                    241,
                    255
                ],
                [
                    116,
                    11,
                    243,
                    255
                ],
                [
                    118,
                    9,
                    245,
                    255
                ],
                [
                    120,
                    7,
                    247,
                    255
                ],
                [
                    122,
                    5,
                    249,
                    255
                ],
                [
                    124,
                    3,
                    251,
                    255
                ],
                [
                    126,
                    1,
                    253,
                    255
                ],
                [
                    128,
                    0,
                    255,
                    255
                ],
                [
                    130,
                    2,
                    252,
                    255
                ],
                [
                    132,
                    4,
                    248,
                    255
                ],
                [
                    134,
                    6,
                    244,
                    255
                ],
                [
                    136,
                    8,
                    240,
                    255
                ],
                [
                    138,
                    10,
                    236,
                    255
                ],
                [
                    140,
                    12,
                    232,
                    255
                ],
                [
                    142,
                    14,
                    228,
                    255
                ],
                [
                    144,
                    16,
                    224,
                    255
                ],
                [
                    146,
                    18,
                    220,
                    255
                ],
                [
                    148,
                    20,
                    216,
                    255
                ],
                [
                    150,
                    22,
                    212,
                    255
                ],
                [
                    152,
                    24,
                    208,
                    255
                ],
                [
                    154,
                    26,
                    204,
                    255
                ],
                [
                    156,
                    28,
                    200,
                    255
                ],
                [
                    158,
                    30,
                    196,
                    255
                ],
                [
                    160,
                    32,
                    192,
                    255
                ],
                [
                    162,
                    34,
                    188,
                    255
                ],
                [
                    164,
                    36,
                    184,
                    255
                ],
                [
                    166,
                    38,
                    180,
                    255
                ],
                [
                    168,
                    40,
                    176,
                    255
                ],
                [
                    170,
                    42,
                    172,
                    255
                ],
                [
                    171,
                    44,
                    168,
                    255
                ],
                [
                    173,
                    46,
                    164,
                    255
                ],
                [
                    175,
                    48,
                    160,
                    255
                ],
                [
                    177,
                    50,
                    156,
                    255
                ],
                [
                    179,
                    52,
                    152,
                    255
                ],
                [
                    181,
                    54,
                    148,
                    255
                ],
                [
                    183,
                    56,
                    144,
                    255
                ],
                [
                    185,
                    58,
                    140,
                    255
                ],
                [
                    187,
                    60,
                    136,
                    255
                ],
                [
                    189,
                    62,
                    132,
                    255
                ],
                [
                    191,
                    64,
                    128,
                    255
                ],
                [
                    193,
                    66,
                    124,
                    255
                ],
                [
                    195,
                    68,
                    120,
                    255
                ],
                [
                    197,
                    70,
                    116,
                    255
                ],
                [
                    199,
                    72,
                    112,
                    255
                ],
                [
                    201,
                    74,
                    108,
                    255
                ],
                [
                    203,
                    76,
                    104,
                    255
                ],
                [
                    205,
                    78,
                    100,
                    255
                ],
                [
                    207,
                    80,
                    96,
                    255
                ],
                [
                    209,
                    82,
                    92,
                    255
                ],
                [
                    211,
                    84,
                    88,
                    255
                ],
                [
                    213,
                    86,
                    84,
                    255
                ],
                [
                    215,
                    88,
                    80,
                    255
                ],
                [
                    217,
                    90,
                    76,
                    255
                ],
                [
                    219,
                    92,
                    72,
                    255
                ],
                [
                    221,
                    94,
                    68,
                    255
                ],
                [
                    223,
                    96,
                    64,
                    255
                ],
                [
                    225,
                    98,
                    60,
                    255
                ],
                [
                    227,
                    100,
                    56,
                    255
                ],
                [
                    229,
                    102,
                    52,
                    255
                ],
                [
                    231,
                    104,
                    48,
                    255
                ],
                [
                    233,
                    106,
                    44,
                    255
                ],
                [
                    235,
                    108,
                    40,
                    255
                ],
                [
                    237,
                    110,
                    36,
                    255
                ],
                [
                    239,
                    112,
                    32,
                    255
                ],
                [
                    241,
                    114,
                    28,
                    255
                ],
                [
                    243,
                    116,
                    24,
                    255
                ],
                [
                    245,
                    118,
                    20,
                    255
                ],
                [
                    247,
                    120,
                    16,
                    255
                ],
                [
                    249,
                    122,
                    12,
                    255
                ],
                [
                    251,
                    124,
                    8,
                    255
                ],
                [
                    253,
                    126,
                    4,
                    255
                ],
                [
                    255,
                    128,
                    0,
                    255
                ],
                [
                    255,
                    130,
                    4,
                    255
                ],
                [
                    255,
                    132,
                    8,
                    255
                ],
                [
                    255,
                    134,
                    12,
                    255
                ],
                [
                    255,
                    136,
                    16,
                    255
                ],
                [
                    255,
                    138,
                    20,
                    255
                ],
                [
                    255,
                    140,
                    24,
                    255
                ],
                [
                    255,
                    142,
                    28,
                    255
                ],
                [
                    255,
                    144,
                    32,
                    255
                ],
                [
                    255,
                    146,
                    36,
                    255
                ],
                [
                    255,
                    148,
                    40,
                    255
                ],
                [
                    255,
                    150,
                    44,
                    255
                ],
                [
                    255,
                    152,
                    48,
                    255
                ],
                [
                    255,
                    154,
                    52,
                    255
                ],
                [
                    255,
                    156,
                    56,
                    255
                ],
                [
                    255,
                    158,
                    60,
                    255
                ],
                [
                    255,
                    160,
                    64,
                    255
                ],
                [
                    255,
                    162,
                    68,
                    255
                ],
                [
                    255,
                    164,
                    72,
                    255
                ],
                [
                    255,
                    166,
                    76,
                    255
                ],
                [
                    255,
                    168,
                    80,
                    255
                ],
                [
                    255,
                    170,
                    85,
                    255
                ],
                [
                    255,
                    172,
                    89,
                    255
                ],
                [
                    255,
                    174,
                    93,
                    255
                ],
                [
                    255,
                    176,
                    97,
                    255
                ],
                [
                    255,
                    178,
                    101,
                    255
                ],
                [
                    255,
                    180,
                    105,
                    255
                ],
                [
                    255,
                    182,
                    109,
                    255
                ],
                [
                    255,
                    184,
                    113,
                    255
                ],
                [
                    255,
                    186,
                    117,
                    255
                ],
                [
                    255,
                    188,
                    121,
                    255
                ],
                [
                    255,
                    190,
                    125,
                    255
                ],
                [
                    255,
                    192,
                    129,
                    255
                ],
                [
                    255,
                    194,
                    133,
                    255
                ],
                [
                    255,
                    196,
                    137,
                    255
                ],
                [
                    255,
                    198,
                    141,
                    255
                ],
                [
                    255,
                    200,
                    145,
                    255
                ],
                [
                    255,
                    202,
                    149,
                    255
                ],
                [
                    255,
                    204,
                    153,
                    255
                ],
                [
                    255,
                    206,
                    157,
                    255
                ],
                [
                    255,
                    208,
                    161,
                    255
                ],
                [
                    255,
                    210,
                    165,
                    255
                ],
                [
                    255,
                    212,
                    170,
                    255
                ],
                [
                    255,
                    214,
                    174,
                    255
                ],
                [
                    255,
                    216,
                    178,
                    255
                ],
                [
                    255,
                    218,
                    182,
                    255
                ],
                [
                    255,
                    220,
                    186,
                    255
                ],
                [
                    255,
                    222,
                    190,
                    255
                ],
                [
                    255,
                    224,
                    194,
                    255
                ],
                [
                    255,
                    226,
                    198,
                    255
                ],
                [
                    255,
                    228,
                    202,
                    255
                ],
                [
                    255,
                    230,
                    206,
                    255
                ],
                [
                    255,
                    232,
                    210,
                    255
                ],
                [
                    255,
                    234,
                    214,
                    255
                ],
                [
                    255,
                    236,
                    218,
                    255
                ],
                [
                    255,
                    238,
                    222,
                    255
                ],
                [
                    255,
                    240,
                    226,
                    255
                ],
                [
                    255,
                    242,
                    230,
                    255
                ],
                [
                    255,
                    244,
                    234,
                    255
                ],
                [
                    255,
                    246,
                    238,
                    255
                ],
                [
                    255,
                    248,
                    242,
                    255
                ],
                [
                    255,
                    250,
                    246,
                    255
                ],
                [
                    255,
                    252,
                    250,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ]
            ]
        },
        hotMetalBlue: {
            name: "Hot Metal Blue",
            numColors: 256,
            colors: [
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    2,
                    255
                ],
                [
                    0,
                    0,
                    4,
                    255
                ],
                [
                    0,
                    0,
                    6,
                    255
                ],
                [
                    0,
                    0,
                    8,
                    255
                ],
                [
                    0,
                    0,
                    10,
                    255
                ],
                [
                    0,
                    0,
                    12,
                    255
                ],
                [
                    0,
                    0,
                    14,
                    255
                ],
                [
                    0,
                    0,
                    16,
                    255
                ],
                [
                    0,
                    0,
                    17,
                    255
                ],
                [
                    0,
                    0,
                    19,
                    255
                ],
                [
                    0,
                    0,
                    21,
                    255
                ],
                [
                    0,
                    0,
                    23,
                    255
                ],
                [
                    0,
                    0,
                    25,
                    255
                ],
                [
                    0,
                    0,
                    27,
                    255
                ],
                [
                    0,
                    0,
                    29,
                    255
                ],
                [
                    0,
                    0,
                    31,
                    255
                ],
                [
                    0,
                    0,
                    33,
                    255
                ],
                [
                    0,
                    0,
                    35,
                    255
                ],
                [
                    0,
                    0,
                    37,
                    255
                ],
                [
                    0,
                    0,
                    39,
                    255
                ],
                [
                    0,
                    0,
                    41,
                    255
                ],
                [
                    0,
                    0,
                    43,
                    255
                ],
                [
                    0,
                    0,
                    45,
                    255
                ],
                [
                    0,
                    0,
                    47,
                    255
                ],
                [
                    0,
                    0,
                    49,
                    255
                ],
                [
                    0,
                    0,
                    51,
                    255
                ],
                [
                    0,
                    0,
                    53,
                    255
                ],
                [
                    0,
                    0,
                    55,
                    255
                ],
                [
                    0,
                    0,
                    57,
                    255
                ],
                [
                    0,
                    0,
                    59,
                    255
                ],
                [
                    0,
                    0,
                    61,
                    255
                ],
                [
                    0,
                    0,
                    63,
                    255
                ],
                [
                    0,
                    0,
                    65,
                    255
                ],
                [
                    0,
                    0,
                    67,
                    255
                ],
                [
                    0,
                    0,
                    69,
                    255
                ],
                [
                    0,
                    0,
                    71,
                    255
                ],
                [
                    0,
                    0,
                    73,
                    255
                ],
                [
                    0,
                    0,
                    75,
                    255
                ],
                [
                    0,
                    0,
                    77,
                    255
                ],
                [
                    0,
                    0,
                    79,
                    255
                ],
                [
                    0,
                    0,
                    81,
                    255
                ],
                [
                    0,
                    0,
                    83,
                    255
                ],
                [
                    0,
                    0,
                    84,
                    255
                ],
                [
                    0,
                    0,
                    86,
                    255
                ],
                [
                    0,
                    0,
                    88,
                    255
                ],
                [
                    0,
                    0,
                    90,
                    255
                ],
                [
                    0,
                    0,
                    92,
                    255
                ],
                [
                    0,
                    0,
                    94,
                    255
                ],
                [
                    0,
                    0,
                    96,
                    255
                ],
                [
                    0,
                    0,
                    98,
                    255
                ],
                [
                    0,
                    0,
                    100,
                    255
                ],
                [
                    0,
                    0,
                    102,
                    255
                ],
                [
                    0,
                    0,
                    104,
                    255
                ],
                [
                    0,
                    0,
                    106,
                    255
                ],
                [
                    0,
                    0,
                    108,
                    255
                ],
                [
                    0,
                    0,
                    110,
                    255
                ],
                [
                    0,
                    0,
                    112,
                    255
                ],
                [
                    0,
                    0,
                    114,
                    255
                ],
                [
                    0,
                    0,
                    116,
                    255
                ],
                [
                    0,
                    0,
                    117,
                    255
                ],
                [
                    0,
                    0,
                    119,
                    255
                ],
                [
                    0,
                    0,
                    121,
                    255
                ],
                [
                    0,
                    0,
                    123,
                    255
                ],
                [
                    0,
                    0,
                    125,
                    255
                ],
                [
                    0,
                    0,
                    127,
                    255
                ],
                [
                    0,
                    0,
                    129,
                    255
                ],
                [
                    0,
                    0,
                    131,
                    255
                ],
                [
                    0,
                    0,
                    133,
                    255
                ],
                [
                    0,
                    0,
                    135,
                    255
                ],
                [
                    0,
                    0,
                    137,
                    255
                ],
                [
                    0,
                    0,
                    139,
                    255
                ],
                [
                    0,
                    0,
                    141,
                    255
                ],
                [
                    0,
                    0,
                    143,
                    255
                ],
                [
                    0,
                    0,
                    145,
                    255
                ],
                [
                    0,
                    0,
                    147,
                    255
                ],
                [
                    0,
                    0,
                    149,
                    255
                ],
                [
                    0,
                    0,
                    151,
                    255
                ],
                [
                    0,
                    0,
                    153,
                    255
                ],
                [
                    0,
                    0,
                    155,
                    255
                ],
                [
                    0,
                    0,
                    157,
                    255
                ],
                [
                    0,
                    0,
                    159,
                    255
                ],
                [
                    0,
                    0,
                    161,
                    255
                ],
                [
                    0,
                    0,
                    163,
                    255
                ],
                [
                    0,
                    0,
                    165,
                    255
                ],
                [
                    0,
                    0,
                    167,
                    255
                ],
                [
                    3,
                    0,
                    169,
                    255
                ],
                [
                    6,
                    0,
                    171,
                    255
                ],
                [
                    9,
                    0,
                    173,
                    255
                ],
                [
                    12,
                    0,
                    175,
                    255
                ],
                [
                    15,
                    0,
                    177,
                    255
                ],
                [
                    18,
                    0,
                    179,
                    255
                ],
                [
                    21,
                    0,
                    181,
                    255
                ],
                [
                    24,
                    0,
                    183,
                    255
                ],
                [
                    26,
                    0,
                    184,
                    255
                ],
                [
                    29,
                    0,
                    186,
                    255
                ],
                [
                    32,
                    0,
                    188,
                    255
                ],
                [
                    35,
                    0,
                    190,
                    255
                ],
                [
                    38,
                    0,
                    192,
                    255
                ],
                [
                    41,
                    0,
                    194,
                    255
                ],
                [
                    44,
                    0,
                    196,
                    255
                ],
                [
                    47,
                    0,
                    198,
                    255
                ],
                [
                    50,
                    0,
                    200,
                    255
                ],
                [
                    52,
                    0,
                    197,
                    255
                ],
                [
                    55,
                    0,
                    194,
                    255
                ],
                [
                    57,
                    0,
                    191,
                    255
                ],
                [
                    59,
                    0,
                    188,
                    255
                ],
                [
                    62,
                    0,
                    185,
                    255
                ],
                [
                    64,
                    0,
                    182,
                    255
                ],
                [
                    66,
                    0,
                    179,
                    255
                ],
                [
                    69,
                    0,
                    176,
                    255
                ],
                [
                    71,
                    0,
                    174,
                    255
                ],
                [
                    74,
                    0,
                    171,
                    255
                ],
                [
                    76,
                    0,
                    168,
                    255
                ],
                [
                    78,
                    0,
                    165,
                    255
                ],
                [
                    81,
                    0,
                    162,
                    255
                ],
                [
                    83,
                    0,
                    159,
                    255
                ],
                [
                    85,
                    0,
                    156,
                    255
                ],
                [
                    88,
                    0,
                    153,
                    255
                ],
                [
                    90,
                    0,
                    150,
                    255
                ],
                [
                    93,
                    2,
                    144,
                    255
                ],
                [
                    96,
                    4,
                    138,
                    255
                ],
                [
                    99,
                    6,
                    132,
                    255
                ],
                [
                    102,
                    8,
                    126,
                    255
                ],
                [
                    105,
                    9,
                    121,
                    255
                ],
                [
                    108,
                    11,
                    115,
                    255
                ],
                [
                    111,
                    13,
                    109,
                    255
                ],
                [
                    114,
                    15,
                    103,
                    255
                ],
                [
                    116,
                    17,
                    97,
                    255
                ],
                [
                    119,
                    19,
                    91,
                    255
                ],
                [
                    122,
                    21,
                    85,
                    255
                ],
                [
                    125,
                    23,
                    79,
                    255
                ],
                [
                    128,
                    24,
                    74,
                    255
                ],
                [
                    131,
                    26,
                    68,
                    255
                ],
                [
                    134,
                    28,
                    62,
                    255
                ],
                [
                    137,
                    30,
                    56,
                    255
                ],
                [
                    140,
                    32,
                    50,
                    255
                ],
                [
                    143,
                    34,
                    47,
                    255
                ],
                [
                    146,
                    36,
                    44,
                    255
                ],
                [
                    149,
                    38,
                    41,
                    255
                ],
                [
                    152,
                    40,
                    38,
                    255
                ],
                [
                    155,
                    41,
                    35,
                    255
                ],
                [
                    158,
                    43,
                    32,
                    255
                ],
                [
                    161,
                    45,
                    29,
                    255
                ],
                [
                    164,
                    47,
                    26,
                    255
                ],
                [
                    166,
                    49,
                    24,
                    255
                ],
                [
                    169,
                    51,
                    21,
                    255
                ],
                [
                    172,
                    53,
                    18,
                    255
                ],
                [
                    175,
                    55,
                    15,
                    255
                ],
                [
                    178,
                    56,
                    12,
                    255
                ],
                [
                    181,
                    58,
                    9,
                    255
                ],
                [
                    184,
                    60,
                    6,
                    255
                ],
                [
                    187,
                    62,
                    3,
                    255
                ],
                [
                    190,
                    64,
                    0,
                    255
                ],
                [
                    194,
                    66,
                    0,
                    255
                ],
                [
                    198,
                    68,
                    0,
                    255
                ],
                [
                    201,
                    70,
                    0,
                    255
                ],
                [
                    205,
                    72,
                    0,
                    255
                ],
                [
                    209,
                    73,
                    0,
                    255
                ],
                [
                    213,
                    75,
                    0,
                    255
                ],
                [
                    217,
                    77,
                    0,
                    255
                ],
                [
                    221,
                    79,
                    0,
                    255
                ],
                [
                    224,
                    81,
                    0,
                    255
                ],
                [
                    228,
                    83,
                    0,
                    255
                ],
                [
                    232,
                    85,
                    0,
                    255
                ],
                [
                    236,
                    87,
                    0,
                    255
                ],
                [
                    240,
                    88,
                    0,
                    255
                ],
                [
                    244,
                    90,
                    0,
                    255
                ],
                [
                    247,
                    92,
                    0,
                    255
                ],
                [
                    251,
                    94,
                    0,
                    255
                ],
                [
                    255,
                    96,
                    0,
                    255
                ],
                [
                    255,
                    98,
                    3,
                    255
                ],
                [
                    255,
                    100,
                    6,
                    255
                ],
                [
                    255,
                    102,
                    9,
                    255
                ],
                [
                    255,
                    104,
                    12,
                    255
                ],
                [
                    255,
                    105,
                    15,
                    255
                ],
                [
                    255,
                    107,
                    18,
                    255
                ],
                [
                    255,
                    109,
                    21,
                    255
                ],
                [
                    255,
                    111,
                    24,
                    255
                ],
                [
                    255,
                    113,
                    26,
                    255
                ],
                [
                    255,
                    115,
                    29,
                    255
                ],
                [
                    255,
                    117,
                    32,
                    255
                ],
                [
                    255,
                    119,
                    35,
                    255
                ],
                [
                    255,
                    120,
                    38,
                    255
                ],
                [
                    255,
                    122,
                    41,
                    255
                ],
                [
                    255,
                    124,
                    44,
                    255
                ],
                [
                    255,
                    126,
                    47,
                    255
                ],
                [
                    255,
                    128,
                    50,
                    255
                ],
                [
                    255,
                    130,
                    53,
                    255
                ],
                [
                    255,
                    132,
                    56,
                    255
                ],
                [
                    255,
                    134,
                    59,
                    255
                ],
                [
                    255,
                    136,
                    62,
                    255
                ],
                [
                    255,
                    137,
                    65,
                    255
                ],
                [
                    255,
                    139,
                    68,
                    255
                ],
                [
                    255,
                    141,
                    71,
                    255
                ],
                [
                    255,
                    143,
                    74,
                    255
                ],
                [
                    255,
                    145,
                    76,
                    255
                ],
                [
                    255,
                    147,
                    79,
                    255
                ],
                [
                    255,
                    149,
                    82,
                    255
                ],
                [
                    255,
                    151,
                    85,
                    255
                ],
                [
                    255,
                    152,
                    88,
                    255
                ],
                [
                    255,
                    154,
                    91,
                    255
                ],
                [
                    255,
                    156,
                    94,
                    255
                ],
                [
                    255,
                    158,
                    97,
                    255
                ],
                [
                    255,
                    160,
                    100,
                    255
                ],
                [
                    255,
                    162,
                    103,
                    255
                ],
                [
                    255,
                    164,
                    106,
                    255
                ],
                [
                    255,
                    166,
                    109,
                    255
                ],
                [
                    255,
                    168,
                    112,
                    255
                ],
                [
                    255,
                    169,
                    115,
                    255
                ],
                [
                    255,
                    171,
                    118,
                    255
                ],
                [
                    255,
                    173,
                    121,
                    255
                ],
                [
                    255,
                    175,
                    124,
                    255
                ],
                [
                    255,
                    177,
                    126,
                    255
                ],
                [
                    255,
                    179,
                    129,
                    255
                ],
                [
                    255,
                    181,
                    132,
                    255
                ],
                [
                    255,
                    183,
                    135,
                    255
                ],
                [
                    255,
                    184,
                    138,
                    255
                ],
                [
                    255,
                    186,
                    141,
                    255
                ],
                [
                    255,
                    188,
                    144,
                    255
                ],
                [
                    255,
                    190,
                    147,
                    255
                ],
                [
                    255,
                    192,
                    150,
                    255
                ],
                [
                    255,
                    194,
                    153,
                    255
                ],
                [
                    255,
                    196,
                    156,
                    255
                ],
                [
                    255,
                    198,
                    159,
                    255
                ],
                [
                    255,
                    200,
                    162,
                    255
                ],
                [
                    255,
                    201,
                    165,
                    255
                ],
                [
                    255,
                    203,
                    168,
                    255
                ],
                [
                    255,
                    205,
                    171,
                    255
                ],
                [
                    255,
                    207,
                    174,
                    255
                ],
                [
                    255,
                    209,
                    176,
                    255
                ],
                [
                    255,
                    211,
                    179,
                    255
                ],
                [
                    255,
                    213,
                    182,
                    255
                ],
                [
                    255,
                    215,
                    185,
                    255
                ],
                [
                    255,
                    216,
                    188,
                    255
                ],
                [
                    255,
                    218,
                    191,
                    255
                ],
                [
                    255,
                    220,
                    194,
                    255
                ],
                [
                    255,
                    222,
                    197,
                    255
                ],
                [
                    255,
                    224,
                    200,
                    255
                ],
                [
                    255,
                    226,
                    203,
                    255
                ],
                [
                    255,
                    228,
                    206,
                    255
                ],
                [
                    255,
                    229,
                    210,
                    255
                ],
                [
                    255,
                    231,
                    213,
                    255
                ],
                [
                    255,
                    233,
                    216,
                    255
                ],
                [
                    255,
                    235,
                    219,
                    255
                ],
                [
                    255,
                    237,
                    223,
                    255
                ],
                [
                    255,
                    239,
                    226,
                    255
                ],
                [
                    255,
                    240,
                    229,
                    255
                ],
                [
                    255,
                    242,
                    232,
                    255
                ],
                [
                    255,
                    244,
                    236,
                    255
                ],
                [
                    255,
                    246,
                    239,
                    255
                ],
                [
                    255,
                    248,
                    242,
                    255
                ],
                [
                    255,
                    250,
                    245,
                    255
                ],
                [
                    255,
                    251,
                    249,
                    255
                ],
                [
                    255,
                    253,
                    252,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ]
            ]
        },
        pet20Step: {
            name: "PET 20 Step",
            numColors: 256,
            colors: [
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    0,
                    0,
                    0,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    96,
                    0,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    80,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    48,
                    48,
                    112,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    80,
                    80,
                    128,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    96,
                    96,
                    176,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    112,
                    112,
                    192,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    128,
                    128,
                    224,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    96,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    48,
                    144,
                    48,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    80,
                    192,
                    80,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    64,
                    224,
                    64,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    224,
                    224,
                    80,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    208,
                    96,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    176,
                    64,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    208,
                    144,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    192,
                    96,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    176,
                    48,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    0,
                    0,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ],
                [
                    255,
                    255,
                    255,
                    255
                ]
            ]
        },
        gray: {
            name: "Gray",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ]
            }
        },
        jet: {
            name: "Jet",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .35,
                        0,
                        0
                    ],
                    [
                        .66,
                        1,
                        1
                    ],
                    [
                        .89,
                        1,
                        1
                    ],
                    [
                        1,
                        .5,
                        .5
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .125,
                        0,
                        0
                    ],
                    [
                        .375,
                        1,
                        1
                    ],
                    [
                        .64,
                        1,
                        1
                    ],
                    [
                        .91,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ],
                blue: [
                    [
                        0,
                        .5,
                        .5
                    ],
                    [
                        .11,
                        1,
                        1
                    ],
                    [
                        .34,
                        1,
                        1
                    ],
                    [
                        .65,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ]
            }
        },
        hsv: {
            name: "HSV",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        .15873,
                        1,
                        1
                    ],
                    [
                        .174603,
                        .96875,
                        .96875
                    ],
                    [
                        .333333,
                        .03125,
                        .03125
                    ],
                    [
                        .349206,
                        0,
                        0
                    ],
                    [
                        .666667,
                        0,
                        0
                    ],
                    [
                        .68254,
                        .03125,
                        .03125
                    ],
                    [
                        .84127,
                        .96875,
                        .96875
                    ],
                    [
                        .857143,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .15873,
                        .9375,
                        .9375
                    ],
                    [
                        .174603,
                        1,
                        1
                    ],
                    [
                        .507937,
                        1,
                        1
                    ],
                    [
                        .666667,
                        .0625,
                        .0625
                    ],
                    [
                        .68254,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .333333,
                        0,
                        0
                    ],
                    [
                        .349206,
                        .0625,
                        .0625
                    ],
                    [
                        .507937,
                        1,
                        1
                    ],
                    [
                        .84127,
                        1,
                        1
                    ],
                    [
                        .857143,
                        .9375,
                        .9375
                    ],
                    [
                        1,
                        .09375,
                        .09375
                    ]
                ]
            }
        },
        hot: {
            name: "Hot",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        .0416,
                        .0416
                    ],
                    [
                        .365079,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .365079,
                        0,
                        0
                    ],
                    [
                        .746032,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .746032,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ]
            }
        },
        cool: {
            name: "Cool",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ],
                blue: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ]
            }
        },
        spring: {
            name: "Spring",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ]
            }
        },
        summer: {
            name: "Summer",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        .5,
                        .5
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        .4,
                        .4
                    ],
                    [
                        1,
                        .4,
                        .4
                    ]
                ]
            }
        },
        autumn: {
            name: "Autumn",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ]
            }
        },
        winter: {
            name: "Winter",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        0,
                        0
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        1,
                        .5,
                        .5
                    ]
                ]
            }
        },
        bone: {
            name: "Bone",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .746032,
                        .652778,
                        .652778
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .365079,
                        .319444,
                        .319444
                    ],
                    [
                        .746032,
                        .777778,
                        .777778
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .365079,
                        .444444,
                        .444444
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ]
            }
        },
        copper: {
            name: "Copper",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .809524,
                        1,
                        1
                    ],
                    [
                        1,
                        1,
                        1
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        .7812,
                        .7812
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        1,
                        .4975,
                        .4975
                    ]
                ]
            }
        },
        spectral: {
            name: "Spectral",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .05,
                        .4667,
                        .4667
                    ],
                    [
                        .1,
                        .5333,
                        .5333
                    ],
                    [
                        .15,
                        0,
                        0
                    ],
                    [
                        .2,
                        0,
                        0
                    ],
                    [
                        .25,
                        0,
                        0
                    ],
                    [
                        .3,
                        0,
                        0
                    ],
                    [
                        .35,
                        0,
                        0
                    ],
                    [
                        .4,
                        0,
                        0
                    ],
                    [
                        .45,
                        0,
                        0
                    ],
                    [
                        .5,
                        0,
                        0
                    ],
                    [
                        .55,
                        0,
                        0
                    ],
                    [
                        .6,
                        0,
                        0
                    ],
                    [
                        .65,
                        .7333,
                        .7333
                    ],
                    [
                        .7,
                        .9333,
                        .9333
                    ],
                    [
                        .75,
                        1,
                        1
                    ],
                    [
                        .8,
                        1,
                        1
                    ],
                    [
                        .85,
                        1,
                        1
                    ],
                    [
                        .9,
                        .8667,
                        .8667
                    ],
                    [
                        .95,
                        .8,
                        .8
                    ],
                    [
                        1,
                        .8,
                        .8
                    ]
                ],
                green: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .05,
                        0,
                        0
                    ],
                    [
                        .1,
                        0,
                        0
                    ],
                    [
                        .15,
                        0,
                        0
                    ],
                    [
                        .2,
                        0,
                        0
                    ],
                    [
                        .25,
                        .4667,
                        .4667
                    ],
                    [
                        .3,
                        .6,
                        .6
                    ],
                    [
                        .35,
                        .6667,
                        .6667
                    ],
                    [
                        .4,
                        .6667,
                        .6667
                    ],
                    [
                        .45,
                        .6,
                        .6
                    ],
                    [
                        .5,
                        .7333,
                        .7333
                    ],
                    [
                        .55,
                        .8667,
                        .8667
                    ],
                    [
                        .6,
                        1,
                        1
                    ],
                    [
                        .65,
                        1,
                        1
                    ],
                    [
                        .7,
                        .9333,
                        .9333
                    ],
                    [
                        .75,
                        .8,
                        .8
                    ],
                    [
                        .8,
                        .6,
                        .6
                    ],
                    [
                        .85,
                        0,
                        0
                    ],
                    [
                        .9,
                        0,
                        0
                    ],
                    [
                        .95,
                        0,
                        0
                    ],
                    [
                        1,
                        .8,
                        .8
                    ]
                ],
                blue: [
                    [
                        0,
                        0,
                        0
                    ],
                    [
                        .05,
                        .5333,
                        .5333
                    ],
                    [
                        .1,
                        .6,
                        .6
                    ],
                    [
                        .15,
                        .6667,
                        .6667
                    ],
                    [
                        .2,
                        .8667,
                        .8667
                    ],
                    [
                        .25,
                        .8667,
                        .8667
                    ],
                    [
                        .3,
                        .8667,
                        .8667
                    ],
                    [
                        .35,
                        .6667,
                        .6667
                    ],
                    [
                        .4,
                        .5333,
                        .5333
                    ],
                    [
                        .45,
                        0,
                        0
                    ],
                    [
                        .5,
                        0,
                        0
                    ],
                    [
                        .55,
                        0,
                        0
                    ],
                    [
                        .6,
                        0,
                        0
                    ],
                    [
                        .65,
                        0,
                        0
                    ],
                    [
                        .7,
                        0,
                        0
                    ],
                    [
                        .75,
                        0,
                        0
                    ],
                    [
                        .8,
                        0,
                        0
                    ],
                    [
                        .85,
                        0,
                        0
                    ],
                    [
                        .9,
                        0,
                        0
                    ],
                    [
                        .95,
                        0,
                        0
                    ],
                    [
                        1,
                        .8,
                        .8
                    ]
                ]
            }
        },
        coolwarm: {
            name: "CoolWarm",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        .2298057,
                        .2298057
                    ],
                    [
                        .03125,
                        .26623388,
                        .26623388
                    ],
                    [
                        .0625,
                        .30386891,
                        .30386891
                    ],
                    [
                        .09375,
                        .342804478,
                        .342804478
                    ],
                    [
                        .125,
                        .38301334,
                        .38301334
                    ],
                    [
                        .15625,
                        .424369608,
                        .424369608
                    ],
                    [
                        .1875,
                        .46666708,
                        .46666708
                    ],
                    [
                        .21875,
                        .509635204,
                        .509635204
                    ],
                    [
                        .25,
                        .552953156,
                        .552953156
                    ],
                    [
                        .28125,
                        .596262162,
                        .596262162
                    ],
                    [
                        .3125,
                        .639176211,
                        .639176211
                    ],
                    [
                        .34375,
                        .681291281,
                        .681291281
                    ],
                    [
                        .375,
                        .722193294,
                        .722193294
                    ],
                    [
                        .40625,
                        .761464949,
                        .761464949
                    ],
                    [
                        .4375,
                        .798691636,
                        .798691636
                    ],
                    [
                        .46875,
                        .833466556,
                        .833466556
                    ],
                    [
                        .5,
                        .865395197,
                        .865395197
                    ],
                    [
                        .53125,
                        .897787179,
                        .897787179
                    ],
                    [
                        .5625,
                        .924127593,
                        .924127593
                    ],
                    [
                        .59375,
                        .944468518,
                        .944468518
                    ],
                    [
                        .625,
                        .958852946,
                        .958852946
                    ],
                    [
                        .65625,
                        .96732803,
                        .96732803
                    ],
                    [
                        .6875,
                        .969954137,
                        .969954137
                    ],
                    [
                        .71875,
                        .966811177,
                        .966811177
                    ],
                    [
                        .75,
                        .958003065,
                        .958003065
                    ],
                    [
                        .78125,
                        .943660866,
                        .943660866
                    ],
                    [
                        .8125,
                        .923944917,
                        .923944917
                    ],
                    [
                        .84375,
                        .89904617,
                        .89904617
                    ],
                    [
                        .875,
                        .869186849,
                        .869186849
                    ],
                    [
                        .90625,
                        .834620542,
                        .834620542
                    ],
                    [
                        .9375,
                        .795631745,
                        .795631745
                    ],
                    [
                        .96875,
                        .752534934,
                        .752534934
                    ],
                    [
                        1,
                        .705673158,
                        .705673158
                    ]
                ],
                green: [
                    [
                        0,
                        .298717966,
                        .298717966
                    ],
                    [
                        .03125,
                        .353094838,
                        .353094838
                    ],
                    [
                        .0625,
                        .406535296,
                        .406535296
                    ],
                    [
                        .09375,
                        .458757618,
                        .458757618
                    ],
                    [
                        .125,
                        .50941904,
                        .50941904
                    ],
                    [
                        .15625,
                        .558148092,
                        .558148092
                    ],
                    [
                        .1875,
                        .604562568,
                        .604562568
                    ],
                    [
                        .21875,
                        .648280772,
                        .648280772
                    ],
                    [
                        .25,
                        .688929332,
                        .688929332
                    ],
                    [
                        .28125,
                        .726149107,
                        .726149107
                    ],
                    [
                        .3125,
                        .759599947,
                        .759599947
                    ],
                    [
                        .34375,
                        .788964712,
                        .788964712
                    ],
                    [
                        .375,
                        .813952739,
                        .813952739
                    ],
                    [
                        .40625,
                        .834302879,
                        .834302879
                    ],
                    [
                        .4375,
                        .849786142,
                        .849786142
                    ],
                    [
                        .46875,
                        .860207984,
                        .860207984
                    ],
                    [
                        .5,
                        .86541021,
                        .86541021
                    ],
                    [
                        .53125,
                        .848937047,
                        .848937047
                    ],
                    [
                        .5625,
                        .827384882,
                        .827384882
                    ],
                    [
                        .59375,
                        .800927443,
                        .800927443
                    ],
                    [
                        .625,
                        .769767752,
                        .769767752
                    ],
                    [
                        .65625,
                        .734132809,
                        .734132809
                    ],
                    [
                        .6875,
                        .694266682,
                        .694266682
                    ],
                    [
                        .71875,
                        .650421156,
                        .650421156
                    ],
                    [
                        .75,
                        .602842431,
                        .602842431
                    ],
                    [
                        .78125,
                        .551750968,
                        .551750968
                    ],
                    [
                        .8125,
                        .49730856,
                        .49730856
                    ],
                    [
                        .84375,
                        .439559467,
                        .439559467
                    ],
                    [
                        .875,
                        .378313092,
                        .378313092
                    ],
                    [
                        .90625,
                        .312874446,
                        .312874446
                    ],
                    [
                        .9375,
                        .24128379,
                        .24128379
                    ],
                    [
                        .96875,
                        .157246067,
                        .157246067
                    ],
                    [
                        1,
                        .01555616,
                        .01555616
                    ]
                ],
                blue: [
                    [
                        0,
                        .753683153,
                        .753683153
                    ],
                    [
                        .03125,
                        .801466763,
                        .801466763
                    ],
                    [
                        .0625,
                        .84495867,
                        .84495867
                    ],
                    [
                        .09375,
                        .883725899,
                        .883725899
                    ],
                    [
                        .125,
                        .917387822,
                        .917387822
                    ],
                    [
                        .15625,
                        .945619588,
                        .945619588
                    ],
                    [
                        .1875,
                        .968154911,
                        .968154911
                    ],
                    [
                        .21875,
                        .98478814,
                        .98478814
                    ],
                    [
                        .25,
                        .995375608,
                        .995375608
                    ],
                    [
                        .28125,
                        .999836203,
                        .999836203
                    ],
                    [
                        .3125,
                        .998151185,
                        .998151185
                    ],
                    [
                        .34375,
                        .990363227,
                        .990363227
                    ],
                    [
                        .375,
                        .976574709,
                        .976574709
                    ],
                    [
                        .40625,
                        .956945269,
                        .956945269
                    ],
                    [
                        .4375,
                        .931688648,
                        .931688648
                    ],
                    [
                        .46875,
                        .901068838,
                        .901068838
                    ],
                    [
                        .5,
                        .865395561,
                        .865395561
                    ],
                    [
                        .53125,
                        .820880546,
                        .820880546
                    ],
                    [
                        .5625,
                        .774508472,
                        .774508472
                    ],
                    [
                        .59375,
                        .726736146,
                        .726736146
                    ],
                    [
                        .625,
                        .678007945,
                        .678007945
                    ],
                    [
                        .65625,
                        .628751763,
                        .628751763
                    ],
                    [
                        .6875,
                        .579375448,
                        .579375448
                    ],
                    [
                        .71875,
                        .530263762,
                        .530263762
                    ],
                    [
                        .75,
                        .481775914,
                        .481775914
                    ],
                    [
                        .78125,
                        .434243684,
                        .434243684
                    ],
                    [
                        .8125,
                        .387970225,
                        .387970225
                    ],
                    [
                        .84375,
                        .343229596,
                        .343229596
                    ],
                    [
                        .875,
                        .300267182,
                        .300267182
                    ],
                    [
                        .90625,
                        .259301199,
                        .259301199
                    ],
                    [
                        .9375,
                        .220525627,
                        .220525627
                    ],
                    [
                        .96875,
                        .184115123,
                        .184115123
                    ],
                    [
                        1,
                        .150232812,
                        .150232812
                    ]
                ]
            }
        },
        blues: {
            name: "Blues",
            numColors: 256,
            gamma: 1,
            segmentedData: {
                red: [
                    [
                        0,
                        .9686274528503418,
                        .9686274528503418
                    ],
                    [
                        .125,
                        .8705882430076599,
                        .8705882430076599
                    ],
                    [
                        .25,
                        .7764706015586853,
                        .7764706015586853
                    ],
                    [
                        .375,
                        .6196078658103943,
                        .6196078658103943
                    ],
                    [
                        .5,
                        .41960784792900085,
                        .41960784792900085
                    ],
                    [
                        .625,
                        .25882354378700256,
                        .25882354378700256
                    ],
                    [
                        .75,
                        .12941177189350128,
                        .12941177189350128
                    ],
                    [
                        .875,
                        .0313725508749485,
                        .0313725508749485
                    ],
                    [
                        1,
                        .0313725508749485,
                        .0313725508749485
                    ]
                ],
                green: [
                    [
                        0,
                        .9843137264251709,
                        .9843137264251709
                    ],
                    [
                        .125,
                        .9215686321258545,
                        .9215686321258545
                    ],
                    [
                        .25,
                        .8588235378265381,
                        .8588235378265381
                    ],
                    [
                        .375,
                        .7921568751335144,
                        .7921568751335144
                    ],
                    [
                        .5,
                        .6823529601097107,
                        .6823529601097107
                    ],
                    [
                        .625,
                        .572549045085907,
                        .572549045085907
                    ],
                    [
                        .75,
                        .4431372582912445,
                        .4431372582912445
                    ],
                    [
                        .875,
                        .3176470696926117,
                        .3176470696926117
                    ],
                    [
                        1,
                        .1882352977991104,
                        .1882352977991104
                    ]
                ],
                blue: [
                    [
                        0,
                        1,
                        1
                    ],
                    [
                        .125,
                        .9686274528503418,
                        .9686274528503418
                    ],
                    [
                        .25,
                        .9372549057006836,
                        .9372549057006836
                    ],
                    [
                        .375,
                        .8823529481887817,
                        .8823529481887817
                    ],
                    [
                        .5,
                        .8392156958580017,
                        .8392156958580017
                    ],
                    [
                        .625,
                        .7764706015586853,
                        .7764706015586853
                    ],
                    [
                        .75,
                        .7098039388656616,
                        .7098039388656616
                    ],
                    [
                        .875,
                        .6117647290229797,
                        .6117647290229797
                    ],
                    [
                        1,
                        .41960784792900085,
                        .41960784792900085
                    ]
                ]
            }
        }
    };
    Er = {
        MINIMUM_SLAB_THICKNESS: .05,
        MAXIMUM_RAY_DISTANCE: 1e6
    };
    Object.freeze(Er);
    const Jo = .001;
    function $7(t) {
        const e = Object.getOwnPropertyNames(t);
        for (const n of e){
            const r = t[n];
            r && typeof r == "object" && $7(r);
        }
        return Object.freeze(t);
    }
    let eb, Il, z7, tb, Ff, Rd;
    eb = {
        axial: {
            viewPlaneNormal: [
                0,
                0,
                -1
            ],
            viewUp: [
                0,
                -1,
                0
            ],
            viewRight: [
                1,
                0,
                0
            ]
        },
        sagittal: {
            viewPlaneNormal: [
                1,
                0,
                0
            ],
            viewUp: [
                0,
                0,
                1
            ],
            viewRight: [
                0,
                1,
                0
            ]
        },
        coronal: {
            viewPlaneNormal: [
                0,
                -1,
                0
            ],
            viewUp: [
                0,
                0,
                1
            ],
            viewRight: [
                1,
                0,
                0
            ]
        }
    };
    Il = $7(eb);
    z7 = [
        {
            name: "CT-AAA",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "12 -3024 0 143.556 0 166.222 0.686275 214.389 0.696078 419.736 0.833333 3071 0.803922",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "24 -3024 0 0 0 143.556 0.615686 0.356863 0.184314 166.222 0.882353 0.603922 0.290196 214.389 1 1 1 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-AAA2",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "16 -3024 0 129.542 0 145.244 0.166667 157.02 0.5 169.918 0.627451 395.575 0.8125 1578.73 0.8125 3071 0.8125",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "32 -3024 0 0 0 129.542 0.54902 0.25098 0.14902 145.244 0.6 0.627451 0.843137 157.02 0.890196 0.47451 0.6 169.918 0.992157 0.870588 0.392157 395.575 1 0.886275 0.658824 1578.73 1 0.829256 0.957922 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Bone",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "8 -3024 0 -16.4458 0 641.385 0.715686 3071 0.705882",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "16 -3024 0 0 0 -16.4458 0.729412 0.254902 0.301961 641.385 0.905882 0.815686 0.552941 3071 1 1 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Bones",
            gradientOpacity: "4 0 1 985.12 1",
            specularPower: "1",
            scalarOpacity: "8 -1000 0 152.19 0 278.93 0.190476 952 0.2",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "20 -1000 0.3 0.3 1 -488 0.3 1 0.3 463.28 1 0 0 659.15 1 0.912535 0.0374849 953 1 0.3 0.3",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Cardiac",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "12 -3024 0 -77.6875 0 94.9518 0.285714 179.052 0.553571 260.439 0.848214 3071 0.875",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "24 -3024 0 0 0 -77.6875 0.54902 0.25098 0.14902 94.9518 0.882353 0.603922 0.290196 179.052 1 0.937033 0.954531 260.439 0.615686 0 0 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Cardiac2",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "12 -3024 0 42.8964 0 163.488 0.428571 277.642 0.776786 1587 0.754902 3071 0.754902",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "24 -3024 0 0 0 42.8964 0.54902 0.25098 0.14902 163.488 0.917647 0.639216 0.0588235 277.642 1 0.878431 0.623529 1587 1 1 1 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Cardiac3",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "14 -3024 0 -86.9767 0 45.3791 0.169643 139.919 0.589286 347.907 0.607143 1224.16 0.607143 3071 0.616071",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "28 -3024 0 0 0 -86.9767 0 0.25098 1 45.3791 1 0 0 139.919 1 0.894893 0.894893 347.907 1 1 0.25098 1224.16 1 1 1 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Chest-Contrast-Enhanced",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "10 -3024 0 67.0106 0 251.105 0.446429 439.291 0.625 3071 0.616071",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "20 -3024 0 0 0 67.0106 0.54902 0.25098 0.14902 251.105 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Chest-Vessels",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "10 -3024 0 -1278.35 0 22.8277 0.428571 439.291 0.625 3071 0.616071",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "20 -3024 0 0 0 -1278.35 0.54902 0.25098 0.14902 22.8277 0.882353 0.603922 0.290196 439.291 1 0.937033 0.954531 3071 0.827451 0.658824 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Coronary-Arteries",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "12 -2048 0 136.47 0 159.215 0.258929 318.43 0.571429 478.693 0.776786 3661 1",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "24 -2048 0 0 0 136.47 0 0 0 159.215 0.159804 0.159804 0.159804 318.43 0.764706 0.764706 0.764706 478.693 1 1 1 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Coronary-Arteries-2",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "14 -2048 0 142.677 0 145.016 0.116071 192.174 0.5625 217.24 0.776786 384.347 0.830357 3661 0.830357",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "28 -2048 0 0 0 142.677 0 0 0 145.016 0.615686 0 0.0156863 192.174 0.909804 0.454902 0 217.24 0.972549 0.807843 0.611765 384.347 0.909804 0.909804 1 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Coronary-Arteries-3",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "14 -2048 0 128.643 0 129.982 0.0982143 173.636 0.669643 255.884 0.857143 584.878 0.866071 3661 1",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "28 -2048 0 0 0 128.643 0 0 0 129.982 0.615686 0 0.0156863 173.636 0.909804 0.454902 0 255.884 0.886275 0.886275 0.886275 584.878 0.968627 0.968627 0.968627 3661 1 1 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Cropped-Volume-Bone",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "10 -2048 0 -451 0 -450 1 1050 1 3661 1",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "20 -2048 0 0 0 -451 0 0 0 -450 0.0556356 0.0556356 0.0556356 1050 1 1 1 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Fat",
            gradientOpacity: "6 0 1 985.12 1 988 1",
            specularPower: "1",
            scalarOpacity: "14 -1000 0 -100 0 -99 0.15 -60 0.15 -59 0 101.2 0 952 0",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "36 -1000 0.3 0.3 1 -497.5 0.3 1 0.3 -99 0 0 1 -76.946 0 1 0 -65.481 0.835431 0.888889 0.0165387 83.89 1 0 0 463.28 1 0 0 659.15 1 0.912535 0.0374849 2952 1 0.300267 0.299886",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Liver-Vasculature",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "14 -2048 0 149.113 0 157.884 0.482143 339.96 0.660714 388.526 0.830357 1197.95 0.839286 3661 0.848214",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "28 -2048 0 0 0 149.113 0 0 0 157.884 0.501961 0.25098 0 339.96 0.695386 0.59603 0.36886 388.526 0.854902 0.85098 0.827451 1197.95 1 1 1 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Lung",
            gradientOpacity: "6 0 1 985.12 1 988 1",
            specularPower: "1",
            scalarOpacity: "12 -1000 0 -600 0 -599 0.15 -400 0.15 -399 0 2952 0",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "24 -1000 0.3 0.3 1 -600 0 0 1 -530 0.134704 0.781726 0.0724558 -460 0.929244 1 0.109473 -400 0.888889 0.254949 0.0240258 2952 1 0.3 0.3",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-MIP",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "8 -3024 0 -637.62 0 700 1 3071 1",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "16 -3024 0 0 0 -637.62 1 1 1 700 1 1 1 3071 1 1 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Muscle",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "10 -3024 0 -155.407 0 217.641 0.676471 419.736 0.833333 3071 0.803922",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "20 -3024 0 0 0 -155.407 0.54902 0.25098 0.14902 217.641 0.882353 0.603922 0.290196 419.736 1 0.937033 0.954531 3071 0.827451 0.658824 1",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "CT-Pulmonary-Arteries",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "14 -2048 0 -568.625 0 -364.081 0.0714286 -244.813 0.401786 18.2775 0.607143 447.798 0.830357 3592.73 0.839286",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "28 -2048 0 0 0 -568.625 0 0 0 -364.081 0.396078 0.301961 0.180392 -244.813 0.611765 0.352941 0.0705882 18.2775 0.843137 0.0156863 0.156863 447.798 0.752941 0.752941 0.752941 3592.73 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Soft-Tissue",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "10 -2048 0 -167.01 0 -160 1 240 1 3661 1",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "20 -2048 0 0 0 -167.01 0 0 0 -160 0.0556356 0.0556356 0.0556356 240 1 1 1 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "CT-Air",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "10",
            scalarOpacity: "8 -3024 0.705882 -900.0 0.715686 -500.0 0 3071 0",
            specular: "0.2",
            shade: "1",
            ambient: "0.1",
            colorTransfer: "16 -3024 1 1 1 -900.0 0.2 1.0 1.0 -500.0 0.3 0.3 1.0 3071 0 0 0 ",
            diffuse: "0.9",
            interpolation: "1"
        },
        {
            name: "MR-Angio",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "12 -2048 0 151.354 0 158.279 0.4375 190.112 0.580357 200.873 0.732143 3661 0.741071",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "24 -2048 0 0 0 151.354 0 0 0 158.279 0.74902 0.376471 0 190.112 1 0.866667 0.733333 200.873 0.937255 0.937255 0.937255 3661 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "MR-Default",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "12 0 0 20 0 40 0.15 120 0.3 220 0.375 1024 0.5",
            specular: "0",
            shade: "1",
            ambient: "0.2",
            colorTransfer: "24 0 0 0 0 20 0.168627 0 0 40 0.403922 0.145098 0.0784314 120 0.780392 0.607843 0.380392 220 0.847059 0.835294 0.788235 1024 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "MR-MIP",
            gradientOpacity: "4 0 1 255 1",
            specularPower: "1",
            scalarOpacity: "8 0 0 98.3725 0 416.637 1 2800 1",
            specular: "0",
            shade: "0",
            ambient: "0.2",
            colorTransfer: "16 0 1 1 1 98.3725 1 1 1 416.637 1 1 1 2800 1 1 1",
            diffuse: "1",
            interpolation: "1"
        },
        {
            name: "MR-T2-Brain",
            gradientOpacity: "4 0 1 160.25 1",
            specularPower: "40",
            scalarOpacity: "10 0 0 36.05 0 218.302 0.171429 412.406 1 641 1",
            specular: "0.5",
            shade: "1",
            ambient: "0.3",
            colorTransfer: "16 0 0 0 0 98.7223 0.956863 0.839216 0.192157 412.406 0 0.592157 0.807843 641 1 1 1",
            diffuse: "0.6",
            interpolation: "1"
        },
        {
            name: "DTI-FA-Brain",
            gradientOpacity: "4 0 1 0.9950 1",
            specularPower: "40",
            scalarOpacity: "16 0 0 0 0 0.3501 0.0158 0.49379 0.7619 0.6419 1 0.9920 1 0.9950 0 0.9950 0",
            specular: "0.5",
            shade: "1",
            ambient: "0.3",
            colorTransfer: "28 0 1 0 0 0 1 0 0 0.24974 0.4941 1 0 0.49949 0 0.9882 1 0.7492 0.51764 0 1 0.9950 1 0 0 0.9950 1 0 0",
            diffuse: "0.9",
            interpolation: "1"
        }
    ];
    tb = {
        slicer3D: [
            160 / 255,
            164 / 255,
            217 / 255
        ]
    };
    u3 = Object.freeze(Object.defineProperty({
        __proto__: null,
        BACKGROUND_COLORS: tb,
        CPU_COLORMAPS: dv,
        EPSILON: Jo,
        MPR_CAMERA_VALUES: Il,
        RENDERING_DEFAULTS: Er,
        VIEWPORT_PRESETS: z7
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    Ff = {};
    Rd = {
        get: (t)=>Ff[t],
        set: (t)=>{
            const e = t.id;
            Ff[e] = t;
        },
        delete: (t)=>delete Ff[t],
        getAll: ()=>{
            const e = Object.keys(Ff).map((n)=>Ff[n]);
            return e.sort((n, r)=>n.id[0] === "_" && r.id[0] !== "_" ? 1 : n.id[0] !== "_" && r.id[0] === "_" ? -1 : 0), e;
        }
    };
    ws = function(t) {
        return Rd.get(t);
    };
    Es = function() {
        return Rd.getAll();
    };
    const bh = (t)=>t && typeof t == "object" && Object.prototype.toString.call(t) !== "[object RegExp]" && Object.prototype.toString.call(t) !== "[object Date]", nb = (t)=>Array.isArray(t) ? [] : {}, Od = (t, e)=>e && e.clone === !0 && bh(t) ? Ma(nb(t), t, e) : t, U6 = (t, e, n)=>{
        const r = t.slice();
        return e.forEach(function(i, a) {
            typeof r[a] > "u" ? r[a] = Od(i, n) : bh(i) ? r[a] = Ma(t[a], i, n) : t.indexOf(i) === -1 && (r[a] = Od(i, n));
        }), r;
    }, rb = (t, e, n)=>{
        const r = {};
        return bh(t) && Object.keys(t).forEach(function(i) {
            r[i] = Od(t[i], n);
        }), Object.keys(e).forEach(function(i) {
            !bh(e[i]) || !t[i] ? r[i] = Od(e[i], n) : r[i] = Ma(t[i], e[i], n);
        }), r;
    }, Ma = (t = {}, e = {}, n = void 0)=>{
        const r = Array.isArray(e), a = (n || {
            arrayMerge: U6
        }).arrayMerge || U6;
        return r ? Array.isArray(t) ? a(t, e, n) : Od(e, n) : rb(t, e, n);
    };
    const j7 = Symbol("Comlink.proxy"), ib = Symbol("Comlink.endpoint"), H7 = Symbol("Comlink.releaseProxy"), Km = Symbol("Comlink.finalizer"), K1 = Symbol("Comlink.thrown"), K7 = (t)=>typeof t == "object" && t !== null || typeof t == "function", ab = {
        canHandle: (t)=>K7(t) && t[j7],
        serialize (t) {
            const { port1: e, port2: n } = new MessageChannel;
            return f3(t, e), [
                n,
                [
                    n
                ]
            ];
        },
        deserialize (t) {
            return t.start(), gv(t);
        }
    }, ob = {
        canHandle: (t)=>K7(t) && K1 in t,
        serialize ({ value: t }) {
            let e;
            return t instanceof Error ? e = {
                isError: !0,
                value: {
                    message: t.message,
                    name: t.name,
                    stack: t.stack
                }
            } : e = {
                isError: !1,
                value: t
            }, [
                e,
                []
            ];
        },
        deserialize (t) {
            throw t.isError ? Object.assign(new Error(t.value.message), t.value) : t.value;
        }
    }, q7 = new Map([
        [
            "proxy",
            ab
        ],
        [
            "throw",
            ob
        ]
    ]);
    function sb(t, e) {
        for (const n of t)if (e === n || n === "*" || n instanceof RegExp && n.test(e)) return !0;
        return !1;
    }
    function f3(t, e = globalThis, n = [
        "*"
    ]) {
        e.addEventListener("message", function r(i) {
            if (!i || !i.data) return;
            if (!sb(n, i.origin)) {
                console.warn(`Invalid origin '${i.origin}' for comlink proxy`);
                return;
            }
            const { id: a, type: o, path: s } = Object.assign({
                path: []
            }, i.data), c = (i.data.argumentList || []).map(D0);
            let l;
            try {
                const f = s.slice(0, -1).reduce((g, h)=>g[h], t), u = s.reduce((g, h)=>g[h], t);
                switch(o){
                    case "GET":
                        l = u;
                        break;
                    case "SET":
                        f[s.slice(-1)[0]] = D0(i.data.value), l = !0;
                        break;
                    case "APPLY":
                        l = u.apply(f, c);
                        break;
                    case "CONSTRUCT":
                        {
                            const g = new u(...c);
                            l = J7(g);
                        }
                        break;
                    case "ENDPOINT":
                        {
                            const { port1: g, port2: h } = new MessageChannel;
                            f3(t, h), l = db(g, [
                                g
                            ]);
                        }
                        break;
                    case "RELEASE":
                        l = void 0;
                        break;
                    default:
                        return;
                }
            } catch (f) {
                l = {
                    value: f,
                    [K1]: 0
                };
            }
            Promise.resolve(l).catch((f)=>({
                    value: f,
                    [K1]: 0
                })).then((f)=>{
                const [u, g] = Vh(f);
                e.postMessage(Object.assign(Object.assign({}, u), {
                    id: a
                }), g), o === "RELEASE" && (e.removeEventListener("message", r), X7(e), Km in t && typeof t[Km] == "function" && t[Km]());
            }).catch((f)=>{
                const [u, g] = Vh({
                    value: new TypeError("Unserializable return value"),
                    [K1]: 0
                });
                e.postMessage(Object.assign(Object.assign({}, u), {
                    id: a
                }), g);
            });
        }), e.start && e.start();
    }
    function cb(t) {
        return t.constructor.name === "MessagePort";
    }
    function X7(t) {
        cb(t) && t.close();
    }
    function gv(t, e) {
        const n = new Map;
        return t.addEventListener("message", function(i) {
            const { data: a } = i;
            if (!a || !a.id) return;
            const o = n.get(a.id);
            if (o) try {
                o(a);
            } finally{
                n.delete(a.id);
            }
        }), hv(t, n, [], e);
    }
    function f1(t) {
        if (t) throw new Error("Proxy has been released and is not useable");
    }
    function Y7(t) {
        return Du(t, new Map, {
            type: "RELEASE"
        }).then(()=>{
            X7(t);
        });
    }
    const Lh = new WeakMap, Ph = "FinalizationRegistry" in globalThis && new FinalizationRegistry((t)=>{
        const e = (Lh.get(t) || 0) - 1;
        Lh.set(t, e), e === 0 && Y7(t);
    });
    function lb(t, e) {
        const n = (Lh.get(e) || 0) + 1;
        Lh.set(e, n), Ph && Ph.register(t, e, t);
    }
    function ub(t) {
        Ph && Ph.unregister(t);
    }
    function hv(t, e, n = [], r = function() {}) {
        let i = !1;
        const a = new Proxy(r, {
            get (o, s) {
                if (f1(i), s === H7) return ()=>{
                    ub(a), Y7(t), e.clear(), i = !0;
                };
                if (s === "then") {
                    if (n.length === 0) return {
                        then: ()=>a
                    };
                    const c = Du(t, e, {
                        type: "GET",
                        path: n.map((l)=>l.toString())
                    }).then(D0);
                    return c.then.bind(c);
                }
                return hv(t, e, [
                    ...n,
                    s
                ]);
            },
            set (o, s, c) {
                f1(i);
                const [l, f] = Vh(c);
                return Du(t, e, {
                    type: "SET",
                    path: [
                        ...n,
                        s
                    ].map((u)=>u.toString()),
                    value: l
                }, f).then(D0);
            },
            apply (o, s, c) {
                f1(i);
                const l = n[n.length - 1];
                if (l === ib) return Du(t, e, {
                    type: "ENDPOINT"
                }).then(D0);
                if (l === "bind") return hv(t, e, n.slice(0, -1));
                const [f, u] = F6(c);
                return Du(t, e, {
                    type: "APPLY",
                    path: n.map((g)=>g.toString()),
                    argumentList: f
                }, u).then(D0);
            },
            construct (o, s) {
                f1(i);
                const [c, l] = F6(s);
                return Du(t, e, {
                    type: "CONSTRUCT",
                    path: n.map((f)=>f.toString()),
                    argumentList: c
                }, l).then(D0);
            }
        });
        return lb(a, t), a;
    }
    function fb(t) {
        return Array.prototype.concat.apply([], t);
    }
    function F6(t) {
        const e = t.map(Vh);
        return [
            e.map((n)=>n[0]),
            fb(e.map((n)=>n[1]))
        ];
    }
    const Z7 = new WeakMap;
    function db(t, e) {
        return Z7.set(t, e), t;
    }
    function J7(t) {
        return Object.assign(t, {
            [j7]: !0
        });
    }
    function Vh(t) {
        for (const [e, n] of q7)if (n.canHandle(t)) {
            const [r, i] = n.serialize(t);
            return [
                {
                    type: "HANDLER",
                    name: e,
                    value: r
                },
                i
            ];
        }
        return [
            {
                type: "RAW",
                value: t
            },
            Z7.get(t) || []
        ];
    }
    function D0(t) {
        switch(t.type){
            case "HANDLER":
                return q7.get(t.name).deserialize(t.value);
            case "RAW":
                return t.value;
        }
    }
    function Du(t, e, n, r) {
        return new Promise((i)=>{
            const a = gb();
            e.set(a, i), t.start && t.start(), t.postMessage(Object.assign({
                id: a
            }, n), r);
        });
    }
    function gb() {
        return new Array(4).fill(0).map(()=>Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
    }
    function Vn() {
        return typeof crypto.randomUUID == "function" ? crypto.randomUUID() : ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, (t)=>(t ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16));
    }
    class d3 {
        constructor(e){
            this.numRequests = {
                [Gt.Interaction]: 0,
                [Gt.Thumbnail]: 0,
                [Gt.Prefetch]: 0,
                [Gt.Compute]: 0
            }, this.id = e || Vn(), this.requestPool = {
                [Gt.Interaction]: {
                    0: []
                },
                [Gt.Thumbnail]: {
                    0: []
                },
                [Gt.Prefetch]: {
                    0: []
                },
                [Gt.Compute]: {
                    0: []
                }
            }, this.grabDelay = 5, this.awake = !1, this.numRequests = {
                [Gt.Interaction]: 0,
                [Gt.Thumbnail]: 0,
                [Gt.Prefetch]: 0,
                [Gt.Compute]: 0
            }, this.maxNumRequests = {
                [Gt.Interaction]: 6,
                [Gt.Thumbnail]: 6,
                [Gt.Prefetch]: 5,
                [Gt.Compute]: 1e3
            };
        }
        setMaxSimultaneousRequests(e, n) {
            this.maxNumRequests[e] = n;
        }
        getMaxSimultaneousRequests(e) {
            return this.maxNumRequests[e];
        }
        destroy() {
            this.timeoutHandle && window.clearTimeout(this.timeoutHandle);
        }
        addRequest(e, n, r, i = 0) {
            const a = {
                requestFn: e,
                type: n,
                additionalDetails: r
            };
            this.requestPool[n][i] === void 0 && (this.requestPool[n][i] = []), this.requestPool[n][i].push(a), this.startGrabbing();
        }
        filterRequests(e) {
            Object.keys(this.requestPool).forEach((n)=>{
                const r = this.requestPool[n];
                Object.keys(r).forEach((i)=>{
                    r[i] = r[i].filter((a)=>e(a));
                });
            });
        }
        clearRequestStack(e) {
            if (!this.requestPool[e]) throw new Error(`No category for the type ${e} found`);
            this.requestPool[e] = {
                0: []
            };
        }
        sendRequests(e) {
            const n = this.maxNumRequests[e] - this.numRequests[e];
            let r = 0;
            for(let i = 0; i < n; i++){
                const a = this.getNextRequest(e);
                if (a === null) return !1;
                if (a) {
                    this.numRequests[e]++, this.awake = !0;
                    let o;
                    try {
                        o = a.requestFn();
                    } catch (s) {
                        console.warn("sendRequest failed", s);
                    }
                    o?.finally ? o.finally(()=>{
                        this.numRequests[e]--, this.startAgain();
                    }) : (this.numRequests[e]--, r++);
                }
            }
            return r && this.startAgain(), !0;
        }
        getNextRequest(e) {
            const n = this.getSortedPriorityGroups(e);
            for (const r of n)if (this.requestPool[e][r].length) return this.requestPool[e][r].shift();
            return null;
        }
        startGrabbing() {
            const e = this.sendRequests(Gt.Interaction), n = this.sendRequests(Gt.Thumbnail), r = this.sendRequests(Gt.Prefetch), i = this.sendRequests(Gt.Compute);
            !e && !n && !r && !i && (this.awake = !1);
        }
        startAgain() {
            this.awake && (this.grabDelay !== void 0 ? this.timeoutHandle || (this.timeoutHandle = window.setTimeout(()=>{
                this.timeoutHandle = null, this.startGrabbing();
            }, this.grabDelay)) : this.startGrabbing());
        }
        getSortedPriorityGroups(e) {
            return Object.keys(this.requestPool[e]).map(Number).filter((r)=>this.requestPool[e][r].length).sort((r, i)=>r - i);
        }
        getRequestPool() {
            return this.requestPool;
        }
    }
    class Q7 {
        constructor(){
            this.workerRegistry = {}, this.workerPoolManager = new d3("webworker");
        }
        registerWorker(e, n, r = {}) {
            const { maxWorkerInstances: i = 1, overwrite: a = !1, autoTerminateOnIdle: o = {
                enabled: !1,
                idleTimeThreshold: 3e3
            } } = r;
            if (this.workerRegistry[e] && !a) {
                console.warn(`Worker type '${e}' is already registered...`);
                return;
            }
            a && this.workerRegistry[e]?.idleCheckIntervalId && clearInterval(this.workerRegistry[e].idleCheckIntervalId);
            const s = {
                workerFn: null,
                instances: [],
                loadCounters: [],
                lastActiveTime: [],
                nativeWorkers: [],
                autoTerminateOnIdle: o.enabled,
                idleCheckIntervalId: null,
                idleTimeThreshold: o.idleTimeThreshold
            };
            s.loadCounters = Array(i).fill(0), s.lastActiveTime = Array(i).fill(null);
            for(let c = 0; c < i; c++){
                const l = n();
                s.instances.push(gv(l)), s.nativeWorkers.push(l), s.workerFn = n;
            }
            this.workerRegistry[e] = s;
        }
        getNextWorkerAPI(e) {
            const n = this.workerRegistry[e];
            if (!n) return console.error(`Worker type '${e}' is not registered.`), null;
            const r = n.instances.filter((o)=>o !== null);
            let i = 0, a = n.loadCounters[0] || 0;
            for(let o = 1; o < r.length; o++){
                const s = n.loadCounters[o] || 0;
                s < a && (i = o, a = s);
            }
            if (n.instances[i] === null) {
                const o = n.workerFn();
                n.instances[i] = gv(o), n.nativeWorkers[i] = o;
            }
            return n.loadCounters[i] += 1, {
                api: n.instances[i],
                index: i
            };
        }
        executeTask(e, n, r = {}, { requestType: i = Gt.Compute, priority: a = 0, options: o = {}, callbacks: s = [] } = {}) {
            return new Promise((c, l)=>{
                const f = async ()=>{
                    const { api: u, index: g } = this.getNextWorkerAPI(e);
                    if (!u) {
                        const h = new Error(`No available worker instance for '${e}'`);
                        console.error(h), l(h);
                        return;
                    }
                    try {
                        let h = [];
                        s.length && (h = s.map((y)=>J7(y)));
                        const v = this.workerRegistry[e];
                        v.processing = !0;
                        const m = await u[n](r, ...h);
                        v.processing = !1, v.lastActiveTime[g] = Date.now(), v.autoTerminateOnIdle && !v.idleCheckIntervalId && v.idleTimeThreshold && (v.idleCheckIntervalId = setInterval(()=>{
                            this.terminateIdleWorkers(e, v.idleTimeThreshold);
                        }, v.idleTimeThreshold)), c(m);
                    } catch (h) {
                        console.error(`Error executing method '${n}' on worker '${e}':`, h), l(h);
                    } finally{
                        this.workerRegistry[e].loadCounters[g]--;
                    }
                };
                this.workerPoolManager.addRequest(f, i, o, a);
            });
        }
        terminateIdleWorkers(e, n) {
            const r = this.workerRegistry[e];
            if (r.processing) return;
            const i = Date.now();
            r.instances.forEach((a, o)=>{
                const s = r.lastActiveTime[o], c = s !== null && r.loadCounters[o] > 0, l = i - s;
                !c && l > n && this.terminateWorkerInstance(e, o);
            });
        }
        terminate(e) {
            const n = this.workerRegistry[e];
            if (!n) {
                console.error(`Worker type '${e}' is not registered.`);
                return;
            }
            n.instances.forEach((r, i)=>{
                this.terminateWorkerInstance(e, i);
            });
        }
        terminateWorkerInstance(e, n) {
            const r = this.workerRegistry[e], i = r.instances[n];
            i !== null && (i[H7](), r.nativeWorkers[n].terminate(), r.instances[n] = null, r.lastActiveTime[n] = null);
        }
    }
    const qm = 4, hb = 5, pb = 1, B6 = [
        1,
        1
    ];
    function G6({ ext: t, filterType: e, texData: n, internalFormat: r, glDataType: i }) {
        try {
            const a = document.createElement("canvas");
            a.width = qm, a.height = qm;
            const o = a.getContext("webgl2");
            if (!o) return !1;
            const s = `#version 300 es
    void main() {
      gl_PointSize = ${qm.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `, c = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
            let l;
            if (t && (l = o.getExtension(t), !l)) return !1;
            const f = o.createShader(o.VERTEX_SHADER);
            if (o.shaderSource(f, s), o.compileShader(f), !o.getShaderParameter(f, o.COMPILE_STATUS)) return !1;
            const u = o.createShader(o.FRAGMENT_SHADER);
            if (o.shaderSource(u, c), o.compileShader(u), !o.getShaderParameter(u, o.COMPILE_STATUS)) return !1;
            const g = o.createProgram();
            if (o.attachShader(g, f), o.attachShader(g, u), o.linkProgram(g), !o.getProgramParameter(g, o.LINK_STATUS)) return !1;
            const h = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, h), o.texImage2D(o.TEXTURE_2D, 0, r(o, l), hb, pb, 0, o.RED, i(o, l), n);
            const v = e === "LINEAR" ? o.LINEAR : o.NEAREST;
            o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, v), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, v), o.useProgram(g), o.drawArrays(o.POINTS, 0, 1);
            const m = new Uint8Array(4);
            o.readPixels(B6[0], B6[1], 1, 1, o.RGBA, o.UNSIGNED_BYTE, m);
            const [y, C, T] = m, x = o.getExtension("WEBGL_lose_context");
            return x && x.loseContext(), y === C && C === T && y !== 0;
        } catch  {
            return !1;
        }
    }
    function mb() {
        const t = new Int16Array([
            32767,
            2e3,
            3e3,
            4e3,
            5e3,
            16784,
            7e3,
            8e3,
            9e3,
            32767
        ]);
        return {
            norm16: G6({
                ext: "EXT_texture_norm16",
                filterType: "NEAREST",
                texData: t,
                internalFormat: (e, n)=>n.R16_SNORM_EXT,
                glDataType: (e)=>e.SHORT
            }),
            norm16Linear: G6({
                ext: "EXT_texture_norm16",
                filterType: "LINEAR",
                texData: t,
                internalFormat: (e, n)=>n.R16_SNORM_EXT,
                glDataType: (e)=>e.SHORT
            })
        };
    }
    let Ml = !1;
    const pv = {
        gpuTier: {
            tier: 2
        },
        isMobile: !1,
        rendering: {
            useCPURendering: !1,
            preferSizeOverAccuracy: !1,
            strictZSpacingForVolumeViewport: !0,
            renderingEngineMode: k0.ContextPool,
            webGlContextCount: 7
        },
        peerImport: (t)=>null
    };
    let vo = {
        ...pv,
        rendering: {
            ...pv.rendering
        }
    }, dd = null, eT = !1;
    function vb() {
        const t = document.createElement("canvas");
        return t.getContext("webgl2") || t.getContext("webgl") || t.getContext("experimental-webgl");
    }
    function tT() {
        const t = vb();
        return t instanceof WebGLRenderingContext || t instanceof WebGL2RenderingContext;
    }
    function yb() {
        const t = mb();
        return t.norm16 && t.norm16Linear;
    }
    function nT() {
        return /iPad|iPhone|iPod/.test(navigator.platform) ? !0 : navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && navigator.platform.includes("MacIntel");
    }
    Cb = function(t = vo) {
        return Ml || (eT = yb(), vo = Ma(pv, t), vo.isMobile && (vo.rendering.webGlContextCount = 1), nT() && (t.rendering?.preferSizeOverAccuracy ? vo.rendering.preferSizeOverAccuracy = !0 : console.log("norm16 texture not supported, you can turn on the preferSizeOverAccuracy flag to use native data type, but be aware of the inaccuracy of the rendering in high bits")), tT() ? console.log("CornerstoneRender: using GPU rendering") : (console.log("CornerstoneRender: GPU not detected, using CPU rendering"), vo.rendering.useCPURendering = !0), Ml = !0, dd || (dd = new Q7), Ml);
    };
    function wb() {
        return eT;
    }
    kae = function(t, e = !0) {
        vo.rendering.useCPURendering = t, Ml = !0, e && Dp();
    };
    Uae = function(t) {
        vo.rendering.preferSizeOverAccuracy = t, Ml = !0, Dp();
    };
    g3 = function() {
        return !nT();
    };
    Fae = function() {
        vo.rendering.useCPURendering = !tT(), Dp();
    };
    gd = function() {
        return vo.rendering.useCPURendering;
    };
    Tb = function() {
        return Ml;
    };
    Bae = function() {
        Ml = !1;
    };
    tf = function() {
        return vo;
    };
    Gae = function(t) {
        vo = t, Dp();
    };
    function Dp() {
        Es().forEach((t)=>{
            t.getViewports().forEach((e)=>{
                e.updateRenderingPipeline();
            });
        });
    }
    rT = function() {
        return dd || (dd = new Q7), dd;
    };
    xb = async function(t) {
        return vo.peerImport(t);
    };
    class Sb {
        constructor(){
            this.listeners = {}, this.debouncedListeners = {};
        }
        reset() {
            this.listeners = {}, this.debouncedListeners = {};
        }
        addEventListenerOnce(e, n) {
            const r = (i)=>{
                this.removeEventListener(e, r), n.call(this, i);
            };
            this.addEventListener(e, r);
        }
        addEventListener(e, n) {
            this.listeners[e] || (this.listeners[e] = []), this.listeners[e].indexOf(n) === -1 && this.listeners[e].push(n);
        }
        addEventListenerDebounced(e, n, r) {
            this.debouncedListeners[e] = this.debouncedListeners[e] || {};
            const i = this.debouncedListeners[e];
            if (!i[n]) {
                const a = (o)=>{
                    i[n] && clearTimeout(i[n].timeoutId), i[n].timeoutId = setTimeout(()=>{
                        n.call(this, o);
                    }, r);
                };
                i[n] = {
                    original: n,
                    handle: a,
                    timeoutId: null
                }, this.addEventListener(e, a);
            }
        }
        removeEventListenerDebounced(e, n) {
            if (this.debouncedListeners[e]?.[n]) {
                const r = this.debouncedListeners[e][n];
                this.removeEventListener(e, r.handle), clearTimeout(r.timeoutId), delete this.debouncedListeners[e][n];
            }
        }
        removeEventListener(e, n) {
            if (!this.listeners[e]) return;
            const r = this.listeners[e], i = r.length;
            for(let a = 0; a < i; a++)if (r[a] === n) {
                r.splice(a, 1);
                return;
            }
        }
        dispatchEvent(e) {
            if (!this.listeners[e.type]) return !e.defaultPrevented;
            const n = this.listeners[e.type].slice(), r = n.length;
            for(let i = 0; i < r; i++)try {
                n[i].call(this, e);
            } catch (a) {
                console.error(`error in event listener of type:  ${e.type}`, a);
            }
            return !e.defaultPrevented;
        }
    }
    Ke = new Sb;
    We = function(t = Ke, e, n = null) {
        if (!e) throw new Error("Event type was not defined");
        const r = new CustomEvent(e, {
            detail: n,
            cancelable: !0
        });
        return t?.dispatchEvent(r);
    };
    var Xm, W6;
    function Eb() {
        return W6 || (W6 = 1, Xm = function t(e, n) {
            if (e === n) return !0;
            if (e && n && typeof e == "object" && typeof n == "object") {
                if (e.constructor !== n.constructor) return !1;
                var r, i, a;
                if (Array.isArray(e)) {
                    if (r = e.length, r != n.length) return !1;
                    for(i = r; i-- !== 0;)if (!t(e[i], n[i])) return !1;
                    return !0;
                }
                if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
                if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
                if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
                if (a = Object.keys(e), r = a.length, r !== Object.keys(n).length) return !1;
                for(i = r; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(n, a[i])) return !1;
                for(i = r; i-- !== 0;){
                    var o = a[i];
                    if (!t(e[o], n[o])) return !1;
                }
                return !0;
            }
            return e !== e && n !== n;
        }), Xm;
    }
    var Db = Eb();
    const h3 = Qa(Db);
    var Ym, $6;
    function iT() {
        if ($6) return Ym;
        $6 = 1;
        var t = Object.prototype.toString;
        return Ym = function(n) {
            var r = t.call(n), i = r === "[object Arguments]";
            return i || (i = r !== "[object Array]" && n !== null && typeof n == "object" && typeof n.length == "number" && n.length >= 0 && t.call(n.callee) === "[object Function]"), i;
        }, Ym;
    }
    var Zm, z6;
    function _b() {
        if (z6) return Zm;
        z6 = 1;
        var t;
        if (!Object.keys) {
            var e = Object.prototype.hasOwnProperty, n = Object.prototype.toString, r = iT(), i = Object.prototype.propertyIsEnumerable, a = !i.call({
                toString: null
            }, "toString"), o = i.call(function() {}, "prototype"), s = [
                "toString",
                "toLocaleString",
                "valueOf",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "constructor"
            ], c = function(g) {
                var h = g.constructor;
                return h && h.prototype === g;
            }, l = {
                $applicationCache: !0,
                $console: !0,
                $external: !0,
                $frame: !0,
                $frameElement: !0,
                $frames: !0,
                $innerHeight: !0,
                $innerWidth: !0,
                $onmozfullscreenchange: !0,
                $onmozfullscreenerror: !0,
                $outerHeight: !0,
                $outerWidth: !0,
                $pageXOffset: !0,
                $pageYOffset: !0,
                $parent: !0,
                $scrollLeft: !0,
                $scrollTop: !0,
                $scrollX: !0,
                $scrollY: !0,
                $self: !0,
                $webkitIndexedDB: !0,
                $webkitStorageInfo: !0,
                $window: !0
            }, f = function() {
                if (typeof window > "u") return !1;
                for(var g in window)try {
                    if (!l["$" + g] && e.call(window, g) && window[g] !== null && typeof window[g] == "object") try {
                        c(window[g]);
                    } catch  {
                        return !0;
                    }
                } catch  {
                    return !0;
                }
                return !1;
            }(), u = function(g) {
                if (typeof window > "u" || !f) return c(g);
                try {
                    return c(g);
                } catch  {
                    return !1;
                }
            };
            t = function(h) {
                var v = h !== null && typeof h == "object", m = n.call(h) === "[object Function]", y = r(h), C = v && n.call(h) === "[object String]", T = [];
                if (!v && !m && !y) throw new TypeError("Object.keys called on a non-object");
                var x = o && m;
                if (C && h.length > 0 && !e.call(h, 0)) for(var S = 0; S < h.length; ++S)T.push(String(S));
                if (y && h.length > 0) for(var D = 0; D < h.length; ++D)T.push(String(D));
                else for(var _ in h)!(x && _ === "prototype") && e.call(h, _) && T.push(String(_));
                if (a) for(var M = u(h), P = 0; P < s.length; ++P)!(M && s[P] === "constructor") && e.call(h, s[P]) && T.push(s[P]);
                return T;
            };
        }
        return Zm = t, Zm;
    }
    var Jm, j6;
    function Rb() {
        if (j6) return Jm;
        j6 = 1;
        var t = Array.prototype.slice, e = iT(), n = Object.keys, r = n ? function(o) {
            return n(o);
        } : _b(), i = Object.keys;
        return r.shim = function() {
            if (Object.keys) {
                var o = function() {
                    var s = Object.keys(arguments);
                    return s && s.length === arguments.length;
                }(1, 2);
                o || (Object.keys = function(c) {
                    return e(c) ? i(t.call(c)) : i(c);
                });
            } else Object.keys = r;
            return Object.keys || r;
        }, Jm = r, Jm;
    }
    var Qm, H6;
    function aT() {
        if (H6) return Qm;
        H6 = 1;
        var t = Object.defineProperty || !1;
        if (t) try {
            t({}, "a", {
                value: 1
            });
        } catch  {
            t = !1;
        }
        return Qm = t, Qm;
    }
    var e5, K6;
    function Ob() {
        return K6 || (K6 = 1, e5 = SyntaxError), e5;
    }
    var t5, q6;
    function Ib() {
        return q6 || (q6 = 1, t5 = TypeError), t5;
    }
    var n5, X6;
    function Mb() {
        return X6 || (X6 = 1, n5 = Object.getOwnPropertyDescriptor), n5;
    }
    var r5, Y6;
    function bb() {
        if (Y6) return r5;
        Y6 = 1;
        var t = Mb();
        if (t) try {
            t([], "length");
        } catch  {
            t = null;
        }
        return r5 = t, r5;
    }
    var i5, Z6;
    function Lb() {
        if (Z6) return i5;
        Z6 = 1;
        var t = aT(), e = Ob(), n = Ib(), r = bb();
        return i5 = function(a, o, s) {
            if (!a || typeof a != "object" && typeof a != "function") throw new n("`obj` must be an object or a function`");
            if (typeof o != "string" && typeof o != "symbol") throw new n("`property` must be a string or a symbol`");
            if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new n("`nonEnumerable`, if provided, must be a boolean or null");
            if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new n("`nonWritable`, if provided, must be a boolean or null");
            if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new n("`nonConfigurable`, if provided, must be a boolean or null");
            if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new n("`loose`, if provided, must be a boolean");
            var c = arguments.length > 3 ? arguments[3] : null, l = arguments.length > 4 ? arguments[4] : null, f = arguments.length > 5 ? arguments[5] : null, u = arguments.length > 6 ? arguments[6] : !1, g = !!r && r(a, o);
            if (t) t(a, o, {
                configurable: f === null && g ? g.configurable : !f,
                enumerable: c === null && g ? g.enumerable : !c,
                value: s,
                writable: l === null && g ? g.writable : !l
            });
            else if (u || !c && !l && !f) a[o] = s;
            else throw new e("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
        }, i5;
    }
    var a5, J6;
    function Pb() {
        if (J6) return a5;
        J6 = 1;
        var t = aT(), e = function() {
            return !!t;
        };
        return e.hasArrayLengthDefineBug = function() {
            if (!t) return null;
            try {
                return t([], "length", {
                    value: 1
                }).length !== 1;
            } catch  {
                return !0;
            }
        }, a5 = e, a5;
    }
    var o5, Q6;
    function oT() {
        if (Q6) return o5;
        Q6 = 1;
        var t = Rb(), e = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", n = Object.prototype.toString, r = Array.prototype.concat, i = Lb(), a = function(l) {
            return typeof l == "function" && n.call(l) === "[object Function]";
        }, o = Pb()(), s = function(l, f, u, g) {
            if (f in l) {
                if (g === !0) {
                    if (l[f] === u) return;
                } else if (!a(g) || !g()) return;
            }
            o ? i(l, f, u, !0) : i(l, f, u);
        }, c = function(l, f) {
            var u = arguments.length > 2 ? arguments[2] : {}, g = t(f);
            e && (g = r.call(g, Object.getOwnPropertySymbols(f)));
            for(var h = 0; h < g.length; h += 1)s(l, g[h], f[g[h]], u[g[h]]);
        };
        return c.supportsDescriptors = !!o, o5 = c, o5;
    }
    var Bf = {
        exports: {}
    }, e9;
    function sT() {
        return e9 || (e9 = 1, typeof self < "u" ? Bf.exports = self : typeof window < "u" ? Bf.exports = window : Bf.exports = Function("return this")()), Bf.exports;
    }
    var s5, t9;
    function cT() {
        if (t9) return s5;
        t9 = 1;
        var t = sT();
        return s5 = function() {
            return typeof globalThis != "object" || !globalThis || globalThis.Math !== Math || globalThis.Array !== Array ? t : globalThis;
        }, s5;
    }
    var c5, n9;
    function Vb() {
        if (n9) return c5;
        n9 = 1;
        var t = oT(), e = cT();
        return c5 = function() {
            var r = e();
            if (t.supportsDescriptors) {
                var i = Object.getOwnPropertyDescriptor(r, "globalThis");
                (!i || i.configurable && (i.enumerable || !i.writable || globalThis !== r)) && Object.defineProperty(r, "globalThis", {
                    configurable: !0,
                    enumerable: !1,
                    value: r,
                    writable: !0
                });
            } else (typeof globalThis != "object" || globalThis !== r) && (r.globalThis = r);
            return r;
        }, c5;
    }
    var l5, r9;
    function Nb() {
        if (r9) return l5;
        r9 = 1;
        var t = oT(), e = sT(), n = cT(), r = Vb(), i = n(), a = function() {
            return i;
        };
        return t(a, {
            getPolyfill: n,
            implementation: e,
            shim: r
        }), l5 = a, l5;
    }
    var Ab = Nb();
    const kb = Qa(Ab), hs = kb(), lT = {
        vtkObject: ()=>null
    };
    function vs(t) {
        if (t == null || t.isA) return t;
        if (!t.vtkClass) return hs.console && hs.console.error && hs.console.error("Invalid VTK object"), null;
        const e = lT[t.vtkClass];
        if (!e) return hs.console && hs.console.error && hs.console.error(`No vtk class found for Object of type ${t.vtkClass}`), null;
        const n = {
            ...t
        };
        Object.keys(n).forEach((i)=>{
            n[i] && typeof n[i] == "object" && n[i].vtkClass && (n[i] = vs(n[i]));
        });
        const r = e(n);
        return r && r.modified && r.modified(), r;
    }
    function Ub(t, e) {
        lT[t] = e;
    }
    vs.register = Ub;
    class u5 extends Array {
        push() {
            for(let e = 0; e < arguments.length; e++)this.includes(arguments[e]) || super.push(arguments[e]);
            return this.length;
        }
    }
    let mv = 0;
    const uT = Symbol("void");
    function Fb() {
        return mv;
    }
    const fT = {};
    function _0() {}
    const Bb = [
        "log",
        "debug",
        "info",
        "warn",
        "error",
        "time",
        "timeEnd",
        "group",
        "groupEnd"
    ];
    Bb.forEach((t)=>{
        fT[t] = _0;
    });
    hs.console = console.hasOwnProperty("log") ? console : fT;
    const Bl = {
        debug: _0,
        error: hs.console.error || _0,
        info: hs.console.info || _0,
        log: hs.console.log || _0,
        warn: hs.console.warn || _0
    };
    function dT(t, e) {
        Bl[t] && (Bl[t] = e || _0);
    }
    function gT() {
        Bl.log(...arguments);
    }
    function hT() {
        Bl.info(...arguments);
    }
    function Nh() {
        Bl.debug(...arguments);
    }
    function Zt() {
        Bl.error(...arguments);
    }
    function _p() {
        Bl.warn(...arguments);
    }
    const i9 = {};
    function pT(t) {
        i9[t] || (Bl.error(t), i9[t] = !0);
    }
    const la = Object.create(null);
    la.Float32Array = Float32Array;
    la.Float64Array = Float64Array;
    la.Uint8Array = Uint8Array;
    la.Int8Array = Int8Array;
    la.Uint16Array = Uint16Array;
    la.Int16Array = Int16Array;
    la.Uint32Array = Uint32Array;
    la.Int32Array = Int32Array;
    la.Uint8ClampedArray = Uint8ClampedArray;
    try {
        la.BigInt64Array = BigInt64Array, la.BigUint64Array = BigUint64Array;
    } catch  {}
    function nf(t) {
        for(var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r];
        return new (la[t] || Float64Array)(...n);
    }
    function Rp(t) {
        for(var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r];
        return (la[t] || Float64Array).from(...n);
    }
    function Op(t) {
        return t.charAt(0).toUpperCase() + t.slice(1);
    }
    function Fr(t) {
        return Op(t[0] === "_" ? t.slice(1) : t);
    }
    function mT(t) {
        return t.charAt(0).toLowerCase() + t.slice(1);
    }
    function vT(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
        const r = [
            "TB",
            "GB",
            "MB",
            "KB"
        ];
        let i = Number(t), a = "B";
        for(; i > n;)i /= n, a = r.pop();
        return `${i.toFixed(e)} ${a}`;
    }
    function yT(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
        const n = [];
        let r = t;
        for(; r > 1e3;)n.push(`000${r % 1e3}`.slice(-3)), r = Math.floor(r / 1e3);
        return r > 0 && n.push(r), n.reverse(), n.join(e);
    }
    function CT(t) {
        Object.keys(t).forEach((e)=>{
            Array.isArray(t[e]) && (t[e] = [].concat(t[e]));
        });
    }
    function Gb(t) {
        return Object.values(la).some((e)=>t instanceof e);
    }
    function Wb(t, e) {
        if (t === e) return !0;
        if (Array.isArray(t) && Array.isArray(e)) {
            if (t.length !== e.length) return !1;
            for(let n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1;
            return !0;
        }
        return !1;
    }
    function $b(t, e) {
        return Object.keys(t).find((n)=>t[n] === e);
    }
    function wT(t) {
        return t && t.isA ? t.getState() : t;
    }
    function p3(t) {
        setTimeout(t, 0);
    }
    function TT(t, e) {
        const n = performance.now();
        t.finally(()=>{
            const r = performance.now() - n;
            e(r);
        });
    }
    tr = function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        CT(e);
        const n = [];
        if (Number.isInteger(e.mtime) || (e.mtime = ++mv), !("classHierarchy" in e)) e.classHierarchy = new u5("vtkObject");
        else if (!(e.classHierarchy instanceof u5)) {
            const a = new u5;
            for(let o = 0; o < e.classHierarchy.length; o++)a.push(e.classHierarchy[o]);
            e.classHierarchy = a;
        }
        function r(a) {
            n[a] = null;
        }
        function i(a) {
            function o() {
                r(a);
            }
            return Object.freeze({
                unsubscribe: o
            });
        }
        return t.isDeleted = ()=>!!e.deleted, t.modified = (a)=>{
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            a && a < t.getMTime() || (e.mtime = ++mv, n.forEach((o)=>o && o(t)));
        }, t.onModified = (a)=>{
            if (e.deleted) return Zt("instance deleted - cannot call any method"), null;
            const o = n.length;
            return n.push(a), i(o);
        }, t.getMTime = ()=>e.mtime, t.isA = (a)=>{
            let o = e.classHierarchy.length;
            for(; o--;)if (e.classHierarchy[o] === a) return !0;
            return !1;
        }, t.getClassName = function() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.classHierarchy[e.classHierarchy.length - 1 - a];
        }, t.set = function() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, c = !1;
            return Object.keys(a).forEach((l)=>{
                const f = s ? null : t[`set${Op(l)}`];
                f && Array.isArray(a[l]) && f.length > 1 ? c = f(...a[l]) || c : f ? c = f(a[l]) || c : ([
                    "mtime"
                ].indexOf(l) === -1 && !o && _p(`Warning: Set value to model directly ${l}, ${a[l]}`), c = e[l] !== a[l] || c, e[l] = a[l]);
            }), c;
        }, t.get = function() {
            for(var a = arguments.length, o = new Array(a), s = 0; s < a; s++)o[s] = arguments[s];
            if (!o.length) return e;
            const c = {};
            return o.forEach((l)=>{
                c[l] = e[l];
            }), c;
        }, t.getReferenceByName = (a)=>e[a], t.delete = ()=>{
            Object.keys(e).forEach((a)=>delete e[a]), n.forEach((a, o)=>r(o)), e.deleted = !0;
        }, t.getState = ()=>{
            if (e.deleted) return null;
            const a = {
                ...e,
                vtkClass: t.getClassName()
            };
            Object.keys(a).forEach((s)=>{
                a[s] === null || a[s] === void 0 || s[0] === "_" ? delete a[s] : a[s].isA ? a[s] = a[s].getState() : Array.isArray(a[s]) ? a[s] = a[s].map(wT) : Gb(a[s]) && (a[s] = Array.from(a[s]));
            });
            const o = {};
            return Object.keys(a).sort().forEach((s)=>{
                o[s] = a[s];
            }), o.mtime && delete o.mtime, o;
        }, t.shallowCopy = function(a) {
            let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (a.getClassName() !== t.getClassName()) throw new Error(`Cannot ShallowCopy ${a.getClassName()} into ${t.getClassName()}`);
            const s = a.get(), c = Object.keys(e).sort();
            Object.keys(s).sort().forEach((f)=>{
                const u = c.indexOf(f);
                u === -1 ? o && Nh(`add ${f} in shallowCopy`) : c.splice(u, 1), e[f] = s[f];
            }), c.length && o && Nh(`Untouched keys: ${c.join(", ")}`), t.modified();
        }, t.toJSON = function() {
            return t.getState();
        }, t;
    };
    const zb = {
        object (t, e, n) {
            return function() {
                return {
                    ...e[n.name]
                };
            };
        }
    };
    La = function(t, e, n) {
        n.forEach((r)=>{
            if (typeof r == "object") {
                const i = zb[r.type];
                i ? t[`get${Fr(r.name)}`] = i(t, e, r) : t[`get${Fr(r.name)}`] = ()=>e[r.name];
            } else t[`get${Fr(r)}`] = ()=>e[r];
        });
    };
    const xT = {
        enum (t, e, n) {
            const r = `_on${Fr(n.name)}Changed`;
            return (i)=>{
                if (typeof i == "string") {
                    if (n.enum[i] !== void 0) return e[n.name] !== n.enum[i] ? (e[n.name] = n.enum[i], t.modified(), !0) : !1;
                    throw Zt(`Set Enum with invalid argument ${n}, ${i}`), new RangeError("Set Enum with invalid string argument");
                }
                if (typeof i == "number") {
                    if (e[n.name] !== i) {
                        if (Object.keys(n.enum).map((a)=>n.enum[a]).indexOf(i) !== -1) {
                            const a = e[n.name];
                            return e[n.name] = i, e[r]?.(t, e, i, a), t.modified(), !0;
                        }
                        throw Zt(`Set Enum outside numeric range ${n}, ${i}`), new RangeError("Set Enum outside numeric range");
                    }
                    return !1;
                }
                throw Zt(`Set Enum with invalid argument (String/Number) ${n}, ${i}`), new TypeError("Set Enum with invalid argument (String/Number)");
            };
        },
        object (t, e, n) {
            n.params?.length === 1 && _p('Setter of type "object" with a single "param" field is not supported');
            const r = `_on${Fr(n.name)}Changed`;
            return function() {
                for(var i = arguments.length, a = new Array(i), o = 0; o < i; o++)a[o] = arguments[o];
                let s;
                if (a.length > 1 && n.params?.length ? s = n.params.reduce((c, l, f)=>Object.assign(c, {
                        [l]: a[f]
                    }), {}) : s = a[0], !h3(e[n.name], s)) {
                    const c = e[n.name];
                    return e[n.name] = s, e[r]?.(t, e, s, c), t.modified(), !0;
                }
                return !1;
            };
        }
    };
    function a9(t) {
        if (typeof t == "object") {
            const e = xT[t.type];
            if (e) return (n, r)=>e(n, r, t);
            throw Zt(`No setter for field ${t}`), new TypeError("No setter for field");
        }
        return function(n, r) {
            const i = `_on${Fr(t)}Changed`;
            return function(o) {
                if (r.deleted) return Zt("instance deleted - cannot call any method"), !1;
                if (r[t] !== o) {
                    const s = r[t.name];
                    return r[t] = o, r[i]?.(n, r, o, s), n.modified(), !0;
                }
                return !1;
            };
        };
    }
    function $d(t, e, n) {
        n.forEach((r)=>{
            typeof r == "object" ? t[`set${Fr(r.name)}`] = a9(r)(t, e) : t[`set${Fr(r)}`] = a9(r)(t, e);
        });
    }
    si = function(t, e, n) {
        La(t, e, n), $d(t, e, n);
    };
    function rf(t, e, n) {
        n.forEach((r)=>{
            t[`get${Fr(r)}`] = ()=>e[r] ? Array.from(e[r]) : e[r], t[`get${Fr(r)}ByReference`] = ()=>e[r];
        });
    }
    function m3(t, e, n, r) {
        let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
        n.forEach((a)=>{
            if (e[a] && r && e[a].length !== r) throw new RangeError(`Invalid initial number of values for array (${a})`);
            const o = `_on${Fr(a)}Changed`;
            t[`set${Fr(a)}`] = function() {
                if (e.deleted) return Zt("instance deleted - cannot call any method"), !1;
                for(var s = arguments.length, c = new Array(s), l = 0; l < s; l++)c[l] = arguments[l];
                let f = c, u, g = !1;
                if (f.length === 1 && (f[0] == null || f[0].length >= 0) && (f = f[0], g = !0), f == null) u = e[a] !== f;
                else {
                    if (r && f.length !== r) if (f.length < r && i !== void 0) for(f = Array.from(f), g = !1; f.length < r;)f.push(i);
                    else throw new RangeError(`Invalid number of values for array setter (${a})`);
                    u = e[a] == null || e[a].length !== f.length;
                    for(let h = 0; !u && h < f.length; ++h)u = e[a][h] !== f[h];
                    u && g && (f = Array.from(f));
                }
                if (u) {
                    const h = e[a.name];
                    e[a] = f, e[o]?.(t, e, f, h), t.modified();
                }
                return u;
            }, t[`set${Fr(a)}From`] = (s)=>{
                const c = e[a];
                s.forEach((l, f)=>{
                    c[f] = l;
                });
            };
        });
    }
    function v3(t, e, n, r) {
        let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
        rf(t, e, n), m3(t, e, n, r, i);
    }
    function zd(t, e, n) {
        for(let r = 0; r < n.length; r++){
            const i = n[r];
            e[i] !== void 0 && (e[`_${i}`] = e[i], delete e[i]);
        }
    }
    function y3(t, e, n, r) {
        e.inputData ? e.inputData = e.inputData.map(vs) : e.inputData = [], e.inputConnection ? e.inputConnection = e.inputConnection.map(vs) : e.inputConnection = [], e.output ? e.output = e.output.map(vs) : e.output = [], e.inputArrayToProcess ? e.inputArrayToProcess = e.inputArrayToProcess.map(vs) : e.inputArrayToProcess = [], e.numberOfInputs = n;
        function i(h) {
            let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            if (v >= e.numberOfInputs) {
                Zt(`algorithm ${t.getClassName()} only has ${e.numberOfInputs} input ports. To add more input ports, use addInputData()`);
                return;
            }
            (e.inputData[v] !== h || e.inputConnection[v]) && (e.inputData[v] = h, e.inputConnection[v] = null, t.modified && t.modified());
        }
        function a() {
            let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.inputConnection[h] && (e.inputData[h] = e.inputConnection[h]()), e.inputData[h];
        }
        function o(h) {
            let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            if (v >= e.numberOfInputs) {
                let m = `algorithm ${t.getClassName()} only has `;
                m += `${e.numberOfInputs}`, m += " input ports. To add more input ports, use addInputConnection()", Zt(m);
                return;
            }
            e.inputData[v] = null, e.inputConnection[v] = h;
        }
        function s() {
            let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.inputConnection[h];
        }
        function c() {
            let h = e.numberOfInputs;
            for(; h && !e.inputData[h - 1] && !e.inputConnection[h - 1];)h--;
            return h === e.numberOfInputs && e.numberOfInputs++, h;
        }
        function l(h) {
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            o(h, c());
        }
        function f(h) {
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            i(h, c());
        }
        function u() {
            let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.deleted ? (Zt("instance deleted - cannot call any method"), null) : (t.shouldUpdate() && t.update(), e.output[h]);
        }
        t.shouldUpdate = ()=>{
            const h = t.getMTime();
            let v = 1 / 0, m = r;
            for(; m--;){
                if (!e.output[m] || e.output[m].isDeleted()) return !0;
                const y = e.output[m].getMTime();
                if (y < h) return !0;
                y < v && (v = y);
            }
            for(m = e.numberOfInputs; m--;)if (e.inputConnection[m]?.filter.shouldUpdate() || t.getInputData(m)?.getMTime() > v) return !0;
            return !1;
        };
        function g() {
            let h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            const v = ()=>u(h);
            return v.filter = t, v;
        }
        if (e.numberOfInputs) {
            let h = e.numberOfInputs;
            for(; h--;)e.inputData.push(null), e.inputConnection.push(null);
            t.setInputData = i, t.setInputConnection = o, t.addInputData = f, t.addInputConnection = l, t.getInputData = a, t.getInputConnection = s;
        }
        r && (t.getOutputData = u, t.getOutputPort = g), t.update = ()=>{
            const h = [];
            if (e.numberOfInputs) {
                let v = 0;
                for(; v < e.numberOfInputs;)h[v] = t.getInputData(v), v++;
            }
            t.shouldUpdate() && t.requestData && t.requestData(h, e.output);
        }, t.getNumberOfInputPorts = ()=>e.numberOfInputs, t.getNumberOfOutputPorts = ()=>r || e.output.length, t.getInputArrayToProcess = (h)=>{
            const v = e.inputArrayToProcess[h], m = e.inputData[h];
            return v && m ? m[`get${v.fieldAssociation}`]().getArray(v.arrayName) : null;
        }, t.setInputArrayToProcess = function(h, v, m) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
            for(; e.inputArrayToProcess.length < h;)e.inputArrayToProcess.push(null);
            e.inputArrayToProcess[h] = {
                arrayName: v,
                fieldAssociation: m,
                attributeType: y
            };
        };
    }
    const C3 = Symbol("Event abort");
    ST = function(t, e, n) {
        const r = [], i = t.delete;
        let a = 1;
        function o(l) {
            for(let f = 0; f < r.length; ++f){
                const [u] = r[f];
                if (u === l) {
                    r.splice(f, 1);
                    return;
                }
            }
        }
        function s(l) {
            function f() {
                o(l);
            }
            return Object.freeze({
                unsubscribe: f
            });
        }
        function c() {
            if (e.deleted) {
                Zt("instance deleted - cannot call any method");
                return;
            }
            const l = r.slice();
            for(let f = 0; f < l.length; ++f){
                const [, u, g] = l[f];
                if (u) {
                    if (g < 0) setTimeout(()=>u.apply(t, arguments), 1 - g);
                    else if (u.apply(t, arguments) === C3) break;
                }
            }
        }
        t[`invoke${Fr(n)}`] = c, t[`on${Fr(n)}`] = function(l) {
            let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (!l.apply) return console.error(`Invalid callback for event ${n}`), null;
            if (e.deleted) return Zt("instance deleted - cannot call any method"), null;
            const u = a++;
            return r.push([
                u,
                l,
                f
            ]), r.sort((g, h)=>h[2] - g[2]), s(u);
        }, t.delete = ()=>{
            i(), r.forEach((l)=>{
                let [f] = l;
                return o(f);
            });
        };
    };
    kn = function(t, e) {
        const n = function() {
            let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            const i = {}, a = {};
            return t(a, i, r), Object.freeze(a);
        };
        return e && vs.register(e, n), n;
    };
    function jd() {
        for(var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n];
        return function() {
            for(var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a];
            return e.filter((o)=>!!o).map((o)=>o(...i));
        };
    }
    function w3(t) {
        return t && t.isA && t.isA("vtkObject");
    }
    function Ah(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
        if (w3(t)) {
            if (r.indexOf(t) >= 0) return n;
            r.push(t);
            const i = e(t);
            i !== void 0 && n.push(i);
            const a = t.get();
            Object.keys(a).forEach((o)=>{
                const s = a[o];
                Array.isArray(s) ? s.forEach((c)=>{
                    Ah(c, e, n, r);
                }) : Ah(s, e, n, r);
            });
        }
        return n;
    }
    function ET(t, e, n) {
        var r = this;
        let i;
        const a = function() {
            for(var o = arguments.length, s = new Array(o), c = 0; c < o; c++)s[c] = arguments[c];
            const l = r, f = ()=>{
                i = null, n || t.apply(l, s);
            }, u = n && !i;
            clearTimeout(i), i = setTimeout(f, e), u && t.apply(l, s);
        };
        return a.cancel = ()=>clearTimeout(i), a;
    }
    function DT(t, e) {
        let n = !1, r = null;
        function i() {
            n = !1, r !== null && (a(...r), r = null);
        }
        function a() {
            for(var o = arguments.length, s = new Array(o), c = 0; c < o; c++)s[c] = arguments[c];
            if (n) {
                r = s;
                return;
            }
            n = !0, t(...s), setTimeout(i, e);
        }
        return a;
    }
    function T3(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        e.keystore = Object.assign(e.keystore || {}, n), t.setKey = (r, i)=>{
            e.keystore[r] = i;
        }, t.getKey = (r)=>e.keystore[r], t.getAllKeys = ()=>Object.keys(e.keystore), t.deleteKey = (r)=>delete e.keystore[r], t.clearKeystore = ()=>t.getAllKeys().forEach((r)=>delete e.keystore[r]);
    }
    let jb = 1;
    const d1 = "__root__";
    function _T(t, e) {
        T3(t, e);
        const n = t.delete;
        e.proxyId = `${jb++}`, e.ui = JSON.parse(JSON.stringify(e.ui || [])), La(t, e, [
            "proxyId",
            "proxyGroup",
            "proxyName"
        ]), si(t, e, [
            "proxyManager"
        ]);
        const r = {}, i = {};
        function a(l, f) {
            i[f] || (i[f] = []);
            const u = i[f];
            for(let g = 0; g < l.length; g++)u.push(l[g].name), r[l[g].name] = l[g], l[g].children && l[g].children.length && a(l[g].children, l[g].name);
        }
        a(e.ui, d1), t.updateUI = (l)=>{
            e.ui = JSON.parse(JSON.stringify(l || [])), Object.keys(r).forEach((f)=>delete r[f]), Object.keys(i).forEach((f)=>delete i[f]), a(e.ui, d1), t.modified();
        };
        function o() {
            let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : d1;
            return i[l];
        }
        t.updateProxyProperty = (l, f)=>{
            const u = r[l];
            u ? Object.assign(u, f) : r[l] = {
                ...f
            };
        }, t.activate = ()=>{
            if (e.proxyManager) {
                const l = `setActive${Fr(t.getProxyGroup().slice(0, -1))}`;
                e.proxyManager[l] && e.proxyManager[l](t);
            }
        }, e.propertyLinkSubscribers = {}, t.registerPropertyLinkForGC = (l, f)=>{
            f in e.propertyLinkSubscribers || (e.propertyLinkSubscribers[f] = []), e.propertyLinkSubscribers[f].push(l);
        }, t.gcPropertyLinks = (l)=>{
            const f = e.propertyLinkSubscribers[l] || [];
            for(; f.length;)f.pop().unbind(t);
        }, e.propertyLinkMap = {}, t.getPropertyLink = function(l) {
            let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (e.propertyLinkMap[l]) return e.propertyLinkMap[l];
            let u = null;
            const g = [];
            let h = 0, v = !1;
            function m(S) {
                let D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                if (v) return null;
                const _ = [];
                let M = null;
                for(h = g.length; h--;){
                    const F = g[h];
                    F.instance === S ? M = F : _.push(F);
                }
                if (!M) return null;
                const P = M.instance[`get${Fr(M.propertyName)}`]();
                if (!Wb(P, u) || D) {
                    for(u = P, v = !0; _.length;){
                        const F = _.pop();
                        F.instance.set({
                            [F.propertyName]: u
                        });
                    }
                    v = !1;
                }
                return e.propertyLinkMap[l].persistent && (e.propertyLinkMap[l].value = P), P;
            }
            function y(S, D) {
                const _ = [];
                for(h = g.length; h--;){
                    const M = g[h];
                    M.instance === S && (M.propertyName === D || D === void 0) && (M.subscription.unsubscribe(), _.push(h));
                }
                for(; _.length;)g.splice(_.pop(), 1);
            }
            function C(S, D) {
                let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
                const M = S.onModified(m), P = g[0];
                return g.push({
                    instance: S,
                    propertyName: D,
                    subscription: M
                }), _ && (e.propertyLinkMap[l].persistent && e.propertyLinkMap[l].value !== void 0 ? S.set({
                    [D]: e.propertyLinkMap[l].value
                }) : P && m(P.instance, !0)), {
                    unsubscribe: ()=>y(S, D)
                };
            }
            function T() {
                for(; g.length;)g.pop().subscription.unsubscribe();
            }
            const x = {
                bind: C,
                unbind: y,
                unsubscribe: T,
                persistent: f
            };
            return e.propertyLinkMap[l] = x, x;
        };
        function s() {
            let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : d1;
            const f = [], u = e.proxyId, g = o(l) || [];
            for(let h = 0; h < g.length; h++){
                const v = g[h], m = t[`get${Fr(v)}`], y = m ? m() : void 0, C = {
                    id: u,
                    name: v,
                    value: y
                }, T = s(v);
                T.length && (C.children = T), f.push(C);
            }
            return f;
        }
        t.listPropertyNames = ()=>s().map((l)=>l.name), t.getPropertyByName = (l)=>s().find((f)=>f.name === l), t.getPropertyDomainByName = (l)=>(r[l] || {}).domain, t.getProxySection = ()=>({
                id: e.proxyId,
                name: e.proxyGroup,
                ui: e.ui,
                properties: s()
            }), t.delete = ()=>{
            const l = Object.keys(e.propertyLinkMap);
            let f = l.length;
            for(; f--;)e.propertyLinkMap[l[f]].unsubscribe();
            Object.keys(e.propertyLinkSubscribers).forEach(t.gcPropertyLinks), n();
        }, t.getState = ()=>null;
        function c() {
            if (e.links) for(let l = 0; l < e.links.length; l++){
                const { link: f, property: u, persistent: g, updateOnBind: h, type: v } = e.links[l];
                if (v === "application") {
                    const m = e.proxyManager.getPropertyLink(f, g);
                    t.registerPropertyLinkForGC(m, "application"), m.bind(t, u, h);
                }
            }
        }
        p3(c);
    }
    function RT(t, e, n) {
        const r = t.delete, i = [], a = Object.keys(n);
        let o = a.length;
        for(; o--;){
            const s = a[o], { modelKey: c, property: l, modified: f = !0 } = n[s], u = Fr(l), g = Fr(s);
            t[`get${g}`] = e[c][`get${u}`], t[`set${g}`] = e[c][`set${u}`], f && i.push(e[c].onModified(t.modified));
        }
        t.delete = ()=>{
            for(; i.length;)i.pop().unsubscribe();
            r();
        };
    }
    function OT(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        e.this = t;
        function i(s) {
            const c = Object.keys(s);
            let l = c.length;
            for(; l--;){
                const f = c[l];
                e[f].set(s[f]);
            }
        }
        const a = Object.keys(r);
        let o = a.length;
        for(; o--;){
            const s = a[o];
            e[s] = r[s];
            const c = n[s];
            t[`set${Fr(s)}`] = (l)=>{
                if (l !== e[s]) {
                    e[s] = l;
                    const f = c[l];
                    i(f), t.modified();
                }
            };
        }
        a.length && La(t, e, a);
    }
    const o9 = 10, s9 = 40, c9 = 800;
    function IT(t) {
        let e = 0, n = 0, r = 0, i = 0;
        return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = n, n = 0), r = e * o9, i = n * o9, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode === 1 ? (r *= s9, i *= s9) : (r *= c9, i *= c9)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
            spinX: e,
            spinY: n || e,
            pixelX: r,
            pixelY: i || r
        };
    }
    let q1, Hb, l9;
    K = {
        algo: y3,
        capitalize: Op,
        chain: jd,
        debounce: ET,
        enumToString: $b,
        event: ST,
        EVENT_ABORT: C3,
        formatBytesToProperUnit: vT,
        formatNumbersWithThousandSeparator: yT,
        get: La,
        getArray: rf,
        getCurrentGlobalMTime: Fb,
        getStateArrayMapFunc: wT,
        isVtkObject: w3,
        keystore: T3,
        measurePromiseExecution: TT,
        moveToProtected: zd,
        newInstance: kn,
        newTypedArray: nf,
        newTypedArrayFrom: Rp,
        normalizeWheel: IT,
        obj: tr,
        proxy: _T,
        proxyPropertyMapping: RT,
        proxyPropertyState: OT,
        safeArrays: CT,
        set: $d,
        setArray: m3,
        setGet: si,
        setGetArray: v3,
        setImmediate: p3,
        setLoggerFunction: dT,
        throttle: DT,
        traverseInstanceTree: Ah,
        TYPED_ARRAYS: la,
        uncapitalize: mT,
        VOID: uT,
        vtkDebugMacro: Nh,
        vtkErrorMacro: Zt,
        vtkInfoMacro: hT,
        vtkLogMacro: gT,
        vtkOnceErrorMacro: pT,
        vtkWarningMacro: _p,
        objectSetterMap: xT
    };
    da = Object.freeze({
        __proto__: null,
        VOID: uT,
        setLoggerFunction: dT,
        vtkLogMacro: gT,
        vtkInfoMacro: hT,
        vtkDebugMacro: Nh,
        vtkErrorMacro: Zt,
        vtkWarningMacro: _p,
        vtkOnceErrorMacro: pT,
        TYPED_ARRAYS: la,
        newTypedArray: nf,
        newTypedArrayFrom: Rp,
        capitalize: Op,
        _capitalize: Fr,
        uncapitalize: mT,
        formatBytesToProperUnit: vT,
        formatNumbersWithThousandSeparator: yT,
        setImmediateVTK: p3,
        measurePromiseExecution: TT,
        obj: tr,
        get: La,
        set: $d,
        setGet: si,
        getArray: rf,
        setArray: m3,
        setGetArray: v3,
        moveToProtected: zd,
        algo: y3,
        EVENT_ABORT: C3,
        event: ST,
        newInstance: kn,
        chain: jd,
        isVtkObject: w3,
        traverseInstanceTree: Ah,
        debounce: ET,
        throttle: DT,
        keystore: T3,
        proxy: _T,
        proxyPropertyMapping: RT,
        proxyPropertyState: OT,
        normalizeWheel: IT,
        default: K
    });
    q1 = {
        exports: {}
    };
    Hb = q1.exports;
    function Kb() {
        return l9 || (l9 = 1, function(t) {
            (function(e, n, r) {
                function i(c) {
                    var l = this, f = s();
                    l.next = function() {
                        var u = 2091639 * l.s0 + l.c * 23283064365386963e-26;
                        return l.s0 = l.s1, l.s1 = l.s2, l.s2 = u - (l.c = u | 0);
                    }, l.c = 1, l.s0 = f(" "), l.s1 = f(" "), l.s2 = f(" "), l.s0 -= f(c), l.s0 < 0 && (l.s0 += 1), l.s1 -= f(c), l.s1 < 0 && (l.s1 += 1), l.s2 -= f(c), l.s2 < 0 && (l.s2 += 1), f = null;
                }
                function a(c, l) {
                    return l.c = c.c, l.s0 = c.s0, l.s1 = c.s1, l.s2 = c.s2, l;
                }
                function o(c, l) {
                    var f = new i(c), u = l && l.state, g = f.next;
                    return g.int32 = function() {
                        return f.next() * 4294967296 | 0;
                    }, g.double = function() {
                        return g() + (g() * 2097152 | 0) * 11102230246251565e-32;
                    }, g.quick = g, u && (typeof u == "object" && a(u, f), g.state = function() {
                        return a(f, {});
                    }), g;
                }
                function s() {
                    var c = 4022871197, l = function(f) {
                        f = String(f);
                        for(var u = 0; u < f.length; u++){
                            c += f.charCodeAt(u);
                            var g = .02519603282416938 * c;
                            c = g >>> 0, g -= c, g *= c, c = g >>> 0, g -= c, c += g * 4294967296;
                        }
                        return (c >>> 0) * 23283064365386963e-26;
                    };
                    return l;
                }
                n && n.exports ? n.exports = o : this.alea = o;
            })(Hb, t);
        }(q1)), q1.exports;
    }
    var X1 = {
        exports: {}
    }, qb = X1.exports, u9;
    function Xb() {
        return u9 || (u9 = 1, function(t) {
            (function(e, n, r) {
                function i(s) {
                    var c = this, l = "";
                    c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.next = function() {
                        var u = c.x ^ c.x << 11;
                        return c.x = c.y, c.y = c.z, c.z = c.w, c.w ^= c.w >>> 19 ^ u ^ u >>> 8;
                    }, s === (s | 0) ? c.x = s : l += s;
                    for(var f = 0; f < l.length + 64; f++)c.x ^= l.charCodeAt(f) | 0, c.next();
                }
                function a(s, c) {
                    return c.x = s.x, c.y = s.y, c.z = s.z, c.w = s.w, c;
                }
                function o(s, c) {
                    var l = new i(s), f = c && c.state, u = function() {
                        return (l.next() >>> 0) / 4294967296;
                    };
                    return u.double = function() {
                        do var g = l.next() >>> 11, h = (l.next() >>> 0) / 4294967296, v = (g + h) / (1 << 21);
                        while (v === 0);
                        return v;
                    }, u.int32 = l.next, u.quick = u, f && (typeof f == "object" && a(f, l), u.state = function() {
                        return a(l, {});
                    }), u;
                }
                n && n.exports ? n.exports = o : this.xor128 = o;
            })(qb, t);
        }(X1)), X1.exports;
    }
    var Y1 = {
        exports: {}
    }, Yb = Y1.exports, f9;
    function Zb() {
        return f9 || (f9 = 1, function(t) {
            (function(e, n, r) {
                function i(s) {
                    var c = this, l = "";
                    c.next = function() {
                        var u = c.x ^ c.x >>> 2;
                        return c.x = c.y, c.y = c.z, c.z = c.w, c.w = c.v, (c.d = c.d + 362437 | 0) + (c.v = c.v ^ c.v << 4 ^ (u ^ u << 1)) | 0;
                    }, c.x = 0, c.y = 0, c.z = 0, c.w = 0, c.v = 0, s === (s | 0) ? c.x = s : l += s;
                    for(var f = 0; f < l.length + 64; f++)c.x ^= l.charCodeAt(f) | 0, f == l.length && (c.d = c.x << 10 ^ c.x >>> 4), c.next();
                }
                function a(s, c) {
                    return c.x = s.x, c.y = s.y, c.z = s.z, c.w = s.w, c.v = s.v, c.d = s.d, c;
                }
                function o(s, c) {
                    var l = new i(s), f = c && c.state, u = function() {
                        return (l.next() >>> 0) / 4294967296;
                    };
                    return u.double = function() {
                        do var g = l.next() >>> 11, h = (l.next() >>> 0) / 4294967296, v = (g + h) / (1 << 21);
                        while (v === 0);
                        return v;
                    }, u.int32 = l.next, u.quick = u, f && (typeof f == "object" && a(f, l), u.state = function() {
                        return a(l, {});
                    }), u;
                }
                n && n.exports ? n.exports = o : this.xorwow = o;
            })(Yb, t);
        }(Y1)), Y1.exports;
    }
    var Z1 = {
        exports: {}
    }, Jb = Z1.exports, d9;
    function Qb() {
        return d9 || (d9 = 1, function(t) {
            (function(e, n, r) {
                function i(s) {
                    var c = this;
                    c.next = function() {
                        var f = c.x, u = c.i, g, h;
                        return g = f[u], g ^= g >>> 7, h = g ^ g << 24, g = f[u + 1 & 7], h ^= g ^ g >>> 10, g = f[u + 3 & 7], h ^= g ^ g >>> 3, g = f[u + 4 & 7], h ^= g ^ g << 7, g = f[u + 7 & 7], g = g ^ g << 13, h ^= g ^ g << 9, f[u] = h, c.i = u + 1 & 7, h;
                    };
                    function l(f, u) {
                        var g, h = [];
                        if (u === (u | 0)) h[0] = u;
                        else for(u = "" + u, g = 0; g < u.length; ++g)h[g & 7] = h[g & 7] << 15 ^ u.charCodeAt(g) + h[g + 1 & 7] << 13;
                        for(; h.length < 8;)h.push(0);
                        for(g = 0; g < 8 && h[g] === 0; ++g);
                        for(g == 8 ? h[7] = -1 : h[g], f.x = h, f.i = 0, g = 256; g > 0; --g)f.next();
                    }
                    l(c, s);
                }
                function a(s, c) {
                    return c.x = s.x.slice(), c.i = s.i, c;
                }
                function o(s, c) {
                    s == null && (s = +new Date);
                    var l = new i(s), f = c && c.state, u = function() {
                        return (l.next() >>> 0) / 4294967296;
                    };
                    return u.double = function() {
                        do var g = l.next() >>> 11, h = (l.next() >>> 0) / 4294967296, v = (g + h) / (1 << 21);
                        while (v === 0);
                        return v;
                    }, u.int32 = l.next, u.quick = u, f && (f.x && a(f, l), u.state = function() {
                        return a(l, {});
                    }), u;
                }
                n && n.exports ? n.exports = o : this.xorshift7 = o;
            })(Jb, t);
        }(Z1)), Z1.exports;
    }
    var J1 = {
        exports: {}
    }, eL = J1.exports, g9;
    function tL() {
        return g9 || (g9 = 1, function(t) {
            (function(e, n, r) {
                function i(s) {
                    var c = this;
                    c.next = function() {
                        var f = c.w, u = c.X, g = c.i, h, v;
                        return c.w = f = f + 1640531527 | 0, v = u[g + 34 & 127], h = u[g = g + 1 & 127], v ^= v << 13, h ^= h << 17, v ^= v >>> 15, h ^= h >>> 12, v = u[g] = v ^ h, c.i = g, v + (f ^ f >>> 16) | 0;
                    };
                    function l(f, u) {
                        var g, h, v, m, y, C = [], T = 128;
                        for(u === (u | 0) ? (h = u, u = null) : (u = u + "\0", h = 0, T = Math.max(T, u.length)), v = 0, m = -32; m < T; ++m)u && (h ^= u.charCodeAt((m + 32) % u.length)), m === 0 && (y = h), h ^= h << 10, h ^= h >>> 15, h ^= h << 4, h ^= h >>> 13, m >= 0 && (y = y + 1640531527 | 0, g = C[m & 127] ^= h + y, v = g == 0 ? v + 1 : 0);
                        for(v >= 128 && (C[(u && u.length || 0) & 127] = -1), v = 127, m = 4 * 128; m > 0; --m)h = C[v + 34 & 127], g = C[v = v + 1 & 127], h ^= h << 13, g ^= g << 17, h ^= h >>> 15, g ^= g >>> 12, C[v] = h ^ g;
                        f.w = y, f.X = C, f.i = v;
                    }
                    l(c, s);
                }
                function a(s, c) {
                    return c.i = s.i, c.w = s.w, c.X = s.X.slice(), c;
                }
                function o(s, c) {
                    s == null && (s = +new Date);
                    var l = new i(s), f = c && c.state, u = function() {
                        return (l.next() >>> 0) / 4294967296;
                    };
                    return u.double = function() {
                        do var g = l.next() >>> 11, h = (l.next() >>> 0) / 4294967296, v = (g + h) / (1 << 21);
                        while (v === 0);
                        return v;
                    }, u.int32 = l.next, u.quick = u, f && (f.X && a(f, l), u.state = function() {
                        return a(l, {});
                    }), u;
                }
                n && n.exports ? n.exports = o : this.xor4096 = o;
            })(eL, t);
        }(J1)), J1.exports;
    }
    var Q1 = {
        exports: {}
    }, nL = Q1.exports, h9;
    function rL() {
        return h9 || (h9 = 1, function(t) {
            (function(e, n, r) {
                function i(s) {
                    var c = this, l = "";
                    c.next = function() {
                        var u = c.b, g = c.c, h = c.d, v = c.a;
                        return u = u << 25 ^ u >>> 7 ^ g, g = g - h | 0, h = h << 24 ^ h >>> 8 ^ v, v = v - u | 0, c.b = u = u << 20 ^ u >>> 12 ^ g, c.c = g = g - h | 0, c.d = h << 16 ^ g >>> 16 ^ v, c.a = v - u | 0;
                    }, c.a = 0, c.b = 0, c.c = -1640531527, c.d = 1367130551, s === Math.floor(s) ? (c.a = s / 4294967296 | 0, c.b = s | 0) : l += s;
                    for(var f = 0; f < l.length + 20; f++)c.b ^= l.charCodeAt(f) | 0, c.next();
                }
                function a(s, c) {
                    return c.a = s.a, c.b = s.b, c.c = s.c, c.d = s.d, c;
                }
                function o(s, c) {
                    var l = new i(s), f = c && c.state, u = function() {
                        return (l.next() >>> 0) / 4294967296;
                    };
                    return u.double = function() {
                        do var g = l.next() >>> 11, h = (l.next() >>> 0) / 4294967296, v = (g + h) / (1 << 21);
                        while (v === 0);
                        return v;
                    }, u.int32 = l.next, u.quick = u, f && (typeof f == "object" && a(f, l), u.state = function() {
                        return a(l, {});
                    }), u;
                }
                n && n.exports ? n.exports = o : this.tychei = o;
            })(nL, t);
        }(Q1)), Q1.exports;
    }
    var eh = {
        exports: {}
    };
    const iL = {}, aL = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: iL
    }, Symbol.toStringTag, {
        value: "Module"
    })), ec = mM(aL);
    var oL = eh.exports, p9;
    function sL() {
        return p9 || (p9 = 1, function(t) {
            (function(e, n, r) {
                var i = 256, a = 6, o = 52, s = "random", c = r.pow(i, a), l = r.pow(2, o), f = l * 2, u = i - 1, g;
                function h(S, D, _) {
                    var M = [];
                    D = D == !0 ? {
                        entropy: !0
                    } : D || {};
                    var P = C(y(D.entropy ? [
                        S,
                        x(n)
                    ] : S ?? T(), 3), M), F = new v(M), N = function() {
                        for(var B = F.g(a), G = c, Z = 0; B < l;)B = (B + Z) * i, G *= i, Z = F.g(1);
                        for(; B >= f;)B /= 2, G /= 2, Z >>>= 1;
                        return (B + Z) / G;
                    };
                    return N.int32 = function() {
                        return F.g(4) | 0;
                    }, N.quick = function() {
                        return F.g(4) / 4294967296;
                    }, N.double = N, C(x(F.S), n), (D.pass || _ || function(B, G, Z, H) {
                        return H && (H.S && m(H, F), B.state = function() {
                            return m(F, {});
                        }), Z ? (r[s] = B, G) : B;
                    })(N, P, "global" in D ? D.global : this == r, D.state);
                }
                function v(S) {
                    var D, _ = S.length, M = this, P = 0, F = M.i = M.j = 0, N = M.S = [];
                    for(_ || (S = [
                        _++
                    ]); P < i;)N[P] = P++;
                    for(P = 0; P < i; P++)N[P] = N[F = u & F + S[P % _] + (D = N[P])], N[F] = D;
                    (M.g = function(B) {
                        for(var G, Z = 0, H = M.i, ne = M.j, ae = M.S; B--;)G = ae[H = u & H + 1], Z = Z * i + ae[u & (ae[H] = ae[ne = u & ne + G]) + (ae[ne] = G)];
                        return M.i = H, M.j = ne, Z;
                    })(i);
                }
                function m(S, D) {
                    return D.i = S.i, D.j = S.j, D.S = S.S.slice(), D;
                }
                function y(S, D) {
                    var _ = [], M = typeof S, P;
                    if (D && M == "object") for(P in S)try {
                        _.push(y(S[P], D - 1));
                    } catch  {}
                    return _.length ? _ : M == "string" ? S : S + "\0";
                }
                function C(S, D) {
                    for(var _ = S + "", M, P = 0; P < _.length;)D[u & P] = u & (M ^= D[u & P] * 19) + _.charCodeAt(P++);
                    return x(D);
                }
                function T() {
                    try {
                        var S;
                        return g && (S = g.randomBytes) ? S = S(i) : (S = new Uint8Array(i), (e.crypto || e.msCrypto).getRandomValues(S)), x(S);
                    } catch  {
                        var D = e.navigator, _ = D && D.plugins;
                        return [
                            +new Date,
                            e,
                            _,
                            e.screen,
                            x(n)
                        ];
                    }
                }
                function x(S) {
                    return String.fromCharCode.apply(0, S);
                }
                if (C(r.random(), n), t.exports) {
                    t.exports = h;
                    try {
                        g = ec;
                    } catch  {}
                } else r["seed" + s] = h;
            })(typeof self < "u" ? self : oL, [], Math);
        }(eh)), eh.exports;
    }
    var f5, m9;
    function cL() {
        if (m9) return f5;
        m9 = 1;
        var t = Kb(), e = Xb(), n = Zb(), r = Qb(), i = tL(), a = rL(), o = sL();
        return o.alea = t, o.xor128 = e, o.xorwow = n, o.xorshift7 = r, o.xor4096 = i, o.tychei = a, f5 = o, f5;
    }
    var lL = cL();
    const uL = Qa(lL), x3 = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ], fL = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
    ], S3 = 1e-6, E3 = 1e-12, { vtkErrorMacro: MT, vtkWarningMacro: U0 } = K;
    let bT = 0;
    const v9 = 20;
    function Hd(t) {
        return ()=>MT(`vtkMath::${t} - NOT IMPLEMENTED`);
    }
    function hd(t, e, n, r) {
        let i;
        for(let a = 0; a < e; a++)i = t[n * e + a], t[n * e + a] = t[r * e + a], t[r * e + a] = i;
    }
    function ed(t, e, n, r) {
        let i;
        for(let a = 0; a < e; a++)i = t[a * e + n], t[a * e + n] = t[a * e + r], t[a * e + r] = i;
    }
    function Jn() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
        const e = Array(t);
        for(let n = 0; n < t; ++n)e[n] = 0;
        return e;
    }
    const dL = ()=>Math.PI;
    function gL(t, e) {
        return e > 1023 ? t * 2 ** 1023 * 2 ** (e - 1023) : e < -1074 ? t * 2 ** -1074 * 2 ** (e + 1074) : t * 2 ** e;
    }
    function Sr(t) {
        return t / 180 * Math.PI;
    }
    function kh(t) {
        return t * 180 / Math.PI;
    }
    let D3, pL, mL, vL;
    ({ round: hL, floor: D3, ceil: pL, min: mL, max: vL } = Math);
    function yL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = 1 / 0;
        for(let i = e, a = t.length; i < a; i += n)t[i] < r && (r = t[i]);
        return r;
    }
    function CL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = -1 / 0;
        for(let i = e, a = t.length; i < a; i += n)r < t[i] && (r = t[i]);
        return r;
    }
    function wL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = 1 / 0, i = -1 / 0;
        for(let a = e, o = t.length; a < o; a += n)t[a] < r && (r = t[a]), i < t[a] && (i = t[a]);
        return [
            r,
            i
        ];
    }
    const TL = Hd("ceilLog2"), xL = Hd("factorial");
    El = function(t) {
        let e = 1;
        for(; e < t;)e *= 2;
        return e;
    };
    function td(t) {
        return t === El(t);
    }
    function SL(t, e) {
        let n = 1;
        for(let r = 1; r <= e; ++r)n *= (t - r + 1) / r;
        return Math.floor(n);
    }
    function EL(t, e) {
        if (t < e) return 0;
        const n = Jn(e);
        for(let r = 0; r < e; ++r)n[r] = r;
        return n;
    }
    function DL(t, e, n) {
        let r = 0;
        for(let i = e - 1; i >= 0; --i)if (n[i] < t - e + i) {
            let a = n[i] + 1;
            for(; i < e;)n[i++] = a++;
            r = 1;
            break;
        }
        return r;
    }
    function _L(t) {
        uL(`${t}`, {
            global: !0
        }), bT = t;
    }
    function RL() {
        return bT;
    }
    function OL() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1) - t;
        return t + n * Math.random();
    }
    const IL = Hd("gaussian");
    function Uh(t, e, n) {
        return n[0] = t[0] + e[0], n[1] = t[1] + e[1], n[2] = t[2] + e[2], n;
    }
    function zc(t, e, n) {
        return n[0] = t[0] - e[0], n[1] = t[1] - e[1], n[2] = t[2] - e[2], n;
    }
    function LT(t, e) {
        return t[0] *= e, t[1] *= e, t[2] *= e, t;
    }
    function PT(t, e) {
        return t[0] *= e, t[1] *= e, t;
    }
    function vv(t, e, n, r) {
        return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r[2] = t[2] + e[2] * n, r;
    }
    function ML(t, e, n, r) {
        return r[0] = t[0] + e[0] * n, r[1] = t[1] + e[1] * n, r;
    }
    function $t(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    }
    function bL(t, e, n) {
        n[0] = t[0] * e[0], n[1] = t[0] * e[1], n[2] = t[0] * e[2], n[3] = t[1] * e[0], n[4] = t[1] * e[1], n[5] = t[1] * e[2], n[6] = t[2] * e[0], n[7] = t[2] * e[1], n[8] = t[2] * e[2];
    }
    function tc(t, e, n) {
        const r = t[1] * e[2] - t[2] * e[1], i = t[2] * e[0] - t[0] * e[2], a = t[0] * e[1] - t[1] * e[0];
        return n[0] = r, n[1] = i, n[2] = a, n;
    }
    function bl(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
        switch(e){
            case 1:
                return Math.abs(t);
            case 2:
                return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
            case 3:
                return Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]);
            default:
                {
                    let n = 0;
                    for(let r = 0; r < e; r++)n += t[r] * t[r];
                    return Math.sqrt(n);
                }
        }
    }
    function F0(t) {
        const e = bl(t);
        return e !== 0 && (t[0] /= e, t[1] /= e, t[2] /= e), e;
    }
    function LL(t, e, n, r) {
        const i = t[0] * t[0], a = t[1] * t[1], o = t[2] * t[2], s = Math.sqrt(i + a + o);
        let c, l, f;
        i > a && i > o ? (c = 0, l = 1, f = 2) : a > o ? (c = 1, l = 2, f = 0) : (c = 2, l = 0, f = 1);
        const u = t[c] / s, g = t[l] / s, h = t[f] / s, v = Math.sqrt(u * u + h * h);
        if (r !== 0) {
            const m = Math.sin(r), y = Math.cos(r);
            e && (e[c] = (h * y - u * g * m) / v, e[l] = m * v, e[f] = (-(u * y) - g * h * m) / v), n && (n[c] = (-(h * m) - u * g * y) / v, n[l] = y * v, n[f] = (u * m - g * h * y) / v);
        } else e && (e[c] = h / v, e[l] = 0, e[f] = -u / v), n && (n[c] = -u * g / v, n[l] = v, n[f] = -g * h / v);
    }
    function PL(t, e, n) {
        const r = $t(e, e);
        if (r === 0) return n[0] = 0, n[1] = 0, n[2] = 0, !1;
        const i = $t(t, e) / r;
        for(let a = 0; a < 3; a++)n[a] = e[a];
        return LT(n, i), !0;
    }
    function yv(t, e) {
        return t[0] * e[0] + t[1] * e[1];
    }
    function VL(t, e, n) {
        const r = yv(e, e);
        if (r === 0) return n[0] = 0, n[1] = 0, !1;
        const i = yv(t, e) / r;
        for(let a = 0; a < 2; a++)n[a] = e[a];
        return PT(n, i), !0;
    }
    function Hs(t, e) {
        return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]) + (t[2] - e[2]) * (t[2] - e[2]);
    }
    function NL(t, e) {
        const n = [
            0,
            0,
            0
        ];
        return tc(t, e, n), Math.atan2(bl(n), $t(t, e));
    }
    function AL(t, e, n) {
        const r = Math.abs(t - n);
        return 1 / Math.sqrt(2 * Math.PI * e) * Math.exp(-(r ** 2) / (2 * e));
    }
    function kL(t, e, n) {
        const r = Math.abs(t - n);
        return Math.exp(-(r ** 2) / (2 * e));
    }
    function UL(t, e, n) {
        n[0] = t[0] * e[0], n[1] = t[0] * e[1], n[2] = t[1] * e[0], n[3] = t[1] * e[1];
    }
    function VT(t) {
        return Math.sqrt(t[0] * t[0] + t[1] * t[1]);
    }
    FL = function(t) {
        const e = VT(t);
        return e !== 0 && (t[0] /= e, t[1] /= e), e;
    };
    function Dr() {
        for(var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n];
        return e.length === 2 ? e[0][0] * e[1][1] - e[1][0] * e[0][1] : e.length === 4 ? e[0] * e[3] - e[1] * e[2] : Number.NaN;
    }
    function BL(t, e) {
        let n, r, i;
        const a = [
            0,
            0,
            0
        ];
        for(let o = 0; o < 3; o++)i = Math.abs(t[o * 3]), (r = Math.abs(t[o * 3 + 1])) > i && (i = r), (r = Math.abs(t[o * 3 + 2])) > i && (i = r), a[o] = 1 / i;
        i = a[0] * Math.abs(t[0]), n = 0, (r = a[1] * Math.abs(t[3])) >= i && (i = r, n = 1), (r = a[2] * Math.abs(t[6])) >= i && (n = 2), n !== 0 && (hd(t, 3, n, 0), a[n] = a[0]), e[0] = n, t[3] /= t[0], t[6] /= t[0], t[4] -= t[3] * t[1], t[7] -= t[6] * t[1], i = a[1] * Math.abs(t[4]), n = 1, (r = a[2] * Math.abs(t[7])) >= i && (n = 2, hd(t, 3, 1, 2), a[2] = a[1]), e[1] = n, t[7] /= t[4], t[5] -= t[3] * t[2], t[8] -= t[6] * t[2] + t[7] * t[5], e[2] = 2;
    }
    function GL(t, e, n) {
        let r = n[e[0]];
        n[e[0]] = n[0], n[0] = r, r = n[e[1]], n[e[1]] = n[1], n[1] = r - t[3] * n[0], r = n[e[2]], n[e[2]] = n[2], n[2] = r - t[6] * n[0] - t[7] * n[1], n[2] /= t[8], n[1] = (n[1] - t[5] * n[2]) / t[4], n[0] = (n[0] - t[1] * n[1] - t[2] * n[2]) / t[0];
    }
    function WL(t, e, n) {
        const r = t[0], i = t[1], a = t[2], o = t[3], s = t[4], c = t[5], l = t[6], f = t[7], u = t[8], g = +Dr(s, f, c, u), h = -Dr(o, l, c, u), v = +Dr(o, l, s, f), m = -Dr(i, f, a, u), y = +Dr(r, l, a, u), C = -Dr(r, l, i, f), T = +Dr(i, s, a, c), x = -Dr(r, o, a, c), S = +Dr(r, o, i, s), D = r * g + i * h + a * v, _ = g * e[0] + m * e[1] + T * e[2], M = h * e[0] + y * e[1] + x * e[2], P = v * e[0] + C * e[1] + S * e[2];
        n[0] = _ / D, n[1] = M / D, n[2] = P / D;
    }
    function th(t, e, n) {
        const r = t[0] * e[0] + t[1] * e[1] + t[2] * e[2], i = t[3] * e[0] + t[4] * e[1] + t[5] * e[2], a = t[6] * e[0] + t[7] * e[1] + t[8] * e[2];
        n[0] = r, n[1] = i, n[2] = a;
    }
    function Cv(t, e, n) {
        const r = [
            ...t
        ], i = [
            ...e
        ];
        for(let a = 0; a < 3; a++)n[a] = r[0] * i[a] + r[1] * i[a + 3] + r[2] * i[a + 6], n[a + 3] = r[3] * i[a] + r[4] * i[a + 3] + r[5] * i[a + 6], n[a + 6] = r[6] * i[a] + r[7] * i[a + 3] + r[8] * i[a + 6];
    }
    function $L(t, e, n, r, i, a, o) {
        r !== i && MT("Number of columns of A must match number of rows of B.");
        const s = [
            ...t
        ], c = [
            ...e
        ];
        for(let l = 0; l < n; l++)for(let f = 0; f < a; f++){
            o[l * a + f] = 0;
            for(let u = 0; u < r; u++)o[l * a + f] += s[l * r + u] * c[f + a * u];
        }
    }
    function Uu(t, e) {
        let n;
        n = t[3], e[3] = t[1], e[1] = n, n = t[6], e[6] = t[2], e[2] = n, n = t[7], e[7] = t[5], e[5] = n, e[0] = t[0], e[4] = t[4], e[8] = t[8];
    }
    function zL(t, e) {
        const n = t[0], r = t[1], i = t[2], a = t[3], o = t[4], s = t[5], c = t[6], l = t[7], f = t[8], u = +Dr(o, l, s, f), g = -Dr(a, c, s, f), h = +Dr(a, c, o, l), v = -Dr(r, l, i, f), m = +Dr(n, c, i, f), y = -Dr(n, c, r, l), C = +Dr(r, o, i, s), T = -Dr(n, a, i, s), x = +Dr(n, a, r, o), S = n * u + r * g + i * h;
        S === 0 && U0("Matrix has 0 determinant"), e[0] = u / S, e[3] = g / S, e[6] = h / S, e[1] = v / S, e[4] = m / S, e[7] = y / S, e[2] = C / S, e[5] = T / S, e[8] = x / S;
    }
    function Ip(t) {
        return t[0] * t[4] * t[8] + t[3] * t[7] * t[2] + t[6] * t[1] * t[5] - t[0] * t[7] * t[5] - t[3] * t[1] * t[8] - t[6] * t[4] * t[2];
    }
    function NT(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : S3;
        if (t.length !== e.length) return !1;
        function r(i, a) {
            return Math.abs(i - e[a]) <= n;
        }
        return t.every(r);
    }
    const Kd = NT;
    function AT(t) {
        for(let e = 0; e < 3; e++)t[e * 3] = t[e * 3 + 1] = t[e * 3 + 2] = 0, t[e * 3 + e] = 1;
    }
    function kT(t, e) {
        for(let n = 0; n < t; n++){
            for(let r = 0; r < t; r++)e[n * t + r] = 0;
            e[n * t + n] = 1;
        }
        return e;
    }
    function jL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S3;
        return Kd(t, x3, e);
    }
    function HL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : S3;
        return Kd(t, fL, e);
    }
    function UT(t, e) {
        const n = t[0] * t[0], r = t[0] * t[1], i = t[0] * t[2], a = t[0] * t[3], o = t[1] * t[1], s = t[2] * t[2], c = t[3] * t[3], l = t[1] * t[2], f = t[1] * t[3], u = t[2] * t[3], g = o + s + c;
        let h = 1 / (n + g);
        const v = (n - g) * h;
        h *= 2, e[0] = o * h + v, e[3] = (l + a) * h, e[6] = (f - i) * h, e[1] = (l - a) * h, e[4] = s * h + v, e[7] = (u + r) * h, e[2] = (f + i) * h, e[5] = (u - r) * h, e[8] = c * h + v;
    }
    function nh(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (!`${t}`.includes("e")) return +`${Math.round(`${t}e+${e}`)}e-${e}`;
        const n = `${t}`.split("e");
        let r = "";
        return +n[1] + e > 0 && (r = "+"), +`${Math.round(`${+n[0]}e${r}${+n[1] + e}`)}e-${e}`;
    }
    function wv(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
            0,
            0,
            0
        ], n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        return e[0] = nh(t[0], n), e[1] = nh(t[1], n), e[2] = nh(t[2], n), e;
    }
    function qd(t, e, n, r) {
        let i, a, o, s, c, l, f, u, g, h, v, m, y, C, T, x;
        const S = Jn(e), D = Jn(e), _ = (P, F, N)=>{
            C = P[F], y = P[N], P[F] = C - m * (y + C * h), P[N] = y + m * (C - y * h);
        };
        for(kT(e, r), c = 0; c < e; c++)S[c] = n[c] = t[c + c * e], D[c] = 0;
        for(i = 0; i < v9; i++){
            for(v = 0, c = 0; c < e - 1; c++)for(s = c + 1; s < e; s++)v += Math.abs(t[c * e + s]);
            if (v === 0) break;
            for(i < 3 ? f = .2 * v / (e * e) : f = 0, c = 0; c < e - 1; c++)for(s = c + 1; s < e; s++)if (C = 100 * Math.abs(t[c * e + s]), i > 3 && Math.abs(n[c]) + C === Math.abs(n[c]) && Math.abs(n[s]) + C === Math.abs(n[s])) t[c * e + s] = 0;
            else if (Math.abs(t[c * e + s]) > f) {
                for(y = n[s] - n[c], Math.abs(y) + C === Math.abs(y) ? g = t[c * e + s] / y : (u = .5 * y / t[c * e + s], g = 1 / (Math.abs(u) + Math.sqrt(1 + u * u)), u < 0 && (g = -g)), T = 1 / Math.sqrt(1 + g * g), m = g * T, h = m / (1 + T), y = g * t[c * e + s], D[c] -= y, D[s] += y, n[c] -= y, n[s] += y, t[c * e + s] = 0, a = 0; a <= c - 1; a++)_(t, a * e + c, a * e + s);
                for(a = c + 1; a <= s - 1; a++)_(t, c * e + a, a * e + s);
                for(a = s + 1; a < e; a++)_(t, c * e + a, s * e + a);
                for(a = 0; a < e; a++)_(r, a * e + c, a * e + s);
            }
            for(c = 0; c < e; c++)S[c] += D[c], n[c] = S[c], D[c] = 0;
        }
        if (i >= v9) return U0("vtkMath::Jacobi: Error extracting eigenfunctions"), 0;
        for(a = 0; a < e - 1; a++){
            for(o = a, x = n[o], i = a + 1; i < e; i++)(n[i] >= x || Math.abs(n[i] - x) < E3) && (o = i, x = n[o]);
            o !== a && (n[o] = n[a], n[a] = x, ed(r, e, a, o));
        }
        const M = (e >> 1) + (e & 1);
        for(l = 0, i = 0; i < e * e; i++)r[i] >= 0 && l++;
        if (l < M) for(i = 0; i < e; i++)r[i * e + a] *= -1;
        return 1;
    }
    function FT(t, e) {
        const n = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ];
        n[0] = t[0] + t[4] + t[8], n[5] = t[0] - t[4] - t[8], n[10] = -t[0] + t[4] - t[8], n[15] = -t[0] - t[4] + t[8], n[1] = n[4] = t[7] - t[5], n[2] = n[8] = t[2] - t[6], n[3] = n[12] = t[3] - t[1], n[6] = n[9] = t[3] + t[1], n[7] = n[13] = t[2] + t[6], n[11] = n[14] = t[7] + t[5];
        const r = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ], i = [
            0,
            0,
            0,
            0
        ], a = [
            ...n
        ];
        qd(a, 4, i, r), e[0] = r[0], e[1] = r[4], e[2] = r[8], e[3] = r[12];
    }
    function KL(t, e, n) {
        const r = t[0] * e[0], i = t[0] * e[1], a = t[0] * e[2], o = t[0] * e[3], s = t[1] * e[0], c = t[1] * e[1], l = t[1] * e[2], f = t[1] * e[3], u = t[2] * e[0], g = t[2] * e[1], h = t[2] * e[2], v = t[2] * e[3], m = t[3] * e[0], y = t[3] * e[1], C = t[3] * e[2], T = t[3] * e[3];
        n[0] = r - c - h - T, n[1] = i + s + v - C, n[2] = a - f + u + y, n[3] = o + l - g + m;
    }
    function BT(t, e) {
        for(let g = 0; g < 9; g++)e[g] = t[g];
        const n = Jn(3), r = Jn(3);
        let i;
        for(let g = 0; g < 3; g++){
            const h = Math.abs(e[g * 3]), v = Math.abs(e[g * 3 + 1]), m = Math.abs(e[g * 3 + 2]);
            i = v > h ? v : h, i = m > i ? m : i, n[g] = 1, i !== 0 && (n[g] /= i);
        }
        const a = Math.abs(e[0]) * n[0], o = Math.abs(e[3]) * n[1], s = Math.abs(e[6]) * n[2];
        r[0] = 0, i = a, o >= i && (i = o, r[0] = 1), s >= i && (r[0] = 2), r[0] !== 0 && (ed(e, 3, r[0], 0), n[r[0]] = n[0]);
        const c = Math.abs(e[4]) * n[1], l = Math.abs(e[7]) * n[2];
        r[1] = 1, i = c, l >= i && (r[1] = 2, ed(e, 3, 1, 2)), r[2] = 2;
        let f = 0;
        if (Ip(e) < 0) {
            f = 1;
            for(let g = 0; g < 9; g++)e[g] = -e[g];
        }
        const u = Jn(4);
        if (FT(e, u), UT(u, e), f) for(let g = 0; g < 9; g++)e[g] = -e[g];
        r[1] !== 1 && ed(e, 3, r[1], 1), r[0] !== 0 && ed(e, 3, r[0], 0);
    }
    function GT(t, e, n) {
        let r, i, a, o, s, c;
        const l = [
            ...t
        ];
        if (qd(l, 3, e, n), e[0] === e[1] && e[0] === e[2]) {
            AT(n);
            return;
        }
        for(Uu(n, n), r = 0; r < 3; r++)if (e[(r + 1) % 3] === e[(r + 2) % 3]) {
            for(c = Math.abs(n[r * 3]), o = 0, i = 1; i < 3; i++)c < (s = Math.abs(n[r * 3 + i])) && (c = s, o = i);
            o !== r && (s = e[o], e[o] = e[r], e[r] = s, hd(n, 3, r, o)), n[o * 3 + o] < 0 && (n[o * 3] = -n[o * 3], n[o * 3 + 1] = -n[o * 3 + 1], n[o * 3 + 2] = -n[o * 3 + 2]), i = (o + 1) % 3, a = (o + 2) % 3, n[i * 3] = 0, n[i * 3 + 1] = 0, n[i * 3 + 2] = 0, n[i * 3 + i] = 1;
            const f = tc([
                n[o * 3],
                n[o * 3 + 1],
                n[o * 3 + 2]
            ], [
                n[i * 3],
                n[i * 3 + 1],
                n[i * 3 + 2]
            ], []);
            F0(f);
            const u = tc(f, [
                n[o * 3],
                n[o * 3 + 1],
                n[o * 3 + 2]
            ], []);
            for(let g = 0; g < 3; g++)n[a * 3 + g] = f[g], n[i * 3 + g] = u[g];
            Uu(n, n);
            return;
        }
        for(c = Math.abs(n[0]), o = 0, r = 1; r < 3; r++)c < (s = Math.abs(n[r * 3])) && (c = s, o = r);
        if (o !== 0) {
            const f = e[o];
            e[o] = e[0], e[0] = f, hd(n, 3, o, 0);
        }
        if (Math.abs(n[4]) < Math.abs(n[7])) {
            const f = e[2];
            e[2] = e[1], e[1] = f, hd(n, 3, 1, 2);
        }
        for(r = 0; r < 2; r++)n[r * 3 + r] < 0 && (n[r * 3] = -n[r * 3], n[r * 3 + 1] = -n[r * 3 + 1], n[r * 3 + 2] = -n[r * 3 + 2]);
        Ip(n) < 0 && (n[6] = -n[6], n[7] = -n[7], n[8] = -n[8]), Uu(n, n);
    }
    function qL(t, e, n, r) {
        let i;
        const a = [
            ...t
        ], o = Ip(a);
        if (o < 0) for(i = 0; i < 9; i++)a[i] = -a[i];
        BT(a, e), Uu(a, a), Cv(a, e, r), GT(r, n, r), Cv(e, r, e), Uu(r, r), o < 0 && (n[0] = -n[0], n[1] = -n[1], n[2] = -n[2]);
    }
    function _3(t, e, n) {
        let r, i, a, o, s = 0, c, l, f;
        const u = Jn(n);
        for(r = 0; r < n; r++){
            for(o = 0, i = 0; i < n; i++)(f = Math.abs(t[r * n + i])) > o && (o = f);
            if (o === 0) return U0("Unable to factor linear system"), 0;
            u[r] = 1 / o;
        }
        for(i = 0; i < n; i++){
            for(r = 0; r < i; r++){
                for(c = t[r * n + i], a = 0; a < r; a++)c -= t[r * n + a] * t[a * n + i];
                t[r * n + i] = c;
            }
            for(o = 0, r = i; r < n; r++){
                for(c = t[r * n + i], a = 0; a < i; a++)c -= t[r * n + a] * t[a * n + i];
                t[r * n + i] = c, (l = u[r] * Math.abs(c)) >= o && (o = l, s = r);
            }
            if (i !== s) {
                for(a = 0; a < n; a++)l = t[s * n + a], t[s * n + a] = t[i * n + a], t[i * n + a] = l;
                u[s] = u[i];
            }
            if (e[i] = s, Math.abs(t[i * n + i]) <= E3) return U0("Unable to factor linear system"), 0;
            if (i !== n - 1) for(l = 1 / t[i * n + i], r = i + 1; r < n; r++)t[r * n + i] *= l;
        }
        return 1;
    }
    function R3(t, e, n, r) {
        let i, a, o, s, c;
        for(o = -1, i = 0; i < r; i++){
            if (s = e[i], c = n[s], n[s] = n[i], o >= 0) for(a = o; a <= i - 1; a++)c -= t[i * r + a] * n[a];
            else c !== 0 && (o = i);
            n[i] = c;
        }
        for(i = r - 1; i >= 0; i--){
            for(c = n[i], a = i + 1; a < r; a++)c -= t[i * r + a] * n[a];
            n[i] = c / t[i * r + i];
        }
    }
    function WT(t, e, n) {
        if (n === 2) {
            const i = Jn(2), a = Dr(t[0], t[1], t[2], t[3]);
            return a === 0 ? 0 : (i[0] = (t[3] * e[0] - t[1] * e[1]) / a, i[1] = (-(t[2] * e[0]) + t[0] * e[1]) / a, e[0] = i[0], e[1] = i[1], 1);
        }
        if (n === 1) return t[0] === 0 ? 0 : (e[0] /= t[0], 1);
        const r = Jn(n);
        return _3(t, r, n) === 0 ? 0 : (R3(t, r, e, n), 1);
    }
    function $T(t, e, n) {
        let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
        const a = r || Jn(n), o = i || Jn(n);
        if (_3(t, a, n) === 0) return null;
        for(let s = 0; s < n; s++){
            for(let c = 0; c < n; c++)o[c] = 0;
            o[s] = 1, R3(t, a, o, n);
            for(let c = 0; c < n; c++)e[c * n + s] = o[c];
        }
        return e;
    }
    function XL(t, e) {
        let n = +Number.MAX_VALUE, r = -Number.MAX_VALUE;
        for(let i = 0; i < e; i++)for(let a = i; a < e; a++)Math.abs(t[i * e + a]) > r && (r = Math.abs(t[i * e + a]));
        for(let i = 0; i < e; i++)Math.abs(t[i * e + i]) < n && (n = Math.abs(t[i * e + i]));
        return n === 0 ? Number.MAX_VALUE : r / n;
    }
    function YL(t, e, n) {
        return qd(t, 3, e, n);
    }
    function Tv(t, e, n, r) {
        if (t < n) return U0("Insufficient number of samples. Underdetermined."), 0;
        let i, a, o;
        const s = Jn(n * n), c = Jn(n), l = Jn(n * n);
        for(o = 0; o < t; o++)for(i = 0; i < n; i++)for(a = i; a < n; a++)s[i * n + a] += e[o * n + i] * e[o * n + a];
        for(i = 0; i < n; i++)for(a = 0; a < i; a++)s[i * n + a] = s[a * n + i];
        for(qd(s, n, c, l), i = 0; i < n; i++)r[i] = l[i * n + n - 1];
        return 1;
    }
    function ZL(t, e, n, r, i, a) {
        let o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !0;
        if (t < n || t < i) return U0("Insufficient number of samples. Underdetermined."), 0;
        const s = Jn(i);
        let c = 1, l, f = 0, u, g, h, v = 0;
        if (o) {
            for(g = 0; g < i; g++)s[g] = 1;
            for(u = 0; u < t; u++)for(g = 0; g < i; g++)Math.abs(r[u * i + g]) > E3 && (c = 0, s[g] = 0);
            if (c && i === 1) return U0("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"), Tv(t, e, n, a);
            if (c) v = 1;
            else for(g = 0; g < i; g++)s[g] && (v = 1);
        }
        v && (l = Jn(n), f = Tv(t, e, n, l));
        const m = Jn(n * n), y = Jn(n * n), C = Jn(n * i);
        for(h = 0; h < t; h++)for(u = 0; u < n; u++){
            for(g = u; g < n; g++)m[u * n + g] += e[h * n + u] * e[h * n + g];
            for(g = 0; g < i; g++)C[u * i + g] += e[h * n + u] * r[h * i + g];
        }
        for(u = 0; u < n; u++)for(g = 0; g < u; g++)m[u * n + g] = m[g * n + u];
        const T = $T(m, y, n);
        if (T) for(u = 0; u < n; u++)for(g = 0; g < i; g++)for(a[u * i + g] = 0, h = 0; h < n; h++)a[u * i + g] += y[u * n + h] * C[h * i + g];
        if (v) {
            for(g = 0; g < i; g++)if (s[g]) for(u = 0; u < n; u++)a[u * i + g] = l[u * i];
        }
        return v ? f && T : T;
    }
    function JL(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
            0,
            .5,
            1
        ];
        switch(t.length){
            case 3:
                return e[0] = parseInt(t[0], 16) * 17 / 255, e[1] = parseInt(t[1], 16) * 17 / 255, e[2] = parseInt(t[2], 16) * 17 / 255, e;
            case 4:
                return e[0] = parseInt(t[1], 16) * 17 / 255, e[1] = parseInt(t[2], 16) * 17 / 255, e[2] = parseInt(t[3], 16) * 17 / 255, e;
            case 6:
                return e[0] = parseInt(t.substr(0, 2), 16) / 255, e[1] = parseInt(t.substr(2, 2), 16) / 255, e[2] = parseInt(t.substr(4, 2), 16) / 255, e;
            case 7:
                return e[0] = parseInt(t.substr(1, 2), 16) / 255, e[1] = parseInt(t.substr(3, 2), 16) / 255, e[2] = parseInt(t.substr(5, 2), 16) / 255, e;
            case 9:
                return e[0] = parseInt(t.substr(1, 2), 16) / 255, e[1] = parseInt(t.substr(3, 2), 16) / 255, e[2] = parseInt(t.substr(5, 2), 16) / 255, e[3] = parseInt(t.substr(7, 2), 16) / 255, e;
            default:
                return e;
        }
    }
    function nd(t, e) {
        let n, r;
        const [i, a, o] = t, s = 1 / 3, c = 1 / 6, l = 2 / 3;
        let f = i, u = i;
        a > f ? f = a : a < u && (u = a), o > f ? f = o : o < u && (u = o);
        const g = f;
        g > 0 ? r = (f - u) / f : r = 0, r > 0 ? (i === f ? n = c * (a - o) / (f - u) : a === f ? n = s + c * (o - i) / (f - u) : n = l + c * (i - a) / (f - u), n < 0 && (n += 1)) : n = 0, e[0] = n, e[1] = r, e[2] = g;
    }
    function R0(t, e) {
        const [n, r, i] = t, a = 1 / 3, o = 1 / 6, s = 2 / 3, c = 5 / 6;
        let l, f, u;
        n > o && n <= a ? (f = 1, l = (a - n) / o, u = 0) : n > a && n <= .5 ? (f = 1, u = (n - a) / o, l = 0) : n > .5 && n <= s ? (u = 1, f = (s - n) / o, l = 0) : n > s && n <= c ? (u = 1, l = (n - s) / o, f = 0) : n > c && n <= 1 ? (l = 1, u = (1 - n) / o, f = 0) : (l = 1, f = n / o, u = 0), l = r * l + (1 - r), f = r * f + (1 - r), u = r * u + (1 - r), l *= i, f *= i, u *= i, e[0] = l, e[1] = f, e[2] = u;
    }
    function zT(t, e) {
        const [n, r, i] = t;
        let a = (n + 16) / 116, o = r / 500 + a, s = a - i / 200;
        a ** 3 > .008856 ? a **= 3 : a = (a - 16 / 116) / 7.787, o ** 3 > .008856 ? o **= 3 : o = (o - 16 / 116) / 7.787, s ** 3 > .008856 ? s **= 3 : s = (s - 16 / 116) / 7.787;
        const c = .9505, l = 1, f = 1.089;
        e[0] = c * o, e[1] = l * a, e[2] = f * s;
    }
    function jT(t, e) {
        const [n, r, i] = t, a = .9505, o = 1, s = 1.089;
        let c = n / a, l = r / o, f = i / s;
        c > .008856 ? c **= 1 / 3 : c = 7.787 * c + 16 / 116, l > .008856 ? l **= 1 / 3 : l = 7.787 * l + 16 / 116, f > .008856 ? f **= 1 / 3 : f = 7.787 * f + 16 / 116, e[0] = 116 * l - 16, e[1] = 500 * (c - l), e[2] = 200 * (l - f);
    }
    function HT(t, e) {
        const [n, r, i] = t;
        let a = n * 3.2406 + r * -1.5372 + i * -.4986, o = n * -.9689 + r * 1.8758 + i * .0415, s = n * .0557 + r * -.204 + i * 1.057;
        a > .0031308 ? a = 1.055 * a ** (1 / 2.4) - .055 : a *= 12.92, o > .0031308 ? o = 1.055 * o ** (1 / 2.4) - .055 : o *= 12.92, s > .0031308 ? s = 1.055 * s ** (1 / 2.4) - .055 : s *= 12.92;
        let c = a;
        c < o && (c = o), c < s && (c = s), c > 1 && (a /= c, o /= c, s /= c), a < 0 && (a = 0), o < 0 && (o = 0), s < 0 && (s = 0), e[0] = a, e[1] = o, e[2] = s;
    }
    function KT(t, e) {
        let [n, r, i] = t;
        n > .04045 ? n = ((n + .055) / 1.055) ** 2.4 : n /= 12.92, r > .04045 ? r = ((r + .055) / 1.055) ** 2.4 : r /= 12.92, i > .04045 ? i = ((i + .055) / 1.055) ** 2.4 : i /= 12.92, e[0] = n * .4124 + r * .3576 + i * .1805, e[1] = n * .2126 + r * .7152 + i * .0722, e[2] = n * .0193 + r * .1192 + i * .9505;
    }
    function I0(t, e) {
        const n = [
            0,
            0,
            0
        ];
        KT(t, n), jT(n, e);
    }
    function Fh(t, e) {
        const n = [
            0,
            0,
            0
        ];
        zT(t, n), HT(n, e);
    }
    function af(t) {
        return t[0] = 1, t[1] = -1, t[2] = 1, t[3] = -1, t[4] = 1, t[5] = -1, t;
    }
    function rh(t) {
        return !(t[1] - t[0] < 0);
    }
    function QL(t, e, n) {
        return n[0] = Math.min(t[0], e[0]), n[1] = Math.max(t[0], e[0]), n[2] = Math.min(t[1], e[1]), n[3] = Math.max(t[1], e[1]), n[4] = Math.min(t[2], e[2]), n[5] = Math.max(t[2], e[2]), n;
    }
    function ys(t, e, n) {
        return t < e ? e : t > n ? n : t;
    }
    function xv(t, e, n) {
        let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [
            0,
            0,
            0
        ];
        return r[0] = ys(t[0], e[0], n[0]), r[1] = ys(t[1], e[1], n[1]), r[2] = ys(t[2], e[2], n[2]), r;
    }
    function eP(t, e) {
        let n = 0;
        return e[0] !== e[1] && (t < e[0] ? n = e[0] : t > e[1] ? n = e[1] : n = t, n = (n - e[0]) / (e[1] - e[0])), n;
    }
    const tP = Hd("GetScalarTypeFittingRange"), nP = Hd("GetAdjustedScalarRange");
    function rP(t, e) {
        if (!t || !e) return 0;
        for(let n = 0; n < 6; n += 2)if (t[n] < e[n] || t[n] > e[n + 1] || t[n + 1] < e[n] || t[n + 1] > e[n + 1]) return 0;
        return 1;
    }
    function iP(t, e, n) {
        if (!t || !e) return 0;
        for(let r = 0; r < 6; r += 2)if (t[r] + n[r / 2] < e[r] || t[r] - n[r / 2] > e[r + 1] || t[r + 1] + n[r / 2] < e[r] || t[r + 1] - n[r / 2] > e[r + 1]) return 0;
        return 1;
    }
    function aP(t, e, n) {
        if (!t || !e || !n) return 0;
        for(let r = 0; r < 3; r++)if (t[r] + n[r] < e[2 * r] || t[r] - n[r] > e[2 * r + 1]) return 0;
        return 1;
    }
    function oP(t, e, n, r) {
        const i = Jn(3), a = Jn(3), o = Jn(3), s = Jn(3), c = Jn(3), l = Jn(3);
        for(let S = 0; S < 3; ++S)i[S] = t[S] - e[S], a[S] = e[S] - n[S], o[S] = n[S] - t[S], s[S] = -i[S], c[S] = -a[S], l[S] = -o[S];
        const f = bl(s), u = bl(c), g = bl(o), h = Jn(3);
        tc(i, a, h);
        const v = bl(h), m = f * u * g / (2 * v), y = 2 * v * v, C = u * u * $t(i, l) / y, T = g * g * $t(s, a) / y, x = f * f * $t(o, c) / y;
        for(let S = 0; S < 3; ++S)r[S] = C * t[S] + T * e[S] + x * n[S];
        return m;
    }
    const sP = 1 / 0, cP = -1 / 0, qT = (t)=>!Number.isFinite(t), { isFinite: lP, isNaN: Sv } = Number, Bh = Sv;
    function Gl() {
        return [].concat([
            Number.MAX_VALUE,
            -Number.MAX_VALUE,
            Number.MAX_VALUE,
            -Number.MAX_VALUE,
            Number.MAX_VALUE,
            -Number.MAX_VALUE
        ]);
    }
    function uP(t) {
        let e = -1, n = -1;
        for(let r = 0; r < t.length; r++){
            const i = Math.abs(t[r]);
            i > e && (n = r, e = i);
        }
        return n;
    }
    function XT(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
        const n = new Array(e), r = new Array(e);
        for(let a = 0; a < e; ++a)n[a] = a, r[a] = a;
        for(let a = e - 1; a > 0; a--){
            let o = -1 / 0, s = 0, c = 0;
            for(let l = 0; l <= a; ++l){
                const f = n[l];
                for(let u = 0; u <= a; ++u){
                    const g = r[u], h = Math.abs(t[f + e * g]);
                    h > o && (o = h, s = l, c = u);
                }
            }
            [n[a], n[s]] = [
                n[s],
                n[a]
            ], [r[a], r[c]] = [
                r[c],
                r[a]
            ];
        }
        const i = new Array(e * e).fill(0);
        for(let a = 0; a < e; ++a){
            const o = n[a] + e * r[a];
            i[o] = t[o] < 0 ? -1 : 1;
        }
        return i;
    }
    function YT(t) {
        const e = Math.floor(t * 255);
        return e > 15 ? e.toString(16) : `0${e.toString(16)}`;
    }
    function fP(t) {
        return `${arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#"}${t.map(YT).join("")}`;
    }
    function g1(t) {
        return Math.round(t * 255);
    }
    function dP(t) {
        return t.length === 3 ? `rgb(${t.map(g1).join(", ")})` : `rgba(${g1(t[0] || 0)}, ${g1(t[1] || 0)}, ${g1(t[2] || 0)}, ${t[3] || 0})`;
    }
    Xo = {
        Pi: dL,
        ldexp: gL,
        radiansFromDegrees: Sr,
        degreesFromRadians: kh,
        round: hL,
        floor: D3,
        ceil: pL,
        ceilLog2: TL,
        min: mL,
        max: vL,
        arrayMin: yL,
        arrayMax: CL,
        arrayRange: wL,
        isPowerOfTwo: td,
        nearestPowerOfTwo: El,
        factorial: xL,
        binomial: SL,
        beginCombination: EL,
        nextCombination: DL,
        randomSeed: _L,
        getSeed: RL,
        random: OL,
        gaussian: IL,
        add: Uh,
        subtract: zc,
        multiplyScalar: LT,
        multiplyScalar2D: PT,
        multiplyAccumulate: vv,
        multiplyAccumulate2D: ML,
        dot: $t,
        outer: bL,
        cross: tc,
        norm: bl,
        normalize: F0,
        perpendiculars: LL,
        projectVector: PL,
        projectVector2D: VL,
        distance2BetweenPoints: Hs,
        angleBetweenVectors: NL,
        gaussianAmplitude: AL,
        gaussianWeight: kL,
        dot2D: yv,
        outer2D: UL,
        norm2D: VT,
        normalize2D: FL,
        determinant2x2: Dr,
        LUFactor3x3: BL,
        LUSolve3x3: GL,
        linearSolve3x3: WL,
        multiply3x3_vect3: th,
        multiply3x3_mat3: Cv,
        multiplyMatrix: $L,
        transpose3x3: Uu,
        invert3x3: zL,
        identity3x3: AT,
        identity: kT,
        isIdentity: jL,
        isIdentity3x3: HL,
        determinant3x3: Ip,
        quaternionToMatrix3x3: UT,
        areEquals: NT,
        areMatricesEqual: Kd,
        roundNumber: nh,
        roundVector: wv,
        matrix3x3ToQuaternion: FT,
        multiplyQuaternion: KL,
        orthogonalize3x3: BT,
        diagonalize3x3: GT,
        singularValueDecomposition3x3: qL,
        solveLinearSystem: WT,
        invertMatrix: $T,
        luFactorLinearSystem: _3,
        luSolveLinearSystem: R3,
        estimateMatrixCondition: XL,
        jacobi: YL,
        jacobiN: qd,
        solveHomogeneousLeastSquares: Tv,
        solveLeastSquares: ZL,
        hex2float: JL,
        rgb2hsv: nd,
        hsv2rgb: R0,
        lab2xyz: zT,
        xyz2lab: jT,
        xyz2rgb: HT,
        rgb2xyz: KT,
        rgb2lab: I0,
        lab2rgb: Fh,
        uninitializeBounds: af,
        areBoundsInitialized: rh,
        computeBoundsFromPoints: QL,
        clampValue: ys,
        clampVector: xv,
        clampAndNormalizeValue: eP,
        getScalarTypeFittingRange: tP,
        getAdjustedScalarRange: nP,
        extentIsWithinOtherExtent: rP,
        boundsIsWithinOtherBounds: iP,
        pointIsWithinBounds: aP,
        solve3PointCircle: oP,
        inf: sP,
        negInf: cP,
        isInf: qT,
        isNan: Sv,
        isNaN: Sv,
        isFinite: lP,
        createUninitializedBounds: Gl,
        getMajorAxisIndex: uP,
        getSparseOrthogonalMatrix: XT,
        floatToHex2: YT,
        floatRGB2HexCode: fP,
        float2CssRGBA: dP
    };
    let qt, hP;
    gP = {
        Int8Array: 1,
        Uint8Array: 1,
        Uint8ClampedArray: 1,
        Int16Array: 2,
        Uint16Array: 2,
        Int32Array: 4,
        Uint32Array: 4,
        Float32Array: 4,
        Float64Array: 8
    };
    qt = {
        VOID: "",
        CHAR: "Int8Array",
        SIGNED_CHAR: "Int8Array",
        UNSIGNED_CHAR: "Uint8Array",
        UNSIGNED_CHAR_CLAMPED: "Uint8ClampedArray",
        SHORT: "Int16Array",
        UNSIGNED_SHORT: "Uint16Array",
        INT: "Int32Array",
        UNSIGNED_INT: "Uint32Array",
        FLOAT: "Float32Array",
        DOUBLE: "Float64Array"
    };
    hP = qt.FLOAT;
    var ZT = {
        DefaultDataType: hP,
        DataTypeByteSize: gP,
        VtkDataTypes: qt
    };
    const { vtkErrorMacro: pP } = da, { DefaultDataType: mP } = ZT, vP = 1e-6;
    function Ev(t, e, n) {
        const r = t.length;
        let i = Number.MAX_VALUE, a = -Number.MAX_VALUE, o, s;
        for(s = e; s < r; s += n)if (!Number.isNaN(t[s])) {
            i = t[s], a = i;
            break;
        }
        for(; s < r; s += n)o = t[s], o < i ? i = o : o > a && (a = o);
        return {
            min: i,
            max: a
        };
    }
    function yP() {
        let t = Number.MAX_VALUE, e = -Number.MAX_VALUE, n = 0, r = 0;
        return {
            add (i) {
                t > i && (t = i), e < i && (e = i), n++, r += i;
            },
            get () {
                return {
                    min: t,
                    max: e,
                    count: n,
                    sum: r,
                    mean: r / n
                };
            },
            getRange () {
                return {
                    min: t,
                    max: e
                };
            }
        };
    }
    function JT(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
        if (e < 0 && n > 1) {
            const i = t.length / n, a = new Float64Array(i);
            for(let o = 0, s = 0; o < i; ++o){
                for(let c = s + n; s < c; ++s)a[o] += t[s] * t[s];
                a[o] **= .5;
            }
            return Ev(a, 0, 1);
        }
        return Ev(t, e < 0 ? 0 : e, n);
    }
    function y9(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        const n = t || [];
        for(; n.length <= e;)n.push(null);
        return n;
    }
    function O3(t) {
        return Object.prototype.toString.call(t).slice(8, -1);
    }
    function CP(t) {
        const e = t.getNumberOfComponents();
        let n = 0;
        const r = new Array(e);
        for(let i = 0; i < t.getNumberOfTuples(); ++i){
            t.getTuple(i, r);
            const a = bl(r, e);
            a > n && (n = a);
        }
        return n;
    }
    const wP = {
        computeRange: JT,
        createRangeHelper: yP,
        fastComputeRange: Ev,
        getDataType: O3,
        getMaxNorm: CP
    };
    function TP(t, e) {
        e.classHierarchy.push("vtkDataArray");
        function n(r) {
            if (r < 0) return !1;
            const i = t.getNumberOfComponents(), a = e.values.length / (i > 0 ? i : 1);
            if (r === a) return !0;
            if (r > a) {
                const o = e.values;
                return e.values = nf(e.dataType, (r + a) * i), e.values.set(o), !0;
            }
            return e.size > r * i && (e.size = r * i, t.dataChange()), !0;
        }
        t.dataChange = ()=>{
            e.ranges = null, t.modified();
        }, t.resize = (r)=>{
            n(r);
            const i = r * t.getNumberOfComponents();
            return e.size !== i ? (e.size = i, t.dataChange(), !0) : !1;
        }, t.initialize = ()=>{
            t.resize(0);
        }, t.getElementComponentSize = ()=>e.values.BYTES_PER_ELEMENT, t.getComponent = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return e.values[r * e.numberOfComponents + i];
        }, t.setComponent = (r, i, a)=>{
            a !== e.values[r * e.numberOfComponents + i] && (e.values[r * e.numberOfComponents + i] = a, t.dataChange());
        }, t.getValue = (r)=>{
            const i = r / e.numberOfComponents, a = r % e.numberOfComponents;
            return t.getComponent(i, a);
        }, t.setValue = (r, i)=>{
            const a = r / e.numberOfComponents, o = r % e.numberOfComponents;
            t.setComponent(a, o, i);
        }, t.getData = ()=>e.size === e.values.length ? e.values : e.values.subarray(0, e.size), t.getRange = function() {
            let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1, i = r;
            i < 0 && (i = e.numberOfComponents === 1 ? 0 : e.numberOfComponents);
            let a = null;
            return e.ranges || (e.ranges = y9(e.ranges, e.numberOfComponents)), a = e.ranges[i], a ? (e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple) : (a = JT(t.getData(), r, e.numberOfComponents), e.ranges[i] = a, e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple);
        }, t.setRange = (r, i)=>{
            e.ranges || (e.ranges = y9(e.ranges, e.numberOfComponents));
            const a = {
                min: r.min,
                max: r.max
            };
            return e.ranges[i] = a, e.rangeTuple[0] = a.min, e.rangeTuple[1] = a.max, e.rangeTuple;
        }, t.getRanges = function() {
            if (!(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0)) return structuredClone(e.ranges);
            const i = [];
            for(let a = 0; a < e.numberOfComponents; a++){
                const [o, s] = t.getRange(a), c = {
                    min: o,
                    max: s
                };
                i.push(c);
            }
            if (e.numberOfComponents > 1) {
                const [a, o] = t.getRange(-1), s = {
                    min: a,
                    max: o
                };
                i.push(s);
            }
            return i;
        }, t.setTuple = (r, i)=>{
            const a = r * e.numberOfComponents;
            for(let o = 0; o < e.numberOfComponents; o++)e.values[a + o] = i[o];
        }, t.setTuples = (r, i)=>{
            let a = r * e.numberOfComponents;
            const o = Math.min(i.length, e.size - a);
            for(let s = 0; s < o;)e.values[a++] = i[s++];
        }, t.insertTuple = (r, i)=>(e.size <= r * e.numberOfComponents && (e.size = (r + 1) * e.numberOfComponents, n(r + 1)), t.setTuple(r, i), r), t.insertTuples = (r, i)=>{
            const a = r + i.length / e.numberOfComponents;
            return e.size < a * e.numberOfComponents && (e.size = a * e.numberOfComponents, n(a)), t.setTuples(r, i), a;
        }, t.insertNextTuple = (r)=>{
            const i = e.size / e.numberOfComponents;
            return t.insertTuple(i, r);
        }, t.insertNextTuples = (r)=>{
            const i = e.size / e.numberOfComponents;
            return t.insertTuples(i, r);
        }, t.findTuple = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : vP;
            for(let a = 0; a < e.size; a += e.numberOfComponents)if (Math.abs(r[0] - e.values[a]) <= i) {
                let o = !0;
                for(let s = 1; s < e.numberOfComponents; ++s)if (Math.abs(r[s] - e.values[a + s]) > i) {
                    o = !1;
                    break;
                }
                if (o) return a / e.numberOfComponents;
            }
            return -1;
        }, t.getTuple = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            const a = e.numberOfComponents || 1, o = r * a;
            switch(a){
                case 4:
                    i[3] = e.values[o + 3];
                case 3:
                    i[2] = e.values[o + 2];
                case 2:
                    i[1] = e.values[o + 1];
                case 1:
                    i[0] = e.values[o];
                    break;
                default:
                    for(let s = a - 1; s >= 0; --s)i[s] = e.values[o + s];
            }
            return i;
        }, t.getTuples = (r, i)=>{
            const a = (r ?? 0) * e.numberOfComponents, o = (i ?? t.getNumberOfTuples()) * e.numberOfComponents, s = t.getData().subarray(a, o);
            return s.length > 0 ? s : null;
        }, t.getTupleLocation = function() {
            return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1) * e.numberOfComponents;
        }, t.getNumberOfComponents = ()=>e.numberOfComponents, t.getNumberOfValues = ()=>e.size, t.getNumberOfTuples = ()=>e.size / e.numberOfComponents, t.getDataType = ()=>e.dataType, t.newClone = ()=>ex({
                empty: !0,
                name: e.name,
                dataType: e.dataType,
                numberOfComponents: e.numberOfComponents
            }), t.getName = ()=>(e.name || (t.modified(), e.name = `vtkDataArray${t.getMTime()}`), e.name), t.setData = (r, i)=>{
            e.values = r, e.size = r.length, e.dataType = O3(r), i && (e.numberOfComponents = i), e.size % e.numberOfComponents !== 0 && (e.numberOfComponents = 1), t.dataChange();
        }, t.getState = ()=>{
            if (e.deleted) return null;
            const r = {
                ...e,
                vtkClass: t.getClassName()
            };
            r.values = Array.from(r.values), delete r.buffer, Object.keys(r).forEach((a)=>{
                r[a] || delete r[a];
            });
            const i = {};
            return Object.keys(r).sort().forEach((a)=>{
                i[a] = r[a];
            }), i.mtime && delete i.mtime, i;
        }, t.deepCopy = (r)=>{
            const i = t.getDataType(), a = e.values;
            t.shallowCopy(r), e.ranges = structuredClone(r.getRanges()), a?.length >= r.getNumberOfValues() && i === r.getDataType() ? (a.set(r.getData()), e.values = a, t.dataChange()) : t.setData(r.getData().slice());
        }, t.interpolateTuple = (r, i, a, o, s, c)=>{
            const l = e.numberOfComponents || 1;
            (l !== i.getNumberOfComponents() || l !== o.getNumberOfComponents()) && pP("numberOfComponents must match");
            const f = i.getTuple(a), u = o.getTuple(s), g = [];
            switch(g.length = l, l){
                case 4:
                    g[3] = f[3] + (u[3] - f[3]) * c;
                case 3:
                    g[2] = f[2] + (u[2] - f[2]) * c;
                case 2:
                    g[1] = f[1] + (u[1] - f[1]) * c;
                case 1:
                    g[0] = f[0] + (u[0] - f[0]) * c;
                    break;
                default:
                    for(let h = 0; h < l; h++)g[h] = f[h] + (u[h] - f[h]) * c;
            }
            return t.insertTuple(r, g);
        };
    }
    const xP = {
        name: "",
        numberOfComponents: 1,
        dataType: mP,
        rangeTuple: [
            0,
            0
        ]
    };
    function QT(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (Object.assign(e, xP, n), Array.isArray(n.values) && n.dataType === void 0 && console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"), !e.empty && !e.values && !e.size) throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
        if (e.values ? Array.isArray(e.values) && (e.values = Rp(e.dataType, e.values)) : e.values = nf(e.dataType, e.size), e.values && (e.size = e.size ?? e.values.length, e.dataType = O3(e.values)), tr(t, e), $d(t, e, [
            "name",
            "numberOfComponents"
        ]), e.size % e.numberOfComponents !== 0) throw new RangeError("model.size is not a multiple of model.numberOfComponents");
        TP(t, e);
    }
    const ex = kn(QT, "vtkDataArray");
    Wt = {
        newInstance: ex,
        extend: QT,
        ...wP,
        ...ZT
    };
    const SP = {
        MAGNITUDE: 0,
        COMPONENT: 1,
        RGBCOLORS: 2
    }, Dv = {
        LUMINANCE: 1,
        LUMINANCE_ALPHA: 2,
        RGB: 3,
        RGBA: 4
    };
    var I3 = {
        VectorMode: SP,
        ScalarMappingTarget: Dv
    };
    const EP = {
        DEFAULT: 0,
        MAP_SCALARS: 1,
        DIRECT_SCALARS: 2
    }, DP = {
        DEFAULT: 0,
        USE_POINT_DATA: 1,
        USE_CELL_DATA: 2,
        USE_POINT_FIELD_DATA: 3,
        USE_CELL_FIELD_DATA: 4,
        USE_FIELD_DATA: 5
    }, _P = {
        BY_ID: 0,
        BY_NAME: 1
    };
    M3 = {
        ColorMode: EP,
        GetArray: _P,
        ScalarMode: DP
    };
    const { ScalarMappingTarget: C9, VectorMode: js } = I3, { VtkDataTypes: ml } = Wt, { ColorMode: h1 } = M3, { vtkErrorMacro: w9 } = K;
    function RP(t) {
        return t;
    }
    function T9(t) {
        return Math.floor(t * 255 + .5);
    }
    function OP(t, e) {
        e.classHierarchy.push("vtkScalarsToColors"), t.setVectorModeToMagnitude = ()=>t.setVectorMode(js.MAGNITUDE), t.setVectorModeToComponent = ()=>t.setVectorMode(js.COMPONENT), t.setVectorModeToRGBColors = ()=>t.setVectorMode(js.RGBCOLORS), t.build = ()=>{}, t.isOpaque = ()=>!0, t.setAnnotations = (n, r)=>{
            if (!(n && !r || !n && r)) {
                if (n && r && n.length !== r.length) {
                    w9("Values and annotations do not have the same number of tuples so ignoring");
                    return;
                }
                if (e.annotationArray = [], r && n) {
                    const i = r.length;
                    for(let a = 0; a < i; a++)e.annotationArray.push({
                        value: n[a],
                        annotation: String(r[a])
                    });
                }
                t.updateAnnotatedValueMap(), t.modified();
            }
        }, t.setAnnotation = (n, r)=>{
            let i = t.checkForAnnotatedValue(n), a = !1;
            return i >= 0 ? e.annotationArray[i].annotation !== r && (e.annotationArray[i].annotation = r, a = !0) : (e.annotationArray.push({
                value: n,
                annotation: r
            }), i = e.annotationArray.length - 1, a = !0), a && (t.updateAnnotatedValueMap(), t.modified()), i;
        }, t.getNumberOfAnnotatedValues = ()=>e.annotationArray.length, t.getAnnotatedValue = (n)=>n < 0 || n >= e.annotationArray.length ? null : e.annotationArray[n].value, t.getAnnotation = (n)=>e.annotationArray[n] === void 0 ? null : e.annotationArray[n].annotation, t.getAnnotatedValueIndex = (n)=>e.annotationArray.length ? t.checkForAnnotatedValue(n) : -1, t.removeAnnotation = (n)=>{
            const r = t.checkForAnnotatedValue(n), i = r >= 0;
            return i && (e.annotationArray.splice(r, 1), t.updateAnnotatedValueMap(), t.modified()), i;
        }, t.resetAnnotations = ()=>{
            e.annotationArray = [], e.annotatedValueMap = [], t.modified();
        }, t.getAnnotationColor = (n, r)=>{
            if (e.indexedLookup) {
                const i = t.getAnnotatedValueIndex(n);
                t.getIndexedColor(i, r);
            } else t.getColor(parseFloat(n), r), r[3] = 1;
        }, t.checkForAnnotatedValue = (n)=>t.getAnnotatedValueIndexInternal(n), t.getAnnotatedValueIndexInternal = (n)=>{
            if (e.annotatedValueMap[n] !== void 0) {
                const r = e.annotationArray.length;
                return e.annotatedValueMap[n] % r;
            }
            return -1;
        }, t.getIndexedColor = (n, r)=>{
            r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0;
        }, t.updateAnnotatedValueMap = ()=>{
            e.annotatedValueMap = [];
            const n = e.annotationArray.length;
            for(let r = 0; r < n; r++)e.annotatedValueMap[e.annotationArray[r].value] = r;
        }, t.mapScalars = (n, r, i)=>{
            const a = n.getNumberOfComponents();
            let o = null;
            if (r === h1.DEFAULT && (n.getDataType() === ml.UNSIGNED_CHAR || n.getDataType() === ml.UNSIGNED_CHAR_CLAMPED) || r === h1.DIRECT_SCALARS && n) o = t.convertToRGBA(n, a, n.getNumberOfTuples());
            else {
                const s = {
                    type: "vtkDataArray",
                    name: "temp",
                    numberOfComponents: 4,
                    dataType: ml.UNSIGNED_CHAR
                }, c = K.newTypedArray(s.dataType, 4 * n.getNumberOfTuples());
                s.values = c, s.size = c.length, o = Wt.newInstance(s);
                let l = i;
                l < 0 && a > 1 ? t.mapVectorsThroughTable(n, o, C9.RGBA, -1, -1) : (l < 0 && (l = 0), l >= a && (l = a - 1), t.mapScalarsThroughTable(n, o, C9.RGBA, l));
            }
            return o;
        }, t.mapVectorsToMagnitude = (n, r, i)=>{
            const a = n.getNumberOfTuples(), o = n.getNumberOfComponents(), s = r.getData(), c = n.getData();
            for(let l = 0; l < a; l++){
                let f = 0;
                for(let u = 0; u < i; u++)f += c[l * o + u] * c[l * o + u];
                s[l] = Math.sqrt(f);
            }
        }, t.mapVectorsThroughTable = (n, r, i, a, o)=>{
            let s = t.getVectorMode(), c = o, l = a;
            const f = n.getNumberOfComponents();
            s === js.COMPONENT ? (l === -1 && (l = t.getVectorComponent()), l < 0 && (l = 0), l >= f && (l = f - 1)) : (c === -1 && (c = t.getVectorSize()), c <= 0 ? (l = 0, c = f) : (l < 0 && (l = 0), l >= f && (l = f - 1), l + c > f && (c = f - l)), s === js.MAGNITUDE && (f === 1 || c === 1) && (s = js.COMPONENT));
            let u = 0;
            switch(l > 0 && (u = l), s){
                case js.COMPONENT:
                    {
                        t.mapScalarsThroughTable(n, r, i, u);
                        break;
                    }
                case js.RGBCOLORS:
                    break;
                case js.MAGNITUDE:
                default:
                    {
                        const g = Wt.newInstance({
                            numberOfComponents: 1,
                            values: new Float32Array(n.getNumberOfTuples())
                        });
                        t.mapVectorsToMagnitude(n, g, c), t.mapScalarsThroughTable(g, r, i, 0);
                        break;
                    }
            }
        }, t.luminanceToRGBA = (n, r, i, a)=>{
            const o = a(i), s = r.getData(), c = n.getData(), l = s.length, f = 0, u = 1;
            let g = 0;
            for(let h = f; h < l; h += u){
                const v = a(s[h]);
                c[g * 4] = v, c[g * 4 + 1] = v, c[g * 4 + 2] = v, c[g * 4 + 3] = o, g++;
            }
        }, t.luminanceAlphaToRGBA = (n, r, i, a)=>{
            const o = r.getData(), s = n.getData(), c = o.length, l = 0, f = 2;
            let u = 0;
            for(let g = l; g < c; g += f){
                const h = a(o[g]);
                s[u] = h, s[u + 1] = h, s[u + 2] = h, s[u + 3] = a(o[g + 1]) * i, u += 4;
            }
        }, t.rGBToRGBA = (n, r, i, a)=>{
            const o = T9(i), s = r.getData(), c = n.getData(), l = s.length, f = 0, u = 3;
            let g = 0;
            for(let h = f; h < l; h += u)c[g * 4] = a(s[h]), c[g * 4 + 1] = a(s[h + 1]), c[g * 4 + 2] = a(s[h + 2]), c[g * 4 + 3] = o, g++;
        }, t.rGBAToRGBA = (n, r, i, a)=>{
            const o = r.getData(), s = n.getData(), c = o.length, l = 0, f = 4;
            let u = 0;
            for(let g = l; g < c; g += f)s[u * 4] = a(o[g]), s[u * 4 + 1] = a(o[g + 1]), s[u * 4 + 2] = a(o[g + 2]), s[u * 4 + 3] = a(o[g + 3]) * i, u++;
        }, t.convertToRGBA = (n, r, i)=>{
            let { alpha: a } = e;
            if (r === 4 && a >= 1 && n.getDataType() === ml.UNSIGNED_CHAR) return n;
            const o = Wt.newInstance({
                numberOfComponents: 4,
                empty: !0,
                size: 4 * i,
                dataType: ml.UNSIGNED_CHAR
            });
            if (i <= 0) return o;
            a = a > 0 ? a : 0, a = a < 1 ? a : 1;
            let s = RP;
            switch((n.getDataType() === ml.FLOAT || n.getDataType() === ml.DOUBLE) && (s = T9), r){
                case 1:
                    t.luminanceToRGBA(o, n, a, s);
                    break;
                case 2:
                    t.luminanceAlphaToRGBA(o, n, s);
                    break;
                case 3:
                    t.rGBToRGBA(o, n, a, s);
                    break;
                case 4:
                    t.rGBAToRGBA(o, n, a, s);
                    break;
                default:
                    return w9("Cannot convert colors"), null;
            }
            return o;
        }, t.usingLogScale = ()=>!1, t.getNumberOfAvailableColors = ()=>256 * 256 * 256, t.setRange = (n, r)=>t.setMappingRange(n, r), t.getRange = ()=>t.getMappingRange(), t.areScalarsOpaque = (n, r, i)=>{
            if (!n) return t.isOpaque();
            const a = n.getNumberOfComponents();
            return r === h1.DEFAULT && n.getDataType() === ml.UNSIGNED_CHAR || r === h1.DIRECT_SCALARS ? a === 3 || a === 1 ? e.alpha >= 1 : n.getRange(a - 1)[0] === 255 : !0;
        };
    }
    const IP = {
        alpha: 1,
        vectorComponent: 0,
        vectorSize: -1,
        vectorMode: js.COMPONENT,
        mappingRange: null,
        annotationArray: null,
        annotatedValueMap: null,
        indexedLookup: !1
    };
    function tx(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, IP, n), K.obj(t, e), e.mappingRange = [
            0,
            255
        ], e.annotationArray = [], e.annotatedValueMap = [], K.setGet(t, e, [
            "vectorSize",
            "vectorComponent",
            "vectorMode",
            "alpha",
            "indexedLookup"
        ]), K.setArray(t, e, [
            "mappingRange"
        ], 2), K.getArray(t, e, [
            "mappingRange"
        ]), OP(t, e);
    }
    const MP = K.newInstance(tx, "vtkScalarsToColors");
    b3 = {
        newInstance: MP,
        extend: tx,
        ...I3
    };
    const bP = {
        RGB: 0,
        HSV: 1,
        LAB: 2,
        DIVERGING: 3
    }, LP = {
        LINEAR: 0,
        LOG10: 1
    };
    var nx = {
        ColorSpace: bP,
        Scale: LP
    };
    const { ColorSpace: Ho, Scale: L3 } = nx, { ScalarMappingTarget: p1 } = b3, { vtkDebugMacro: PP, vtkErrorMacro: Mc, vtkWarningMacro: VP } = K;
    function x9(t, e) {
        const n = t[0], r = t[1], i = t[2], a = Math.sqrt(n * n + r * r + i * i), o = a > .001 ? Math.acos(n / a) : 0, s = o > .001 ? Math.atan2(i, r) : 0;
        e[0] = a, e[1] = o, e[2] = s;
    }
    function NP(t, e) {
        const n = t[0], r = t[1], i = t[2];
        e[0] = n * Math.cos(r), e[1] = n * Math.sin(r) * Math.cos(i), e[2] = n * Math.sin(r) * Math.sin(i);
    }
    function S9(t, e) {
        if (t[0] >= e - .1) return t[2];
        const n = t[1] * Math.sqrt(e * e - t[0] * t[0]) / (t[0] * Math.sin(t[1]));
        return t[2] > -.3 * Math.PI ? t[2] + n : t[2] - n;
    }
    function AP(t, e) {
        let n = t - e;
        for(n < 0 && (n = -n); n >= 2 * Math.PI;)n -= 2 * Math.PI;
        return n > Math.PI && (n = 2 * Math.PI - n), n;
    }
    function E9(t, e, n, r) {
        const i = [], a = [];
        I0(e, i), I0(n, a);
        const o = [], s = [];
        x9(i, o), x9(a, s);
        let c = t;
        if (o[1] > .05 && s[1] > .05 && AP(o[2], s[2]) > .33 * Math.PI) {
            let u = Math.max(o[0], s[0]);
            u = Math.max(88, u), t < .5 ? (s[0] = u, s[1] = 0, s[2] = 0, c *= 2) : (o[0] = u, o[1] = 0, o[2] = 0, c = 2 * c - 1);
        }
        o[1] < .05 && s[1] > .05 ? o[2] = S9(s, o[0]) : s[1] < .05 && o[1] > .05 && (s[2] = S9(o, s[0]));
        const l = [];
        l[0] = (1 - c) * o[0] + c * s[0], l[1] = (1 - c) * o[1] + c * s[1], l[2] = (1 - c) * o[2] + c * s[2];
        const f = [];
        NP(l, f), Fh(f, r);
    }
    function kP(t, e) {
        e.classHierarchy.push("vtkColorTransferFunction"), t.getSize = ()=>e.nodes.length, t.addRGBPoint = (n, r, i, a)=>t.addRGBPointLong(n, r, i, a, .5, 0), t.addRGBPointLong = function(n, r, i, a) {
            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .5, s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
            if (o < 0 || o > 1) return Mc("Midpoint outside range [0.0, 1.0]"), -1;
            if (s < 0 || s > 1) return Mc("Sharpness outside range [0.0, 1.0]"), -1;
            e.allowDuplicateScalars || t.removePoint(n);
            const c = {
                x: n,
                r,
                g: i,
                b: a,
                midpoint: o,
                sharpness: s
            };
            e.nodes.push(c), t.sortAndUpdateRange();
            let l = 0;
            for(; l < e.nodes.length && e.nodes[l].x !== n; l++);
            return l < e.nodes.length ? l : -1;
        }, t.addHSVPoint = (n, r, i, a)=>t.addHSVPointLong(n, r, i, a, .5, 0), t.addHSVPointLong = function(n, r, i, a) {
            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .5, s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
            const c = [];
            return R0([
                r,
                i,
                a
            ], c), t.addRGBPoint(n, c[0], c[1], c[2], o, s);
        }, t.setNodes = (n)=>{
            if (e.nodes !== n) {
                const r = JSON.stringify(e.nodes);
                e.nodes = n;
                const i = JSON.stringify(e.nodes);
                if (t.sortAndUpdateRange() || r !== i) return t.modified(), !0;
            }
            return !1;
        }, t.sortAndUpdateRange = ()=>{
            const n = JSON.stringify(e.nodes);
            e.nodes.sort((a, o)=>a.x - o.x);
            const r = JSON.stringify(e.nodes), i = t.updateRange();
            return !i && n !== r ? (t.modified(), !0) : i;
        }, t.updateRange = ()=>{
            const n = [
                2
            ];
            n[0] = e.mappingRange[0], n[1] = e.mappingRange[1];
            const r = e.nodes.length;
            return r ? (e.mappingRange[0] = e.nodes[0].x, e.mappingRange[1] = e.nodes[r - 1].x) : (e.mappingRange[0] = 0, e.mappingRange[1] = 0), n[0] === e.mappingRange[0] && n[1] === e.mappingRange[1] ? !1 : (t.modified(), !0);
        }, t.removePoint = (n)=>{
            let r = 0;
            for(; r < e.nodes.length && e.nodes[r].x !== n; r++);
            const i = r;
            if (r >= e.nodes.length) return -1;
            let a = !1;
            return e.nodes.splice(r, 1), (r === 0 || r === e.nodes.length) && (a = t.updateRange()), a || t.modified(), i;
        }, t.movePoint = (n, r)=>{
            if (n !== r) {
                t.removePoint(r);
                for(let i = 0; i < e.nodes.length; i++)if (e.nodes[i].x === n) {
                    e.nodes[i].x = r, t.sortAndUpdateRange();
                    break;
                }
            }
        }, t.removeAllPoints = ()=>{
            e.nodes = [], t.sortAndUpdateRange();
        }, t.addRGBSegment = (n, r, i, a, o, s, c, l)=>{
            t.sortAndUpdateRange();
            for(let f = 0; f < e.nodes.length;)e.nodes[f].x >= n && e.nodes[f].x <= o ? e.nodes.splice(f, 1) : f++;
            t.addRGBPointLong(n, r, i, a, .5, 0), t.addRGBPointLong(o, s, c, l, .5, 0), t.modified();
        }, t.addHSVSegment = (n, r, i, a, o, s, c, l)=>{
            const f = [
                r,
                i,
                a
            ], u = [
                s,
                c,
                l
            ], g = [], h = [];
            R0(f, g), R0(u, h), t.addRGBSegment(n, g[0], g[1], g[2], o, h[0], h[1], h[2]);
        }, t.mapValue = (n)=>{
            const r = [];
            return t.getColor(n, r), [
                Math.floor(255 * r[0] + .5),
                Math.floor(255 * r[1] + .5),
                Math.floor(255 * r[2] + .5),
                255
            ];
        }, t.getColor = (n, r)=>{
            if (e.indexedLookup) {
                const i = t.getSize(), a = t.getAnnotatedValueIndexInternal(n);
                if (a < 0 || i === 0) {
                    const o = t.getNanColorByReference();
                    r[0] = o[0], r[1] = o[1], r[2] = o[2];
                } else {
                    const o = [];
                    t.getNodeValue(a % i, o), r[0] = o[1], r[1] = o[2], r[2] = o[3];
                }
                return;
            }
            t.getTable(n, n, 1, r);
        }, t.getRedValue = (n)=>{
            const r = [];
            return t.getColor(n, r), r[0];
        }, t.getGreenValue = (n)=>{
            const r = [];
            return t.getColor(n, r), r[1];
        }, t.getBlueValue = (n)=>{
            const r = [];
            return t.getColor(n, r), r[2];
        }, t.getTable = (n, r, i, a)=>{
            const o = Number(n), s = Number(r);
            if (Bh(o) || Bh(s)) {
                for(let F = 0; F < i; F++)a[F * 3 + 0] = e.nanColor[0], a[F * 3 + 1] = e.nanColor[1], a[F * 3 + 2] = e.nanColor[2];
                return;
            }
            let c = 0;
            const l = e.nodes.length;
            let f = 0, u = 0, g = 0;
            l !== 0 && (f = e.nodes[l - 1].r, u = e.nodes[l - 1].g, g = e.nodes[l - 1].b);
            let h = 0, v = 0, m = 0;
            const y = [
                0,
                0,
                0
            ], C = [
                0,
                0,
                0
            ];
            let T = 0, x = 0;
            const S = [];
            let D = e.scale === L3.LOG10;
            D && (D = e.mappingRange[0] > 0);
            let _ = 0, M = 0, P = 0;
            D && (_ = Math.log10(o), M = Math.log10(s));
            for(let F = 0; F < i; F++){
                const N = 3 * F;
                if (i > 1 ? D ? (P = _ + F / (i - 1) * (M - _), h = 10 ** P) : h = o + F / (i - 1) * (s - o) : D ? (P = .5 * (_ + M), h = 10 ** P) : h = .5 * (o + s), e.discretize) {
                    const B = e.mappingRange;
                    if (h >= B[0] && h <= B[1]) {
                        const G = e.numberOfValues, Z = B[1] - B[0];
                        if (G <= 1) h = B[0] + Z / 2;
                        else {
                            const H = (h - B[0]) / Z, ne = D3(G * H);
                            h = B[0] + ne / (G - 1) * Z;
                        }
                    }
                }
                for(; c < l && h > e.nodes[c].x;)c++, c < l && (v = e.nodes[c - 1].x, m = e.nodes[c].x, D && (v = Math.log10(v), m = Math.log10(m)), y[0] = e.nodes[c - 1].r, C[0] = e.nodes[c].r, y[1] = e.nodes[c - 1].g, C[1] = e.nodes[c].g, y[2] = e.nodes[c - 1].b, C[2] = e.nodes[c].b, T = e.nodes[c - 1].midpoint, x = e.nodes[c - 1].sharpness, T < 1e-5 && (T = 1e-5), T > .99999 && (T = .99999));
                if (h > e.mappingRange[1]) a[N] = 0, a[N + 1] = 0, a[N + 2] = 0, e.clamping && (t.getUseAboveRangeColor() ? (a[N] = e.aboveRangeColor[0], a[N + 1] = e.aboveRangeColor[1], a[N + 2] = e.aboveRangeColor[2]) : (a[N] = f, a[N + 1] = u, a[N + 2] = g));
                else if (h < e.mappingRange[0] || qT(h) && h < 0) a[N] = 0, a[N + 1] = 0, a[N + 2] = 0, e.clamping && (t.getUseBelowRangeColor() ? (a[N] = e.belowRangeColor[0], a[N + 1] = e.belowRangeColor[1], a[N + 2] = e.belowRangeColor[2]) : l > 0 && (a[N] = e.nodes[0].r, a[N + 1] = e.nodes[0].g, a[N + 2] = e.nodes[0].b));
                else if (c === 0 && (Math.abs(h - o) < 1e-6 || e.discretize)) l > 0 ? (a[N] = e.nodes[0].r, a[N + 1] = e.nodes[0].g, a[N + 2] = e.nodes[0].b) : (a[N] = 0, a[N + 1] = 0, a[N + 2] = 0);
                else {
                    let B = 0;
                    if (D ? B = (P - v) / (m - v) : B = (h - v) / (m - v), B < T ? B = .5 * B / T : B = .5 + .5 * (B - T) / (1 - T), x > .99) if (B < .5) {
                        a[N] = y[0], a[N + 1] = y[1], a[N + 2] = y[2];
                        continue;
                    } else {
                        a[N] = C[0], a[N + 1] = C[1], a[N + 2] = C[2];
                        continue;
                    }
                    if (x < .01) {
                        if (e.colorSpace === Ho.RGB) a[N] = (1 - B) * y[0] + B * C[0], a[N + 1] = (1 - B) * y[1] + B * C[1], a[N + 2] = (1 - B) * y[2] + B * C[2];
                        else if (e.colorSpace === Ho.HSV) {
                            const re = [], X = [];
                            nd(y, re), nd(C, X), e.hSVWrap && (re[0] - X[0] > .5 || X[0] - re[0] > .5) && (re[0] > X[0] ? re[0] -= 1 : X[0] -= 1);
                            const ie = [];
                            ie[0] = (1 - B) * re[0] + B * X[0], ie[0] < 0 && (ie[0] += 1), ie[1] = (1 - B) * re[1] + B * X[1], ie[2] = (1 - B) * re[2] + B * X[2], R0(ie, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2];
                        } else if (e.colorSpace === Ho.LAB) {
                            const re = [], X = [];
                            I0(y, re), I0(C, X);
                            const ie = [];
                            ie[0] = (1 - B) * re[0] + B * X[0], ie[1] = (1 - B) * re[1] + B * X[1], ie[2] = (1 - B) * re[2] + B * X[2], Fh(ie, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2];
                        } else e.colorSpace === Ho.DIVERGING ? (E9(B, y, C, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2]) : Mc("ColorSpace set to invalid value.", e.colorSpace);
                        continue;
                    }
                    B < .5 ? B = .5 * (B * 2) ** (1 + 10 * x) : B > .5 && (B = 1 - .5 * ((1 - B) * 2) ** (1 + 10 * x));
                    const G = B * B, Z = G * B, H = 2 * Z - 3 * G + 1, ne = -2 * Z + 3 * G, ae = Z - 2 * G + B, ue = Z - G;
                    let le, oe;
                    if (e.colorSpace === Ho.RGB) for(let re = 0; re < 3; re++)le = C[re] - y[re], oe = (1 - x) * le, a[N + re] = H * y[re] + ne * C[re] + ae * oe + ue * oe;
                    else if (e.colorSpace === Ho.HSV) {
                        const re = [], X = [];
                        nd(y, re), nd(C, X), e.hSVWrap && (re[0] - X[0] > .5 || X[0] - re[0] > .5) && (re[0] > X[0] ? re[0] -= 1 : X[0] -= 1);
                        const ie = [];
                        for(let he = 0; he < 3; he++)le = X[he] - re[he], oe = (1 - x) * le, ie[he] = H * re[he] + ne * X[he] + ae * oe + ue * oe, he === 0 && ie[he] < 0 && (ie[he] += 1);
                        R0(ie, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2];
                    } else if (e.colorSpace === Ho.LAB) {
                        const re = [], X = [];
                        I0(y, re), I0(C, X);
                        const ie = [];
                        for(let he = 0; he < 3; he++)le = X[he] - re[he], oe = (1 - x) * le, ie[he] = H * re[he] + ne * X[he] + ae * oe + ue * oe;
                        Fh(ie, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2];
                    } else e.colorSpace === Ho.DIVERGING ? (E9(B, y, C, S), a[N] = S[0], a[N + 1] = S[1], a[N + 2] = S[2]) : Mc("ColorSpace set to invalid value.");
                    for(let re = 0; re < 3; re++)a[N + re] = a[N + re] < 0 ? 0 : a[N + re], a[N + re] = a[N + re] > 1 ? 1 : a[N + re];
                }
            }
        }, t.getUint8Table = function(n, r, i) {
            let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            if (t.getMTime() <= e.buildTime && e.tableSize === i && e.tableWithAlpha !== a) return e.table;
            if (e.nodes.length === 0) return Mc("Attempting to lookup a value with no points in the function"), e.table;
            const o = a ? 4 : 3;
            (e.tableSize !== i || e.tableWithAlpha !== a) && (e.table = new Uint8Array(i * o), e.tableSize = i, e.tableWithAlpha = a);
            const s = [];
            t.getTable(n, r, i, s);
            for(let c = 0; c < i; c++)e.table[c * o + 0] = Math.floor(s[c * 3 + 0] * 255 + .5), e.table[c * o + 1] = Math.floor(s[c * 3 + 1] * 255 + .5), e.table[c * o + 2] = Math.floor(s[c * 3 + 2] * 255 + .5), a && (e.table[c * o + 3] = 255);
            return e.buildTime.modified(), e.table;
        }, t.buildFunctionFromArray = (n)=>{
            t.removeAllPoints();
            const r = n.getNumberOfComponents();
            for(let i = 0; i < n.getNumberOfTuples(); i++)switch(r){
                case 3:
                    {
                        e.nodes.push({
                            x: i,
                            r: n.getComponent(i, 0),
                            g: n.getComponent(i, 1),
                            b: n.getComponent(i, 2),
                            midpoint: .5,
                            sharpness: 0
                        });
                        break;
                    }
                case 4:
                    {
                        e.nodes.push({
                            x: n.getComponent(i, 0),
                            r: n.getComponent(i, 1),
                            g: n.getComponent(i, 2),
                            b: n.getComponent(i, 3),
                            midpoint: .5,
                            sharpness: 0
                        });
                        break;
                    }
                case 5:
                    {
                        e.nodes.push({
                            x: i,
                            r: n.getComponent(i, 0),
                            g: n.getComponent(i, 1),
                            b: n.getComponent(i, 2),
                            midpoint: n.getComponent(i, 4),
                            sharpness: n.getComponent(i, 5)
                        });
                        break;
                    }
                case 6:
                    {
                        e.nodes.push({
                            x: n.getComponent(i, 0),
                            r: n.getComponent(i, 1),
                            g: n.getComponent(i, 2),
                            b: n.getComponent(i, 3),
                            midpoint: n.getComponent(i, 4),
                            sharpness: n.getComponent(i, 5)
                        });
                        break;
                    }
            }
            t.sortAndUpdateRange();
        }, t.buildFunctionFromTable = (n, r, i, a)=>{
            let o = 0;
            t.removeAllPoints(), i > 1 && (o = (r - n) / (i - 1));
            for(let s = 0; s < i; s++){
                const c = {
                    x: n + o * s,
                    r: a[s * 3],
                    g: a[s * 3 + 1],
                    b: a[s * 3 + 2],
                    sharpness: 0,
                    midpoint: .5
                };
                e.nodes.push(c);
            }
            t.sortAndUpdateRange();
        }, t.getNodeValue = (n, r)=>n < 0 || n >= e.nodes.length ? (Mc("Index out of range!"), -1) : (r[0] = e.nodes[n].x, r[1] = e.nodes[n].r, r[2] = e.nodes[n].g, r[3] = e.nodes[n].b, r[4] = e.nodes[n].midpoint, r[5] = e.nodes[n].sharpness, 1), t.setNodeValue = (n, r)=>{
            if (n < 0 || n >= e.nodes.length) return Mc("Index out of range!"), -1;
            const i = e.nodes[n].x;
            return e.nodes[n].x = r[0], e.nodes[n].r = r[1], e.nodes[n].g = r[2], e.nodes[n].b = r[3], e.nodes[n].midpoint = r[4], e.nodes[n].sharpness = r[5], i !== r[0] ? t.sortAndUpdateRange() : t.modified(), 1;
        }, t.getNumberOfAvailableColors = ()=>{
            if (e.indexedLookup && t.getSize()) return t.getSize();
            if (e.tableSize) return e.tableSize;
            const n = e.nodes?.length ?? 0;
            return Math.max(4094, n);
        }, t.getIndexedColor = (n, r)=>{
            const i = t.getSize();
            if (i > 0 && n >= 0) {
                const o = [];
                t.getNodeValue(n % i, o);
                for(let s = 0; s < 3; ++s)r[s] = o[s + 1];
                r[3] = 1;
                return;
            }
            const a = t.getNanColorByReference();
            r[0] = a[0], r[1] = a[1], r[2] = a[2], r[3] = 1;
        }, t.fillFromDataPointer = (n, r)=>{
            if (!(n <= 0 || !r)) {
                t.removeAllPoints();
                for(let i = 0; i < n; i++)t.addRGBPoint(r[i * 4], r[i * 4 + 1], r[i * 4 + 2], r[i * 4 + 3]);
            }
        }, t.setMappingRange = (n, r)=>{
            const i = [
                n,
                r
            ], a = t.getRange();
            if (a[1] === i[1] && a[0] === i[0]) return;
            if (i[1] === i[0]) {
                Mc("attempt to set zero width color range");
                return;
            }
            const o = (i[1] - i[0]) / (a[1] - a[0]), s = i[0] - a[0] * o;
            for(let c = 0; c < e.nodes.length; ++c)e.nodes[c].x = e.nodes[c].x * o + s;
            e.mappingRange[0] = i[0], e.mappingRange[1] = i[1], t.modified();
        }, t.adjustRange = (n)=>{
            const r = t.getRange(), i = [];
            r[0] < n[0] ? (t.getColor(n[0], i), t.addRGBPoint(n[0], i[0], i[1], i[2])) : (t.getColor(r[0], i), t.addRGBPoint(n[0], i[0], i[1], i[2])), r[1] > n[1] ? (t.getColor(n[1], i), t.addRGBPoint(n[1], i[0], i[1], i[2])) : (t.getColor(r[1], i), t.addRGBPoint(n[1], i[0], i[1], i[2])), t.sortAndUpdateRange();
            for(let a = 0; a < e.nodes.length;)e.nodes[a].x >= n[0] && e.nodes[a].x <= n[1] ? e.nodes.splice(a, 1) : ++a;
            return 1;
        }, t.estimateMinNumberOfSamples = (n, r)=>{
            const i = t.findMinimumXDistance();
            return Math.ceil((r - n) / i);
        }, t.findMinimumXDistance = ()=>{
            if (e.nodes.length < 2) return -1;
            let n = Number.MAX_VALUE;
            for(let r = 0; r < e.nodes.length - 1; r++){
                const i = e.nodes[r + 1].x - e.nodes[r].x;
                i < n && (n = i);
            }
            return n;
        }, t.mapScalarsThroughTable = (n, r, i, a)=>{
            if (t.getSize() === 0) {
                PP("Transfer Function Has No Points!");
                return;
            }
            e.indexedLookup ? t.mapDataIndexed(n, r, i, a) : t.mapData(n, r, i, a);
        }, t.mapData = (n, r, i, a)=>{
            if (t.getSize() === 0) {
                VP("Transfer Function Has No Points!");
                return;
            }
            const o = Math.floor(t.getAlpha() * 255 + .5), s = n.getNumberOfTuples(), c = n.getNumberOfComponents(), l = r.getData(), f = n.getData(), u = [];
            if (i === p1.RGBA) for(let g = 0; g < s; g++){
                const h = f[g * c + a];
                t.getColor(h, u), l[g * 4] = Math.floor(u[0] * 255 + .5), l[g * 4 + 1] = Math.floor(u[1] * 255 + .5), l[g * 4 + 2] = Math.floor(u[2] * 255 + .5), l[g * 4 + 3] = o;
            }
            if (i === p1.RGB) for(let g = 0; g < s; g++){
                const h = f[g * c + a];
                t.getColor(h, u), l[g * 3] = Math.floor(u[0] * 255 + .5), l[g * 3 + 1] = Math.floor(u[1] * 255 + .5), l[g * 3 + 2] = Math.floor(u[2] * 255 + .5);
            }
            if (i === p1.LUMINANCE) for(let g = 0; g < s; g++){
                const h = f[g * c + a];
                t.getColor(h, u), l[g] = Math.floor(u[0] * 76.5 + u[1] * 150.45 + u[2] * 28.05 + .5);
            }
            if (i === p1.LUMINANCE_ALPHA) for(let g = 0; g < s; g++){
                const h = f[g * c + a];
                t.getColor(h, u), l[g * 2] = Math.floor(u[0] * 76.5 + u[1] * 150.45 + u[2] * 28.05 + .5), l[g * 2 + 1] = o;
            }
        }, t.applyColorMap = (n)=>{
            const r = JSON.stringify(e.colorSpace);
            n.ColorSpace && (e.colorSpace = Ho[n.ColorSpace.toUpperCase()], e.colorSpace === void 0 && (Mc(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`), e.colorSpace = Ho.RGB));
            let i = r !== JSON.stringify(e.colorSpace);
            const a = i || JSON.stringify(e.nanColor);
            if (n.NanColor) for(e.nanColor = [].concat(n.NanColor); e.nanColor.length < 4;)e.nanColor.push(1);
            i = i || a !== JSON.stringify(e.nanColor);
            const o = i || JSON.stringify(e.nodes);
            if (n.RGBPoints) {
                const l = n.RGBPoints.length;
                e.nodes = [];
                const f = .5, u = 0;
                for(let g = 0; g < l; g += 4)e.nodes.push({
                    x: n.RGBPoints[g],
                    r: n.RGBPoints[g + 1],
                    g: n.RGBPoints[g + 2],
                    b: n.RGBPoints[g + 3],
                    midpoint: f,
                    sharpness: u
                });
            }
            const s = t.sortAndUpdateRange(), c = !s && (i || o !== JSON.stringify(e.nodes));
            return c && t.modified(), s || c;
        };
    }
    const UP = {
        clamping: !0,
        colorSpace: Ho.RGB,
        hSVWrap: !0,
        scale: L3.LINEAR,
        nanColor: null,
        belowRangeColor: null,
        aboveRangeColor: null,
        useAboveRangeColor: !1,
        useBelowRangeColor: !1,
        allowDuplicateScalars: !1,
        table: null,
        tableSize: 0,
        buildTime: null,
        nodes: null,
        discretize: !1,
        numberOfValues: 256
    };
    function rx(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, UP, n), b3.extend(t, e, n), e.table = [], e.nodes = [], e.nanColor = [
            .5,
            0,
            0,
            1
        ], e.belowRangeColor = [
            0,
            0,
            0,
            1
        ], e.aboveRangeColor = [
            1,
            1,
            1,
            1
        ], e.buildTime = {}, K.obj(e.buildTime), K.get(t, e, [
            "buildTime",
            "mappingRange"
        ]), K.setGet(t, e, [
            "useAboveRangeColor",
            "useBelowRangeColor",
            "discretize",
            "numberOfValues",
            {
                type: "enum",
                name: "colorSpace",
                enum: Ho
            },
            {
                type: "enum",
                name: "scale",
                enum: L3
            }
        ]), K.setArray(t, e, [
            "nanColor",
            "belowRangeColor",
            "aboveRangeColor"
        ], 4), K.getArray(t, e, [
            "nanColor",
            "belowRangeColor",
            "aboveRangeColor"
        ]), kP(t, e);
    }
    const FP = K.newInstance(rx, "vtkColorTransferFunction");
    var Jc = {
        newInstance: FP,
        extend: rx,
        ...nx
    }, BP = [
        {
            Name: "KAAMS",
            IndexedColors: [
                1,
                1,
                1,
                1,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                1,
                1,
                1,
                0,
                1,
                0,
                1,
                0,
                1,
                1,
                .63,
                .63,
                1,
                .67,
                .5,
                .33,
                1,
                .5,
                .75,
                .53,
                .35,
                .7,
                1,
                .75,
                .5
            ],
            Annotations: [
                0,
                0,
                1,
                1,
                2,
                2,
                3,
                3,
                4,
                4,
                5,
                5,
                6,
                6,
                7,
                7,
                8,
                8,
                9,
                9,
                10,
                10,
                11,
                11
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Cool to Warm",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                .23137254902,
                .298039215686,
                .752941176471,
                .5,
                .865,
                .865,
                .865,
                1,
                .705882352941,
                .0156862745098,
                .149019607843
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Cool to Warm (Extended)",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                .34902,
                .03125,
                .039216,
                .062745,
                .380392,
                .0625,
                .062745,
                .117647,
                .411765,
                .09375,
                .090196,
                .184314,
                .45098,
                .125,
                .12549,
                .262745,
                .501961,
                .15625,
                .160784,
                .337255,
                .541176,
                .1875,
                .2,
                .396078,
                .568627,
                .21875,
                .239216,
                .454902,
                .6,
                .25,
                .286275,
                .521569,
                .65098,
                .28125,
                .337255,
                .592157,
                .701961,
                .3125,
                .388235,
                .654902,
                .74902,
                .34375,
                .466667,
                .737255,
                .819608,
                .375,
                .572549,
                .819608,
                .878431,
                .40625,
                .654902,
                .866667,
                .909804,
                .4375,
                .752941,
                .917647,
                .941176,
                .46875,
                .823529,
                .956863,
                .968627,
                .5,
                .988235,
                .960784,
                .901961,
                .5,
                .941176,
                .984314,
                .988235,
                .52,
                .988235,
                .945098,
                .85098,
                .54,
                .980392,
                .898039,
                .784314,
                .5625,
                .968627,
                .835294,
                .698039,
                .59375,
                .94902,
                .733333,
                .588235,
                .625,
                .929412,
                .65098,
                .509804,
                .65625,
                .909804,
                .564706,
                .435294,
                .6875,
                .878431,
                .458824,
                .352941,
                .71875,
                .839216,
                .388235,
                .286275,
                .75,
                .760784,
                .294118,
                .211765,
                .78125,
                .701961,
                .211765,
                .168627,
                .8125,
                .65098,
                .156863,
                .129412,
                .84375,
                .6,
                .094118,
                .094118,
                .875,
                .54902,
                .066667,
                .098039,
                .90625,
                .501961,
                .05098,
                .12549,
                .9375,
                .45098,
                .054902,
                .172549,
                .96875,
                .4,
                .054902,
                .192157,
                1,
                .34902,
                .070588,
                .211765
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Warm to Cool",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                .705882352941,
                .0156862745098,
                .149019607843,
                .5,
                .865,
                .865,
                .865,
                1,
                .23137254902,
                .298039215686,
                .752941176471
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Warm to Cool (Extended)",
            NanColor: [
                .250004,
                0,
                0
            ],
            RGBPoints: [
                0,
                .34902,
                0,
                .129412,
                .025,
                .4,
                .00392157,
                .101961,
                .05,
                .470588,
                .0156863,
                .0901961,
                .075,
                .54902,
                .027451,
                .0705882,
                .1,
                .619608,
                .0627451,
                .0431373,
                .125,
                .690196,
                .12549,
                .0627451,
                .15,
                .741176,
                .184314,
                .0745098,
                .175,
                .788235,
                .266667,
                .0941176,
                .2,
                .811765,
                .345098,
                .113725,
                .225,
                .831373,
                .411765,
                .133333,
                .25,
                .85098,
                .47451,
                .145098,
                .275,
                .870588,
                .54902,
                .156863,
                .3,
                .878431,
                .619608,
                .168627,
                .325,
                .890196,
                .658824,
                .196078,
                .35,
                .909804,
                .717647,
                .235294,
                .375,
                .929412,
                .776471,
                .278431,
                .395522,
                .94902,
                .823529,
                .321569,
                .418905,
                .968627,
                .87451,
                .407843,
                .444278,
                .980392,
                .917647,
                .509804,
                .470149,
                .988235,
                .956863,
                .643137,
                .483582,
                .992157,
                .964706,
                .713725,
                .499,
                .988235,
                .980392,
                .870588,
                .5,
                1,
                1,
                1,
                .501,
                .913725,
                .988235,
                .937255,
                .516418,
                .827451,
                .980392,
                .886275,
                .531343,
                .764706,
                .980392,
                .866667,
                .546766,
                .658824,
                .980392,
                .843137,
                .564179,
                .572549,
                .964706,
                .835294,
                .587562,
                .423529,
                .941176,
                .87451,
                .60597,
                .262745,
                .901961,
                .862745,
                .629851,
                .0705882,
                .854902,
                .870588,
                .651741,
                .0509804,
                .8,
                .85098,
                .681592,
                .0235294,
                .709804,
                .831373,
                .712935,
                .0313725,
                .615686,
                .811765,
                .75,
                .0313725,
                .537255,
                .788235,
                .775,
                .0392157,
                .466667,
                .768627,
                .8,
                .0509804,
                .396078,
                .741176,
                .825,
                .054902,
                .317647,
                .709804,
                .85,
                .054902,
                .243137,
                .678431,
                .875,
                .0431373,
                .164706,
                .639216,
                .9,
                .0313725,
                .0980392,
                .6,
                .925,
                .0392157,
                .0392157,
                .560784,
                .95,
                .105882,
                .0509804,
                .509804,
                .975,
                .113725,
                .0235294,
                .45098,
                1,
                .12549,
                0,
                .380392
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Rainbow Desaturated",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                .278431372549,
                .278431372549,
                .858823529412,
                .143,
                0,
                0,
                .360784313725,
                .285,
                0,
                1,
                1,
                .429,
                0,
                .501960784314,
                0,
                .571,
                1,
                1,
                0,
                .714,
                1,
                .380392156863,
                0,
                .857,
                .419607843137,
                0,
                0,
                1,
                .878431372549,
                .301960784314,
                .301960784314
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Cold and Hot",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                1,
                1,
                .45,
                0,
                0,
                1,
                .5,
                0,
                0,
                .501960784314,
                .55,
                1,
                0,
                0,
                1,
                1,
                1,
                0
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Black-Body Radiation",
            NanColor: [
                0,
                .498039215686,
                1
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                .4,
                .901960784314,
                0,
                0,
                .8,
                .901960784314,
                .901960784314,
                0,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "X Ray",
            NanColor: [
                1,
                0,
                0
            ],
            RGBPoints: [
                0,
                1,
                1,
                1,
                1,
                0,
                0,
                0
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Grayscale",
            NanColor: [
                1,
                0,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "BkRd",
            NanColor: [
                0,
                1,
                1
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                1,
                0,
                0
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "BkGn",
            NanColor: [
                1,
                0,
                1
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                0,
                1,
                0
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "BkBu",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "BkMa",
            NanColor: [
                0,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                1,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "BkCy",
            NanColor: [
                0,
                1,
                1
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                1,
                0,
                1,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Black, Blue and White",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                .333,
                0,
                0,
                .501960784314,
                .666,
                0,
                .501960784314,
                1,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Black, Orange and White",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                .333,
                .501960784314,
                0,
                0,
                .666,
                1,
                .501960784314,
                0,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Linear YGB 1211g",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                1,
                .988235,
                .968627,
                .02,
                1,
                .952941,
                .878431,
                .05,
                .968627,
                .905882,
                .776471,
                .1,
                .94902,
                .898039,
                .647059,
                .15,
                .901961,
                .878431,
                .556863,
                .2,
                .847059,
                .858824,
                .482353,
                .25,
                .690196,
                .819608,
                .435294,
                .3,
                .513725,
                .768627,
                .384314,
                .35,
                .337255,
                .721569,
                .337255,
                .4,
                .278431,
                .658824,
                .392157,
                .45,
                .231373,
                .639216,
                .435294,
                .5,
                .203922,
                .6,
                .486275,
                .55,
                .172549,
                .568627,
                .537255,
                .6,
                .141176,
                .517647,
                .54902,
                .65,
                .133333,
                .458824,
                .541176,
                .7,
                .12549,
                .396078,
                .529412,
                .75,
                .117647,
                .321569,
                .521569,
                .8,
                .121569,
                .258824,
                .509804,
                .85,
                .133333,
                .227451,
                .501961,
                .9,
                .145098,
                .192157,
                .490196,
                .95,
                .188235,
                .164706,
                .470588,
                1,
                .258824,
                .196078,
                .439216
            ]
        },
        {
            ColorSpace: "CIELAB",
            Creator: "Francesca Samsel",
            Name: "Linear Green (Gr4L)",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                .054902,
                .109804,
                .121569,
                .05,
                .07451,
                .172549,
                .180392,
                .1,
                .086275,
                .231373,
                .219608,
                .15,
                .094118,
                .278431,
                .25098,
                .2,
                .109804,
                .34902,
                .278431,
                .25,
                .113725,
                .4,
                .278431,
                .3,
                .117647,
                .45098,
                .270588,
                .35,
                .117647,
                .490196,
                .243137,
                .4,
                .113725,
                .521569,
                .203922,
                .45,
                .109804,
                .54902,
                .152941,
                .5,
                .082353,
                .588235,
                .082353,
                .55,
                .109804,
                .631373,
                .05098,
                .6,
                .211765,
                .678431,
                .082353,
                .65,
                .317647,
                .721569,
                .113725,
                .7,
                .431373,
                .760784,
                .160784,
                .75,
                .556863,
                .8,
                .239216,
                .8,
                .666667,
                .839216,
                .294118,
                .85,
                .784314,
                .878431,
                .396078,
                .9,
                .886275,
                .921569,
                .533333,
                .95,
                .960784,
                .94902,
                .670588,
                1,
                1,
                .984314,
                .901961
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Linear Blue (8_31f)",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                .960784,
                1,
                .980392,
                .05,
                .815686,
                .960784,
                .913725,
                .1,
                .670588,
                .929412,
                .870588,
                .15,
                .556863,
                .901961,
                .843137,
                .2,
                .478431,
                .870588,
                .823529,
                .25,
                .439216,
                .831373,
                .803922,
                .3,
                .4,
                .8,
                .788235,
                .35,
                .376471,
                .768627,
                .768627,
                .4,
                .34902,
                .709804,
                .729412,
                .45,
                .32549,
                .654902,
                .690196,
                .5,
                .301961,
                .607843,
                .658824,
                .55,
                .247059,
                .545098,
                .619608,
                .6,
                .239216,
                .494118,
                .580392,
                .65,
                .227451,
                .439216,
                .541176,
                .7,
                .227451,
                .403922,
                .521569,
                .75,
                .231373,
                .368627,
                .501961,
                .8,
                .227451,
                .321569,
                .470588,
                .85,
                .219608,
                .282353,
                .439216,
                .9,
                .192157,
                .235294,
                .4,
                .95,
                .160784,
                .184314,
                .34902,
                1,
                .133333,
                .12549,
                .301961
            ]
        },
        {
            ColorSpace: "HSV",
            Name: "Blue to Red Rainbow",
            NanColor: [
                .498039215686,
                .498039215686,
                .498039215686
            ],
            RGBPoints: [
                0,
                0,
                0,
                1,
                1,
                1,
                0,
                0
            ]
        },
        {
            ColorSpace: "HSV",
            Name: "Red to Blue Rainbow",
            NanColor: [
                .498039215686,
                .498039215686,
                .498039215686
            ],
            RGBPoints: [
                0,
                1,
                0,
                0,
                1,
                0,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Rainbow Blended White",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                1,
                1,
                1,
                .17,
                0,
                0,
                1,
                .34,
                0,
                1,
                1,
                .5,
                0,
                1,
                0,
                .67,
                1,
                1,
                0,
                .84,
                1,
                0,
                0,
                1,
                .878431372549,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Rainbow Blended Grey",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                .317647058824,
                .341176470588,
                .43137254902,
                .17,
                0,
                0,
                1,
                .34,
                0,
                1,
                1,
                .5,
                0,
                1,
                0,
                .67,
                1,
                1,
                0,
                .84,
                1,
                0,
                0,
                1,
                .878431372549,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Rainbow Blended Black",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                0,
                0,
                .17,
                0,
                0,
                1,
                .34,
                0,
                1,
                1,
                .5,
                0,
                1,
                0,
                .67,
                1,
                1,
                0,
                .84,
                1,
                0,
                0,
                1,
                .878431372549,
                0,
                1
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Blue to Yellow",
            NanColor: [
                1,
                0,
                0
            ],
            RGBPoints: [
                0,
                .0392156862745,
                .0392156862745,
                .949019607843,
                1,
                .949019607843,
                .949019607843,
                .0392156862745
            ]
        },
        {
            ColorSpace: "HSV",
            Name: "blot",
            RGBPoints: [
                0,
                0,
                0,
                1,
                .166,
                0,
                0,
                1,
                .167,
                1,
                0,
                1,
                .332,
                1,
                0,
                1,
                .333,
                0,
                1,
                1,
                .5,
                0,
                1,
                1,
                .501,
                0,
                1,
                0,
                .666,
                0,
                1,
                0,
                .667,
                1,
                1,
                0,
                .832,
                1,
                1,
                0,
                .833,
                1,
                0,
                0,
                1,
                1,
                0,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "CIELab Blue to Red",
            NanColor: [
                1,
                1,
                0
            ],
            RGBPoints: [
                0,
                0,
                .6,
                .749019607843,
                1,
                .76862745098,
                .466666666667,
                .341176470588
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "jet",
            RGBPoints: [
                -1,
                0,
                0,
                .5625,
                -.777778,
                0,
                0,
                1,
                -.269841,
                0,
                1,
                1,
                -.015873,
                .5,
                1,
                .5,
                .238095,
                1,
                1,
                0,
                .746032,
                1,
                0,
                0,
                1,
                .5,
                0,
                0
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "rainbow",
            RGBPoints: [
                -1,
                0,
                0,
                1,
                -.5,
                0,
                1,
                1,
                0,
                0,
                1,
                0,
                .5,
                1,
                1,
                0,
                1,
                1,
                0,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_rainbow_bright",
            RGBPoints: [
                -1,
                .32549,
                .14902,
                .960784,
                -.866221,
                .297047,
                .375586,
                .963836,
                -.732441,
                .180302,
                .536818,
                .964627,
                -.598662,
                .1302,
                .649207,
                .929647,
                -.464883,
                .0445143,
                .749654,
                .855998,
                -.331104,
                .0271325,
                .830713,
                .721527,
                -.197324,
                .259504,
                .866145,
                .543555,
                -.0635452,
                .428364,
                .890725,
                .329819,
                .0702341,
                .568503,
                .898508,
                .187623,
                .204013,
                .738259,
                .890317,
                .0825461,
                .337793,
                .84546,
                .86136,
                .0147555,
                .471572,
                .912191,
                .808018,
                0,
                .605351,
                .962848,
                .710445,
                0,
                .73913,
                .999469,
                .600258,
                .0176284,
                .87291,
                .994156,
                .445975,
                .193912,
                1,
                .980407,
                .247105,
                .262699
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_rainbow_dark",
            RGBPoints: [
                -1,
                0,
                0,
                .423499,
                -.866221,
                0,
                .119346,
                .529237,
                -.732441,
                0,
                .238691,
                .634976,
                -.598662,
                0,
                .346852,
                .68788,
                -.464883,
                0,
                .45022,
                .718141,
                -.331104,
                0,
                .553554,
                .664839,
                -.197324,
                0,
                .651082,
                .519303,
                -.0635452,
                .115841,
                .72479,
                .352857,
                .0702341,
                .326771,
                .781195,
                .140187,
                .204013,
                .522765,
                .798524,
                .0284624,
                .337793,
                .703162,
                .788685,
                .00885756,
                .471572,
                .845118,
                .751133,
                0,
                .605351,
                .955734,
                .690825,
                0,
                .73913,
                .995402,
                .567916,
                .0618524,
                .87291,
                .987712,
                .403398,
                .164851,
                1,
                .980407,
                .247105,
                .262699
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "nic_CubicL",
            RGBPoints: [
                -1,
                .479965,
                .0118108,
                .5307,
                -.87451,
                .522213,
                .0551282,
                .706919,
                -.74902,
                .50839,
                .237278,
                .867764,
                -.623529,
                .451617,
                .373834,
                .987255,
                -.498039,
                .39365,
                .497255,
                .97506,
                -.372549,
                .328631,
                .599639,
                .891843,
                -.247059,
                .250043,
                .690286,
                .778553,
                -.121569,
                .249656,
                .764905,
                .645857,
                .00392157,
                .297954,
                .821466,
                .50449,
                .129412,
                .337509,
                .872595,
                .358447,
                .254902,
                .430011,
                .913789,
                .297079,
                .380392,
                .587191,
                .931381,
                .333353,
                .505882,
                .727937,
                .93591,
                .353742,
                .631373,
                .826403,
                .921081,
                .365066,
                .756863,
                .893201,
                .846317,
                .372662,
                .882353,
                .965347,
                .73884,
                .378506,
                1,
                .983235,
                .597451,
                .366856
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "nic_CubicYF",
            RGBPoints: [
                -1,
                .5151,
                .0482,
                .6697,
                -.87451,
                .520711,
                .168955,
                .800574,
                -.74902,
                .493694,
                .278596,
                .911824,
                -.623529,
                .440026,
                .369475,
                .984978,
                -.498039,
                .398932,
                .457593,
                .987053,
                -.372549,
                .350651,
                .540644,
                .929608,
                -.247059,
                .298827,
                .615625,
                .857729,
                -.121569,
                .239928,
                .685061,
                .769531,
                .00392157,
                .228832,
                .739349,
                .673287,
                .129412,
                .263297,
                .78608,
                .569988,
                .254902,
                .298107,
                .828337,
                .460214,
                .380392,
                .33092,
                .864071,
                .352674,
                .505882,
                .38306,
                .898169,
                .287309,
                .631373,
                .49023,
                .917481,
                .307961,
                .756863,
                .62372,
                .926026,
                .332309,
                .882353,
                .717458,
                .92527,
                .342476,
                1,
                .8,
                .9255,
                .3529
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "gist_earth",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .239216,
                .027451,
                .415686,
                -.74902,
                .0901961,
                .254902,
                .556863,
                -.623529,
                .0941176,
                .352941,
                .54902,
                -.498039,
                .105882,
                .435294,
                .533333,
                -.372549,
                .12549,
                .52549,
                .501961,
                -.247059,
                .156863,
                .596078,
                .443137,
                -.121569,
                .196078,
                .65098,
                .380392,
                .00392157,
                .282353,
                .717647,
                .301961,
                .129412,
                .466667,
                .772549,
                .27451,
                .254902,
                .678431,
                .784314,
                .309804,
                .380392,
                .901961,
                .756863,
                .376471,
                .505882,
                .992157,
                .705882,
                .521569,
                .631373,
                1,
                .721569,
                .701961,
                .756863,
                1,
                .784314,
                .784314,
                .882353,
                1,
                .866667,
                .866667,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "2hot",
            RGBPoints: [
                -1,
                .0416667,
                0,
                0,
                -.873016,
                .208333,
                0,
                0,
                -.746032,
                .375,
                0,
                0,
                -.619048,
                .541667,
                0,
                0,
                -.492063,
                .708333,
                0,
                0,
                -.365079,
                .854137,
                0,
                0,
                -.238095,
                .937488,
                .039062,
                0,
                -.111111,
                1,
                .208333,
                0,
                .015873,
                1,
                .375,
                0,
                .142857,
                1,
                .541667,
                0,
                .269841,
                1,
                .708333,
                0,
                .396825,
                1,
                .858805,
                .03125,
                .52381,
                1,
                .947392,
                .15625,
                .650794,
                1,
                1,
                .3125,
                .777778,
                1,
                1,
                .5625,
                .904762,
                1,
                1,
                .8125,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_red2yellow_BW",
            RGBPoints: [
                -1,
                754296e-12,
                0,
                109827e-10,
                -.87451,
                .18285,
                .0264094,
                0,
                -.74902,
                .3066,
                0,
                0,
                -.623529,
                .422841,
                0,
                0,
                -.498039,
                .522945,
                0,
                0,
                -.372549,
                .605721,
                0,
                0,
                -.247059,
                .672502,
                .14168,
                0,
                -.121569,
                .728167,
                .244025,
                0,
                .00392157,
                .781215,
                .333454,
                0,
                .129412,
                .825,
                .423586,
                0,
                .254902,
                .855893,
                .516793,
                0,
                .380392,
                .880491,
                .608846,
                0,
                .505882,
                .910305,
                .695505,
                0,
                .631373,
                .94109,
                .779067,
                .223528,
                .756863,
                .967873,
                .858572,
                .473521,
                .882353,
                .986815,
                .933211,
                .751583,
                1,
                1,
                1,
                .999997
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_marine2gold_BW",
            RGBPoints: [
                -1,
                111641e-12,
                0,
                162551e-11,
                -.87451,
                .0413146,
                .0619808,
                .209857,
                -.74902,
                .0185557,
                .101341,
                .350684,
                -.623529,
                .00486405,
                .149847,
                .461054,
                -.498039,
                .0836345,
                .210845,
                .517906,
                -.372549,
                .173222,
                .276134,
                .541793,
                -.247059,
                .259857,
                .343877,
                .535869,
                -.121569,
                .362299,
                .408124,
                .504293,
                .00392157,
                .468266,
                .468276,
                .468257,
                .129412,
                .582781,
                .527545,
                .374914,
                .254902,
                .691591,
                .585251,
                .274266,
                .380392,
                .784454,
                .645091,
                .247332,
                .505882,
                .862299,
                .710383,
                .27518,
                .631373,
                .920863,
                .782923,
                .351563,
                .756863,
                .955792,
                .859699,
                .533541,
                .882353,
                .976162,
                .93433,
                .780671,
                1,
                1,
                1,
                .999983
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2gold_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .0742735,
                .0440331,
                .230013,
                -.74902,
                .125276,
                .0258685,
                .415826,
                -.623529,
                .143879,
                .0163031,
                .591346,
                -.498039,
                .212261,
                .0627855,
                .705239,
                -.372549,
                .306048,
                .141178,
                .763636,
                -.247059,
                .391537,
                .232286,
                .773263,
                -.121569,
                .461734,
                .336633,
                .708321,
                .00392157,
                .54209,
                .427581,
                .590007,
                .129412,
                .61704,
                .508623,
                .460978,
                .254902,
                .702703,
                .579586,
                .309117,
                .380392,
                .790336,
                .644811,
                .170397,
                .505882,
                .870173,
                .710733,
                .117134,
                .631373,
                .93656,
                .781991,
                .157144,
                .756863,
                .965672,
                .862068,
                .409836,
                .882353,
                .985751,
                .936296,
                .714162,
                1,
                1,
                1,
                .999999
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_sapphire2gold_BW",
            RGBPoints: [
                -1,
                .107704,
                .107708,
                .107694,
                -.87451,
                .1851,
                .112354,
                .308554,
                -.74902,
                .236782,
                .114233,
                .48788,
                -.623529,
                .28296,
                .126187,
                .639464,
                -.498039,
                .344787,
                .171643,
                .739713,
                -.372549,
                .413325,
                .242371,
                .76913,
                -.247059,
                .481863,
                .3131,
                .719841,
                -.121569,
                .550402,
                .383829,
                .612222,
                .00392157,
                .61894,
                .454558,
                .51126,
                .129412,
                .687478,
                .525287,
                .39993,
                .254902,
                .756017,
                .596016,
                .289923,
                .380392,
                .824555,
                .666745,
                .255498,
                .505882,
                .892979,
                .736822,
                .27696,
                .631373,
                .938851,
                .804966,
                .351734,
                .756863,
                .966491,
                .874853,
                .53572,
                .882353,
                .982105,
                .94153,
                .782579,
                1,
                1,
                1,
                .999986
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_red2purple_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .167793,
                .0166271,
                .0431278,
                -.74902,
                .262608,
                .0107595,
                .0791181,
                -.623529,
                .351902,
                .0101858,
                .100926,
                -.498039,
                .441257,
                .0160835,
                .131919,
                -.372549,
                .5221,
                .0555972,
                .195625,
                -.247059,
                .593852,
                .104294,
                .310234,
                -.121569,
                .654628,
                .158115,
                .448486,
                .00392157,
                .707443,
                .220914,
                .570253,
                .129412,
                .749504,
                .293268,
                .67897,
                .254902,
                .781587,
                .370517,
                .779269,
                .380392,
                .809951,
                .451099,
                .855831,
                .505882,
                .84424,
                .531462,
                .900451,
                .631373,
                .865174,
                .620901,
                .91606,
                .756863,
                .875041,
                .714054,
                .910284,
                .882353,
                .880764,
                .80554,
                .896276,
                1,
                .887572,
                .887591,
                .887556
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_purple2pink_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .117562,
                .0291202,
                .175876,
                -.74902,
                .178368,
                .0458476,
                .285454,
                -.623529,
                .237731,
                .0680173,
                .387717,
                -.498039,
                .300877,
                .0956291,
                .484802,
                -.372549,
                .370929,
                .136858,
                .554985,
                -.247059,
                .449033,
                .189273,
                .58863,
                -.121569,
                .529971,
                .245796,
                .598587,
                .00392157,
                .609914,
                .300643,
                .610244,
                .129412,
                .697079,
                .351286,
                .616371,
                .254902,
                .785858,
                .401991,
                .617376,
                .380392,
                .862517,
                .45745,
                .64463,
                .505882,
                .91359,
                .525462,
                .705336,
                .631373,
                .932583,
                .61064,
                .767412,
                .756863,
                .922478,
                .706966,
                .817522,
                .882353,
                .901302,
                .803071,
                .856311,
                1,
                .887571,
                .887591,
                .887549
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_pbj_lin",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .091821,
                .0611476,
                .10617,
                -.74902,
                .160311,
                .0900022,
                .192713,
                -.623529,
                .22484,
                .12126,
                .272128,
                -.498039,
                .291263,
                .157469,
                .340828,
                -.372549,
                .360015,
                .200388,
                .388903,
                -.247059,
                .437497,
                .250058,
                .387201,
                -.121569,
                .512636,
                .304969,
                .355955,
                .00392157,
                .582603,
                .360874,
                .33488,
                .129412,
                .655126,
                .416374,
                .306351,
                .254902,
                .725889,
                .473329,
                .279051,
                .380392,
                .778125,
                .537928,
                .302697,
                .505882,
                .815894,
                .606931,
                .382431,
                .631373,
                .839159,
                .679308,
                .497608,
                .756863,
                .854748,
                .751666,
                .631792,
                .882353,
                .869483,
                .822508,
                .768592,
                1,
                .887572,
                .887589,
                .887565
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2green_muted",
            RGBPoints: [
                -1,
                .107704,
                .107708,
                .107695,
                -.87451,
                .141522,
                .13066,
                .270741,
                -.74902,
                .180123,
                .146119,
                .42308,
                -.623529,
                .210161,
                .169674,
                .551795,
                -.498039,
                .239701,
                .212939,
                .634969,
                -.372549,
                .253916,
                .282947,
                .653641,
                -.247059,
                .242791,
                .366933,
                .608521,
                -.121569,
                .226302,
                .446776,
                .52693,
                .00392157,
                .236237,
                .514689,
                .458798,
                .129412,
                .274641,
                .577589,
                .376069,
                .254902,
                .349625,
                .633993,
                .288131,
                .380392,
                .4437,
                .683677,
                .260497,
                .505882,
                .536247,
                .731214,
                .285424,
                .631373,
                .628472,
                .777128,
                .349151,
                .756863,
                .718259,
                .819287,
                .496825,
                .882353,
                .804768,
                .856164,
                .703299,
                1,
                .887571,
                .887591,
                .887548
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2green_BW",
            RGBPoints: [
                -1,
                363578e-12,
                0,
                529374e-11,
                -.87451,
                .0539915,
                .0577948,
                .212806,
                -.74902,
                .0620393,
                .0758942,
                .388959,
                -.623529,
                .0697499,
                .102032,
                .54177,
                -.498039,
                .113295,
                .156156,
                .64334,
                -.372549,
                .152047,
                .243196,
                .670283,
                -.247059,
                .158096,
                .344084,
                .622864,
                -.121569,
                .151142,
                .43922,
                .532767,
                .00392157,
                .17155,
                .521588,
                .457719,
                .129412,
                .225861,
                .599141,
                .363997,
                .254902,
                .32328,
                .67007,
                .259083,
                .380392,
                .442344,
                .733697,
                .223754,
                .505882,
                .558409,
                .794941,
                .257411,
                .631373,
                .673875,
                .854344,
                .340822,
                .756863,
                .787244,
                .909326,
                .524717,
                .882353,
                .896483,
                .958063,
                .775914,
                1,
                1,
                1,
                .999982
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GREEN-WHITE_LINEAR",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                0,
                .062745,
                0,
                -.74902,
                0,
                .12549,
                0,
                -.623529,
                0,
                .188235,
                0,
                -.498039,
                0,
                .25098,
                0,
                -.372549,
                0,
                .313725,
                0,
                -.247059,
                0,
                .376471,
                0,
                -.121569,
                .094118,
                .439216,
                0,
                .00392157,
                .196078,
                .501961,
                0,
                .129412,
                .294118,
                .564706,
                0,
                .254902,
                .396078,
                .627451,
                0,
                .380392,
                .498039,
                .690196,
                0,
                .505882,
                .6,
                .752941,
                .145098,
                .631373,
                .701961,
                .815686,
                .364706,
                .756863,
                .8,
                .878431,
                .580392,
                .882353,
                .901961,
                .941176,
                .796078,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_green2yellow_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                0,
                .105542,
                .0603919,
                -.74902,
                0,
                .159454,
                .104148,
                -.623529,
                0,
                .219502,
                .15542,
                -.498039,
                0,
                .282276,
                .203811,
                -.372549,
                0,
                .346331,
                .235652,
                -.247059,
                0,
                .411765,
                .235428,
                -.121569,
                0,
                .477177,
                .217977,
                .00392157,
                .0593644,
                .541635,
                .21361,
                .129412,
                .233081,
                .604722,
                .210591,
                .254902,
                .369803,
                .664942,
                .226536,
                .380392,
                .498446,
                .722367,
                .288237,
                .505882,
                .601929,
                .782244,
                .380815,
                .631373,
                .703207,
                .840497,
                .512134,
                .756863,
                .803186,
                .896433,
                .674462,
                .882353,
                .903834,
                .950266,
                .846715,
                1,
                1,
                1,
                .999981
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "blue2cyan",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                0,
                .152941,
                .364706,
                -.74902,
                0,
                .254902,
                .470588,
                -.623529,
                0,
                .34902,
                .572549,
                -.498039,
                0,
                .443137,
                .670588,
                -.372549,
                0,
                .537255,
                .772549,
                -.247059,
                0,
                .627451,
                .870588,
                -.121569,
                0,
                .717647,
                .964706,
                .00392157,
                .0784314,
                .772549,
                1,
                .129412,
                .207843,
                .858824,
                1,
                .254902,
                .32549,
                .941176,
                1,
                .380392,
                .45098,
                1,
                1,
                .505882,
                .560784,
                1,
                1,
                .631373,
                .662745,
                1,
                1,
                .756863,
                .760784,
                1,
                1,
                .882353,
                .870588,
                1,
                1,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2cyan_BW",
            RGBPoints: [
                -1,
                405298e-12,
                0,
                59012e-10,
                -.87451,
                .0207526,
                .0740933,
                .18093,
                -.74902,
                0,
                .121033,
                .30343,
                -.623529,
                0,
                .166892,
                .416095,
                -.498039,
                0,
                .216768,
                .524796,
                -.372549,
                .0164769,
                .275471,
                .608585,
                -.247059,
                .0544527,
                .344824,
                .659267,
                -.121569,
                .0880643,
                .419118,
                .688675,
                .00392157,
                .127938,
                .492556,
                .720256,
                .129412,
                .149476,
                .566946,
                .756918,
                .254902,
                .188961,
                .641333,
                .792122,
                .380392,
                .245482,
                .715336,
                .827609,
                .505882,
                .329216,
                .786235,
                .874761,
                .631373,
                .453558,
                .852803,
                .918466,
                .756863,
                .626281,
                .910493,
                .954,
                .882353,
                .82257,
                .958709,
                .980146,
                1,
                1,
                1,
                .999989
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .0425591,
                .0763529,
                .150682,
                -.74902,
                .0569472,
                .119154,
                .275403,
                -.623529,
                .0635978,
                .164772,
                .395427,
                -.498039,
                .0774342,
                .213851,
                .510014,
                -.372549,
                .106815,
                .267034,
                .615102,
                -.247059,
                .122093,
                .324649,
                .720068,
                -.121569,
                .160851,
                .387068,
                .806956,
                .00392157,
                .213754,
                .453516,
                .878012,
                .129412,
                .26722,
                .524656,
                .932436,
                .254902,
                .326844,
                .599279,
                .968038,
                .380392,
                .403403,
                .674712,
                .984784,
                .505882,
                .499703,
                .745519,
                1,
                .631373,
                .615055,
                .813983,
                1,
                .756863,
                .74405,
                .879228,
                1,
                .882353,
                .877909,
                .941913,
                1,
                1,
                1,
                1,
                .999996
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BLUE-WHITE",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                0,
                0,
                .082353,
                -.74902,
                0,
                0,
                .168627,
                -.623529,
                0,
                0,
                .254902,
                -.498039,
                0,
                0,
                .337255,
                -.372549,
                0,
                0,
                .423529,
                -.247059,
                0,
                0,
                .509804,
                -.121569,
                0,
                .101961,
                .592157,
                .00392157,
                0,
                .203922,
                .678431,
                .129412,
                0,
                .301961,
                .764706,
                .254902,
                0,
                .403922,
                .85098,
                .380392,
                0,
                .505882,
                .933333,
                .505882,
                0,
                .603922,
                1,
                .631373,
                .254902,
                .705882,
                1,
                .756863,
                .509804,
                .807843,
                1,
                .882353,
                .764706,
                .905882,
                1,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_purple_BW",
            RGBPoints: [
                -1,
                4264e-11,
                0,
                620844e-12,
                -.87451,
                .100579,
                .0593111,
                .145666,
                -.74902,
                .167794,
                .0889224,
                .254953,
                -.623529,
                .231446,
                .123339,
                .360511,
                -.498039,
                .296699,
                .163027,
                .461278,
                -.372549,
                .363211,
                .209286,
                .55306,
                -.247059,
                .431136,
                .260776,
                .637195,
                -.121569,
                .498202,
                .320012,
                .705799,
                .00392157,
                .567456,
                .380459,
                .778091,
                .129412,
                .629381,
                .445284,
                .8448,
                .254902,
                .688373,
                .517374,
                .895694,
                .380392,
                .74891,
                .590906,
                .93976,
                .505882,
                .805017,
                .667956,
                .977626,
                .631373,
                .850914,
                .752618,
                .992396,
                .756863,
                .89724,
                .838454,
                .994093,
                .882353,
                .948461,
                .922603,
                .994449,
                1,
                1,
                1,
                .999967
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_magenta_BW",
            RGBPoints: [
                -1,
                0,
                0,
                254023e-10,
                -.87451,
                .128696,
                .0456782,
                .11635,
                -.74902,
                .228133,
                .0476299,
                .201452,
                -.623529,
                .327273,
                .0374065,
                .282107,
                -.498039,
                .420953,
                .0408166,
                .35709,
                -.372549,
                .511562,
                .0642203,
                .430511,
                -.247059,
                .599552,
                .102686,
                .504257,
                -.121569,
                .684646,
                .150536,
                .579429,
                .00392157,
                .765817,
                .205978,
                .656062,
                .129412,
                .839176,
                .27229,
                .731807,
                .254902,
                .89536,
                .357594,
                .797309,
                .380392,
                .930238,
                .457825,
                .846984,
                .505882,
                .945921,
                .564536,
                .880571,
                .631373,
                .948995,
                .670753,
                .902279,
                .756863,
                .947124,
                .772819,
                .918171,
                .882353,
                .947265,
                .869424,
                .934352,
                1,
                .954719,
                .95475,
                .954726
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "magenta",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .364706,
                0,
                .152941,
                -.74902,
                .470588,
                0,
                .254902,
                -.623529,
                .572549,
                0,
                .34902,
                -.498039,
                .670588,
                0,
                .443137,
                -.372549,
                .772549,
                0,
                .537255,
                -.247059,
                .870588,
                0,
                .627451,
                -.121569,
                .964706,
                0,
                .717647,
                .00392157,
                1,
                .0784314,
                .772549,
                .129412,
                1,
                .207843,
                .858824,
                .254902,
                1,
                .32549,
                .941176,
                .380392,
                1,
                .45098,
                1,
                .505882,
                1,
                .560784,
                1,
                .631373,
                1,
                .662745,
                1,
                .756863,
                1,
                .760784,
                1,
                .882353,
                1,
                .870588,
                1,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "RED-PURPLE",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .188235,
                0,
                .007843,
                -.74902,
                .345098,
                0,
                .035294,
                -.623529,
                .439216,
                0,
                .098039,
                -.498039,
                .533333,
                0,
                .152941,
                -.372549,
                .627451,
                .015686,
                .211765,
                -.247059,
                .721569,
                .031373,
                .266667,
                -.121569,
                .8,
                .047059,
                .329412,
                .00392157,
                .862745,
                .047059,
                .403922,
                .129412,
                .941176,
                .062745,
                .466667,
                .254902,
                .988235,
                .078431,
                .54902,
                .380392,
                .988235,
                .141176,
                .643137,
                .505882,
                .988235,
                .25098,
                .729412,
                .631373,
                .988235,
                .376471,
                .811765,
                .756863,
                .988235,
                .54902,
                .886275,
                .882353,
                .988235,
                .752941,
                .952941,
                1,
                .996078,
                .996078,
                .996078
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_red_BW",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .147204,
                .0480135,
                .0401815,
                -.74902,
                .253411,
                .0617478,
                .0301333,
                -.623529,
                .356059,
                .0746331,
                .0446897,
                -.498039,
                .457731,
                .0934935,
                .0636931,
                -.372549,
                .557199,
                .122714,
                .0860013,
                -.247059,
                .665179,
                .144238,
                .105585,
                -.121569,
                .763833,
                .187056,
                .138326,
                .00392157,
                .847035,
                .254558,
                .189407,
                .129412,
                .905663,
                .345937,
                .258215,
                .254902,
                .941431,
                .447111,
                .346277,
                .380392,
                .962608,
                .546927,
                .457571,
                .505882,
                .987833,
                .637276,
                .569944,
                .631373,
                .994202,
                .732176,
                .687958,
                .756863,
                .993304,
                .826268,
                .800567,
                .882353,
                .994413,
                .917205,
                .906393,
                1,
                1,
                1,
                .999979
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "RED_TEMPERATURE",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .090196,
                0,
                0,
                -.74902,
                .180392,
                0,
                0,
                -.623529,
                .270588,
                0,
                0,
                -.498039,
                .360784,
                0,
                0,
                -.372549,
                .45098,
                0,
                0,
                -.247059,
                .545098,
                0,
                0,
                -.121569,
                .635294,
                0,
                0,
                .00392157,
                .72549,
                .058824,
                0,
                .129412,
                .815686,
                .176471,
                0,
                .254902,
                .905882,
                .294118,
                0,
                .380392,
                1,
                .411765,
                0,
                .505882,
                1,
                .533333,
                .027451,
                .631373,
                1,
                .65098,
                .27451,
                .756863,
                1,
                .768627,
                .521569,
                .882353,
                1,
                .886275,
                .768627,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_orange_BW",
            RGBPoints: [
                -1,
                0,
                0,
                253806e-10,
                -.87451,
                .135871,
                .0593824,
                0,
                -.74902,
                .224328,
                .0907216,
                0,
                -.623529,
                .318083,
                .119647,
                0,
                -.498039,
                .414443,
                .150246,
                0,
                -.372549,
                .511077,
                .184884,
                0,
                -.247059,
                .605501,
                .226033,
                0,
                -.121569,
                .695274,
                .275491,
                0,
                .00392157,
                .777826,
                .334445,
                0,
                .129412,
                .851498,
                .402441,
                0,
                .254902,
                .915899,
                .47759,
                602975e-9,
                .380392,
                .971984,
                .557882,
                .0361443,
                .505882,
                1,
                .641287,
                .135967,
                .631373,
                1,
                .725198,
                .27997,
                .756863,
                1,
                .808205,
                .438135,
                .882353,
                1,
                .89306,
                .587036,
                1,
                1,
                .977928,
                .721599
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "heated_object",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .34902,
                .0862745,
                0,
                -.74902,
                .45098,
                .172549,
                0,
                -.623529,
                .52549,
                .231373,
                0,
                -.498039,
                .580392,
                .278431,
                0,
                -.372549,
                .623529,
                .313725,
                0,
                -.247059,
                .670588,
                .352941,
                0,
                -.121569,
                .717647,
                .392157,
                0,
                .00392157,
                .772549,
                .439216,
                0,
                .129412,
                .839216,
                .494118,
                0,
                .254902,
                .901961,
                .541176,
                0,
                .380392,
                .968627,
                .6,
                0,
                .505882,
                1,
                .658824,
                0,
                .631373,
                1,
                .721569,
                0,
                .756863,
                1,
                .827451,
                .298039,
                .882353,
                1,
                .976471,
                .72549,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_gold_BW",
            RGBPoints: [
                -1,
                0,
                0,
                190933e-10,
                -.87451,
                .128363,
                .0636265,
                0,
                -.74902,
                .193795,
                .111057,
                0,
                -.623529,
                .25976,
                .15987,
                0,
                -.498039,
                .328546,
                .210589,
                0,
                -.372549,
                .399726,
                .26332,
                0,
                -.247059,
                .472969,
                .318261,
                0,
                -.121569,
                .546245,
                .375827,
                0,
                .00392157,
                .61745,
                .436719,
                0,
                .129412,
                .685545,
                .501113,
                0,
                .254902,
                .749578,
                .568799,
                0,
                .380392,
                .80962,
                .6394,
                0,
                .505882,
                .865572,
                .712699,
                .10257,
                .631373,
                .917709,
                .787569,
                .233665,
                .756863,
                .966914,
                .863138,
                .369608,
                .882353,
                1,
                .939405,
                .496104,
                1,
                .999225,
                1,
                .612275
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_brown_BW",
            RGBPoints: [
                -1,
                33216e-11,
                0,
                483629e-11,
                -.87451,
                .14693,
                .0518172,
                0,
                -.74902,
                .225806,
                .0814996,
                0,
                -.623529,
                .301681,
                .111452,
                0,
                -.498039,
                .370487,
                .150664,
                0,
                -.372549,
                .43108,
                .199477,
                0,
                -.247059,
                .4849,
                .255107,
                0,
                -.121569,
                .536798,
                .313486,
                0,
                .00392157,
                .59286,
                .371167,
                0,
                .129412,
                .653119,
                .428135,
                0,
                .254902,
                .714589,
                .485917,
                .0379541,
                .380392,
                .774667,
                .54565,
                .116634,
                .505882,
                .831222,
                .608047,
                .183895,
                .631373,
                .880305,
                .674199,
                .260298,
                .756863,
                .922314,
                .742472,
                .367086,
                .882353,
                .959408,
                .811222,
                .497258,
                1,
                .993548,
                .875183,
                .622093
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "copper_Matlab",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .0784314,
                .0501961,
                .0313725,
                -.74902,
                .156863,
                .100392,
                .0627451,
                -.623529,
                .235294,
                .150588,
                .0941176,
                -.498039,
                .313725,
                .200784,
                .12549,
                -.372549,
                .392157,
                .25098,
                .156863,
                -.247059,
                .470588,
                .301176,
                .188235,
                -.121569,
                .54902,
                .351373,
                .219608,
                .00392157,
                .627451,
                .401569,
                .25098,
                .129412,
                .705882,
                .451765,
                .282353,
                .254902,
                .784314,
                .501961,
                .313725,
                .380392,
                .862745,
                .552157,
                .345098,
                .505882,
                .941176,
                .602353,
                .376471,
                .631373,
                1,
                .652549,
                .407843,
                .756863,
                1,
                .702745,
                .439216,
                .882353,
                1,
                .752941,
                .470588,
                1,
                1,
                .8,
                .5
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "pink_Matlab",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .312416,
                .204524,
                .204524,
                -.74902,
                .441822,
                .289241,
                .289241,
                -.623529,
                .54112,
                .354246,
                .354246,
                -.498039,
                .624831,
                .409048,
                .409048,
                -.372549,
                .698582,
                .45733,
                .45733,
                -.247059,
                .764404,
                .502282,
                .500979,
                -.121569,
                .791292,
                .591516,
                .54112,
                .00392157,
                .817297,
                .66895,
                .578481,
                .129412,
                .842499,
                .738308,
                .613572,
                .254902,
                .866968,
                .801687,
                .646762,
                .380392,
                .890766,
                .86041,
                .678329,
                .505882,
                .913944,
                .913944,
                .711254,
                .631373,
                .936549,
                .936549,
                .79459,
                .756863,
                .958621,
                .958621,
                .869979,
                .882353,
                .980196,
                .980196,
                .939336,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "bone_Matlab",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .054902,
                .054902,
                .075817,
                -.74902,
                .109804,
                .109804,
                .151634,
                -.623529,
                .164706,
                .164706,
                .227451,
                -.498039,
                .219608,
                .219608,
                .303268,
                -.372549,
                .27451,
                .27451,
                .379085,
                -.247059,
                .329412,
                .329902,
                .454412,
                -.121569,
                .384314,
                .405719,
                .509314,
                .00392157,
                .439216,
                .481536,
                .564216,
                .129412,
                .494118,
                .557353,
                .619118,
                .254902,
                .54902,
                .63317,
                .67402,
                .380392,
                .603922,
                .708987,
                .728922,
                .505882,
                .660294,
                .783824,
                .783824,
                .631373,
                .746569,
                .838725,
                .838725,
                .756863,
                .832843,
                .893627,
                .893627,
                .882353,
                .919118,
                .948529,
                .948529,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "gray_Matlab",
            RGBPoints: [
                -1,
                0,
                0,
                0,
                -.87451,
                .0627451,
                .0627451,
                .0627451,
                -.74902,
                .12549,
                .12549,
                .12549,
                -.623529,
                .188235,
                .188235,
                .188235,
                -.498039,
                .25098,
                .25098,
                .25098,
                -.372549,
                .313725,
                .313725,
                .313725,
                -.247059,
                .376471,
                .376471,
                .376471,
                -.121569,
                .439216,
                .439216,
                .439216,
                .00392157,
                .501961,
                .501961,
                .501961,
                .129412,
                .564706,
                .564706,
                .564706,
                .254902,
                .627451,
                .627451,
                .627451,
                .380392,
                .690196,
                .690196,
                .690196,
                .505882,
                .752941,
                .752941,
                .752941,
                .631373,
                .815686,
                .815686,
                .815686,
                .756863,
                .878431,
                .878431,
                .878431,
                .882353,
                .941176,
                .941176,
                .941176,
                1,
                1,
                1,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Purples",
            RGBPoints: [
                -1,
                .247059,
                0,
                .490196,
                -.87451,
                .288397,
                .07677,
                .525629,
                -.74902,
                .32975,
                .153587,
                .561092,
                -.623529,
                .373057,
                .236263,
                .600461,
                -.498039,
                .416363,
                .319,
                .639923,
                -.372549,
                .459669,
                .405613,
                .685198,
                -.247059,
                .503345,
                .491534,
                .730058,
                -.121569,
                .562399,
                .54862,
                .757616,
                .00392157,
                .621453,
                .606075,
                .785544,
                .129412,
                .680508,
                .674971,
                .824914,
                .254902,
                .739562,
                .743406,
                .863899,
                .380392,
                .798616,
                .800492,
                .893426,
                .505882,
                .85684,
                .856655,
                .922491,
                .631373,
                .898178,
                .894056,
                .942176,
                .756863,
                .938654,
                .930919,
                .961646,
                .882353,
                .964245,
                .958478,
                .977393,
                1,
                .988235,
                .984314,
                .992157
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Blues",
            RGBPoints: [
                -1,
                .031373,
                .188235,
                .419608,
                -.87451,
                .031373,
                .253195,
                .516063,
                -.74902,
                .031757,
                .318139,
                .612149,
                -.623529,
                .080969,
                .38113,
                .661361,
                -.498039,
                .130427,
                .444152,
                .710327,
                -.372549,
                .195386,
                .509112,
                .743791,
                -.247059,
                .260715,
                .573841,
                .777209,
                -.121569,
                .341423,
                .628958,
                .808704,
                .00392157,
                .422745,
                .684075,
                .839892,
                .129412,
                .523137,
                .739193,
                .861546,
                .254902,
                .622684,
                .793464,
                .883429,
                .380392,
                .701423,
                .826928,
                .910988,
                .505882,
                .778685,
                .8603,
                .937993,
                .631373,
                .825928,
                .891795,
                .953741,
                .756863,
                .87328,
                .923291,
                .969489,
                .882353,
                .922491,
                .954787,
                .985236,
                1,
                .968627,
                .984314,
                1
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Greens",
            RGBPoints: [
                -1,
                0,
                .266667,
                .105882,
                -.87451,
                0,
                .347374,
                .139346,
                -.74902,
                538e-6,
                .427912,
                .172933,
                -.623529,
                .069435,
                .486967,
                .222145,
                -.498039,
                .138178,
                .546082,
                .271326,
                -.372549,
                .197232,
                .609073,
                .31857,
                -.247059,
                .257255,
                .671742,
                .365859,
                -.121569,
                .357647,
                .720953,
                .415071,
                .00392157,
                .45767,
                .769919,
                .465021,
                .129412,
                .546251,
                .811257,
                .537855,
                .254902,
                .634295,
                .852211,
                .610688,
                .380392,
                .709097,
                .883706,
                .683522,
                .505882,
                .78316,
                .914833,
                .755894,
                .631373,
                .842215,
                .938454,
                .818885,
                .756863,
                .899977,
                .961538,
                .880692,
                .882353,
                .935409,
                .975317,
                .92203,
                1,
                .968627,
                .988235,
                .960784
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "PuBu",
            RGBPoints: [
                -1,
                .301961,
                0,
                .294118,
                -.87451,
                .404321,
                .029527,
                .390573,
                -.74902,
                .50599,
                .059592,
                .486782,
                -.623529,
                .519769,
                .158016,
                .551742,
                -.498039,
                .533456,
                .256194,
                .616301,
                -.372549,
                .54133,
                .33887,
                .655671,
                -.247059,
                .54902,
                .421592,
                .695087,
                -.121569,
                .54902,
                .506236,
                .736424,
                .00392157,
                .550127,
                .590573,
                .777701,
                .129412,
                .585559,
                .665375,
                .81707,
                .254902,
                .622145,
                .739023,
                .855825,
                .380392,
                .687105,
                .784298,
                .879446,
                .505882,
                .752065,
                .829758,
                .903253,
                .631373,
                .817024,
                .87897,
                .930811,
                .756863,
                .880907,
                .927213,
                .957832,
                .882353,
                .926182,
                .958708,
                .975548,
                1,
                .968627,
                .988235,
                .992157
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BuPu",
            RGBPoints: [
                -1,
                .007843,
                .219608,
                .345098,
                -.87451,
                .01178,
                .286536,
                .449427,
                -.74902,
                .015702,
                .35328,
                .553479,
                -.623529,
                .01767,
                .396586,
                .622376,
                -.498039,
                .021115,
                .4402,
                .690688,
                -.372549,
                .11757,
                .503191,
                .722184,
                -.247059,
                .214625,
                .565859,
                .753633,
                -.121569,
                .336671,
                .615071,
                .78316,
                .00392157,
                .457978,
                .663975,
                .812503,
                .129412,
                .556401,
                .703345,
                .836125,
                .254902,
                .65421,
                .742714,
                .859669,
                .380392,
                .736886,
                .782084,
                .881323,
                .505882,
                .81827,
                .821638,
                .903068,
                .631373,
                .873387,
                .864944,
                .92669,
                .756863,
                .927536,
                .907605,
                .949988,
                .882353,
                .964937,
                .9391,
                .967705,
                1,
                1,
                .968627,
                .984314
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BuGn",
            RGBPoints: [
                -1,
                .031373,
                .25098,
                .505882,
                -.87451,
                .031373,
                .329719,
                .590527,
                -.74902,
                .031911,
                .408397,
                .674787,
                -.623529,
                .100807,
                .479262,
                .710219,
                -.498039,
                .169704,
                .550219,
                .745744,
                -.372549,
                .238601,
                .62699,
                .787082,
                -.247059,
                .307958,
                .703114,
                .826759,
                -.121569,
                .39654,
                .752326,
                .797232,
                .00392157,
                .485121,
                .801046,
                .767705,
                .129412,
                .573702,
                .83451,
                .738178,
                .254902,
                .661592,
                .867743,
                .711034,
                .380392,
                .732457,
                .895302,
                .74253,
                .505882,
                .801845,
                .922307,
                .774579,
                .631373,
                .841215,
                .938055,
                .817885,
                .756863,
                .880907,
                .95391,
                .861084,
                .882353,
                .926182,
                .971626,
                .902422,
                1,
                .968627,
                .988235,
                .941176
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GnBu",
            RGBPoints: [
                -1,
                0,
                .266667,
                .105882,
                -.87451,
                0,
                .347374,
                .139346,
                -.74902,
                538e-6,
                .427912,
                .172933,
                -.623529,
                .069435,
                .486967,
                .222145,
                -.498039,
                .138178,
                .546175,
                .272095,
                -.372549,
                .197232,
                .615071,
                .368551,
                -.247059,
                .256609,
                .683276,
                .464867,
                -.121569,
                .329443,
                .722645,
                .555417,
                .00392157,
                .403137,
                .762138,
                .645413,
                .129412,
                .503529,
                .805444,
                .718247,
                .254902,
                .603922,
                .848597,
                .790465,
                .380392,
                .704314,
                .887966,
                .847551,
                .505882,
                .802307,
                .926321,
                .903714,
                .631373,
                .851519,
                .944037,
                .941115,
                .756863,
                .899977,
                .961538,
                .976901,
                .882353,
                .935409,
                .975317,
                .984775,
                1,
                .968627,
                .988235,
                .992157
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GnBuPu",
            RGBPoints: [
                -1,
                .003922,
                .27451,
                .211765,
                -.87451,
                .003922,
                .349312,
                .280661,
                -.74902,
                .003937,
                .423852,
                .349773,
                -.623529,
                .005905,
                .46519,
                .446228,
                -.498039,
                .009443,
                .506344,
                .542837,
                -.372549,
                .111803,
                .535871,
                .649135,
                -.247059,
                .214025,
                .565859,
                .753633,
                -.121569,
                .310481,
                .615071,
                .78316,
                .00392157,
                .407797,
                .663975,
                .812503,
                .129412,
                .531811,
                .703345,
                .836125,
                .254902,
                .65421,
                .742714,
                .859669,
                .380392,
                .736886,
                .782084,
                .881323,
                .505882,
                .81827,
                .821176,
                .902884,
                .631373,
                .873387,
                .854641,
                .922568,
                .756863,
                .927536,
                .888535,
                .942361,
                .882353,
                .964937,
                .929873,
                .964014,
                1,
                1,
                .968627,
                .984314
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BuGnYl",
            RGBPoints: [
                -1,
                .031373,
                .113725,
                .345098,
                -.87451,
                .088458,
                .159,
                .463206,
                -.74902,
                .145052,
                .204567,
                .5807,
                -.623529,
                .139146,
                .287243,
                .620069,
                -.498039,
                .13318,
                .370196,
                .659562,
                -.372549,
                .123337,
                .470588,
                .706805,
                -.247059,
                .115386,
                .570335,
                .753126,
                -.121569,
                .186251,
                .643168,
                .761,
                .00392157,
                .258716,
                .71514,
                .768074,
                .129412,
                .380761,
                .760415,
                .750358,
                .254902,
                .503576,
                .806075,
                .732795,
                .380392,
                .645306,
                .861192,
                .719016,
                .505882,
                .783899,
                .91511,
                .705606,
                .631373,
                .858701,
                .944637,
                .6997,
                .756863,
                .931349,
                .973303,
                .698424,
                .882353,
                .966782,
                .987082,
                .777163,
                1,
                1,
                1,
                .85098
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "PuRd",
            RGBPoints: [
                -1,
                .286275,
                0,
                .415686,
                -.87451,
                .38273,
                .001968,
                .441276,
                -.74902,
                .479231,
                .003922,
                .466774,
                -.623529,
                .581592,
                .003922,
                .480554,
                -.498039,
                .683799,
                .00549,
                .494887,
                -.372549,
                .776317,
                .105882,
                .544098,
                -.247059,
                .867866,
                .206321,
                .592618,
                -.121569,
                .919047,
                .308681,
                .612303,
                .00392157,
                .968812,
                .411226,
                .632603,
                .129412,
                .974717,
                .519493,
                .671972,
                .254902,
                .980546,
                .626451,
                .71065,
                .380392,
                .984483,
                .701253,
                .732303,
                .505882,
                .988328,
                .77504,
                .755617,
                .631373,
                .990296,
                .828189,
                .812703,
                .756863,
                .992372,
                .880907,
                .869035,
                .882353,
                .996309,
                .926182,
                .912341,
                1,
                1,
                .968627,
                .952941
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "RdPu",
            RGBPoints: [
                -1,
                .403922,
                0,
                .121569,
                -.87451,
                .500377,
                0,
                .192434,
                -.74902,
                .596909,
                277e-6,
                .263037,
                -.623529,
                .703206,
                .035709,
                .300438,
                -.498039,
                .808612,
                .071296,
                .338854,
                -.372549,
                .857824,
                .116571,
                .441215,
                -.247059,
                .905513,
                .163552,
                .54293,
                -.121569,
                .889765,
                .281661,
                .617732,
                .00392157,
                .873156,
                .39897,
                .691611,
                .129412,
                .82985,
                .491488,
                .736886,
                .254902,
                .789081,
                .583237,
                .781853,
                .380392,
                .810734,
                .656071,
                .819254,
                .505882,
                .833126,
                .729181,
                .85684,
                .631373,
                .870527,
                .80792,
                .898178,
                .756863,
                .907605,
                .884398,
                .938331,
                .882353,
                .9391,
                .921799,
                .958016,
                1,
                .968627,
                .956863,
                .976471
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Oranges",
            RGBPoints: [
                -1,
                .498039,
                .152941,
                .015686,
                -.87451,
                .57481,
                .182468,
                .013718,
                -.74902,
                .651765,
                .212042,
                .011734,
                -.623529,
                .752157,
                .247474,
                .007797,
                -.498039,
                .851719,
                .283368,
                .004475,
                -.372549,
                .898962,
                .348328,
                .039908,
                -.247059,
                .945652,
                .413426,
                .076401,
                -.121569,
                .969273,
                .484291,
                .157109,
                .00392157,
                .992157,
                .554971,
                .238185,
                .129412,
                .992157,
                .619931,
                .330704,
                .254902,
                .992157,
                .684967,
                .423837,
                .380392,
                .992157,
                .751895,
                .532103,
                .505882,
                .992249,
                .817716,
                .639354,
                .631373,
                .994218,
                .861023,
                .725967,
                .756863,
                .996186,
                .903576,
                .810965,
                .882353,
                .998155,
                .933103,
                .868051,
                1,
                1,
                .960784,
                .921569
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Reds",
            RGBPoints: [
                -1,
                .403922,
                0,
                .05098,
                -.87451,
                .525967,
                .029527,
                .066728,
                -.74902,
                .647643,
                .058962,
                .082476,
                -.623529,
                .722445,
                .076678,
                .098224,
                -.498039,
                .797186,
                .095194,
                .114187,
                -.372549,
                .868051,
                .164091,
                .143714,
                -.247059,
                .937809,
                .233541,
                .173933,
                -.121569,
                .96143,
                .326059,
                .232987,
                .00392157,
                .984375,
                .418147,
                .292657,
                .129412,
                .986344,
                .496886,
                .371396,
                .254902,
                .988235,
                .575702,
                .450673,
                .380392,
                .988235,
                .656409,
                .543191,
                .505882,
                .98842,
                .736747,
                .635894,
                .631373,
                .992357,
                .809581,
                .732349,
                .756863,
                .996186,
                .880692,
                .826759,
                .882353,
                .998155,
                .92203,
                .885813,
                1,
                1,
                .960784,
                .941176
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "RdOr",
            RGBPoints: [
                -1,
                .498039,
                0,
                0,
                -.87451,
                .6004,
                0,
                0,
                -.74902,
                .702514,
                738e-6,
                477e-6,
                -.623529,
                .773379,
                .095225,
                .061499,
                -.498039,
                .843875,
                .189865,
                .12283,
                -.372549,
                .891119,
                .294195,
                .203537,
                -.247059,
                .937855,
                .397924,
                .283137,
                -.121569,
                .963445,
                .476663,
                .316601,
                .00392157,
                .988297,
                .555771,
                .351665,
                .129412,
                .990265,
                .646321,
                .436309,
                .254902,
                .992157,
                .735256,
                .519646,
                .380392,
                .992157,
                .784468,
                .570827,
                .505882,
                .992249,
                .833218,
                .623483,
                .631373,
                .994218,
                .872587,
                .706159,
                .756863,
                .996186,
                .911419,
                .788189,
                .882353,
                .998155,
                .940946,
                .859054,
                1,
                1,
                .968627,
                .92549
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BrOrYl",
            RGBPoints: [
                -1,
                .4,
                .145098,
                .023529,
                -.87451,
                .500392,
                .174625,
                .019592,
                -.74902,
                .600784,
                .204291,
                .015656,
                -.623529,
                .701176,
                .251534,
                .011719,
                -.498039,
                .800984,
                .299146,
                .008397,
                -.372549,
                .863975,
                .370012,
                .043829,
                -.247059,
                .926321,
                .441107,
                .0794,
                -.121569,
                .961753,
                .521815,
                .120738,
                .00392157,
                .996078,
                .602645,
                .163122,
                .129412,
                .996078,
                .68729,
                .237924,
                .254902,
                .996078,
                .771011,
                .314879,
                .380392,
                .996078,
                .832034,
                .444798,
                .505882,
                .996171,
                .892042,
                .572595,
                .631373,
                .998139,
                .931411,
                .65724,
                .756863,
                1,
                .969489,
                .741669,
                .882353,
                1,
                .985236,
                .822376,
                1,
                1,
                1,
                .898039
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "RdOrYl",
            RGBPoints: [
                -1,
                .501961,
                0,
                .14902,
                -.87451,
                .622038,
                0,
                .14902,
                -.74902,
                .741761,
                4e-4,
                .148866,
                -.623529,
                .816563,
                .05158,
                .129181,
                -.498039,
                .890965,
                .10356,
                .110235,
                -.372549,
                .940177,
                .205921,
                .137793,
                -.247059,
                .988281,
                .308789,
                .165536,
                -.121569,
                .99025,
                .432803,
                .200969,
                .00392157,
                .992218,
                .555217,
                .236278,
                .129412,
                .994187,
                .628051,
                .267774,
                .254902,
                .996078,
                .701038,
                .301269,
                .380392,
                .996078,
                .777809,
                .383945,
                .505882,
                .996171,
                .852826,
                .466621,
                .631373,
                .998139,
                .892195,
                .549296,
                .756863,
                1,
                .931349,
                .632188,
                .882353,
                1,
                .966782,
                .7188,
                1,
                1,
                1,
                .8
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "CIELab_blue2red",
            RGBPoints: [
                -1,
                0,
                .6,
                .74902,
                1,
                .76863,
                .46667,
                .34118
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "blue2yellow",
            RGBPoints: [
                -1,
                0,
                0,
                1,
                0,
                .5,
                .5,
                .5,
                1,
                1,
                1,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2gold",
            RGBPoints: [
                -1,
                .175119,
                .0438468,
                1,
                -.874016,
                .22383,
                .159771,
                .94557,
                -.748031,
                .27254,
                .233611,
                .891216,
                -.622047,
                .321251,
                .296526,
                .836857,
                -.496063,
                .369962,
                .354296,
                .782359,
                -.370079,
                .418672,
                .409139,
                .72754,
                -.244094,
                .467383,
                .462152,
                .672148,
                -.11811,
                .51609,
                .51396,
                .615825,
                .00787402,
                .572863,
                .55452,
                .559172,
                .133858,
                .630269,
                .593822,
                .517729,
                .259843,
                .689588,
                .624668,
                .47446,
                .385827,
                .745394,
                .656113,
                .428638,
                .511811,
                .798624,
                .688104,
                .379105,
                .637795,
                .849926,
                .720593,
                .323834,
                .76378,
                .899765,
                .753543,
                .258657,
                .889764,
                .948487,
                .78692,
                .171778,
                1,
                .990413,
                .816451,
                .00729848
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_blue2yellow",
            RGBPoints: [
                -1,
                .0830122,
                0,
                .495617,
                -.87451,
                .141973,
                .0551288,
                .57363,
                -.74902,
                .193048,
                .110258,
                .604561,
                -.623529,
                .234231,
                .165386,
                .57643,
                -.498039,
                .275413,
                .220515,
                .548299,
                -.372549,
                .316596,
                .275644,
                .520169,
                -.247059,
                .357778,
                .330773,
                .492038,
                -.121569,
                .398961,
                .385901,
                .463908,
                .00392157,
                .449929,
                .438487,
                .426815,
                .129412,
                .511572,
                .488299,
                .379944,
                .254902,
                .581222,
                .53603,
                .325741,
                .380392,
                .650871,
                .583761,
                .271538,
                .505882,
                .720521,
                .631493,
                .217335,
                .631373,
                .79017,
                .679224,
                .163132,
                .756863,
                .85982,
                .726955,
                .108929,
                .882353,
                .910254,
                .774159,
                .14112,
                1,
                .927513,
                .81759,
                .306289
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_cyan2orange",
            RGBPoints: [
                -1,
                .0471513,
                .213874,
                .414329,
                -.87451,
                .0674702,
                .256648,
                .439027,
                -.74902,
                .0959957,
                .299331,
                .462089,
                -.623529,
                .132428,
                .341872,
                .483212,
                -.498039,
                .188743,
                .38277,
                .500597,
                -.372549,
                .268511,
                .420229,
                .512179,
                -.247059,
                .352945,
                .455602,
                .519101,
                -.121569,
                .43893,
                .489368,
                .521538,
                .00392157,
                .522445,
                .522495,
                .522436,
                .129412,
                .600089,
                .555682,
                .53205,
                .254902,
                .67988,
                .587981,
                .539163,
                .380392,
                .761011,
                .619586,
                .544439,
                .505882,
                .84278,
                .650741,
                .548567,
                .631373,
                .910713,
                .687347,
                .557822,
                .756863,
                .952232,
                .734972,
                .577775,
                .882353,
                .975642,
                .789858,
                .604868,
                1,
                .990752,
                .843643,
                .632857
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_purple2green",
            RGBPoints: [
                -1,
                .235006,
                .0483128,
                .530899,
                -.87451,
                .302968,
                .108419,
                .552391,
                -.74902,
                .360241,
                .166059,
                .569502,
                -.623529,
                .406746,
                .226782,
                .579373,
                -.498039,
                .444073,
                .28964,
                .582094,
                -.372549,
                .473648,
                .353774,
                .577947,
                -.247059,
                .497636,
                .418154,
                .567911,
                -.121569,
                .519086,
                .481741,
                .553968,
                .00392157,
                .542884,
                .542914,
                .542875,
                .129412,
                .566303,
                .603989,
                .527499,
                .254902,
                .595218,
                .662965,
                .516857,
                .380392,
                .628641,
                .720701,
                .510673,
                .505882,
                .665373,
                .777849,
                .508165,
                .631373,
                .704182,
                .834921,
                .508303,
                .756863,
                .743846,
                .892328,
                .50999,
                .882353,
                .783158,
                .950422,
                .512181,
                1,
                .818617,
                1,
                .513888
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_purple2green_dark",
            RGBPoints: [
                -1,
                .107656,
                0,
                .428682,
                -.87451,
                .1924,
                0,
                .449799,
                -.74902,
                .255118,
                .0648939,
                .466726,
                -.623529,
                .304256,
                .133066,
                .476703,
                -.498039,
                .343202,
                .19716,
                .479793,
                -.372549,
                .373876,
                .260353,
                .476241,
                -.247059,
                .398497,
                .322872,
                .466953,
                -.121569,
                .420016,
                .384252,
                .453785,
                .00392157,
                .44319,
                .443216,
                .443186,
                .129412,
                .465553,
                .502139,
                .428233,
                .254902,
                .492959,
                .559151,
                .417591,
                .380392,
                .524654,
                .615092,
                .411016,
                .505882,
                .55959,
                .670583,
                .40779,
                .631373,
                .596614,
                .726102,
                .406948,
                .756863,
                .634544,
                .782032,
                .407439,
                .882353,
                .672183,
                .838703,
                .408237,
                1,
                .706131,
                .892759,
                .408452
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "coolwarm",
            RGBPoints: [
                -1,
                .229806,
                .298718,
                .753683,
                -.875,
                .303869,
                .406535,
                .844959,
                -.75,
                .383013,
                .509419,
                .917388,
                -.625,
                .466667,
                .604563,
                .968155,
                -.5,
                .552953,
                .688929,
                .995376,
                -.375,
                .639176,
                .7596,
                .998151,
                -.25,
                .722193,
                .813953,
                .976575,
                -.125,
                .798692,
                .849786,
                .931689,
                0,
                .865395,
                .86541,
                .865396,
                .125,
                .924128,
                .827385,
                .774508,
                .25,
                .958853,
                .769768,
                .678008,
                .375,
                .969954,
                .694267,
                .579375,
                .5,
                .958003,
                .602842,
                .481776,
                .625,
                .923945,
                .497309,
                .38797,
                .75,
                .869187,
                .378313,
                .300267,
                .875,
                .795632,
                .241284,
                .220526,
                1,
                .705673,
                .0155562,
                .150233
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BuRd",
            RGBPoints: [
                -1,
                .019608,
                .188235,
                .380392,
                -.87451,
                .088504,
                .321107,
                .564937,
                -.74902,
                .163399,
                .444983,
                .697501,
                -.623529,
                .247059,
                .555709,
                .754095,
                -.498039,
                .420684,
                .676432,
                .818685,
                -.372549,
                .606459,
                .789773,
                .880277,
                -.247059,
                .761476,
                .868512,
                .924567,
                -.121569,
                .878047,
                .925721,
                .951942,
                .00392157,
                .969089,
                .966474,
                .964937,
                .129412,
                .983852,
                .897578,
                .846828,
                .254902,
                .982468,
                .800692,
                .706113,
                .380392,
                .960323,
                .66782,
                .536332,
                .505882,
                .894579,
                .503806,
                .399769,
                .631373,
                .81707,
                .33218,
                .281046,
                .756863,
                .728489,
                .155017,
                .197386,
                .882353,
                .576932,
                .055363,
                .14925,
                1,
                .403922,
                0,
                .121569
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Spectral_lowBlue",
            RGBPoints: [
                -1,
                .368627,
                .309804,
                .635294,
                -.87451,
                .260361,
                .450058,
                .70173,
                -.74902,
                .248058,
                .591311,
                .717186,
                -.623529,
                .376009,
                .734025,
                .658132,
                -.498039,
                .537947,
                .814764,
                .64506,
                -.372549,
                .702345,
                .879585,
                .636678,
                -.247059,
                .84752,
                .938639,
                .607151,
                -.121569,
                .940408,
                .976163,
                .656055,
                .00392157,
                .999923,
                .997616,
                .745021,
                .129412,
                .997463,
                .921338,
                .61707,
                .254902,
                .995002,
                .824606,
                .499885,
                .380392,
                .992541,
                .701576,
                .39654,
                .505882,
                .973472,
                .547405,
                .318108,
                .631373,
                .937793,
                .398539,
                .270127,
                .756863,
                .861515,
                .282891,
                .299654,
                .882353,
                .746482,
                .144637,
                .288812,
                1,
                .619608,
                .003922,
                .258824
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GnRP",
            RGBPoints: [
                -1,
                0,
                .266667,
                .105882,
                -.87451,
                .066436,
                .394617,
                .174779,
                -.74902,
                .168858,
                .524567,
                .25767,
                -.623529,
                .323875,
                .657439,
                .361015,
                -.498039,
                .504883,
                .772318,
                .506344,
                -.372549,
                .678431,
                .870127,
                .654902,
                -.247059,
                .803922,
                .921799,
                .780392,
                -.121569,
                .897116,
                .951942,
                .882814,
                .00392157,
                .967397,
                .965936,
                .967474,
                .129412,
                .928028,
                .879815,
                .930565,
                .254902,
                .866052,
                .780777,
                .882891,
                .380392,
                .77501,
                .665129,
                .821376,
                .505882,
                .675663,
                .537024,
                .737024,
                .631373,
                .57847,
                .396155,
                .645982,
                .756863,
                .492349,
                .223914,
                .547559,
                .882353,
                .375548,
                .096886,
                .423299,
                1,
                .25098,
                0,
                .294118
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GYPi",
            RGBPoints: [
                -1,
                .152941,
                .392157,
                .098039,
                -.87451,
                .246444,
                .505344,
                .117724,
                -.74902,
                .351942,
                .614533,
                .161399,
                -.623529,
                .474971,
                .717878,
                .240138,
                -.498039,
                .611995,
                .811226,
                .392849,
                -.372549,
                .746328,
                .893118,
                .565321,
                -.247059,
                .859516,
                .94233,
                .747405,
                -.121569,
                .928105,
                .96386,
                .875663,
                .00392157,
                .969089,
                .966859,
                .968012,
                .129412,
                .983852,
                .910265,
                .948328,
                .254902,
                .979239,
                .833218,
                .914648,
                .380392,
                .949712,
                .729873,
                .862976,
                .505882,
                .905652,
                .58293,
                .763552,
                .631373,
                .85521,
                .410073,
                .652211,
                .756863,
                .793695,
                .183699,
                .531642,
                .882353,
                .683737,
                .063899,
                .420761,
                1,
                .556863,
                .003922,
                .321569
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GnYlRd",
            RGBPoints: [
                -1,
                0,
                .407843,
                .215686,
                -.87451,
                .063975,
                .525952,
                .277201,
                -.74902,
                .177932,
                .633064,
                .332718,
                -.623529,
                .364937,
                .724106,
                .379469,
                -.498039,
                .527951,
                .797155,
                .40223,
                -.372549,
                .678431,
                .862822,
                .433449,
                -.247059,
                .803922,
                .916955,
                .514648,
                -.121569,
                .909419,
                .961861,
                .625067,
                .00392157,
                .999923,
                .997616,
                .745021,
                .129412,
                .997463,
                .921338,
                .61707,
                .254902,
                .995002,
                .824606,
                .499885,
                .380392,
                .992541,
                .701576,
                .39654,
                .505882,
                .973472,
                .547405,
                .318108,
                .631373,
                .939023,
                .389927,
                .245521,
                .756863,
                .867666,
                .239831,
                .176624,
                .882353,
                .762399,
                .110727,
                .151326,
                1,
                .647059,
                0,
                .14902
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GBBr",
            RGBPoints: [
                -1,
                0,
                .235294,
                .188235,
                -.87451,
                .002461,
                .338639,
                .301423,
                -.74902,
                .055902,
                .448981,
                .417609,
                -.623529,
                .183852,
                .56955,
                .538178,
                -.498039,
                .357785,
                .700115,
                .660746,
                -.372549,
                .540177,
                .819531,
                .77624,
                -.247059,
                .714879,
                .890888,
                .864821,
                -.121569,
                .851134,
                .934564,
                .922645,
                .00392157,
                .960861,
                .959785,
                .95694,
                .129412,
                .963322,
                .927797,
                .83391,
                .254902,
                .939946,
                .868897,
                .68935,
                .380392,
                .883353,
                .775394,
                .517109,
                .505882,
                .808074,
                .625836,
                .324106,
                .631373,
                .717647,
                .476355,
                .15494,
                .756863,
                .592157,
                .358247,
                .06882,
                .882353,
                .458593,
                .26436,
                .031142,
                1,
                .329412,
                .188235,
                .019608
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "PuOr",
            RGBPoints: [
                -1,
                .498039,
                .231373,
                .031373,
                -.87451,
                .62599,
                .30273,
                .026451,
                -.74902,
                .746943,
                .387082,
                .037524,
                -.623529,
                .85767,
                .490427,
                .071972,
                -.498039,
                .936409,
                .617762,
                .236371,
                -.372549,
                .992695,
                .743099,
                .43291,
                -.247059,
                .995156,
                .841523,
                .63714,
                -.121569,
                .985313,
                .913802,
                .813687,
                .00392157,
                .966244,
                .966398,
                .967705,
                .129412,
                .889965,
                .89504,
                .938178,
                .254902,
                .806151,
                .804306,
                .894656,
                .380392,
                .712649,
                .688658,
                .833141,
                .505882,
                .594233,
                .554325,
                .744637,
                .631373,
                .474894,
                .404229,
                .652364,
                .756863,
                .366628,
                .217224,
                .563783,
                .882353,
                .266436,
                .089965,
                .434833,
                1,
                .176471,
                0,
                .294118
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "PRGn",
            RGBPoints: [
                -1,
                .25098,
                0,
                .294118,
                -.87451,
                .383852,
                .103345,
                .431911,
                -.74902,
                .497732,
                .234679,
                .55371,
                -.623529,
                .583852,
                .40692,
                .652134,
                -.498039,
                .681968,
                .545175,
                .742561,
                -.372549,
                .7807,
                .672357,
                .825221,
                -.247059,
                .871742,
                .788005,
                .886736,
                -.121569,
                .930488,
                .885198,
                .932872,
                .00392157,
                .966321,
                .968089,
                .965859,
                .129412,
                .892503,
                .950865,
                .877278,
                .254902,
                .796078,
                .91857,
                .772549,
                .380392,
                .670588,
                .866897,
                .647059,
                .505882,
                .493195,
                .765398,
                .496655,
                .631373,
                .314187,
                .649135,
                .354556,
                .756863,
                .15917,
                .516263,
                .251211,
                .882353,
                .062284,
                .386621,
                .170473,
                1,
                0,
                .266667,
                .105882
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "PiYG",
            RGBPoints: [
                -1,
                .556863,
                .003922,
                .321569,
                -.87451,
                .692195,
                .067897,
                .427374,
                -.74902,
                .797539,
                .197847,
                .539177,
                -.623529,
                .859054,
                .424221,
                .659746,
                -.498039,
                .908574,
                .592618,
                .770319,
                -.372549,
                .951557,
                .736332,
                .866205,
                -.247059,
                .981084,
                .839677,
                .917878,
                -.121569,
                .98293,
                .913802,
                .949558,
                .00392157,
                .96732,
                .968474,
                .965629,
                .129412,
                .92549,
                .963552,
                .869666,
                .254902,
                .852441,
                .939254,
                .736025,
                .380392,
                .739254,
                .890042,
                .553941,
                .505882,
                .60323,
                .805536,
                .382238,
                .631373,
                .467282,
                .711419,
                .235217,
                .756863,
                .344252,
                .608074,
                .156478,
                .882353,
                .2406,
                .49827,
                .116494,
                1,
                .152941,
                .392157,
                .098039
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "OrPu",
            RGBPoints: [
                -1,
                .176471,
                0,
                .294118,
                -.87451,
                .272434,
                .095963,
                .444214,
                -.74902,
                .373395,
                .228912,
                .56932,
                -.623529,
                .481661,
                .415917,
                .657901,
                -.498039,
                .601922,
                .562937,
                .750481,
                -.372549,
                .718493,
                .695886,
                .836986,
                -.247059,
                .811995,
                .811534,
                .898501,
                -.121569,
                .894733,
                .8995,
                .940023,
                .00392157,
                .969166,
                .966859,
                .963629,
                .129412,
                .98639,
                .910265,
                .803691,
                .254902,
                .995002,
                .835371,
                .624375,
                .380392,
                .992541,
                .736947,
                .420146,
                .505882,
                .931949,
                .609458,
                .224221,
                .631373,
                .85075,
                .483968,
                .069819,
                .756863,
                .740023,
                .380623,
                .035371,
                .882353,
                .617993,
                .29827,
                .026759,
                1,
                .498039,
                .231373,
                .031373
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "BrBG",
            RGBPoints: [
                -1,
                .329412,
                .188235,
                .019608,
                -.87451,
                .467205,
                .269435,
                .031911,
                -.74902,
                .6,
                .365629,
                .074202,
                -.623529,
                .72549,
                .483737,
                .160323,
                -.498039,
                .812995,
                .635832,
                .336409,
                -.372549,
                .88689,
                .781238,
                .527874,
                -.247059,
                .943483,
                .87474,
                .700115,
                -.121569,
                .963168,
                .929796,
                .841599,
                .00392157,
                .957247,
                .959938,
                .959554,
                .129412,
                .84406,
                .932872,
                .920185,
                .254902,
                .70396,
                .886428,
                .859285,
                .380392,
                .529258,
                .815071,
                .770704,
                .505882,
                .346251,
                .691811,
                .653057,
                .631373,
                .175855,
                .562015,
                .530642,
                .756863,
                .047905,
                .441446,
                .410073,
                .882353,
                .002307,
                .33218,
                .294348,
                1,
                0,
                .235294,
                .188235
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "GyRd",
            RGBPoints: [
                -1,
                .101961,
                .101961,
                .101961,
                -.87451,
                .227451,
                .227451,
                .227451,
                -.74902,
                .359939,
                .359939,
                .359939,
                -.623529,
                .502653,
                .502653,
                .502653,
                -.498039,
                .631373,
                .631373,
                .631373,
                -.372549,
                .749865,
                .749865,
                .749865,
                -.247059,
                .843368,
                .843368,
                .843368,
                -.121569,
                .926105,
                .926105,
                .926105,
                .00392157,
                .999846,
                .997232,
                .995694,
                .129412,
                .994925,
                .908651,
                .857901,
                .254902,
                .982468,
                .800692,
                .706113,
                .380392,
                .960323,
                .66782,
                .536332,
                .505882,
                .894579,
                .503806,
                .399769,
                .631373,
                .81707,
                .33218,
                .281046,
                .756863,
                .728489,
                .155017,
                .197386,
                .882353,
                .576932,
                .055363,
                .14925,
                1,
                .403922,
                0,
                .121569
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_divHi_purpleGreen",
            RGBPoints: [
                -1,
                .297553,
                0,
                .489074,
                -.87451,
                .40259,
                .151146,
                .567754,
                -.74902,
                .516038,
                .284843,
                .658231,
                -.623529,
                .629783,
                .423646,
                .750938,
                -.498039,
                .735198,
                .563697,
                .835956,
                -.372549,
                .82408,
                .695541,
                .903582,
                -.247059,
                .889091,
                .807454,
                .944862,
                -.121569,
                .92334,
                .886917,
                .951839,
                .00392157,
                .921045,
                .921084,
                .921003,
                .129412,
                .877324,
                .907455,
                .845381,
                .254902,
                .797649,
                .849713,
                .734695,
                .380392,
                .691646,
                .75964,
                .600532,
                .505882,
                .568981,
                .649159,
                .453807,
                .631373,
                .438945,
                .529756,
                .304259,
                .756863,
                .30973,
                .412001,
                .158303,
                .882353,
                .187078,
                .305111,
                .00251458,
                1,
                .101655,
                .220836,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_divHi_purpleGreen_dim",
            RGBPoints: [
                -1,
                .404088,
                .131038,
                .592767,
                -.87451,
                .486469,
                .230957,
                .651243,
                -.74902,
                .575165,
                .339335,
                .717723,
                -.623529,
                .662741,
                .454332,
                .784263,
                -.498039,
                .742071,
                .570213,
                .842918,
                -.372549,
                .806935,
                .678992,
                .886227,
                -.247059,
                .852219,
                .771315,
                .90763,
                -.121569,
                .873345,
                .837327,
                .901572,
                .00392157,
                .866783,
                .86682,
                .866745,
                .129412,
                .82839,
                .858225,
                .796812,
                .254902,
                .762578,
                .814287,
                .700202,
                .380392,
                .676429,
                .744229,
                .585735,
                .505882,
                .577033,
                .65732,
                .461526,
                .631373,
                .47128,
                .562476,
                .33476,
                .756863,
                .365461,
                .467957,
                .21076,
                .882353,
                .264758,
                .381138,
                .0878313,
                1,
                .182591,
                .312249,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_divLow_icePeach",
            RGBPoints: [
                -1,
                .480048,
                .817441,
                .998056,
                -.87451,
                .425898,
                .726921,
                .883187,
                -.74902,
                .366682,
                .629445,
                .761936,
                -.623529,
                .308756,
                .531002,
                .640217,
                -.498039,
                .258021,
                .43705,
                .523433,
                -.372549,
                .219244,
                .352381,
                .416348,
                -.247059,
                .195127,
                .281032,
                .322979,
                -.121569,
                .186286,
                .22627,
                .246525,
                .00392157,
                .192352,
                .19236,
                .192364,
                .129412,
                .255927,
                .214469,
                .191756,
                .254902,
                .340459,
                .254426,
                .206666,
                .380392,
                .444655,
                .309315,
                .234029,
                .505882,
                .565353,
                .376004,
                .270969,
                .631373,
                .697917,
                .450748,
                .314293,
                .756863,
                .836657,
                .529064,
                .360227,
                .882353,
                .972695,
                .614884,
                .413123,
                1,
                1,
                .705904,
                .472699
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_divLow_purpleGreen",
            RGBPoints: [
                -1,
                .956034,
                .666487,
                .952663,
                -.87451,
                .874457,
                .572698,
                .936352,
                -.74902,
                .753465,
                .488253,
                .909063,
                -.623529,
                .63309,
                .413507,
                .763833,
                -.498039,
                .514491,
                .345878,
                .620015,
                -.372549,
                .405008,
                .288141,
                .484376,
                -.247059,
                .311388,
                .241986,
                .363556,
                -.121569,
                .238722,
                .209044,
                .263449,
                .00392157,
                .192352,
                .192366,
                .192362,
                .129412,
                .200379,
                .233201,
                .168618,
                .254902,
                .230151,
                .291737,
                .165227,
                .380392,
                .279481,
                .366076,
                .178607,
                .505882,
                .344927,
                .453267,
                .205703,
                .631373,
                .421554,
                .549449,
                .242643,
                .756863,
                .503334,
                .649999,
                .284377,
                .882353,
                .583497,
                .749672,
                .324969,
                1,
                .650705,
                .837228,
                .356264
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Haze_green",
            RGBPoints: [
                -1,
                1,
                .835294,
                .886275,
                -.87451,
                .937255,
                .756863,
                .870443,
                -.74902,
                .875817,
                .666376,
                .857807,
                -.623529,
                .778359,
                .583007,
                .808134,
                -.498039,
                .676253,
                .494118,
                .745098,
                -.372549,
                .561365,
                .390123,
                .682353,
                -.247059,
                .438344,
                .262745,
                .621496,
                -.121569,
                .321133,
                .141031,
                .558751,
                .00392157,
                .203922,
                .0217865,
                .495861,
                .129412,
                .265505,
                .129412,
                .433261,
                .254902,
                .311692,
                .255338,
                .37008,
                .380392,
                .356282,
                .377342,
                .310821,
                .505882,
                .39971,
                .488889,
                .258243,
                .631373,
                .442556,
                .604357,
                .205519,
                .756863,
                .48671,
                .71968,
                .152941,
                .882353,
                .529847,
                .830356,
                .100944,
                1,
                .572549,
                .933333,
                .054902
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Haze_lime",
            RGBPoints: [
                -1,
                .704034,
                .784196,
                1,
                -.87451,
                .633111,
                .691418,
                .956078,
                -.74902,
                .564021,
                .600606,
                .912157,
                -.623529,
                .496827,
                .51189,
                .868235,
                -.498039,
                .43157,
                .425416,
                .824314,
                -.372549,
                .368248,
                .341347,
                .780392,
                -.247059,
                .306767,
                .259855,
                .736471,
                -.121569,
                .246862,
                .181069,
                .692549,
                .00392157,
                .191619,
                .109542,
                .648627,
                .129412,
                .257404,
                .194031,
                .604706,
                .254902,
                .321794,
                .278775,
                .560784,
                .380392,
                .387909,
                .364617,
                .516863,
                .505882,
                .456569,
                .451881,
                .472941,
                .631373,
                .527424,
                .540773,
                .42902,
                .756863,
                .599759,
                .631427,
                .385098,
                .882353,
                .673065,
                .723898,
                .341176,
                1,
                .742751,
                .812252,
                .3
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "Haze",
            RGBPoints: [
                -1,
                1,
                .835294,
                .996078,
                -.00392157,
                .023529,
                .141176,
                .498039,
                .00392157,
                .015686,
                .137255,
                .494118,
                1,
                .984314,
                .764706,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "Haze_cyan",
            RGBPoints: [
                -1,
                .956863,
                1,
                .835294,
                -.87451,
                .933188,
                .921714,
                .760784,
                -.74902,
                .870588,
                .803486,
                .671605,
                -.623529,
                .807843,
                .684096,
                .583297,
                -.498039,
                .745098,
                .569208,
                .494118,
                -.372549,
                .682353,
                .437763,
                .390123,
                -.247059,
                .621496,
                .288163,
                .262745,
                -.121569,
                .558751,
                .144517,
                .141031,
                .00392157,
                .495861,
                .0217865,
                .0413943,
                .129412,
                .433261,
                .137255,
                .129412,
                .254902,
                .37008,
                .263181,
                .255338,
                .380392,
                .306318,
                .381845,
                .372694,
                .505882,
                .243137,
                .503994,
                .494263,
                .631373,
                .180392,
                .629484,
                .619753,
                .756863,
                .117647,
                .754975,
                .747131,
                .882353,
                .054902,
                .876398,
                .866812,
                1,
                0,
                .988235,
                .976471
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "nic_Edge",
            RGBPoints: [
                -1,
                .191208,
                .191208,
                .191208,
                -.87451,
                .239484,
                .00545035,
                .614821,
                -.74902,
                .220593,
                .0617459,
                .863547,
                -.623529,
                .17509,
                .278988,
                .97794,
                -.498039,
                .143526,
                .576069,
                .998553,
                -.372549,
                .166456,
                .871883,
                .96594,
                -.247059,
                .376202,
                .993555,
                .981833,
                -.121569,
                .681996,
                .991297,
                .999239,
                .00392157,
                .954172,
                .952734,
                .94374,
                .129412,
                .999735,
                .99301,
                .662896,
                .254902,
                .979399,
                .991466,
                .357973,
                .380392,
                .968771,
                .854967,
                .162659,
                .505882,
                .999245,
                .556697,
                .144323,
                .631373,
                .973959,
                .26223,
                .177946,
                .756863,
                .852358,
                .0526707,
                .222974,
                .882353,
                .593889,
                .00912724,
                .238855,
                1,
                .191208,
                .191208,
                .191208
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_iceFire_H",
            RGBPoints: [
                -1,
                405432e-12,
                0,
                590122e-11,
                -.87451,
                0,
                .120401,
                .302675,
                -.74902,
                0,
                .216583,
                .524574,
                -.623529,
                .0552475,
                .345025,
                .6595,
                -.498039,
                .128047,
                .492588,
                .720288,
                -.372549,
                .188955,
                .641309,
                .792092,
                -.247059,
                .327673,
                .784935,
                .873434,
                -.121569,
                .60824,
                .892164,
                .935547,
                .00392157,
                .881371,
                .912178,
                .818099,
                .129412,
                .951407,
                .835621,
                .449279,
                .254902,
                .904481,
                .690489,
                0,
                .380392,
                .85407,
                .510864,
                0,
                .505882,
                .777093,
                .33018,
                88199e-8,
                .631373,
                .672862,
                .139087,
                .00269398,
                .756863,
                .508815,
                0,
                0,
                .882353,
                .299417,
                366289e-9,
                547829e-9,
                1,
                .0157519,
                .00332021,
                455569e-13
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "erdc_iceFire_L",
            RGBPoints: [
                -1,
                .870485,
                .913768,
                .832905,
                -.87451,
                .586919,
                .887865,
                .934003,
                -.74902,
                .31583,
                .776442,
                .867858,
                -.623529,
                .18302,
                .632034,
                .787722,
                -.498039,
                .117909,
                .484134,
                .713825,
                -.372549,
                .0507239,
                .335979,
                .654741,
                -.247059,
                0,
                .209874,
                .511832,
                -.121569,
                0,
                .114689,
                .28935,
                .00392157,
                .0157519,
                .00332021,
                455569e-13,
                .129412,
                .312914,
                0,
                0,
                .254902,
                .520865,
                0,
                0,
                .380392,
                .680105,
                .15255,
                .0025996,
                .505882,
                .785109,
                .339479,
                797922e-9,
                .631373,
                .857354,
                .522494,
                0,
                .756863,
                .910974,
                .699774,
                0,
                .882353,
                .951921,
                .842817,
                .478545,
                1,
                .881371,
                .912178,
                .818099
            ]
        },
        {
            ColorSpace: "RGB",
            Name: "hsv",
            RGBPoints: [
                -1,
                1,
                0,
                0,
                -.666666,
                1,
                0,
                1,
                -.333333,
                0,
                0,
                1,
                0,
                0,
                1,
                1,
                .33333,
                0,
                1,
                0,
                .66666,
                1,
                1,
                0,
                1,
                1,
                0,
                0
            ]
        },
        {
            ColorSpace: "Lab",
            Name: "hue_L60",
            RGBPoints: [
                -1,
                .964784,
                .400592,
                .349549,
                -.87451,
                .964915,
                .372498,
                .53785,
                -.74902,
                .892353,
                .401039,
                .759569,
                -.623529,
                .79263,
                .446956,
                .903017,
                -.498039,
                .682208,
                .49954,
                .966673,
                -.372549,
                .56392,
                .553082,
                .968836,
                -.247059,
                .442031,
                .606396,
                .901601,
                -.121569,
                .305499,
                .65701,
                .765784,
                .00392157,
                .197251,
                .687914,
                .620914,
                .129412,
                .193882,
                .701887,
                .472654,
                .254902,
                .249866,
                .706123,
                .320005,
                .380392,
                .35132,
                .697417,
                .202919,
                .505882,
                .498097,
                .669467,
                .125232,
                .631373,
                .637477,
                .626239,
                .107431,
                .756863,
                .762115,
                .56872,
                .155812,
                .882353,
                .889434,
                .481116,
                .240445,
                1,
                .964784,
                .400592,
                .349549
            ]
        },
        {
            IndexedColors: [
                0,
                0,
                0,
                .8941176470588236,
                .1019607843137255,
                .1098039215686274,
                .2156862745098039,
                .4941176470588236,
                .7215686274509804,
                .3019607843137255,
                .6862745098039216,
                .2901960784313726,
                .596078431372549,
                .3058823529411765,
                .6392156862745098,
                1,
                .4980392156862745,
                0,
                .6509803921568628,
                .3372549019607843,
                .1568627450980392
            ],
            Name: "Spectrum",
            NanColor: [
                .6509803921568628,
                .3372549019607843,
                .1568627450980392
            ]
        },
        {
            IndexedColors: [
                .4745098039215686,
                .09019607843137255,
                .09019607843137255,
                .7098039215686275,
                .00392156862745098,
                .00392156862745098,
                .9372549019607843,
                .2784313725490196,
                .09803921568627451,
                .9764705882352941,
                .5137254901960784,
                .1411764705882353,
                1,
                .7058823529411765,
                0,
                1,
                .8980392156862745,
                .02352941176470588
            ],
            Name: "Warm",
            NanColor: [
                1,
                .8980392156862745,
                .02352941176470588
            ]
        },
        {
            IndexedColors: [
                .4588235294117647,
                .6941176470588235,
                .00392156862745098,
                .3450980392156863,
                .5019607843137255,
                .1607843137254902,
                .3137254901960784,
                .8431372549019608,
                .7490196078431373,
                .1098039215686274,
                .5843137254901961,
                .803921568627451,
                .2313725490196079,
                .407843137254902,
                .6705882352941176,
                .6039215686274509,
                .407843137254902,
                1,
                .3725490196078431,
                .2,
                .5019607843137255
            ],
            Name: "Cool",
            NanColor: [
                .3725490196078431,
                .2,
                .5019607843137255
            ]
        },
        {
            IndexedColors: [
                .2313725490196079,
                .407843137254902,
                .6705882352941176,
                .1098039215686274,
                .5843137254901961,
                .803921568627451,
                .3058823529411765,
                .8509803921568627,
                .9176470588235294,
                .4509803921568628,
                .6039215686274509,
                .8352941176470589,
                .2588235294117647,
                .2392156862745098,
                .6627450980392157,
                .3137254901960784,
                .3294117647058823,
                .5294117647058824,
                .06274509803921569,
                .1647058823529412,
                .3215686274509804
            ],
            Name: "Blues",
            NanColor: [
                .06274509803921569,
                .1647058823529412,
                .3215686274509804
            ]
        },
        {
            IndexedColors: [
                .1098039215686274,
                .5843137254901961,
                .803921568627451,
                .2313725490196079,
                .407843137254902,
                .6705882352941176,
                .4,
                .2431372549019608,
                .7176470588235294,
                .6352941176470588,
                .3294117647058823,
                .8117647058823529,
                .8705882352941177,
                .3803921568627451,
                .807843137254902,
                .8627450980392157,
                .3803921568627451,
                .5843137254901961,
                .2392156862745098,
                .06274509803921569,
                .3215686274509804
            ],
            Name: "Wild Flower",
            NanColor: [
                .2392156862745098,
                .06274509803921569,
                .3215686274509804
            ]
        },
        {
            IndexedColors: [
                .396078431372549,
                .4862745098039216,
                .2156862745098039,
                .4588235294117647,
                .6941176470588235,
                .00392156862745098,
                .6980392156862745,
                .7294117647058823,
                .1882352941176471,
                1,
                .8980392156862745,
                .02352941176470588,
                1,
                .7058823529411765,
                0,
                .9764705882352941,
                .5137254901960784,
                .1411764705882353
            ],
            Name: "Citrus",
            NanColor: [
                .9764705882352941,
                .5137254901960784,
                .1411764705882353
            ]
        },
        {
            IndexedColors: [
                .4980392156862745,
                .2313725490196079,
                .03137254901960784,
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .8784313725490196,
                .5098039215686274,
                .0784313725490196,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .9686274509803922,
                .9686274509803922,
                .9686274509803922,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .5019607843137255,
                .4509803921568628,
                .6745098039215687,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333,
                .1764705882352941,
                0,
                .2941176470588235
            ],
            Name: "Brewer Diverging Purple-Orange (11)",
            NanColor: [
                .1764705882352941,
                0,
                .2941176470588235
            ]
        },
        {
            IndexedColors: [
                .4980392156862745,
                .2313725490196079,
                .03137254901960784,
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .8784313725490196,
                .5098039215686274,
                .0784313725490196,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .5019607843137255,
                .4509803921568628,
                .6745098039215687,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333,
                .1764705882352941,
                0,
                .2941176470588235
            ],
            Name: "Brewer Diverging Purple-Orange (10)",
            NanColor: [
                .1764705882352941,
                0,
                .2941176470588235
            ]
        },
        {
            IndexedColors: [
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .8784313725490196,
                .5098039215686274,
                .0784313725490196,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .9686274509803922,
                .9686274509803922,
                .9686274509803922,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .5019607843137255,
                .4509803921568628,
                .6745098039215687,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ],
            Name: "Brewer Diverging Purple-Orange (9)",
            NanColor: [
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ]
        },
        {
            IndexedColors: [
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .8784313725490196,
                .5098039215686274,
                .0784313725490196,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .5019607843137255,
                .4509803921568628,
                .6745098039215687,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ],
            Name: "Brewer Diverging Purple-Orange (8)",
            NanColor: [
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ]
        },
        {
            IndexedColors: [
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .9450980392156862,
                .6392156862745098,
                .2509803921568627,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .9686274509803922,
                .9686274509803922,
                .9686274509803922,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6,
                .5568627450980392,
                .7647058823529411,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ],
            Name: "Brewer Diverging Purple-Orange (7)",
            NanColor: [
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ]
        },
        {
            IndexedColors: [
                .7019607843137254,
                .3450980392156863,
                .02352941176470588,
                .9450980392156862,
                .6392156862745098,
                .2509803921568627,
                .996078431372549,
                .8784313725490196,
                .7137254901960784,
                .8470588235294118,
                .8549019607843137,
                .9215686274509803,
                .6,
                .5568627450980392,
                .7647058823529411,
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ],
            Name: "Brewer Diverging Purple-Orange (6)",
            NanColor: [
                .3294117647058823,
                .1529411764705882,
                .5333333333333333
            ]
        },
        {
            IndexedColors: [
                .9019607843137255,
                .3803921568627451,
                .00392156862745098,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .9686274509803922,
                .9686274509803922,
                .9686274509803922,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .3686274509803922,
                .2352941176470588,
                .6
            ],
            Name: "Brewer Diverging Purple-Orange (5)",
            NanColor: [
                .3686274509803922,
                .2352941176470588,
                .6
            ]
        },
        {
            IndexedColors: [
                .9019607843137255,
                .3803921568627451,
                .00392156862745098,
                .9921568627450981,
                .7215686274509804,
                .3882352941176471,
                .6980392156862745,
                .6705882352941176,
                .8235294117647058,
                .3686274509803922,
                .2352941176470588,
                .6
            ],
            Name: "Brewer Diverging Purple-Orange (4)",
            NanColor: [
                .3686274509803922,
                .2352941176470588,
                .6
            ]
        },
        {
            IndexedColors: [
                .9450980392156862,
                .6392156862745098,
                .2509803921568627,
                .9686274509803922,
                .9686274509803922,
                .9686274509803922,
                .6,
                .5568627450980392,
                .7647058823529411
            ],
            Name: "Brewer Diverging Purple-Orange (3)",
            NanColor: [
                .6,
                .5568627450980392,
                .7647058823529411
            ]
        },
        {
            IndexedColors: [
                .6196078431372549,
                .00392156862745098,
                .2588235294117647,
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9568627450980393,
                .4274509803921568,
                .2627450980392157,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                1,
                1,
                .7490196078431373,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .4,
                .7607843137254902,
                .6470588235294118,
                .196078431372549,
                .5333333333333333,
                .7411764705882353,
                .3686274509803922,
                .3098039215686275,
                .6352941176470588
            ],
            Name: "Brewer Diverging Spectral (11)",
            NanColor: [
                .3686274509803922,
                .3098039215686275,
                .6352941176470588
            ]
        },
        {
            IndexedColors: [
                .6196078431372549,
                .00392156862745098,
                .2588235294117647,
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9568627450980393,
                .4274509803921568,
                .2627450980392157,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .4,
                .7607843137254902,
                .6470588235294118,
                .196078431372549,
                .5333333333333333,
                .7411764705882353,
                .3686274509803922,
                .3098039215686275,
                .6352941176470588
            ],
            Name: "Brewer Diverging Spectral (10)",
            NanColor: [
                .3686274509803922,
                .3098039215686275,
                .6352941176470588
            ]
        },
        {
            IndexedColors: [
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9568627450980393,
                .4274509803921568,
                .2627450980392157,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                1,
                1,
                .7490196078431373,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .4,
                .7607843137254902,
                .6470588235294118,
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ],
            Name: "Brewer Diverging Spectral (9)",
            NanColor: [
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ]
        },
        {
            IndexedColors: [
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9568627450980393,
                .4274509803921568,
                .2627450980392157,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .4,
                .7607843137254902,
                .6470588235294118,
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ],
            Name: "Brewer Diverging Spectral (8)",
            NanColor: [
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ]
        },
        {
            IndexedColors: [
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9882352941176471,
                .5529411764705883,
                .3490196078431372,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                1,
                1,
                .7490196078431373,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6,
                .8352941176470589,
                .5803921568627451,
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ],
            Name: "Brewer Diverging Spectral (7)",
            NanColor: [
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ]
        },
        {
            IndexedColors: [
                .8352941176470589,
                .2431372549019608,
                .3098039215686275,
                .9882352941176471,
                .5529411764705883,
                .3490196078431372,
                .996078431372549,
                .8784313725490196,
                .5450980392156862,
                .9019607843137255,
                .9607843137254902,
                .596078431372549,
                .6,
                .8352941176470589,
                .5803921568627451,
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ],
            Name: "Brewer Diverging Spectral (6)",
            NanColor: [
                .196078431372549,
                .5333333333333333,
                .7411764705882353
            ]
        },
        {
            IndexedColors: [
                .8431372549019608,
                .09803921568627451,
                .1098039215686274,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                1,
                1,
                .7490196078431373,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .1686274509803922,
                .5137254901960784,
                .7294117647058823
            ],
            Name: "Brewer Diverging Spectral (5)",
            NanColor: [
                .1686274509803922,
                .5137254901960784,
                .7294117647058823
            ]
        },
        {
            IndexedColors: [
                .8431372549019608,
                .09803921568627451,
                .1098039215686274,
                .9921568627450981,
                .6823529411764706,
                .3803921568627451,
                .6705882352941176,
                .8666666666666667,
                .6431372549019608,
                .1686274509803922,
                .5137254901960784,
                .7294117647058823
            ],
            Name: "Brewer Diverging Spectral (4)",
            NanColor: [
                .1686274509803922,
                .5137254901960784,
                .7294117647058823
            ]
        },
        {
            IndexedColors: [
                .9882352941176471,
                .5529411764705883,
                .3490196078431372,
                1,
                1,
                .7490196078431373,
                .6,
                .8352941176470589,
                .5803921568627451
            ],
            Name: "Brewer Diverging Spectral (3)",
            NanColor: [
                .6,
                .8352941176470589,
                .5803921568627451
            ]
        },
        {
            IndexedColors: [
                .3294117647058823,
                .1882352941176471,
                .0196078431372549,
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .7490196078431373,
                .5058823529411764,
                .1764705882352941,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .9607843137254902,
                .9607843137254902,
                .9607843137254902,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .207843137254902,
                .592156862745098,
                .5607843137254902,
                .00392156862745098,
                .4,
                .3686274509803922,
                0,
                .2352941176470588,
                .1882352941176471
            ],
            Name: "Brewer Diverging Brown-Blue-Green (11)",
            NanColor: [
                0,
                .2352941176470588,
                .1882352941176471
            ]
        },
        {
            IndexedColors: [
                .3294117647058823,
                .1882352941176471,
                .0196078431372549,
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .7490196078431373,
                .5058823529411764,
                .1764705882352941,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .207843137254902,
                .592156862745098,
                .5607843137254902,
                .00392156862745098,
                .4,
                .3686274509803922,
                0,
                .2352941176470588,
                .1882352941176471
            ],
            Name: "Brewer Diverging Brown-Blue-Green (10)",
            NanColor: [
                0,
                .2352941176470588,
                .1882352941176471
            ]
        },
        {
            IndexedColors: [
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .7490196078431373,
                .5058823529411764,
                .1764705882352941,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .9607843137254902,
                .9607843137254902,
                .9607843137254902,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .207843137254902,
                .592156862745098,
                .5607843137254902,
                .00392156862745098,
                .4,
                .3686274509803922
            ],
            Name: "Brewer Diverging Brown-Blue-Green (9)",
            NanColor: [
                .00392156862745098,
                .4,
                .3686274509803922
            ]
        },
        {
            IndexedColors: [
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .7490196078431373,
                .5058823529411764,
                .1764705882352941,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .207843137254902,
                .592156862745098,
                .5607843137254902,
                .00392156862745098,
                .4,
                .3686274509803922
            ],
            Name: "Brewer Diverging Brown-Blue-Green (8)",
            NanColor: [
                .00392156862745098,
                .4,
                .3686274509803922
            ]
        },
        {
            IndexedColors: [
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .8470588235294118,
                .7019607843137254,
                .396078431372549,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .9607843137254902,
                .9607843137254902,
                .9607843137254902,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .3529411764705883,
                .7058823529411765,
                .6745098039215687,
                .00392156862745098,
                .4,
                .3686274509803922
            ],
            Name: "Brewer Diverging Brown-Blue-Green (7)",
            NanColor: [
                .00392156862745098,
                .4,
                .3686274509803922
            ]
        },
        {
            IndexedColors: [
                .5490196078431373,
                .3176470588235294,
                .0392156862745098,
                .8470588235294118,
                .7019607843137254,
                .396078431372549,
                .9647058823529412,
                .9098039215686274,
                .7647058823529411,
                .7803921568627451,
                .9176470588235294,
                .8980392156862745,
                .3529411764705883,
                .7058823529411765,
                .6745098039215687,
                .00392156862745098,
                .4,
                .3686274509803922
            ],
            Name: "Brewer Diverging Brown-Blue-Green (6)",
            NanColor: [
                .00392156862745098,
                .4,
                .3686274509803922
            ]
        },
        {
            IndexedColors: [
                .6509803921568628,
                .3803921568627451,
                .1019607843137255,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .9607843137254902,
                .9607843137254902,
                .9607843137254902,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .00392156862745098,
                .5215686274509804,
                .4431372549019608
            ],
            Name: "Brewer Diverging Brown-Blue-Green (5)",
            NanColor: [
                .00392156862745098,
                .5215686274509804,
                .4431372549019608
            ]
        },
        {
            IndexedColors: [
                .6509803921568628,
                .3803921568627451,
                .1019607843137255,
                .8745098039215686,
                .7607843137254902,
                .4901960784313725,
                .5019607843137255,
                .803921568627451,
                .7568627450980392,
                .00392156862745098,
                .5215686274509804,
                .4431372549019608
            ],
            Name: "Brewer Diverging Brown-Blue-Green (4)",
            NanColor: [
                .00392156862745098,
                .5215686274509804,
                .4431372549019608
            ]
        },
        {
            IndexedColors: [
                .8470588235294118,
                .7019607843137254,
                .396078431372549,
                .9607843137254902,
                .9607843137254902,
                .9607843137254902,
                .3529411764705883,
                .7058823529411765,
                .6745098039215687
            ],
            Name: "Brewer Diverging Brown-Blue-Green (3)",
            NanColor: [
                .3529411764705883,
                .7058823529411765,
                .6745098039215687
            ]
        },
        {
            IndexedColors: [
                .9686274509803922,
                .9882352941176471,
                .9921568627450981,
                .8980392156862745,
                .9607843137254902,
                .9764705882352941,
                .8,
                .9254901960784314,
                .9019607843137255,
                .6,
                .8470588235294118,
                .788235294117647,
                .4,
                .7607843137254902,
                .6431372549019608,
                .2549019607843137,
                .6823529411764706,
                .4627450980392157,
                .1372549019607843,
                .5450980392156862,
                .2705882352941176,
                0,
                .4274509803921568,
                .1725490196078431,
                0,
                .2666666666666667,
                .1058823529411765
            ],
            Name: "Brewer Sequential Blue-Green (9)",
            NanColor: [
                0,
                .2666666666666667,
                .1058823529411765
            ]
        },
        {
            IndexedColors: [
                .9686274509803922,
                .9882352941176471,
                .9921568627450981,
                .8980392156862745,
                .9607843137254902,
                .9764705882352941,
                .8,
                .9254901960784314,
                .9019607843137255,
                .6,
                .8470588235294118,
                .788235294117647,
                .4,
                .7607843137254902,
                .6431372549019608,
                .2549019607843137,
                .6823529411764706,
                .4627450980392157,
                .1372549019607843,
                .5450980392156862,
                .2705882352941176,
                0,
                .3450980392156863,
                .1411764705882353
            ],
            Name: "Brewer Sequential Blue-Green (8)",
            NanColor: [
                0,
                .3450980392156863,
                .1411764705882353
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .8,
                .9254901960784314,
                .9019607843137255,
                .8,
                .9254901960784314,
                .9019607843137255,
                .4,
                .7607843137254902,
                .6431372549019608,
                .2549019607843137,
                .6823529411764706,
                .4627450980392157,
                .1372549019607843,
                .5450980392156862,
                .2705882352941176,
                0,
                .3450980392156863,
                .1411764705882353
            ],
            Name: "Brewer Sequential Blue-Green (7)",
            NanColor: [
                0,
                .3450980392156863,
                .1411764705882353
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .8,
                .9254901960784314,
                .9019607843137255,
                .6,
                .8470588235294118,
                .788235294117647,
                .4,
                .7607843137254902,
                .6431372549019608,
                .1725490196078431,
                .6352941176470588,
                .3725490196078431,
                0,
                .4274509803921568,
                .1725490196078431
            ],
            Name: "Brewer Sequential Blue-Green (6)",
            NanColor: [
                0,
                .4274509803921568,
                .1725490196078431
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .6980392156862745,
                .8862745098039215,
                .8862745098039215,
                .4,
                .7607843137254902,
                .6431372549019608,
                .1725490196078431,
                .6352941176470588,
                .3725490196078431,
                0,
                .4274509803921568,
                .1725490196078431
            ],
            Name: "Brewer Sequential Blue-Green (5)",
            NanColor: [
                0,
                .4274509803921568,
                .1725490196078431
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .6980392156862745,
                .8862745098039215,
                .8862745098039215,
                .4,
                .7607843137254902,
                .6431372549019608,
                .1372549019607843,
                .5450980392156862,
                .2705882352941176
            ],
            Name: "Brewer Sequential Blue-Green (4)",
            NanColor: [
                .1372549019607843,
                .5450980392156862,
                .2705882352941176
            ]
        },
        {
            IndexedColors: [
                .8980392156862745,
                .9607843137254902,
                .9764705882352941,
                .6,
                .8470588235294118,
                .788235294117647,
                .1725490196078431,
                .6352941176470588,
                .3725490196078431
            ],
            Name: "Brewer Sequential Blue-Green (3)",
            NanColor: [
                .1725490196078431,
                .6352941176470588,
                .3725490196078431
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8980392156862745,
                1,
                .9686274509803922,
                .7372549019607844,
                .996078431372549,
                .8901960784313725,
                .5686274509803921,
                .996078431372549,
                .7686274509803922,
                .3098039215686275,
                .996078431372549,
                .6,
                .1607843137254902,
                .9254901960784314,
                .4392156862745098,
                .0784313725490196,
                .8,
                .2980392156862745,
                .00784313725490196,
                .6,
                .203921568627451,
                .01568627450980392,
                .4,
                .1450980392156863,
                .02352941176470588
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (9)",
            NanColor: [
                .4,
                .1450980392156863,
                .02352941176470588
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8980392156862745,
                1,
                .9686274509803922,
                .7372549019607844,
                .996078431372549,
                .8901960784313725,
                .5686274509803921,
                .996078431372549,
                .7686274509803922,
                .3098039215686275,
                .996078431372549,
                .6,
                .1607843137254902,
                .9254901960784314,
                .4392156862745098,
                .0784313725490196,
                .8,
                .2980392156862745,
                .00784313725490196,
                .5490196078431373,
                .1764705882352941,
                .01568627450980392
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (8)",
            NanColor: [
                .5490196078431373,
                .1764705882352941,
                .01568627450980392
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8313725490196079,
                .996078431372549,
                .8901960784313725,
                .5686274509803921,
                .996078431372549,
                .7686274509803922,
                .3098039215686275,
                .996078431372549,
                .6,
                .1607843137254902,
                .9254901960784314,
                .4392156862745098,
                .0784313725490196,
                .8,
                .2980392156862745,
                .00784313725490196,
                .5490196078431373,
                .1764705882352941,
                .01568627450980392
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (7)",
            NanColor: [
                .5490196078431373,
                .1764705882352941,
                .01568627450980392
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8313725490196079,
                .996078431372549,
                .8901960784313725,
                .5686274509803921,
                .996078431372549,
                .7686274509803922,
                .3098039215686275,
                .996078431372549,
                .6,
                .1607843137254902,
                .8509803921568627,
                .3725490196078431,
                .05490196078431372,
                .6,
                .203921568627451,
                .01568627450980392
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (6)",
            NanColor: [
                .6,
                .203921568627451,
                .01568627450980392
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8313725490196079,
                .996078431372549,
                .8509803921568627,
                .5568627450980392,
                .996078431372549,
                .6,
                .1607843137254902,
                .8509803921568627,
                .3725490196078431,
                .05490196078431372,
                .6,
                .203921568627451,
                .01568627450980392
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (5)",
            NanColor: [
                .6,
                .203921568627451,
                .01568627450980392
            ]
        },
        {
            IndexedColors: [
                1,
                1,
                .8313725490196079,
                .996078431372549,
                .8509803921568627,
                .5568627450980392,
                .996078431372549,
                .6,
                .1607843137254902,
                .8,
                .2980392156862745,
                .00784313725490196
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (4)",
            NanColor: [
                .8,
                .2980392156862745,
                .00784313725490196
            ]
        },
        {
            IndexedColors: [
                1,
                .9686274509803922,
                .7372549019607844,
                .996078431372549,
                .7686274509803922,
                .3098039215686275,
                .8509803921568627,
                .3725490196078431,
                .05490196078431372
            ],
            Name: "Brewer Sequential Yellow-Orange-Brown (3)",
            NanColor: [
                .8509803921568627,
                .3725490196078431,
                .05490196078431372
            ]
        },
        {
            IndexedColors: [
                .9686274509803922,
                .9882352941176471,
                .9921568627450981,
                .8784313725490196,
                .9254901960784314,
                .9568627450980393,
                .7490196078431373,
                .8274509803921568,
                .9019607843137255,
                .6196078431372549,
                .7372549019607844,
                .8549019607843137,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5490196078431373,
                .4196078431372549,
                .6941176470588235,
                .5333333333333333,
                .2549019607843137,
                .615686274509804,
                .5058823529411764,
                .05882352941176471,
                .4862745098039216,
                .3019607843137255,
                0,
                .2941176470588235
            ],
            Name: "Brewer Sequential Blue-Purple (9)",
            NanColor: [
                .3019607843137255,
                0,
                .2941176470588235
            ]
        },
        {
            IndexedColors: [
                .9686274509803922,
                .9882352941176471,
                .9921568627450981,
                .8784313725490196,
                .9254901960784314,
                .9568627450980393,
                .7490196078431373,
                .8274509803921568,
                .9019607843137255,
                .6196078431372549,
                .7372549019607844,
                .8549019607843137,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5490196078431373,
                .4196078431372549,
                .6941176470588235,
                .5333333333333333,
                .2549019607843137,
                .615686274509804,
                .4313725490196079,
                .00392156862745098,
                .4196078431372549
            ],
            Name: "Brewer Sequential Blue-Purple (8)",
            NanColor: [
                .4313725490196079,
                .00392156862745098,
                .4196078431372549
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .7490196078431373,
                .8274509803921568,
                .9019607843137255,
                .6196078431372549,
                .7372549019607844,
                .8549019607843137,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5490196078431373,
                .4196078431372549,
                .6941176470588235,
                .5333333333333333,
                .2549019607843137,
                .615686274509804,
                .4313725490196079,
                .00392156862745098,
                .4196078431372549
            ],
            Name: "Brewer Sequential Blue-Purple (7)",
            NanColor: [
                .4313725490196079,
                .00392156862745098,
                .4196078431372549
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .7490196078431373,
                .8274509803921568,
                .9019607843137255,
                .6196078431372549,
                .7372549019607844,
                .8549019607843137,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5333333333333333,
                .3372549019607843,
                .6549019607843137,
                .5058823529411764,
                .05882352941176471,
                .4862745098039216
            ],
            Name: "Brewer Sequential Blue-Purple (6)",
            NanColor: [
                .5058823529411764,
                .05882352941176471,
                .4862745098039216
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .7019607843137254,
                .803921568627451,
                .8901960784313725,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5333333333333333,
                .3372549019607843,
                .6549019607843137,
                .5058823529411764,
                .05882352941176471,
                .4862745098039216
            ],
            Name: "Brewer Sequential Blue-Purple (5)",
            NanColor: [
                .5058823529411764,
                .05882352941176471,
                .4862745098039216
            ]
        },
        {
            IndexedColors: [
                .9294117647058824,
                .9725490196078431,
                .984313725490196,
                .7019607843137254,
                .803921568627451,
                .8901960784313725,
                .5490196078431373,
                .5882352941176471,
                .7764705882352941,
                .5333333333333333,
                .2549019607843137,
                .615686274509804
            ],
            Name: "Brewer Sequential Blue-Purple (4)",
            NanColor: [
                .5333333333333333,
                .2549019607843137,
                .615686274509804
            ]
        },
        {
            IndexedColors: [
                .8784313725490196,
                .9254901960784314,
                .9568627450980393,
                .6196078431372549,
                .7372549019607844,
                .8549019607843137,
                .5333333333333333,
                .3372549019607843,
                .6549019607843137
            ],
            Name: "Brewer Sequential Blue-Purple (3)",
            NanColor: [
                .5333333333333333,
                .3372549019607843,
                .6549019607843137
            ]
        },
        {
            IndexedColors: [
                .4980392156862745,
                .788235294117647,
                .4980392156862745,
                .7450980392156863,
                .6823529411764706,
                .8313725490196079,
                .9921568627450981,
                .7529411764705882,
                .5254901960784314,
                1,
                1,
                .6,
                .2196078431372549,
                .4235294117647059,
                .6901960784313725,
                .9411764705882353,
                .00784313725490196,
                .4980392156862745,
                .7490196078431373,
                .3568627450980392,
                .09019607843137255,
                .4,
                .4,
                .4
            ],
            Name: "Brewer Qualitative Accent",
            NanColor: [
                .4,
                .4,
                .4
            ]
        },
        {
            IndexedColors: [
                .1058823529411765,
                .6196078431372549,
                .4666666666666667,
                .8509803921568627,
                .3725490196078431,
                .00784313725490196,
                .4588235294117647,
                .4392156862745098,
                .7019607843137254,
                .9058823529411765,
                .1607843137254902,
                .5411764705882353,
                .4,
                .6509803921568628,
                .1176470588235294,
                .9019607843137255,
                .6705882352941176,
                .00784313725490196,
                .6509803921568628,
                .4627450980392157,
                .1137254901960784,
                .4,
                .4,
                .4
            ],
            Name: "Brewer Qualitative Dark2",
            NanColor: [
                .4,
                .4,
                .4
            ]
        },
        {
            IndexedColors: [
                .4,
                .7607843137254902,
                .6470588235294118,
                .9882352941176471,
                .5529411764705883,
                .3843137254901961,
                .5529411764705883,
                .6274509803921569,
                .796078431372549,
                .9058823529411765,
                .5411764705882353,
                .7647058823529411,
                .6509803921568628,
                .8470588235294118,
                .3294117647058823,
                1,
                .8509803921568627,
                .1843137254901961,
                .8980392156862745,
                .7686274509803922,
                .5803921568627451,
                .7019607843137254,
                .7019607843137254,
                .7019607843137254
            ],
            Name: "Brewer Qualitative Set2",
            NanColor: [
                .7019607843137254,
                .7019607843137254,
                .7019607843137254
            ]
        },
        {
            IndexedColors: [
                .7019607843137254,
                .8862745098039215,
                .803921568627451,
                .9921568627450981,
                .803921568627451,
                .6745098039215687,
                .796078431372549,
                .8352941176470589,
                .9098039215686274,
                .9568627450980393,
                .792156862745098,
                .8941176470588236,
                .9019607843137255,
                .9607843137254902,
                .788235294117647,
                1,
                .9490196078431372,
                .6823529411764706,
                .9450980392156862,
                .8862745098039215,
                .8,
                .8,
                .8,
                .8
            ],
            Name: "Brewer Qualitative Pastel2",
            NanColor: [
                .8,
                .8,
                .8
            ]
        },
        {
            IndexedColors: [
                .984313725490196,
                .7058823529411765,
                .6823529411764706,
                .7019607843137254,
                .803921568627451,
                .8901960784313725,
                .8,
                .9215686274509803,
                .7725490196078432,
                .8705882352941177,
                .796078431372549,
                .8941176470588236,
                .996078431372549,
                .8509803921568627,
                .6509803921568628,
                1,
                1,
                .8,
                .8980392156862745,
                .8470588235294118,
                .7411764705882353,
                .9921568627450981,
                .8549019607843137,
                .9254901960784314,
                .9490196078431372,
                .9490196078431372,
                .9490196078431372
            ],
            Name: "Brewer Qualitative Pastel1",
            NanColor: [
                .9490196078431372,
                .9490196078431372,
                .9490196078431372
            ]
        },
        {
            IndexedColors: [
                .8941176470588236,
                .1019607843137255,
                .1098039215686274,
                .2156862745098039,
                .4941176470588236,
                .7215686274509804,
                .3019607843137255,
                .6862745098039216,
                .2901960784313726,
                .596078431372549,
                .3058823529411765,
                .6392156862745098,
                1,
                .4980392156862745,
                0,
                1,
                1,
                .2,
                .6509803921568628,
                .3372549019607843,
                .1568627450980392,
                .9686274509803922,
                .5058823529411764,
                .7490196078431373,
                .6,
                .6,
                .6
            ],
            Name: "Brewer Qualitative Set1",
            NanColor: [
                .6,
                .6,
                .6
            ]
        },
        {
            IndexedColors: [
                .6509803921568628,
                .807843137254902,
                .8901960784313725,
                .1215686274509804,
                .4705882352941176,
                .7058823529411765,
                .6980392156862745,
                .8745098039215686,
                .5411764705882353,
                .2,
                .6274509803921569,
                .1725490196078431,
                .984313725490196,
                .6039215686274509,
                .6,
                .8901960784313725,
                .1019607843137255,
                .1098039215686274,
                .9921568627450981,
                .7490196078431373,
                .4352941176470588,
                1,
                .4980392156862745,
                0,
                .792156862745098,
                .6980392156862745,
                .8392156862745098,
                .4156862745098039,
                .2392156862745098,
                .6039215686274509,
                1,
                1,
                .6
            ],
            Name: "Brewer Qualitative Paired",
            NanColor: [
                1,
                1,
                .6
            ]
        },
        {
            IndexedColors: [
                .5529411764705883,
                .8274509803921568,
                .7803921568627451,
                1,
                1,
                .7019607843137254,
                .7450980392156863,
                .7294117647058823,
                .8549019607843137,
                .984313725490196,
                .5019607843137255,
                .4470588235294118,
                .5019607843137255,
                .6941176470588235,
                .8274509803921568,
                .9921568627450981,
                .7058823529411765,
                .3843137254901961,
                .7019607843137254,
                .8705882352941177,
                .4117647058823529,
                .9882352941176471,
                .803921568627451,
                .8980392156862745,
                .8509803921568627,
                .8509803921568627,
                .8509803921568627,
                .7372549019607844,
                .5019607843137255,
                .7411764705882353,
                .8,
                .9215686274509803,
                .7725490196078432,
                1,
                .9294117647058824,
                .4352941176470588
            ],
            Name: "Brewer Qualitative Set3",
            NanColor: [
                1,
                .9294117647058824,
                .4352941176470588
            ]
        },
        {
            IndexedColors: [
                1,
                0,
                0,
                1,
                .862745,
                0,
                0,
                .695201,
                0
            ],
            Name: "Traffic Lights",
            NanColor: [
                .803922,
                0,
                .803922
            ]
        },
        {
            IndexedColors: [
                .908659,
                .604013,
                .581857,
                1,
                .862745,
                0,
                0,
                .695201,
                0
            ],
            Name: "Traffic Lights For Deuteranopes",
            NanColor: [
                .803922,
                0,
                .803922
            ]
        },
        {
            IndexedColors: [
                .4196078431372549,
                0,
                .07058823529411765,
                .9019607843137255,
                .9411764705882353,
                .0196078431372549,
                .01568627450980392,
                .6196078431372549,
                .00784313725490196
            ],
            Name: "Traffic Lights For Deuteranopes 2",
            NanColor: [
                .803922,
                0,
                .803922
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Muted Blue-Green",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                .109804,
                .27451,
                .301961,
                .02,
                .129412,
                .309804,
                .341176,
                .05,
                .14902,
                .341176,
                .380392,
                .1,
                .188235,
                .403922,
                .458824,
                .15,
                .227451,
                .447059,
                .521569,
                .2,
                .290196,
                .494118,
                .588235,
                .25,
                .368627,
                .552941,
                .670588,
                .3,
                .458824,
                .619608,
                .74902,
                .35,
                .588235,
                .713725,
                .85098,
                .4,
                .72549,
                .815686,
                .941176,
                .45,
                .831373,
                .882353,
                .980392,
                .475,
                .909804,
                .933333,
                1,
                .5,
                .980392,
                .984314,
                1,
                .5,
                .996078,
                1,
                .94902,
                .5,
                1,
                1,
                .980392,
                .5,
                .980392,
                .984314,
                1,
                .525,
                .972549,
                .988235,
                .890196,
                .55,
                .917647,
                .960784,
                .835294,
                .6,
                .835294,
                .921569,
                .772549,
                .65,
                .768627,
                .901961,
                .737255,
                .7,
                .670588,
                .831373,
                .654902,
                .75,
                .576471,
                .760784,
                .584314,
                .8,
                .498039,
                .678431,
                .521569,
                .85,
                .392157,
                .560784,
                .427451,
                .9,
                .294118,
                .45098,
                .333333,
                .95,
                .211765,
                .34902,
                .254902,
                1,
                .152941,
                .278431,
                .196078
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Green-Blue Asymmetric Divergent (62Blbc)",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                .121569,
                .2,
                .145098,
                .05,
                .196078,
                .301961,
                .223529,
                .1,
                .258824,
                .4,
                .278431,
                .2,
                .341176,
                .54902,
                .341176,
                .25,
                .419608,
                .619608,
                .376471,
                .3,
                .545098,
                .701961,
                .392157,
                .35,
                .643137,
                .780392,
                .403922,
                .4,
                .729412,
                .819608,
                .45098,
                .45,
                .811765,
                .870588,
                .521569,
                .5,
                .898039,
                .909804,
                .564706,
                .55,
                .941176,
                .92549,
                .686275,
                .6,
                .960784,
                .94902,
                .776471,
                .64,
                1,
                1,
                1,
                .65,
                .890196,
                .988235,
                .972549,
                .7,
                .721569,
                .894118,
                .901961,
                .75,
                .631373,
                .823529,
                .839216,
                .8,
                .517647,
                .662745,
                .701961,
                .85,
                .384314,
                .494118,
                .54902,
                .9,
                .298039,
                .360784,
                .45098,
                .95,
                .223529,
                .25098,
                .34902,
                .99,
                .156863,
                .172549,
                .25098,
                1,
                .137255,
                .137255,
                .188235
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Asymmtrical Earth Tones (6_21b)",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                .141176,
                .14902,
                .2,
                .05,
                .215686,
                .258824,
                .321569,
                .1,
                .243137,
                .368627,
                .380392,
                .15,
                .27451,
                .439216,
                .4,
                .2,
                .32549,
                .501961,
                .384314,
                .25,
                .403922,
                .6,
                .419608,
                .3,
                .486275,
                .701961,
                .454902,
                .35,
                .556863,
                .74902,
                .494118,
                .4,
                .670588,
                .8,
                .545098,
                .5,
                .854902,
                .901961,
                .631373,
                .55,
                .92549,
                .941176,
                .694118,
                .6,
                .960784,
                .94902,
                .776471,
                .65,
                .988235,
                .968627,
                .909804,
                .7,
                .839216,
                .815686,
                .772549,
                .75,
                .701961,
                .662745,
                .615686,
                .8,
                .6,
                .529412,
                .478431,
                .85,
                .501961,
                .403922,
                .360784,
                .9,
                .439216,
                .313725,
                .290196,
                1,
                .301961,
                .164706,
                .176471
            ]
        },
        {
            ColorSpace: "Lab",
            Creator: "Francesca Samsel",
            Name: "Yellow 15",
            NanColor: [
                .25,
                0,
                0
            ],
            RGBPoints: [
                0,
                1,
                1,
                .988235,
                .002,
                1,
                1,
                .988235,
                .05,
                .984314,
                .988235,
                .843137,
                .1,
                .988235,
                .988235,
                .741176,
                .15,
                .980392,
                .968627,
                .654902,
                .2,
                .980392,
                .945098,
                .576471,
                .25,
                .968627,
                .905882,
                .486275,
                .3,
                .968627,
                .862745,
                .388235,
                .35,
                .960784,
                .803922,
                .286275,
                .4,
                .94902,
                .741176,
                .219608,
                .45,
                .941176,
                .678431,
                .14902,
                .5,
                .929412,
                .607843,
                .094118,
                .55,
                .921569,
                .545098,
                .054902,
                .6,
                .909804,
                .486275,
                .035294,
                .65,
                .890196,
                .411765,
                .019608,
                .7,
                .8,
                .305882,
                0,
                .75,
                .760784,
                .239216,
                0,
                .8,
                .678431,
                .180392,
                .011765,
                .85,
                .6,
                .121569,
                .023529,
                .9,
                .501961,
                .054902,
                .031373,
                .95,
                .4,
                .039216,
                .058824,
                1,
                .301961,
                .047059,
                .090196
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Magma (matplotlib)",
            NanColor: [
                0,
                1,
                0
            ],
            Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
            License: "CC0",
            Creator: "Nathaniel J. Smith & Stefan van der Walt",
            RGBPoints: [
                0,
                .001462,
                466e-6,
                .013866,
                .003922,
                .002258,
                .001295,
                .018331,
                .007843,
                .003279,
                .002305,
                .023708,
                .011765,
                .004512,
                .00349,
                .029965,
                .015686,
                .00595,
                .004843,
                .03713,
                .019608,
                .007588,
                .006356,
                .044973,
                .023529,
                .009426,
                .008022,
                .052844,
                .027451,
                .011465,
                .009828,
                .06075,
                .031373,
                .013708,
                .011771,
                .068667,
                .035294,
                .016156,
                .01384,
                .076603,
                .039216,
                .018815,
                .016026,
                .084584,
                .043137,
                .021692,
                .01832,
                .09261,
                .047059,
                .024792,
                .020715,
                .100676,
                .05098,
                .028123,
                .023201,
                .108787,
                .054902,
                .031696,
                .025765,
                .116965,
                .058824,
                .03552,
                .028397,
                .125209,
                .062745,
                .039608,
                .03109,
                .133515,
                .066667,
                .04383,
                .03383,
                .141886,
                .070588,
                .048062,
                .036607,
                .150327,
                .07451,
                .05232,
                .039407,
                .158841,
                .078431,
                .056615,
                .04216,
                .167446,
                .082353,
                .060949,
                .044794,
                .176129,
                .086275,
                .06533,
                .047318,
                .184892,
                .090196,
                .069764,
                .049726,
                .193735,
                .094118,
                .074257,
                .052017,
                .20266,
                .098039,
                .078815,
                .054184,
                .211667,
                .101961,
                .083446,
                .056225,
                .220755,
                .105882,
                .088155,
                .058133,
                .229922,
                .109804,
                .092949,
                .059904,
                .239164,
                .113725,
                .097833,
                .061531,
                .248477,
                .117647,
                .102815,
                .06301,
                .257854,
                .121569,
                .107899,
                .064335,
                .267289,
                .12549,
                .113094,
                .065492,
                .276784,
                .129412,
                .118405,
                .066479,
                .286321,
                .133333,
                .123833,
                .067295,
                .295879,
                .137255,
                .12938,
                .067935,
                .305443,
                .141176,
                .135053,
                .068391,
                .315,
                .145098,
                .140858,
                .068654,
                .324538,
                .14902,
                .146785,
                .068738,
                .334011,
                .152941,
                .152839,
                .068637,
                .343404,
                .156863,
                .159018,
                .068354,
                .352688,
                .160784,
                .165308,
                .067911,
                .361816,
                .164706,
                .171713,
                .067305,
                .370771,
                .168627,
                .178212,
                .066576,
                .379497,
                .172549,
                .184801,
                .065732,
                .387973,
                .176471,
                .19146,
                .064818,
                .396152,
                .180392,
                .198177,
                .063862,
                .404009,
                .184314,
                .204935,
                .062907,
                .411514,
                .188235,
                .211718,
                .061992,
                .418647,
                .192157,
                .218512,
                .061158,
                .425392,
                .196078,
                .225302,
                .060445,
                .431742,
                .2,
                .232077,
                .059889,
                .437695,
                .203922,
                .238826,
                .059517,
                .443256,
                .207843,
                .245543,
                .059352,
                .448436,
                .211765,
                .25222,
                .059415,
                .453248,
                .215686,
                .258857,
                .059706,
                .45771,
                .219608,
                .265447,
                .060237,
                .46184,
                .223529,
                .271994,
                .060994,
                .46566,
                .227451,
                .278493,
                .061978,
                .46919,
                .231373,
                .284951,
                .063168,
                .472451,
                .235294,
                .291366,
                .064553,
                .475462,
                .239216,
                .29774,
                .066117,
                .478243,
                .243137,
                .304081,
                .067835,
                .480812,
                .247059,
                .310382,
                .069702,
                .483186,
                .25098,
                .316654,
                .07169,
                .48538,
                .254902,
                .322899,
                .073782,
                .487408,
                .258824,
                .329114,
                .075972,
                .489287,
                .262745,
                .335308,
                .078236,
                .491024,
                .266667,
                .341482,
                .080564,
                .492631,
                .270588,
                .347636,
                .082946,
                .494121,
                .27451,
                .353773,
                .085373,
                .495501,
                .278431,
                .359898,
                .087831,
                .496778,
                .282353,
                .366012,
                .090314,
                .49796,
                .286275,
                .372116,
                .092816,
                .499053,
                .290196,
                .378211,
                .095332,
                .500067,
                .294118,
                .384299,
                .097855,
                .501002,
                .298039,
                .390384,
                .100379,
                .501864,
                .301961,
                .396467,
                .102902,
                .502658,
                .305882,
                .402548,
                .10542,
                .503386,
                .309804,
                .408629,
                .10793,
                .504052,
                .313725,
                .414709,
                .110431,
                .504662,
                .317647,
                .420791,
                .11292,
                .505215,
                .321569,
                .426877,
                .115395,
                .505714,
                .32549,
                .432967,
                .117855,
                .50616,
                .329412,
                .439062,
                .120298,
                .506555,
                .333333,
                .445163,
                .122724,
                .506901,
                .337255,
                .451271,
                .125132,
                .507198,
                .341176,
                .457386,
                .127522,
                .507448,
                .345098,
                .463508,
                .129893,
                .507652,
                .34902,
                .46964,
                .132245,
                .507809,
                .352941,
                .47578,
                .134577,
                .507921,
                .356863,
                .481929,
                .136891,
                .507989,
                .360784,
                .488088,
                .139186,
                .508011,
                .364706,
                .494258,
                .141462,
                .507988,
                .368627,
                .500438,
                .143719,
                .50792,
                .372549,
                .506629,
                .145958,
                .507806,
                .376471,
                .512831,
                .148179,
                .507648,
                .380392,
                .519045,
                .150383,
                .507443,
                .384314,
                .52527,
                .152569,
                .507192,
                .388235,
                .531507,
                .154739,
                .506895,
                .392157,
                .537755,
                .156894,
                .506551,
                .396078,
                .544015,
                .159033,
                .506159,
                .4,
                .550287,
                .161158,
                .505719,
                .403922,
                .556571,
                .163269,
                .50523,
                .407843,
                .562866,
                .165368,
                .504692,
                .411765,
                .569172,
                .167454,
                .504105,
                .415686,
                .57549,
                .16953,
                .503466,
                .419608,
                .581819,
                .171596,
                .502777,
                .423529,
                .588158,
                .173652,
                .502035,
                .427451,
                .594508,
                .175701,
                .501241,
                .431373,
                .600868,
                .177743,
                .500394,
                .435294,
                .607238,
                .179779,
                .499492,
                .439216,
                .613617,
                .181811,
                .498536,
                .443137,
                .620005,
                .18384,
                .497524,
                .447059,
                .626401,
                .185867,
                .496456,
                .45098,
                .632805,
                .187893,
                .495332,
                .454902,
                .639216,
                .189921,
                .49415,
                .458824,
                .645633,
                .191952,
                .49291,
                .462745,
                .652056,
                .193986,
                .491611,
                .466667,
                .658483,
                .196027,
                .490253,
                .470588,
                .664915,
                .198075,
                .488836,
                .47451,
                .671349,
                .200133,
                .487358,
                .478431,
                .677786,
                .202203,
                .485819,
                .482353,
                .684224,
                .204286,
                .484219,
                .486275,
                .690661,
                .206384,
                .482558,
                .490196,
                .697098,
                .208501,
                .480835,
                .494118,
                .703532,
                .210638,
                .479049,
                .498039,
                .709962,
                .212797,
                .477201,
                .501961,
                .716387,
                .214982,
                .47529,
                .505882,
                .722805,
                .217194,
                .473316,
                .509804,
                .729216,
                .219437,
                .471279,
                .513725,
                .735616,
                .221713,
                .46918,
                .517647,
                .742004,
                .224025,
                .467018,
                .521569,
                .748378,
                .226377,
                .464794,
                .52549,
                .754737,
                .228772,
                .462509,
                .529412,
                .761077,
                .231214,
                .460162,
                .533333,
                .767398,
                .233705,
                .457755,
                .537255,
                .773695,
                .236249,
                .455289,
                .541176,
                .779968,
                .238851,
                .452765,
                .545098,
                .786212,
                .241514,
                .450184,
                .54902,
                .792427,
                .244242,
                .447543,
                .552941,
                .798608,
                .24704,
                .444848,
                .556863,
                .804752,
                .249911,
                .442102,
                .560784,
                .810855,
                .252861,
                .439305,
                .564706,
                .816914,
                .255895,
                .436461,
                .568627,
                .822926,
                .259016,
                .433573,
                .572549,
                .828886,
                .262229,
                .430644,
                .576471,
                .834791,
                .26554,
                .427671,
                .580392,
                .840636,
                .268953,
                .424666,
                .584314,
                .846416,
                .272473,
                .421631,
                .588235,
                .852126,
                .276106,
                .418573,
                .592157,
                .857763,
                .279857,
                .415496,
                .596078,
                .86332,
                .283729,
                .412403,
                .6,
                .868793,
                .287728,
                .409303,
                .603922,
                .874176,
                .291859,
                .406205,
                .607843,
                .879464,
                .296125,
                .403118,
                .611765,
                .884651,
                .30053,
                .400047,
                .615686,
                .889731,
                .305079,
                .397002,
                .619608,
                .8947,
                .309773,
                .393995,
                .623529,
                .899552,
                .314616,
                .391037,
                .627451,
                .904281,
                .31961,
                .388137,
                .631373,
                .908884,
                .324755,
                .385308,
                .635294,
                .913354,
                .330052,
                .382563,
                .639216,
                .917689,
                .3355,
                .379915,
                .643137,
                .921884,
                .341098,
                .377376,
                .647059,
                .925937,
                .346844,
                .374959,
                .65098,
                .929845,
                .352734,
                .372677,
                .654902,
                .933606,
                .358764,
                .370541,
                .658824,
                .937221,
                .364929,
                .368567,
                .662745,
                .940687,
                .371224,
                .366762,
                .666667,
                .944006,
                .377643,
                .365136,
                .670588,
                .94718,
                .384178,
                .363701,
                .67451,
                .95021,
                .39082,
                .362468,
                .678431,
                .953099,
                .397563,
                .361438,
                .682353,
                .955849,
                .4044,
                .360619,
                .686275,
                .958464,
                .411324,
                .360014,
                .690196,
                .960949,
                .418323,
                .35963,
                .694118,
                .96331,
                .42539,
                .359469,
                .698039,
                .965549,
                .432519,
                .359529,
                .701961,
                .967671,
                .439703,
                .35981,
                .705882,
                .96968,
                .446936,
                .360311,
                .709804,
                .971582,
                .45421,
                .36103,
                .713725,
                .973381,
                .46152,
                .361965,
                .717647,
                .975082,
                .468861,
                .363111,
                .721569,
                .97669,
                .476226,
                .364466,
                .72549,
                .97821,
                .483612,
                .366025,
                .729412,
                .979645,
                .491014,
                .367783,
                .733333,
                .981,
                .498428,
                .369734,
                .737255,
                .982279,
                .505851,
                .371874,
                .741176,
                .983485,
                .51328,
                .374198,
                .745098,
                .984622,
                .520713,
                .376698,
                .74902,
                .985693,
                .528148,
                .379371,
                .752941,
                .9867,
                .535582,
                .38221,
                .756863,
                .987646,
                .543015,
                .38521,
                .760784,
                .988533,
                .550446,
                .388365,
                .764706,
                .989363,
                .557873,
                .391671,
                .768627,
                .990138,
                .565296,
                .395122,
                .772549,
                .990871,
                .572706,
                .398714,
                .776471,
                .991558,
                .580107,
                .402441,
                .780392,
                .992196,
                .587502,
                .406299,
                .784314,
                .992785,
                .594891,
                .410283,
                .788235,
                .993326,
                .602275,
                .41439,
                .792157,
                .993834,
                .609644,
                .418613,
                .796078,
                .994309,
                .616999,
                .42295,
                .8,
                .994738,
                .62435,
                .427397,
                .803922,
                .995122,
                .631696,
                .431951,
                .807843,
                .99548,
                .639027,
                .436607,
                .811765,
                .99581,
                .646344,
                .441361,
                .815686,
                .996096,
                .653659,
                .446213,
                .819608,
                .996341,
                .660969,
                .45116,
                .823529,
                .99658,
                .668256,
                .456192,
                .827451,
                .996775,
                .675541,
                .461314,
                .831373,
                .996925,
                .682828,
                .466526,
                .835294,
                .997077,
                .690088,
                .471811,
                .839216,
                .997186,
                .697349,
                .477182,
                .843137,
                .997254,
                .704611,
                .482635,
                .847059,
                .997325,
                .711848,
                .488154,
                .85098,
                .997351,
                .719089,
                .493755,
                .854902,
                .997351,
                .726324,
                .499428,
                .858824,
                .997341,
                .733545,
                .505167,
                .862745,
                .997285,
                .740772,
                .510983,
                .866667,
                .997228,
                .747981,
                .516859,
                .870588,
                .997138,
                .75519,
                .522806,
                .87451,
                .997019,
                .762398,
                .528821,
                .878431,
                .996898,
                .769591,
                .534892,
                .882353,
                .996727,
                .776795,
                .541039,
                .886275,
                .996571,
                .783977,
                .547233,
                .890196,
                .996369,
                .791167,
                .553499,
                .894118,
                .996162,
                .798348,
                .55982,
                .898039,
                .995932,
                .805527,
                .566202,
                .901961,
                .99568,
                .812706,
                .572645,
                .905882,
                .995424,
                .819875,
                .57914,
                .909804,
                .995131,
                .827052,
                .585701,
                .913725,
                .994851,
                .834213,
                .592307,
                .917647,
                .994524,
                .841387,
                .598983,
                .921569,
                .994222,
                .84854,
                .605696,
                .92549,
                .993866,
                .855711,
                .612482,
                .929412,
                .993545,
                .862859,
                .619299,
                .933333,
                .99317,
                .870024,
                .626189,
                .937255,
                .992831,
                .877168,
                .633109,
                .941176,
                .99244,
                .88433,
                .640099,
                .945098,
                .992089,
                .89147,
                .647116,
                .94902,
                .991688,
                .898627,
                .654202,
                .952941,
                .991332,
                .905763,
                .661309,
                .956863,
                .99093,
                .912915,
                .668481,
                .960784,
                .99057,
                .920049,
                .675675,
                .964706,
                .990175,
                .927196,
                .682926,
                .968627,
                .989815,
                .934329,
                .690198,
                .972549,
                .989434,
                .94147,
                .697519,
                .976471,
                .989077,
                .948604,
                .704863,
                .980392,
                .988717,
                .955742,
                .712242,
                .984314,
                .988367,
                .962878,
                .719649,
                .988235,
                .988033,
                .970012,
                .727077,
                .992157,
                .987691,
                .977154,
                .734536,
                .996078,
                .987387,
                .984288,
                .742002,
                1,
                .987053,
                .991438,
                .749504
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Inferno (matplotlib)",
            NanColor: [
                0,
                1,
                0
            ],
            Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
            License: "CC0",
            Creator: "Nathaniel J. Smith & Stefan van der Walt",
            RGBPoints: [
                0,
                .001462,
                466e-6,
                .013866,
                .003922,
                .002267,
                .00127,
                .01857,
                .007843,
                .003299,
                .002249,
                .024239,
                .011765,
                .004547,
                .003392,
                .030909,
                .015686,
                .006006,
                .004692,
                .038558,
                .019608,
                .007676,
                .006136,
                .046836,
                .023529,
                .009561,
                .007713,
                .055143,
                .027451,
                .011663,
                .009417,
                .06346,
                .031373,
                .013995,
                .011225,
                .071862,
                .035294,
                .016561,
                .013136,
                .080282,
                .039216,
                .019373,
                .015133,
                .088767,
                .043137,
                .022447,
                .017199,
                .097327,
                .047059,
                .025793,
                .019331,
                .10593,
                .05098,
                .029432,
                .021503,
                .114621,
                .054902,
                .033385,
                .023702,
                .123397,
                .058824,
                .037668,
                .025921,
                .132232,
                .062745,
                .042253,
                .028139,
                .141141,
                .066667,
                .046915,
                .030324,
                .150164,
                .070588,
                .051644,
                .032474,
                .159254,
                .07451,
                .056449,
                .034569,
                .168414,
                .078431,
                .06134,
                .03659,
                .177642,
                .082353,
                .066331,
                .038504,
                .186962,
                .086275,
                .071429,
                .040294,
                .196354,
                .090196,
                .076637,
                .041905,
                .205799,
                .094118,
                .081962,
                .043328,
                .215289,
                .098039,
                .087411,
                .044556,
                .224813,
                .101961,
                .09299,
                .045583,
                .234358,
                .105882,
                .098702,
                .046402,
                .243904,
                .109804,
                .104551,
                .047008,
                .25343,
                .113725,
                .110536,
                .047399,
                .262912,
                .117647,
                .116656,
                .047574,
                .272321,
                .121569,
                .122908,
                .047536,
                .281624,
                .12549,
                .129285,
                .047293,
                .290788,
                .129412,
                .135778,
                .046856,
                .299776,
                .133333,
                .142378,
                .046242,
                .308553,
                .137255,
                .149073,
                .045468,
                .317085,
                .141176,
                .15585,
                .044559,
                .325338,
                .145098,
                .162689,
                .043554,
                .333277,
                .14902,
                .169575,
                .042489,
                .340874,
                .152941,
                .176493,
                .041402,
                .348111,
                .156863,
                .183429,
                .040329,
                .354971,
                .160784,
                .190367,
                .039309,
                .361447,
                .164706,
                .197297,
                .0384,
                .367535,
                .168627,
                .204209,
                .037632,
                .373238,
                .172549,
                .211095,
                .03703,
                .378563,
                .176471,
                .217949,
                .036615,
                .383522,
                .180392,
                .224763,
                .036405,
                .388129,
                .184314,
                .231538,
                .036405,
                .3924,
                .188235,
                .238273,
                .036621,
                .396353,
                .192157,
                .244967,
                .037055,
                .400007,
                .196078,
                .25162,
                .037705,
                .403378,
                .2,
                .258234,
                .038571,
                .406485,
                .203922,
                .26481,
                .039647,
                .409345,
                .207843,
                .271347,
                .040922,
                .411976,
                .211765,
                .27785,
                .042353,
                .414392,
                .215686,
                .284321,
                .043933,
                .416608,
                .219608,
                .290763,
                .045644,
                .418637,
                .223529,
                .297178,
                .04747,
                .420491,
                .227451,
                .303568,
                .049396,
                .422182,
                .231373,
                .309935,
                .051407,
                .423721,
                .235294,
                .316282,
                .05349,
                .425116,
                .239216,
                .32261,
                .055634,
                .426377,
                .243137,
                .328921,
                .057827,
                .427511,
                .247059,
                .335217,
                .06006,
                .428524,
                .25098,
                .3415,
                .062325,
                .429425,
                .254902,
                .347771,
                .064616,
                .430217,
                .258824,
                .354032,
                .066925,
                .430906,
                .262745,
                .360284,
                .069247,
                .431497,
                .266667,
                .366529,
                .071579,
                .431994,
                .270588,
                .372768,
                .073915,
                .4324,
                .27451,
                .379001,
                .076253,
                .432719,
                .278431,
                .385228,
                .078591,
                .432955,
                .282353,
                .391453,
                .080927,
                .433109,
                .286275,
                .397674,
                .083257,
                .433183,
                .290196,
                .403894,
                .08558,
                .433179,
                .294118,
                .410113,
                .087896,
                .433098,
                .298039,
                .416331,
                .090203,
                .432943,
                .301961,
                .422549,
                .092501,
                .432714,
                .305882,
                .428768,
                .09479,
                .432412,
                .309804,
                .434987,
                .097069,
                .432039,
                .313725,
                .441207,
                .099338,
                .431594,
                .317647,
                .447428,
                .101597,
                .43108,
                .321569,
                .453651,
                .103848,
                .430498,
                .32549,
                .459875,
                .106089,
                .429846,
                .329412,
                .4661,
                .108322,
                .429125,
                .333333,
                .472328,
                .110547,
                .428334,
                .337255,
                .478558,
                .112764,
                .427475,
                .341176,
                .484789,
                .114974,
                .426548,
                .345098,
                .491022,
                .117179,
                .425552,
                .34902,
                .497257,
                .119379,
                .424488,
                .352941,
                .503493,
                .121575,
                .423356,
                .356863,
                .50973,
                .123769,
                .422156,
                .360784,
                .515967,
                .12596,
                .420887,
                .364706,
                .522206,
                .12815,
                .419549,
                .368627,
                .528444,
                .130341,
                .418142,
                .372549,
                .534683,
                .132534,
                .416667,
                .376471,
                .54092,
                .134729,
                .415123,
                .380392,
                .547157,
                .136929,
                .413511,
                .384314,
                .553392,
                .139134,
                .411829,
                .388235,
                .559624,
                .141346,
                .410078,
                .392157,
                .565854,
                .143567,
                .408258,
                .396078,
                .572081,
                .145797,
                .406369,
                .4,
                .578304,
                .148039,
                .404411,
                .403922,
                .584521,
                .150294,
                .402385,
                .407843,
                .590734,
                .152563,
                .40029,
                .411765,
                .59694,
                .154848,
                .398125,
                .415686,
                .603139,
                .157151,
                .395891,
                .419608,
                .60933,
                .159474,
                .393589,
                .423529,
                .615513,
                .161817,
                .391219,
                .427451,
                .621685,
                .164184,
                .388781,
                .431373,
                .627847,
                .166575,
                .386276,
                .435294,
                .633998,
                .168992,
                .383704,
                .439216,
                .640135,
                .171438,
                .381065,
                .443137,
                .64626,
                .173914,
                .378359,
                .447059,
                .652369,
                .176421,
                .375586,
                .45098,
                .658463,
                .178962,
                .372748,
                .454902,
                .66454,
                .181539,
                .369846,
                .458824,
                .670599,
                .184153,
                .366879,
                .462745,
                .676638,
                .186807,
                .363849,
                .466667,
                .682656,
                .189501,
                .360757,
                .470588,
                .688653,
                .192239,
                .357603,
                .47451,
                .694627,
                .195021,
                .354388,
                .478431,
                .700576,
                .197851,
                .351113,
                .482353,
                .7065,
                .200728,
                .347777,
                .486275,
                .712396,
                .203656,
                .344383,
                .490196,
                .718264,
                .206636,
                .340931,
                .494118,
                .724103,
                .20967,
                .337424,
                .498039,
                .729909,
                .212759,
                .333861,
                .501961,
                .735683,
                .215906,
                .330245,
                .505882,
                .741423,
                .219112,
                .326576,
                .509804,
                .747127,
                .222378,
                .322856,
                .513725,
                .752794,
                .225706,
                .319085,
                .517647,
                .758422,
                .229097,
                .315266,
                .521569,
                .76401,
                .232554,
                .311399,
                .52549,
                .769556,
                .236077,
                .307485,
                .529412,
                .775059,
                .239667,
                .303526,
                .533333,
                .780517,
                .243327,
                .299523,
                .537255,
                .785929,
                .247056,
                .295477,
                .541176,
                .791293,
                .250856,
                .29139,
                .545098,
                .796607,
                .254728,
                .287264,
                .54902,
                .801871,
                .258674,
                .283099,
                .552941,
                .807082,
                .262692,
                .278898,
                .556863,
                .812239,
                .266786,
                .274661,
                .560784,
                .817341,
                .270954,
                .27039,
                .564706,
                .822386,
                .275197,
                .266085,
                .568627,
                .827372,
                .279517,
                .26175,
                .572549,
                .832299,
                .283913,
                .257383,
                .576471,
                .837165,
                .288385,
                .252988,
                .580392,
                .841969,
                .292933,
                .248564,
                .584314,
                .846709,
                .297559,
                .244113,
                .588235,
                .851384,
                .30226,
                .239636,
                .592157,
                .855992,
                .307038,
                .235133,
                .596078,
                .860533,
                .311892,
                .230606,
                .6,
                .865006,
                .316822,
                .226055,
                .603922,
                .869409,
                .321827,
                .221482,
                .607843,
                .873741,
                .326906,
                .216886,
                .611765,
                .878001,
                .33206,
                .212268,
                .615686,
                .882188,
                .337287,
                .207628,
                .619608,
                .886302,
                .342586,
                .202968,
                .623529,
                .890341,
                .347957,
                .198286,
                .627451,
                .894305,
                .353399,
                .193584,
                .631373,
                .898192,
                .358911,
                .18886,
                .635294,
                .902003,
                .364492,
                .184116,
                .639216,
                .905735,
                .37014,
                .17935,
                .643137,
                .90939,
                .375856,
                .174563,
                .647059,
                .912966,
                .381636,
                .169755,
                .65098,
                .916462,
                .387481,
                .164924,
                .654902,
                .919879,
                .393389,
                .16007,
                .658824,
                .923215,
                .399359,
                .155193,
                .662745,
                .92647,
                .405389,
                .150292,
                .666667,
                .929644,
                .411479,
                .145367,
                .670588,
                .932737,
                .417627,
                .140417,
                .67451,
                .935747,
                .423831,
                .13544,
                .678431,
                .938675,
                .430091,
                .130438,
                .682353,
                .941521,
                .436405,
                .125409,
                .686275,
                .944285,
                .442772,
                .120354,
                .690196,
                .946965,
                .449191,
                .115272,
                .694118,
                .949562,
                .45566,
                .110164,
                .698039,
                .952075,
                .462178,
                .105031,
                .701961,
                .954506,
                .468744,
                .099874,
                .705882,
                .956852,
                .475356,
                .094695,
                .709804,
                .959114,
                .482014,
                .089499,
                .713725,
                .961293,
                .488716,
                .084289,
                .717647,
                .963387,
                .495462,
                .079073,
                .721569,
                .965397,
                .502249,
                .073859,
                .72549,
                .967322,
                .509078,
                .068659,
                .729412,
                .969163,
                .515946,
                .063488,
                .733333,
                .970919,
                .522853,
                .058367,
                .737255,
                .97259,
                .529798,
                .053324,
                .741176,
                .974176,
                .53678,
                .048392,
                .745098,
                .975677,
                .543798,
                .043618,
                .74902,
                .977092,
                .55085,
                .03905,
                .752941,
                .978422,
                .557937,
                .034931,
                .756863,
                .979666,
                .565057,
                .031409,
                .760784,
                .980824,
                .572209,
                .028508,
                .764706,
                .981895,
                .579392,
                .02625,
                .768627,
                .982881,
                .586606,
                .024661,
                .772549,
                .983779,
                .593849,
                .02377,
                .776471,
                .984591,
                .601122,
                .023606,
                .780392,
                .985315,
                .608422,
                .024202,
                .784314,
                .985952,
                .61575,
                .025592,
                .788235,
                .986502,
                .623105,
                .027814,
                .792157,
                .986964,
                .630485,
                .030908,
                .796078,
                .987337,
                .63789,
                .034916,
                .8,
                .987622,
                .64532,
                .039886,
                .803922,
                .987819,
                .652773,
                .045581,
                .807843,
                .987926,
                .66025,
                .05175,
                .811765,
                .987945,
                .667748,
                .058329,
                .815686,
                .987874,
                .675267,
                .065257,
                .819608,
                .987714,
                .682807,
                .072489,
                .823529,
                .987464,
                .690366,
                .07999,
                .827451,
                .987124,
                .697944,
                .087731,
                .831373,
                .986694,
                .70554,
                .095694,
                .835294,
                .986175,
                .713153,
                .103863,
                .839216,
                .985566,
                .720782,
                .112229,
                .843137,
                .984865,
                .728427,
                .120785,
                .847059,
                .984075,
                .736087,
                .129527,
                .85098,
                .983196,
                .743758,
                .138453,
                .854902,
                .982228,
                .751442,
                .147565,
                .858824,
                .981173,
                .759135,
                .156863,
                .862745,
                .980032,
                .766837,
                .166353,
                .866667,
                .978806,
                .774545,
                .176037,
                .870588,
                .977497,
                .782258,
                .185923,
                .87451,
                .976108,
                .789974,
                .196018,
                .878431,
                .974638,
                .797692,
                .206332,
                .882353,
                .973088,
                .805409,
                .216877,
                .886275,
                .971468,
                .813122,
                .227658,
                .890196,
                .969783,
                .820825,
                .238686,
                .894118,
                .968041,
                .828515,
                .249972,
                .898039,
                .966243,
                .836191,
                .261534,
                .901961,
                .964394,
                .843848,
                .273391,
                .905882,
                .962517,
                .851476,
                .285546,
                .909804,
                .960626,
                .859069,
                .29801,
                .913725,
                .95872,
                .866624,
                .31082,
                .917647,
                .956834,
                .874129,
                .323974,
                .921569,
                .954997,
                .881569,
                .337475,
                .92549,
                .953215,
                .888942,
                .351369,
                .929412,
                .951546,
                .896226,
                .365627,
                .933333,
                .950018,
                .903409,
                .380271,
                .937255,
                .948683,
                .910473,
                .395289,
                .941176,
                .947594,
                .917399,
                .410665,
                .945098,
                .946809,
                .924168,
                .426373,
                .94902,
                .946392,
                .930761,
                .442367,
                .952941,
                .946403,
                .937159,
                .458592,
                .956863,
                .946903,
                .943348,
                .47497,
                .960784,
                .947937,
                .949318,
                .491426,
                .964706,
                .949545,
                .955063,
                .50786,
                .968627,
                .95174,
                .960587,
                .524203,
                .972549,
                .954529,
                .965896,
                .540361,
                .976471,
                .957896,
                .971003,
                .556275,
                .980392,
                .961812,
                .975924,
                .571925,
                .984314,
                .966249,
                .980678,
                .587206,
                .988235,
                .971162,
                .985282,
                .602154,
                .992157,
                .976511,
                .989753,
                .61676,
                .996078,
                .982257,
                .994109,
                .631017,
                1,
                .988362,
                .998364,
                .644924
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Plasma (matplotlib)",
            NanColor: [
                0,
                1,
                0
            ],
            Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
            License: "CC0",
            Creator: "Nathaniel J. Smith & Stefan van der Walt",
            RGBPoints: [
                0,
                .050383,
                .029803,
                .527975,
                .003922,
                .063536,
                .028426,
                .533124,
                .007843,
                .075353,
                .027206,
                .538007,
                .011765,
                .086222,
                .026125,
                .542658,
                .015686,
                .096379,
                .025165,
                .547103,
                .019608,
                .10598,
                .024309,
                .551368,
                .023529,
                .115124,
                .023556,
                .555468,
                .027451,
                .123903,
                .022878,
                .559423,
                .031373,
                .132381,
                .022258,
                .56325,
                .035294,
                .140603,
                .021687,
                .566959,
                .039216,
                .148607,
                .021154,
                .570562,
                .043137,
                .156421,
                .020651,
                .574065,
                .047059,
                .16407,
                .020171,
                .577478,
                .05098,
                .171574,
                .019706,
                .580806,
                .054902,
                .17895,
                .019252,
                .584054,
                .058824,
                .186213,
                .018803,
                .587228,
                .062745,
                .193374,
                .018354,
                .59033,
                .066667,
                .200445,
                .017902,
                .593364,
                .070588,
                .207435,
                .017442,
                .596333,
                .07451,
                .21435,
                .016973,
                .599239,
                .078431,
                .221197,
                .016497,
                .602083,
                .082353,
                .227983,
                .016007,
                .604867,
                .086275,
                .234715,
                .015502,
                .607592,
                .090196,
                .241396,
                .014979,
                .610259,
                .094118,
                .248032,
                .014439,
                .612868,
                .098039,
                .254627,
                .013882,
                .615419,
                .101961,
                .261183,
                .013308,
                .617911,
                .105882,
                .267703,
                .012716,
                .620346,
                .109804,
                .274191,
                .012109,
                .622722,
                .113725,
                .280648,
                .011488,
                .625038,
                .117647,
                .287076,
                .010855,
                .627295,
                .121569,
                .293478,
                .010213,
                .62949,
                .12549,
                .299855,
                .009561,
                .631624,
                .129412,
                .30621,
                .008902,
                .633694,
                .133333,
                .312543,
                .008239,
                .6357,
                .137255,
                .318856,
                .007576,
                .63764,
                .141176,
                .32515,
                .006915,
                .639512,
                .145098,
                .331426,
                .006261,
                .641316,
                .14902,
                .337683,
                .005618,
                .643049,
                .152941,
                .343925,
                .004991,
                .64471,
                .156863,
                .35015,
                .004382,
                .646298,
                .160784,
                .356359,
                .003798,
                .64781,
                .164706,
                .362553,
                .003243,
                .649245,
                .168627,
                .368733,
                .002724,
                .650601,
                .172549,
                .374897,
                .002245,
                .651876,
                .176471,
                .381047,
                .001814,
                .653068,
                .180392,
                .387183,
                .001434,
                .654177,
                .184314,
                .393304,
                .001114,
                .655199,
                .188235,
                .399411,
                859e-6,
                .656133,
                .192157,
                .405503,
                678e-6,
                .656977,
                .196078,
                .41158,
                577e-6,
                .65773,
                .2,
                .417642,
                564e-6,
                .65839,
                .203922,
                .423689,
                646e-6,
                .658956,
                .207843,
                .429719,
                831e-6,
                .659425,
                .211765,
                .435734,
                .001127,
                .659797,
                .215686,
                .441732,
                .00154,
                .660069,
                .219608,
                .447714,
                .00208,
                .66024,
                .223529,
                .453677,
                .002755,
                .66031,
                .227451,
                .459623,
                .003574,
                .660277,
                .231373,
                .46555,
                .004545,
                .660139,
                .235294,
                .471457,
                .005678,
                .659897,
                .239216,
                .477344,
                .00698,
                .659549,
                .243137,
                .48321,
                .00846,
                .659095,
                .247059,
                .489055,
                .010127,
                .658534,
                .25098,
                .494877,
                .01199,
                .657865,
                .254902,
                .500678,
                .014055,
                .657088,
                .258824,
                .506454,
                .016333,
                .656202,
                .262745,
                .512206,
                .018833,
                .655209,
                .266667,
                .517933,
                .021563,
                .654109,
                .270588,
                .523633,
                .024532,
                .652901,
                .27451,
                .529306,
                .027747,
                .651586,
                .278431,
                .534952,
                .031217,
                .650165,
                .282353,
                .54057,
                .03495,
                .64864,
                .286275,
                .546157,
                .038954,
                .64701,
                .290196,
                .551715,
                .043136,
                .645277,
                .294118,
                .557243,
                .047331,
                .643443,
                .298039,
                .562738,
                .051545,
                .641509,
                .301961,
                .568201,
                .055778,
                .639477,
                .305882,
                .573632,
                .060028,
                .637349,
                .309804,
                .579029,
                .064296,
                .635126,
                .313725,
                .584391,
                .068579,
                .632812,
                .317647,
                .589719,
                .072878,
                .630408,
                .321569,
                .595011,
                .07719,
                .627917,
                .32549,
                .600266,
                .081516,
                .625342,
                .329412,
                .605485,
                .085854,
                .622686,
                .333333,
                .610667,
                .090204,
                .619951,
                .337255,
                .615812,
                .094564,
                .61714,
                .341176,
                .620919,
                .098934,
                .614257,
                .345098,
                .625987,
                .103312,
                .611305,
                .34902,
                .631017,
                .107699,
                .608287,
                .352941,
                .636008,
                .112092,
                .605205,
                .356863,
                .640959,
                .116492,
                .602065,
                .360784,
                .645872,
                .120898,
                .598867,
                .364706,
                .650746,
                .125309,
                .595617,
                .368627,
                .65558,
                .129725,
                .592317,
                .372549,
                .660374,
                .134144,
                .588971,
                .376471,
                .665129,
                .138566,
                .585582,
                .380392,
                .669845,
                .142992,
                .582154,
                .384314,
                .674522,
                .147419,
                .578688,
                .388235,
                .67916,
                .151848,
                .575189,
                .392157,
                .683758,
                .156278,
                .57166,
                .396078,
                .688318,
                .160709,
                .568103,
                .4,
                .69284,
                .165141,
                .564522,
                .403922,
                .697324,
                .169573,
                .560919,
                .407843,
                .701769,
                .174005,
                .557296,
                .411765,
                .706178,
                .178437,
                .553657,
                .415686,
                .710549,
                .182868,
                .550004,
                .419608,
                .714883,
                .187299,
                .546338,
                .423529,
                .719181,
                .191729,
                .542663,
                .427451,
                .723444,
                .196158,
                .538981,
                .431373,
                .72767,
                .200586,
                .535293,
                .435294,
                .731862,
                .205013,
                .531601,
                .439216,
                .736019,
                .209439,
                .527908,
                .443137,
                .740143,
                .213864,
                .524216,
                .447059,
                .744232,
                .218288,
                .520524,
                .45098,
                .748289,
                .222711,
                .516834,
                .454902,
                .752312,
                .227133,
                .513149,
                .458824,
                .756304,
                .231555,
                .509468,
                .462745,
                .760264,
                .235976,
                .505794,
                .466667,
                .764193,
                .240396,
                .502126,
                .470588,
                .76809,
                .244817,
                .498465,
                .47451,
                .771958,
                .249237,
                .494813,
                .478431,
                .775796,
                .253658,
                .491171,
                .482353,
                .779604,
                .258078,
                .487539,
                .486275,
                .783383,
                .2625,
                .483918,
                .490196,
                .787133,
                .266922,
                .480307,
                .494118,
                .790855,
                .271345,
                .476706,
                .498039,
                .794549,
                .27577,
                .473117,
                .501961,
                .798216,
                .280197,
                .469538,
                .505882,
                .801855,
                .284626,
                .465971,
                .509804,
                .805467,
                .289057,
                .462415,
                .513725,
                .809052,
                .293491,
                .45887,
                .517647,
                .812612,
                .297928,
                .455338,
                .521569,
                .816144,
                .302368,
                .451816,
                .52549,
                .819651,
                .306812,
                .448306,
                .529412,
                .823132,
                .311261,
                .444806,
                .533333,
                .826588,
                .315714,
                .441316,
                .537255,
                .830018,
                .320172,
                .437836,
                .541176,
                .833422,
                .324635,
                .434366,
                .545098,
                .836801,
                .329105,
                .430905,
                .54902,
                .840155,
                .33358,
                .427455,
                .552941,
                .843484,
                .338062,
                .424013,
                .556863,
                .846788,
                .342551,
                .420579,
                .560784,
                .850066,
                .347048,
                .417153,
                .564706,
                .853319,
                .351553,
                .413734,
                .568627,
                .856547,
                .356066,
                .410322,
                .572549,
                .85975,
                .360588,
                .406917,
                .576471,
                .862927,
                .365119,
                .403519,
                .580392,
                .866078,
                .36966,
                .400126,
                .584314,
                .869203,
                .374212,
                .396738,
                .588235,
                .872303,
                .378774,
                .393355,
                .592157,
                .875376,
                .383347,
                .389976,
                .596078,
                .878423,
                .387932,
                .3866,
                .6,
                .881443,
                .392529,
                .383229,
                .603922,
                .884436,
                .397139,
                .37986,
                .607843,
                .887402,
                .401762,
                .376494,
                .611765,
                .89034,
                .406398,
                .37313,
                .615686,
                .89325,
                .411048,
                .369768,
                .619608,
                .896131,
                .415712,
                .366407,
                .623529,
                .898984,
                .420392,
                .363047,
                .627451,
                .901807,
                .425087,
                .359688,
                .631373,
                .904601,
                .429797,
                .356329,
                .635294,
                .907365,
                .434524,
                .35297,
                .639216,
                .910098,
                .439268,
                .34961,
                .643137,
                .9128,
                .444029,
                .346251,
                .647059,
                .915471,
                .448807,
                .34289,
                .65098,
                .918109,
                .453603,
                .339529,
                .654902,
                .920714,
                .458417,
                .336166,
                .658824,
                .923287,
                .463251,
                .332801,
                .662745,
                .925825,
                .468103,
                .329435,
                .666667,
                .928329,
                .472975,
                .326067,
                .670588,
                .930798,
                .477867,
                .322697,
                .67451,
                .933232,
                .48278,
                .319325,
                .678431,
                .93563,
                .487712,
                .315952,
                .682353,
                .93799,
                .492667,
                .312575,
                .686275,
                .940313,
                .497642,
                .309197,
                .690196,
                .942598,
                .502639,
                .305816,
                .694118,
                .944844,
                .507658,
                .302433,
                .698039,
                .947051,
                .512699,
                .299049,
                .701961,
                .949217,
                .517763,
                .295662,
                .705882,
                .951344,
                .52285,
                .292275,
                .709804,
                .953428,
                .52796,
                .288883,
                .713725,
                .95547,
                .533093,
                .28549,
                .717647,
                .957469,
                .53825,
                .282096,
                .721569,
                .959424,
                .543431,
                .278701,
                .72549,
                .961336,
                .548636,
                .275305,
                .729412,
                .963203,
                .553865,
                .271909,
                .733333,
                .965024,
                .559118,
                .268513,
                .737255,
                .966798,
                .564396,
                .265118,
                .741176,
                .968526,
                .5697,
                .261721,
                .745098,
                .970205,
                .575028,
                .258325,
                .74902,
                .971835,
                .580382,
                .254931,
                .752941,
                .973416,
                .585761,
                .25154,
                .756863,
                .974947,
                .591165,
                .248151,
                .760784,
                .976428,
                .596595,
                .244767,
                .764706,
                .977856,
                .602051,
                .241387,
                .768627,
                .979233,
                .607532,
                .238013,
                .772549,
                .980556,
                .613039,
                .234646,
                .776471,
                .981826,
                .618572,
                .231287,
                .780392,
                .983041,
                .624131,
                .227937,
                .784314,
                .984199,
                .629718,
                .224595,
                .788235,
                .985301,
                .63533,
                .221265,
                .792157,
                .986345,
                .640969,
                .217948,
                .796078,
                .987332,
                .646633,
                .214648,
                .8,
                .98826,
                .652325,
                .211364,
                .803922,
                .989128,
                .658043,
                .2081,
                .807843,
                .989935,
                .663787,
                .204859,
                .811765,
                .990681,
                .669558,
                .201642,
                .815686,
                .991365,
                .675355,
                .198453,
                .819608,
                .991985,
                .681179,
                .195295,
                .823529,
                .992541,
                .68703,
                .19217,
                .827451,
                .993032,
                .692907,
                .189084,
                .831373,
                .993456,
                .69881,
                .186041,
                .835294,
                .993814,
                .704741,
                .183043,
                .839216,
                .994103,
                .710698,
                .180097,
                .843137,
                .994324,
                .716681,
                .177208,
                .847059,
                .994474,
                .722691,
                .174381,
                .85098,
                .994553,
                .728728,
                .171622,
                .854902,
                .994561,
                .734791,
                .168938,
                .858824,
                .994495,
                .74088,
                .166335,
                .862745,
                .994355,
                .746995,
                .163821,
                .866667,
                .994141,
                .753137,
                .161404,
                .870588,
                .993851,
                .759304,
                .159092,
                .87451,
                .993482,
                .765499,
                .156891,
                .878431,
                .993033,
                .77172,
                .154808,
                .882353,
                .992505,
                .777967,
                .152855,
                .886275,
                .991897,
                .784239,
                .151042,
                .890196,
                .991209,
                .790537,
                .149377,
                .894118,
                .990439,
                .796859,
                .14787,
                .898039,
                .989587,
                .803205,
                .146529,
                .901961,
                .988648,
                .809579,
                .145357,
                .905882,
                .987621,
                .815978,
                .144363,
                .909804,
                .986509,
                .822401,
                .143557,
                .913725,
                .985314,
                .828846,
                .142945,
                .917647,
                .984031,
                .835315,
                .142528,
                .921569,
                .982653,
                .841812,
                .142303,
                .92549,
                .98119,
                .848329,
                .142279,
                .929412,
                .979644,
                .854866,
                .142453,
                .933333,
                .977995,
                .861432,
                .142808,
                .937255,
                .976265,
                .868016,
                .143351,
                .941176,
                .974443,
                .874622,
                .144061,
                .945098,
                .97253,
                .88125,
                .144923,
                .94902,
                .970533,
                .887896,
                .145919,
                .952941,
                .968443,
                .894564,
                .147014,
                .956863,
                .966271,
                .901249,
                .14818,
                .960784,
                .964021,
                .90795,
                .14937,
                .964706,
                .961681,
                .914672,
                .15052,
                .968627,
                .959276,
                .921407,
                .151566,
                .972549,
                .956808,
                .928152,
                .152409,
                .976471,
                .954287,
                .934908,
                .152921,
                .980392,
                .951726,
                .941671,
                .152925,
                .984314,
                .949151,
                .948435,
                .152178,
                .988235,
                .946602,
                .95519,
                .150328,
                .992157,
                .944152,
                .961916,
                .146861,
                .996078,
                .941896,
                .96859,
                .140956,
                1,
                .940015,
                .975158,
                .131326
            ]
        },
        {
            ColorSpace: "Diverging",
            Name: "Viridis (matplotlib)",
            NanColor: [
                1,
                0,
                0
            ],
            Source: "https://github.com/BIDS/colormap/blob/master/colormaps.py",
            License: "CC0",
            Creator: "Eric Firing",
            RGBPoints: [
                0,
                .267004,
                .004874,
                .329415,
                .003922,
                .26851,
                .009605,
                .335427,
                .007843,
                .269944,
                .014625,
                .341379,
                .011765,
                .271305,
                .019942,
                .347269,
                .015686,
                .272594,
                .025563,
                .353093,
                .019608,
                .273809,
                .031497,
                .358853,
                .023529,
                .274952,
                .037752,
                .364543,
                .027451,
                .276022,
                .044167,
                .370164,
                .031373,
                .277018,
                .050344,
                .375715,
                .035294,
                .277941,
                .056324,
                .381191,
                .039216,
                .278791,
                .062145,
                .386592,
                .043137,
                .279566,
                .067836,
                .391917,
                .047059,
                .280267,
                .073417,
                .397163,
                .05098,
                .280894,
                .078907,
                .402329,
                .054902,
                .281446,
                .08432,
                .407414,
                .058824,
                .281924,
                .089666,
                .412415,
                .062745,
                .282327,
                .094955,
                .417331,
                .066667,
                .282656,
                .100196,
                .42216,
                .070588,
                .28291,
                .105393,
                .426902,
                .07451,
                .283091,
                .110553,
                .431554,
                .078431,
                .283197,
                .11568,
                .436115,
                .082353,
                .283229,
                .120777,
                .440584,
                .086275,
                .283187,
                .125848,
                .44496,
                .090196,
                .283072,
                .130895,
                .449241,
                .094118,
                .282884,
                .13592,
                .453427,
                .098039,
                .282623,
                .140926,
                .457517,
                .101961,
                .28229,
                .145912,
                .46151,
                .105882,
                .281887,
                .150881,
                .465405,
                .109804,
                .281412,
                .155834,
                .469201,
                .113725,
                .280868,
                .160771,
                .472899,
                .117647,
                .280255,
                .165693,
                .476498,
                .121569,
                .279574,
                .170599,
                .479997,
                .12549,
                .278826,
                .17549,
                .483397,
                .129412,
                .278012,
                .180367,
                .486697,
                .133333,
                .277134,
                .185228,
                .489898,
                .137255,
                .276194,
                .190074,
                .493001,
                .141176,
                .275191,
                .194905,
                .496005,
                .145098,
                .274128,
                .199721,
                .498911,
                .14902,
                .273006,
                .20452,
                .501721,
                .152941,
                .271828,
                .209303,
                .504434,
                .156863,
                .270595,
                .214069,
                .507052,
                .160784,
                .269308,
                .218818,
                .509577,
                .164706,
                .267968,
                .223549,
                .512008,
                .168627,
                .26658,
                .228262,
                .514349,
                .172549,
                .265145,
                .232956,
                .516599,
                .176471,
                .263663,
                .237631,
                .518762,
                .180392,
                .262138,
                .242286,
                .520837,
                .184314,
                .260571,
                .246922,
                .522828,
                .188235,
                .258965,
                .251537,
                .524736,
                .192157,
                .257322,
                .25613,
                .526563,
                .196078,
                .255645,
                .260703,
                .528312,
                .2,
                .253935,
                .265254,
                .529983,
                .203922,
                .252194,
                .269783,
                .531579,
                .207843,
                .250425,
                .27429,
                .533103,
                .211765,
                .248629,
                .278775,
                .534556,
                .215686,
                .246811,
                .283237,
                .535941,
                .219608,
                .244972,
                .287675,
                .53726,
                .223529,
                .243113,
                .292092,
                .538516,
                .227451,
                .241237,
                .296485,
                .539709,
                .231373,
                .239346,
                .300855,
                .540844,
                .235294,
                .237441,
                .305202,
                .541921,
                .239216,
                .235526,
                .309527,
                .542944,
                .243137,
                .233603,
                .313828,
                .543914,
                .247059,
                .231674,
                .318106,
                .544834,
                .25098,
                .229739,
                .322361,
                .545706,
                .254902,
                .227802,
                .326594,
                .546532,
                .258824,
                .225863,
                .330805,
                .547314,
                .262745,
                .223925,
                .334994,
                .548053,
                .266667,
                .221989,
                .339161,
                .548752,
                .270588,
                .220057,
                .343307,
                .549413,
                .27451,
                .21813,
                .347432,
                .550038,
                .278431,
                .21621,
                .351535,
                .550627,
                .282353,
                .214298,
                .355619,
                .551184,
                .286275,
                .212395,
                .359683,
                .55171,
                .290196,
                .210503,
                .363727,
                .552206,
                .294118,
                .208623,
                .367752,
                .552675,
                .298039,
                .206756,
                .371758,
                .553117,
                .301961,
                .204903,
                .375746,
                .553533,
                .305882,
                .203063,
                .379716,
                .553925,
                .309804,
                .201239,
                .38367,
                .554294,
                .313725,
                .19943,
                .387607,
                .554642,
                .317647,
                .197636,
                .391528,
                .554969,
                .321569,
                .19586,
                .395433,
                .555276,
                .32549,
                .1941,
                .399323,
                .555565,
                .329412,
                .192357,
                .403199,
                .555836,
                .333333,
                .190631,
                .407061,
                .556089,
                .337255,
                .188923,
                .41091,
                .556326,
                .341176,
                .187231,
                .414746,
                .556547,
                .345098,
                .185556,
                .41857,
                .556753,
                .34902,
                .183898,
                .422383,
                .556944,
                .352941,
                .182256,
                .426184,
                .55712,
                .356863,
                .180629,
                .429975,
                .557282,
                .360784,
                .179019,
                .433756,
                .55743,
                .364706,
                .177423,
                .437527,
                .557565,
                .368627,
                .175841,
                .44129,
                .557685,
                .372549,
                .174274,
                .445044,
                .557792,
                .376471,
                .172719,
                .448791,
                .557885,
                .380392,
                .171176,
                .45253,
                .557965,
                .384314,
                .169646,
                .456262,
                .55803,
                .388235,
                .168126,
                .459988,
                .558082,
                .392157,
                .166617,
                .463708,
                .558119,
                .396078,
                .165117,
                .467423,
                .558141,
                .4,
                .163625,
                .471133,
                .558148,
                .403922,
                .162142,
                .474838,
                .55814,
                .407843,
                .160665,
                .47854,
                .558115,
                .411765,
                .159194,
                .482237,
                .558073,
                .415686,
                .157729,
                .485932,
                .558013,
                .419608,
                .15627,
                .489624,
                .557936,
                .423529,
                .154815,
                .493313,
                .55784,
                .427451,
                .153364,
                .497,
                .557724,
                .431373,
                .151918,
                .500685,
                .557587,
                .435294,
                .150476,
                .504369,
                .55743,
                .439216,
                .149039,
                .508051,
                .55725,
                .443137,
                .147607,
                .511733,
                .557049,
                .447059,
                .14618,
                .515413,
                .556823,
                .45098,
                .144759,
                .519093,
                .556572,
                .454902,
                .143343,
                .522773,
                .556295,
                .458824,
                .141935,
                .526453,
                .555991,
                .462745,
                .140536,
                .530132,
                .555659,
                .466667,
                .139147,
                .533812,
                .555298,
                .470588,
                .13777,
                .537492,
                .554906,
                .47451,
                .136408,
                .541173,
                .554483,
                .478431,
                .135066,
                .544853,
                .554029,
                .482353,
                .133743,
                .548535,
                .553541,
                .486275,
                .132444,
                .552216,
                .553018,
                .490196,
                .131172,
                .555899,
                .552459,
                .494118,
                .129933,
                .559582,
                .551864,
                .498039,
                .128729,
                .563265,
                .551229,
                .501961,
                .127568,
                .566949,
                .550556,
                .505882,
                .126453,
                .570633,
                .549841,
                .509804,
                .125394,
                .574318,
                .549086,
                .513725,
                .124395,
                .578002,
                .548287,
                .517647,
                .123463,
                .581687,
                .547445,
                .521569,
                .122606,
                .585371,
                .546557,
                .52549,
                .121831,
                .589055,
                .545623,
                .529412,
                .121148,
                .592739,
                .544641,
                .533333,
                .120565,
                .596422,
                .543611,
                .537255,
                .120092,
                .600104,
                .54253,
                .541176,
                .119738,
                .603785,
                .5414,
                .545098,
                .119512,
                .607464,
                .540218,
                .54902,
                .119423,
                .611141,
                .538982,
                .552941,
                .119483,
                .614817,
                .537692,
                .556863,
                .119699,
                .61849,
                .536347,
                .560784,
                .120081,
                .622161,
                .534946,
                .564706,
                .120638,
                .625828,
                .533488,
                .568627,
                .12138,
                .629492,
                .531973,
                .572549,
                .122312,
                .633153,
                .530398,
                .576471,
                .123444,
                .636809,
                .528763,
                .580392,
                .12478,
                .640461,
                .527068,
                .584314,
                .126326,
                .644107,
                .525311,
                .588235,
                .128087,
                .647749,
                .523491,
                .592157,
                .130067,
                .651384,
                .521608,
                .596078,
                .132268,
                .655014,
                .519661,
                .6,
                .134692,
                .658636,
                .517649,
                .603922,
                .137339,
                .662252,
                .515571,
                .607843,
                .14021,
                .665859,
                .513427,
                .611765,
                .143303,
                .669459,
                .511215,
                .615686,
                .146616,
                .67305,
                .508936,
                .619608,
                .150148,
                .676631,
                .506589,
                .623529,
                .153894,
                .680203,
                .504172,
                .627451,
                .157851,
                .683765,
                .501686,
                .631373,
                .162016,
                .687316,
                .499129,
                .635294,
                .166383,
                .690856,
                .496502,
                .639216,
                .170948,
                .694384,
                .493803,
                .643137,
                .175707,
                .6979,
                .491033,
                .647059,
                .180653,
                .701402,
                .488189,
                .65098,
                .185783,
                .704891,
                .485273,
                .654902,
                .19109,
                .708366,
                .482284,
                .658824,
                .196571,
                .711827,
                .479221,
                .662745,
                .202219,
                .715272,
                .476084,
                .666667,
                .20803,
                .718701,
                .472873,
                .670588,
                .214,
                .722114,
                .469588,
                .67451,
                .220124,
                .725509,
                .466226,
                .678431,
                .226397,
                .728888,
                .462789,
                .682353,
                .232815,
                .732247,
                .459277,
                .686275,
                .239374,
                .735588,
                .455688,
                .690196,
                .24607,
                .73891,
                .452024,
                .694118,
                .252899,
                .742211,
                .448284,
                .698039,
                .259857,
                .745492,
                .444467,
                .701961,
                .266941,
                .748751,
                .440573,
                .705882,
                .274149,
                .751988,
                .436601,
                .709804,
                .281477,
                .755203,
                .432552,
                .713725,
                .288921,
                .758394,
                .428426,
                .717647,
                .296479,
                .761561,
                .424223,
                .721569,
                .304148,
                .764704,
                .419943,
                .72549,
                .311925,
                .767822,
                .415586,
                .729412,
                .319809,
                .770914,
                .411152,
                .733333,
                .327796,
                .77398,
                .40664,
                .737255,
                .335885,
                .777018,
                .402049,
                .741176,
                .344074,
                .780029,
                .397381,
                .745098,
                .35236,
                .783011,
                .392636,
                .74902,
                .360741,
                .785964,
                .387814,
                .752941,
                .369214,
                .788888,
                .382914,
                .756863,
                .377779,
                .791781,
                .377939,
                .760784,
                .386433,
                .794644,
                .372886,
                .764706,
                .395174,
                .797475,
                .367757,
                .768627,
                .404001,
                .800275,
                .362552,
                .772549,
                .412913,
                .803041,
                .357269,
                .776471,
                .421908,
                .805774,
                .35191,
                .780392,
                .430983,
                .808473,
                .346476,
                .784314,
                .440137,
                .811138,
                .340967,
                .788235,
                .449368,
                .813768,
                .335384,
                .792157,
                .458674,
                .816363,
                .329727,
                .796078,
                .468053,
                .818921,
                .323998,
                .8,
                .477504,
                .821444,
                .318195,
                .803922,
                .487026,
                .823929,
                .312321,
                .807843,
                .496615,
                .826376,
                .306377,
                .811765,
                .506271,
                .828786,
                .300362,
                .815686,
                .515992,
                .831158,
                .294279,
                .819608,
                .525776,
                .833491,
                .288127,
                .823529,
                .535621,
                .835785,
                .281908,
                .827451,
                .545524,
                .838039,
                .275626,
                .831373,
                .555484,
                .840254,
                .269281,
                .835294,
                .565498,
                .84243,
                .262877,
                .839216,
                .575563,
                .844566,
                .256415,
                .843137,
                .585678,
                .846661,
                .249897,
                .847059,
                .595839,
                .848717,
                .243329,
                .85098,
                .606045,
                .850733,
                .236712,
                .854902,
                .616293,
                .852709,
                .230052,
                .858824,
                .626579,
                .854645,
                .223353,
                .862745,
                .636902,
                .856542,
                .21662,
                .866667,
                .647257,
                .8584,
                .209861,
                .870588,
                .657642,
                .860219,
                .203082,
                .87451,
                .668054,
                .861999,
                .196293,
                .878431,
                .678489,
                .863742,
                .189503,
                .882353,
                .688944,
                .865448,
                .182725,
                .886275,
                .699415,
                .867117,
                .175971,
                .890196,
                .709898,
                .868751,
                .169257,
                .894118,
                .720391,
                .87035,
                .162603,
                .898039,
                .730889,
                .871916,
                .156029,
                .901961,
                .741388,
                .873449,
                .149561,
                .905882,
                .751884,
                .874951,
                .143228,
                .909804,
                .762373,
                .876424,
                .137064,
                .913725,
                .772852,
                .877868,
                .131109,
                .917647,
                .783315,
                .879285,
                .125405,
                .921569,
                .79376,
                .880678,
                .120005,
                .92549,
                .804182,
                .882046,
                .114965,
                .929412,
                .814576,
                .883393,
                .110347,
                .933333,
                .82494,
                .88472,
                .106217,
                .937255,
                .83527,
                .886029,
                .102646,
                .941176,
                .845561,
                .887322,
                .099702,
                .945098,
                .85581,
                .888601,
                .097452,
                .94902,
                .866013,
                .889868,
                .095953,
                .952941,
                .876168,
                .891125,
                .09525,
                .956863,
                .886271,
                .892374,
                .095374,
                .960784,
                .89632,
                .893616,
                .096335,
                .964706,
                .906311,
                .894855,
                .098125,
                .968627,
                .916242,
                .896091,
                .100717,
                .972549,
                .926106,
                .89733,
                .104071,
                .976471,
                .935904,
                .89857,
                .108131,
                .980392,
                .945636,
                .899815,
                .112838,
                .984314,
                .9553,
                .901065,
                .118128,
                .988235,
                .964894,
                .902323,
                .123941,
                .992157,
                .974417,
                .90359,
                .130215,
                .996078,
                .983868,
                .904867,
                .136897,
                1,
                .993248,
                .906157,
                .143936
            ]
        },
        {
            ShowIndexedColorActiveValues: 1,
            IndexedColors: [
                .07,
                .5,
                .7,
                1,
                1,
                1,
                .85,
                1,
                1,
                .8,
                .5,
                1,
                .76,
                1,
                0,
                1,
                .71,
                .71,
                .5,
                .5,
                .5,
                .05,
                .05,
                1,
                1,
                .05,
                .05,
                .7,
                1,
                1,
                .7,
                .89,
                .96,
                .67,
                .36,
                .95,
                .54,
                1,
                0,
                .75,
                .65,
                .65,
                .5,
                .6,
                .6,
                1,
                .5,
                0,
                1,
                1,
                .19,
                .12,
                .94,
                .12,
                .5,
                .82,
                .89,
                .56,
                .25,
                .83,
                .24,
                1,
                0,
                .9,
                .9,
                .9,
                .75,
                .76,
                .78,
                .65,
                .65,
                .67,
                .54,
                .6,
                .78,
                .61,
                .48,
                .78,
                .5,
                .48,
                .78,
                .44,
                .48,
                .78,
                .36,
                .48,
                .76,
                1,
                .48,
                .38,
                .49,
                .5,
                .69,
                .76,
                .56,
                .56,
                .4,
                .56,
                .56,
                .74,
                .5,
                .89,
                1,
                .63,
                0,
                .65,
                .16,
                .16,
                .36,
                .72,
                .82,
                .44,
                .18,
                .69,
                0,
                1,
                0,
                .58,
                1,
                1,
                .58,
                .88,
                .88,
                .45,
                .76,
                .79,
                .33,
                .71,
                .71,
                .23,
                .62,
                .62,
                .14,
                .56,
                .56,
                .04,
                .49,
                .55,
                0,
                .41,
                .52,
                .88,
                .88,
                1,
                1,
                .85,
                .56,
                .65,
                .46,
                .45,
                .4,
                .5,
                .5,
                .62,
                .39,
                .71,
                .83,
                .48,
                0,
                .58,
                0,
                .58,
                .26,
                .62,
                .69,
                .34,
                .09,
                .56,
                0,
                .79,
                0,
                .44,
                .83,
                1,
                1,
                1,
                .78,
                .85,
                1,
                .78,
                .78,
                1,
                .78,
                .64,
                1,
                .78,
                .56,
                1,
                .78,
                .38,
                1,
                .78,
                .27,
                1,
                .78,
                .19,
                1,
                .78,
                .12,
                1,
                .78,
                0,
                1,
                .61,
                0,
                .9,
                .46,
                0,
                .83,
                .32,
                0,
                .75,
                .22,
                0,
                .67,
                .14,
                .3,
                .76,
                1,
                .3,
                .65,
                1,
                .13,
                .58,
                .84,
                .15,
                .49,
                .67,
                .15,
                .4,
                .59,
                .09,
                .33,
                .53,
                .96,
                .93,
                .82,
                .8,
                .82,
                .12,
                .71,
                .71,
                .76,
                .65,
                .33,
                .3,
                .34,
                .35,
                .38,
                .62,
                .31,
                .71,
                .67,
                .36,
                0,
                .46,
                .31,
                .27,
                .26,
                .51,
                .59,
                .26,
                0,
                .4,
                0,
                .49,
                0,
                .44,
                .67,
                .98,
                0,
                .73,
                1,
                0,
                .63,
                1,
                0,
                .56,
                1,
                0,
                .5,
                1,
                0,
                .42,
                1,
                .33,
                .36,
                .95,
                .47,
                .36,
                .89,
                .54,
                .31,
                .89,
                .63,
                .21,
                .83,
                .7,
                .12,
                .83,
                .7,
                .12,
                .73,
                .7,
                .05,
                .65,
                .74,
                .05,
                .53,
                .78,
                0,
                .4,
                .8,
                0,
                .35,
                .82,
                0,
                .31,
                .85,
                0,
                .27,
                .88,
                0,
                .22,
                .9,
                0,
                .18,
                .91,
                0,
                .15,
                .92,
                0,
                .14,
                .93,
                0,
                .13,
                .94,
                0,
                .12,
                .95,
                0,
                .11,
                .96,
                0,
                .1,
                .97,
                0,
                .09,
                .98,
                0,
                .08,
                .99,
                0,
                .07,
                1,
                0,
                .06
            ],
            Annotations: [
                0,
                "Xx",
                1,
                "H",
                2,
                "He",
                3,
                "Li",
                4,
                "Be",
                5,
                "B",
                6,
                "C",
                7,
                "N",
                8,
                "O",
                9,
                "F",
                10,
                "Ne",
                11,
                "Na",
                12,
                "Mg",
                13,
                "Al",
                14,
                "Si",
                15,
                "P",
                16,
                "S",
                17,
                "Cl",
                18,
                "Ar",
                19,
                "K",
                20,
                "Ca",
                21,
                "Sc",
                22,
                "Ti",
                23,
                "V",
                24,
                "Cr",
                25,
                "Mn",
                26,
                "Fe",
                27,
                "Co",
                28,
                "Ni",
                29,
                "Cu",
                30,
                "Zn",
                31,
                "Ga",
                32,
                "Ge",
                33,
                "As",
                34,
                "Se",
                35,
                "Br",
                36,
                "Kr",
                37,
                "Rb",
                38,
                "Sr",
                39,
                "Y",
                40,
                "Zr",
                41,
                "Nb",
                42,
                "Mo",
                43,
                "Tc",
                44,
                "Ru",
                45,
                "Rh",
                46,
                "Pd",
                47,
                "Ag",
                48,
                "Cd",
                49,
                "In",
                50,
                "Sn",
                51,
                "Sb",
                52,
                "Te",
                53,
                "I",
                54,
                "Xe",
                55,
                "Cs",
                56,
                "Ba",
                57,
                "La",
                58,
                "Ce",
                59,
                "Pr",
                60,
                "Nd",
                61,
                "Pm",
                62,
                "Sm",
                63,
                "Eu",
                64,
                "Gd",
                65,
                "Tb",
                66,
                "Dy",
                67,
                "Ho",
                68,
                "Er",
                69,
                "Tm",
                70,
                "Yb",
                71,
                "Lu",
                72,
                "Hf",
                73,
                "Ta",
                74,
                "W",
                75,
                "Re",
                76,
                "Os",
                77,
                "Ir",
                78,
                "Pt",
                79,
                "Au",
                80,
                "Hg",
                81,
                "Tl",
                82,
                "Pb",
                83,
                "Bi",
                84,
                "Po",
                85,
                "At",
                86,
                "Rn",
                87,
                "Fr",
                88,
                "Ra",
                89,
                "Ac",
                90,
                "Th",
                91,
                "Pa",
                92,
                "U",
                93,
                "Np",
                94,
                "Pu",
                95,
                "Am",
                96,
                "Cm",
                97,
                "Bk",
                98,
                "Cf",
                99,
                "Es",
                100,
                "Fm",
                101,
                "Md",
                102,
                "No",
                103,
                "Lr",
                104,
                "Rf",
                105,
                "Db",
                106,
                "Sg",
                107,
                "Bh",
                108,
                "Hs",
                109,
                "Mt",
                110,
                "Ds",
                111,
                "Rg",
                112,
                "Cn",
                113,
                "Uut",
                114,
                "Uuq",
                115,
                "Uup",
                116,
                "Uuh",
                117,
                "Uus",
                118,
                "Uuo"
            ],
            Name: "BlueObeliskElements"
        }
    ];
    const Ku = Object.create(null);
    BP.filter((t)=>t.RGBPoints).filter((t)=>t.ColorSpace !== "CIELAB").forEach((t)=>{
        Ku[t.Name] = t;
    });
    const qu = Object.keys(Ku);
    qu.sort();
    function GP(t) {
        return Ku[t];
    }
    function WP(t) {
        !t.RGBPoints || t.ColorSpace === "CIELAB" || (Ku[t.Name] || (qu.push(t.Name), qu.sort()), Ku[t.Name] = t);
    }
    function $P(t) {
        const e = qu.indexOf(t);
        e > -1 && qu.splice(e, 1), delete Ku[t];
    }
    var Id = {
        addPreset: WP,
        removePresetByName: $P,
        getPresetByName: GP,
        rgbPresetNames: qu
    };
    const { vtkErrorMacro: m1 } = K;
    function zP(t, e) {
        e.classHierarchy.push("vtkPiecewiseFunction"), t.getSize = ()=>e.nodes.length, t.getType = ()=>{
            let n, r = 0, i = 0;
            e.nodes.length > 0 && (r = e.nodes[0].y);
            for(let a = 1; a < e.nodes.length; a++){
                if (n = e.nodes[a].y, n !== r) if (n > r) switch(i){
                    case 0:
                    case 1:
                        i = 1;
                        break;
                    case 2:
                    default:
                        i = 3;
                        break;
                }
                else switch(i){
                    case 0:
                    case 2:
                        i = 2;
                        break;
                    case 1:
                    default:
                        i = 3;
                        break;
                }
                if (r = n, i === 3) break;
            }
            switch(i){
                case 0:
                    return "Constant";
                case 1:
                    return "NonDecreasing";
                case 2:
                    return "NonIncreasing";
                case 3:
                default:
                    return "Varied";
            }
        }, t.getDataPointer = ()=>{
            const n = e.nodes.length;
            if (e.function = null, n > 0) {
                e.function = [];
                for(let r = 0; r < n; r++)e.function[2 * r] = e.nodes[r].x, e.function[2 * r + 1] = e.nodes[r].y;
            }
            return e.function;
        }, t.getFirstNonZeroValue = ()=>{
            if (e.nodes.length === 0) return 0;
            let n = 1, r = 0, i = 0;
            for(; i < e.nodes.length; i++)if (e.nodes[i].y !== 0) {
                n = 0;
                break;
            }
            return n ? r = Number.MAX_VALUE : i > 0 ? r = e.nodes[i - 1].x : e.clamping ? r = -Number.MAX_VALUE : r = e.nodes[0].x, r;
        }, t.getNodeValue = (n, r)=>{
            const i = e.nodes.length;
            return n < 0 || n >= i ? (m1("Index out of range!"), -1) : (r[0] = e.nodes[n].x, r[1] = e.nodes[n].y, r[2] = e.nodes[n].midpoint, r[3] = e.nodes[n].sharpness, 1);
        }, t.setNodeValue = (n, r)=>{
            const i = e.nodes.length;
            if (n < 0 || n >= i) return m1("Index out of range!"), -1;
            const a = e.nodes[n].x;
            return e.nodes[n].x = r[0], e.nodes[n].y = r[1], e.nodes[n].midpoint = r[2], e.nodes[n].sharpness = r[3], a !== r[0] ? t.sortAndUpdateRange() : t.modified(), 1;
        }, t.addPoint = (n, r)=>t.addPointLong(n, r, .5, 0), t.addPointLong = (n, r, i, a)=>{
            if (i < 0 || i > 1) return m1("Midpoint outside range [0.0, 1.0]"), -1;
            if (a < 0 || a > 1) return m1("Sharpness outside range [0.0, 1.0]"), -1;
            e.allowDuplicateScalars || t.removePoint(n);
            const o = {
                x: n,
                y: r,
                midpoint: i,
                sharpness: a
            };
            e.nodes.push(o), t.sortAndUpdateRange();
            let s;
            for(s = 0; s < e.nodes.length && e.nodes[s].x !== n; s++);
            return s < e.nodes.length ? s : -1;
        }, t.setNodes = (n)=>{
            e.nodes !== n && (e.nodes = n, t.sortAndUpdateRange());
        }, t.sortAndUpdateRange = ()=>{
            e.nodes.sort((r, i)=>r.x - i.x), t.updateRange() || t.modified();
        }, t.updateRange = ()=>{
            const n = e.range.slice(), r = e.nodes.length;
            return r ? (e.range[0] = e.nodes[0].x, e.range[1] = e.nodes[r - 1].x) : (e.range[0] = 0, e.range[1] = 0), n[0] === e.range[0] && n[1] === e.range[1] ? !1 : (t.modified(), !0);
        }, t.removePoint = (n)=>{
            let r;
            for(r = 0; r < e.nodes.length && e.nodes[r].x !== n; r++);
            if (r >= e.nodes.length) return -1;
            const i = r;
            let a = !1;
            return e.nodes.splice(r, 1), (r === 0 || r === e.nodes.length) && (a = t.updateRange()), a || t.modified(), i;
        }, t.removeAllPoints = ()=>{
            e.nodes = [], t.sortAndUpdateRange();
        }, t.addSegment = (n, r, i, a)=>{
            t.sortAndUpdateRange();
            for(let o = 0; o < e.nodes.length;)e.nodes[o].x >= n && e.nodes[o].x <= i ? e.nodes.splice(o, 1) : o++;
            t.addPoint(n, r, .5, 0), t.addPoint(i, a, .5, 0);
        }, t.getValue = (n)=>{
            const r = [];
            return t.getTable(n, n, 1, r), r[0];
        }, t.adjustRange = (n)=>{
            if (n.length < 2) return 0;
            const r = t.getRange();
            r[0] < n[0] ? t.addPoint(n[0], t.getValue(n[0])) : t.addPoint(n[0], t.getValue(r[0])), r[1] > n[1] ? t.addPoint(n[1], t.getValue(n[1])) : t.addPoint(n[1], t.getValue(r[1])), t.sortAndUpdateRange();
            for(let i = 0; i < e.nodes.length;)e.nodes[i].x >= n[0] && e.nodes[i].x <= n[1] ? e.nodes.splice(i, 1) : ++i;
            return t.sortAndUpdateRange(), 1;
        }, t.estimateMinNumberOfSamples = (n, r)=>{
            const i = t.findMinimumXDistance();
            return Math.ceil((r - n) / i);
        }, t.findMinimumXDistance = ()=>{
            const n = e.nodes.length;
            if (n < 2) return -1;
            let r = e.nodes[1].x - e.nodes[0].x;
            for(let i = 0; i < n - 1; i++){
                const a = e.nodes[i + 1].x - e.nodes[i].x;
                a < r && (r = a);
            }
            return r;
        }, t.getTable = function(n, r, i, a) {
            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, s, c = 0;
            const l = e.nodes.length;
            let f = 0;
            l !== 0 && (f = e.nodes[l - 1].y);
            let u = 0, g = 0, h = 0, v = 0, m = 0, y = 0, C = 0;
            for(s = 0; s < i; s++){
                const T = o * s;
                for(i > 1 ? u = n + s / (i - 1) * (r - n) : u = .5 * (n + r); c < l && u > e.nodes[c].x;)c++, c < l && (g = e.nodes[c - 1].x, h = e.nodes[c].x, v = e.nodes[c - 1].y, m = e.nodes[c].y, y = e.nodes[c - 1].midpoint, C = e.nodes[c - 1].sharpness, y < 1e-5 && (y = 1e-5), y > .99999 && (y = .99999));
                if (c >= l) a[T] = e.clamping ? f : 0;
                else if (c === 0) a[T] = e.clamping ? e.nodes[0].y : 0;
                else {
                    let x = (u - g) / (h - g);
                    if (x < y ? x = .5 * x / y : x = .5 + .5 * (x - y) / (1 - y), C > .99) if (x < .5) {
                        a[T] = v;
                        continue;
                    } else {
                        a[T] = m;
                        continue;
                    }
                    if (C < .01) {
                        a[T] = (1 - x) * v + x * m;
                        continue;
                    }
                    x < .5 ? x = .5 * (x * 2) ** (1 + 10 * C) : x > .5 && (x = 1 - .5 * ((1 - x) * 2) ** (1 + 10 * C));
                    const S = x * x, D = S * x, _ = 2 * D - 3 * S + 1, M = -2 * D + 3 * S, P = D - 2 * S + x, F = D - S, N = m - v, B = (1 - C) * N;
                    a[T] = _ * v + M * m + P * B + F * B;
                    const G = v < m ? v : m, Z = v > m ? v : m;
                    a[T] = a[T] < G ? G : a[T], a[T] = a[T] > Z ? Z : a[T];
                }
            }
        };
    }
    const jP = {
        range: [
            0,
            0
        ],
        clamping: !0,
        allowDuplicateScalars: !1
    };
    function ix(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, jP, n), K.obj(t, e), e.nodes = [], K.setGet(t, e, [
            "allowDuplicateScalars",
            "clamping"
        ]), K.setArray(t, e, [
            "range"
        ], 2), K.getArray(t, e, [
            "range"
        ]), zP(t, e);
    }
    const HP = K.newInstance(ix, "vtkPiecewiseFunction");
    var B0 = {
        newInstance: HP,
        extend: ix
    }, hn = 1e-6, Br = typeof Float32Array < "u" ? Float32Array : Array, KP = Math.PI / 180;
    function qP(t) {
        return t * KP;
    }
    function Gh(t, e) {
        return Math.abs(t - e) <= hn * Math.max(1, Math.abs(t), Math.abs(e));
    }
    Math.hypot || (Math.hypot = function() {
        for(var t = 0, e = arguments.length; e--;)t += arguments[e] * arguments[e];
        return Math.sqrt(t);
    });
    function P3() {
        var t = new Br(9);
        return Br != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
    }
    function Mp(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
    }
    function XP(t) {
        var e = new Br(9);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
    }
    function YP(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
    }
    function rd(t, e, n, r, i, a, o, s, c) {
        var l = new Br(9);
        return l[0] = t, l[1] = e, l[2] = n, l[3] = r, l[4] = i, l[5] = a, l[6] = o, l[7] = s, l[8] = c, l;
    }
    function ax(t, e, n, r, i, a, o, s, c, l) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = a, t[5] = o, t[6] = s, t[7] = c, t[8] = l, t;
    }
    Ts = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    };
    function V3(t, e) {
        if (t === e) {
            var n = e[1], r = e[2], i = e[5];
            t[1] = e[3], t[2] = e[6], t[3] = n, t[5] = e[7], t[6] = r, t[7] = i;
        } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];
        return t;
    }
    function Xd(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], c = e[6], l = e[7], f = e[8], u = f * o - s * l, g = -f * a + s * c, h = l * a - o * c, v = n * u + r * g + i * h;
        return v ? (v = 1 / v, t[0] = u * v, t[1] = (-f * r + i * l) * v, t[2] = (s * r - i * o) * v, t[3] = g * v, t[4] = (f * n - i * c) * v, t[5] = (-s * n + i * a) * v, t[6] = h * v, t[7] = (-l * n + r * c) * v, t[8] = (o * n - r * a) * v, t) : null;
    }
    function ZP(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], c = e[6], l = e[7], f = e[8];
        return t[0] = o * f - s * l, t[1] = i * l - r * f, t[2] = r * s - i * o, t[3] = s * c - a * f, t[4] = n * f - i * c, t[5] = i * a - n * s, t[6] = a * l - o * c, t[7] = r * c - n * l, t[8] = n * o - r * a, t;
    }
    function x0(t) {
        var e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], o = t[5], s = t[6], c = t[7], l = t[8];
        return e * (l * a - o * c) + n * (-l * i + o * s) + r * (c * i - a * s);
    }
    function Xu(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = e[4], c = e[5], l = e[6], f = e[7], u = e[8], g = n[0], h = n[1], v = n[2], m = n[3], y = n[4], C = n[5], T = n[6], x = n[7], S = n[8];
        return t[0] = g * r + h * o + v * l, t[1] = g * i + h * s + v * f, t[2] = g * a + h * c + v * u, t[3] = m * r + y * o + C * l, t[4] = m * i + y * s + C * f, t[5] = m * a + y * c + C * u, t[6] = T * r + x * o + S * l, t[7] = T * i + x * s + S * f, t[8] = T * a + x * c + S * u, t;
    }
    function JP(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = e[4], c = e[5], l = e[6], f = e[7], u = e[8], g = n[0], h = n[1];
        return t[0] = r, t[1] = i, t[2] = a, t[3] = o, t[4] = s, t[5] = c, t[6] = g * r + h * o + l, t[7] = g * i + h * s + f, t[8] = g * a + h * c + u, t;
    }
    function QP(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = e[4], c = e[5], l = e[6], f = e[7], u = e[8], g = Math.sin(n), h = Math.cos(n);
        return t[0] = h * r + g * o, t[1] = h * i + g * s, t[2] = h * a + g * c, t[3] = h * o - g * r, t[4] = h * s - g * i, t[5] = h * c - g * a, t[6] = l, t[7] = f, t[8] = u, t;
    }
    function eV(t, e, n) {
        var r = n[0], i = n[1];
        return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
    }
    function tV(t, e) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t;
    }
    function nV(t, e) {
        var n = Math.sin(e), r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = 0, t[3] = -n, t[4] = r, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }
    function rV(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;
    }
    function iV(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;
    }
    function aV(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = n + n, s = r + r, c = i + i, l = n * o, f = r * o, u = r * s, g = i * o, h = i * s, v = i * c, m = a * o, y = a * s, C = a * c;
        return t[0] = 1 - u - v, t[3] = f - C, t[6] = g + y, t[1] = f + C, t[4] = 1 - l - v, t[7] = h - m, t[2] = g - y, t[5] = h + m, t[8] = 1 - l - u, t;
    }
    function oV(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], c = e[6], l = e[7], f = e[8], u = e[9], g = e[10], h = e[11], v = e[12], m = e[13], y = e[14], C = e[15], T = n * s - r * o, x = n * c - i * o, S = n * l - a * o, D = r * c - i * s, _ = r * l - a * s, M = i * l - a * c, P = f * m - u * v, F = f * y - g * v, N = f * C - h * v, B = u * y - g * m, G = u * C - h * m, Z = g * C - h * y, H = T * Z - x * G + S * B + D * N - _ * F + M * P;
        return H ? (H = 1 / H, t[0] = (s * Z - c * G + l * B) * H, t[1] = (c * N - o * Z - l * F) * H, t[2] = (o * G - s * N + l * P) * H, t[3] = (i * G - r * Z - a * B) * H, t[4] = (n * Z - i * N + a * F) * H, t[5] = (r * N - n * G - a * P) * H, t[6] = (m * M - y * _ + C * D) * H, t[7] = (y * S - v * M - C * x) * H, t[8] = (v * _ - m * S + C * T) * H, t) : null;
    }
    function sV(t, e, n) {
        return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / n, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
    }
    function cV(t) {
        return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
    }
    function lV(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
    }
    function uV(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t;
    }
    function ox(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t;
    }
    function fV(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t;
    }
    function dV(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t;
    }
    function gV(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];
    }
    function hV(t, e) {
        var n = t[0], r = t[1], i = t[2], a = t[3], o = t[4], s = t[5], c = t[6], l = t[7], f = t[8], u = e[0], g = e[1], h = e[2], v = e[3], m = e[4], y = e[5], C = e[6], T = e[7], x = e[8];
        return Math.abs(n - u) <= hn * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(r - g) <= hn * Math.max(1, Math.abs(r), Math.abs(g)) && Math.abs(i - h) <= hn * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(a - v) <= hn * Math.max(1, Math.abs(a), Math.abs(v)) && Math.abs(o - m) <= hn * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(s - y) <= hn * Math.max(1, Math.abs(s), Math.abs(y)) && Math.abs(c - C) <= hn * Math.max(1, Math.abs(c), Math.abs(C)) && Math.abs(l - T) <= hn * Math.max(1, Math.abs(l), Math.abs(T)) && Math.abs(f - x) <= hn * Math.max(1, Math.abs(f), Math.abs(x));
    }
    var pV = Xu, mV = ox;
    const vV = Object.freeze(Object.defineProperty({
        __proto__: null,
        add: uV,
        adjoint: ZP,
        clone: XP,
        copy: YP,
        create: P3,
        determinant: x0,
        equals: hV,
        exactEquals: gV,
        frob: lV,
        fromMat2d: iV,
        fromMat4: Mp,
        fromQuat: aV,
        fromRotation: nV,
        fromScaling: rV,
        fromTranslation: tV,
        fromValues: rd,
        identity: Ts,
        invert: Xd,
        mul: pV,
        multiply: Xu,
        multiplyScalar: fV,
        multiplyScalarAndAdd: dV,
        normalFromMat4: oV,
        projection: sV,
        rotate: QP,
        scale: eV,
        set: ax,
        str: cV,
        sub: mV,
        subtract: ox,
        translate: JP,
        transpose: V3
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function xs() {
        var t = new Br(16);
        return Br != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;
    }
    function yV(t) {
        var e = new Br(16);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], e;
    }
    Ur = function(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    };
    function N3(t, e, n, r, i, a, o, s, c, l, f, u, g, h, v, m) {
        var y = new Br(16);
        return y[0] = t, y[1] = e, y[2] = n, y[3] = r, y[4] = i, y[5] = a, y[6] = o, y[7] = s, y[8] = c, y[9] = l, y[10] = f, y[11] = u, y[12] = g, y[13] = h, y[14] = v, y[15] = m, y;
    }
    function CV(t, e, n, r, i, a, o, s, c, l, f, u, g, h, v, m, y) {
        return t[0] = e, t[1] = n, t[2] = r, t[3] = i, t[4] = a, t[5] = o, t[6] = s, t[7] = c, t[8] = l, t[9] = f, t[10] = u, t[11] = g, t[12] = h, t[13] = v, t[14] = m, t[15] = y, t;
    }
    Ot = function(t) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    };
    cn = function(t, e) {
        if (t === e) {
            var n = e[1], r = e[2], i = e[3], a = e[6], o = e[7], s = e[11];
            t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = n, t[6] = e[9], t[7] = e[13], t[8] = r, t[9] = a, t[11] = e[14], t[12] = i, t[13] = o, t[14] = s;
        } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];
        return t;
    };
    Xr = function(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], c = e[6], l = e[7], f = e[8], u = e[9], g = e[10], h = e[11], v = e[12], m = e[13], y = e[14], C = e[15], T = n * s - r * o, x = n * c - i * o, S = n * l - a * o, D = r * c - i * s, _ = r * l - a * s, M = i * l - a * c, P = f * m - u * v, F = f * y - g * v, N = f * C - h * v, B = u * y - g * m, G = u * C - h * m, Z = g * C - h * y, H = T * Z - x * G + S * B + D * N - _ * F + M * P;
        return H ? (H = 1 / H, t[0] = (s * Z - c * G + l * B) * H, t[1] = (i * G - r * Z - a * B) * H, t[2] = (m * M - y * _ + C * D) * H, t[3] = (g * _ - u * M - h * D) * H, t[4] = (c * N - o * Z - l * F) * H, t[5] = (n * Z - i * N + a * F) * H, t[6] = (y * S - v * M - C * x) * H, t[7] = (f * M - g * S + h * x) * H, t[8] = (o * G - s * N + l * P) * H, t[9] = (r * N - n * G - a * P) * H, t[10] = (v * _ - m * S + C * T) * H, t[11] = (u * S - f * _ - h * T) * H, t[12] = (s * F - o * B - c * P) * H, t[13] = (n * B - r * F + i * P) * H, t[14] = (m * x - v * D - y * T) * H, t[15] = (f * D - u * x + g * T) * H, t) : null;
    };
    function wV(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = e[4], s = e[5], c = e[6], l = e[7], f = e[8], u = e[9], g = e[10], h = e[11], v = e[12], m = e[13], y = e[14], C = e[15];
        return t[0] = s * (g * C - h * y) - u * (c * C - l * y) + m * (c * h - l * g), t[1] = -(r * (g * C - h * y) - u * (i * C - a * y) + m * (i * h - a * g)), t[2] = r * (c * C - l * y) - s * (i * C - a * y) + m * (i * l - a * c), t[3] = -(r * (c * h - l * g) - s * (i * h - a * g) + u * (i * l - a * c)), t[4] = -(o * (g * C - h * y) - f * (c * C - l * y) + v * (c * h - l * g)), t[5] = n * (g * C - h * y) - f * (i * C - a * y) + v * (i * h - a * g), t[6] = -(n * (c * C - l * y) - o * (i * C - a * y) + v * (i * l - a * c)), t[7] = n * (c * h - l * g) - o * (i * h - a * g) + f * (i * l - a * c), t[8] = o * (u * C - h * m) - f * (s * C - l * m) + v * (s * h - l * u), t[9] = -(n * (u * C - h * m) - f * (r * C - a * m) + v * (r * h - a * u)), t[10] = n * (s * C - l * m) - o * (r * C - a * m) + v * (r * l - a * s), t[11] = -(n * (s * h - l * u) - o * (r * h - a * u) + f * (r * l - a * s)), t[12] = -(o * (u * y - g * m) - f * (s * y - c * m) + v * (s * g - c * u)), t[13] = n * (u * y - g * m) - f * (r * y - i * m) + v * (r * g - i * u), t[14] = -(n * (s * y - c * m) - o * (r * y - i * m) + v * (r * c - i * s)), t[15] = n * (s * g - c * u) - o * (r * g - i * u) + f * (r * c - i * s), t;
    }
    function TV(t) {
        var e = t[0], n = t[1], r = t[2], i = t[3], a = t[4], o = t[5], s = t[6], c = t[7], l = t[8], f = t[9], u = t[10], g = t[11], h = t[12], v = t[13], m = t[14], y = t[15], C = e * o - n * a, T = e * s - r * a, x = e * c - i * a, S = n * s - r * o, D = n * c - i * o, _ = r * c - i * s, M = l * v - f * h, P = l * m - u * h, F = l * y - g * h, N = f * m - u * v, B = f * y - g * v, G = u * y - g * m;
        return C * G - T * B + x * N + S * F - D * P + _ * M;
    }
    function Qt(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = e[4], c = e[5], l = e[6], f = e[7], u = e[8], g = e[9], h = e[10], v = e[11], m = e[12], y = e[13], C = e[14], T = e[15], x = n[0], S = n[1], D = n[2], _ = n[3];
        return t[0] = x * r + S * s + D * u + _ * m, t[1] = x * i + S * c + D * g + _ * y, t[2] = x * a + S * l + D * h + _ * C, t[3] = x * o + S * f + D * v + _ * T, x = n[4], S = n[5], D = n[6], _ = n[7], t[4] = x * r + S * s + D * u + _ * m, t[5] = x * i + S * c + D * g + _ * y, t[6] = x * a + S * l + D * h + _ * C, t[7] = x * o + S * f + D * v + _ * T, x = n[8], S = n[9], D = n[10], _ = n[11], t[8] = x * r + S * s + D * u + _ * m, t[9] = x * i + S * c + D * g + _ * y, t[10] = x * a + S * l + D * h + _ * C, t[11] = x * o + S * f + D * v + _ * T, x = n[12], S = n[13], D = n[14], _ = n[15], t[12] = x * r + S * s + D * u + _ * m, t[13] = x * i + S * c + D * g + _ * y, t[14] = x * a + S * l + D * h + _ * C, t[15] = x * o + S * f + D * v + _ * T, t;
    }
    qr = function(t, e, n) {
        var r = n[0], i = n[1], a = n[2], o, s, c, l, f, u, g, h, v, m, y, C;
        return e === t ? (t[12] = e[0] * r + e[4] * i + e[8] * a + e[12], t[13] = e[1] * r + e[5] * i + e[9] * a + e[13], t[14] = e[2] * r + e[6] * i + e[10] * a + e[14], t[15] = e[3] * r + e[7] * i + e[11] * a + e[15]) : (o = e[0], s = e[1], c = e[2], l = e[3], f = e[4], u = e[5], g = e[6], h = e[7], v = e[8], m = e[9], y = e[10], C = e[11], t[0] = o, t[1] = s, t[2] = c, t[3] = l, t[4] = f, t[5] = u, t[6] = g, t[7] = h, t[8] = v, t[9] = m, t[10] = y, t[11] = C, t[12] = o * r + f * i + v * a + e[12], t[13] = s * r + u * i + m * a + e[13], t[14] = c * r + g * i + y * a + e[14], t[15] = l * r + h * i + C * a + e[15]), t;
    };
    function nc(t, e, n) {
        var r = n[0], i = n[1], a = n[2];
        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * a, t[9] = e[9] * a, t[10] = e[10] * a, t[11] = e[11] * a, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
    }
    function fs(t, e, n, r) {
        var i = r[0], a = r[1], o = r[2], s = Math.hypot(i, a, o), c, l, f, u, g, h, v, m, y, C, T, x, S, D, _, M, P, F, N, B, G, Z, H, ne;
        return s < hn ? null : (s = 1 / s, i *= s, a *= s, o *= s, c = Math.sin(n), l = Math.cos(n), f = 1 - l, u = e[0], g = e[1], h = e[2], v = e[3], m = e[4], y = e[5], C = e[6], T = e[7], x = e[8], S = e[9], D = e[10], _ = e[11], M = i * i * f + l, P = a * i * f + o * c, F = o * i * f - a * c, N = i * a * f - o * c, B = a * a * f + l, G = o * a * f + i * c, Z = i * o * f + a * c, H = a * o * f - i * c, ne = o * o * f + l, t[0] = u * M + m * P + x * F, t[1] = g * M + y * P + S * F, t[2] = h * M + C * P + D * F, t[3] = v * M + T * P + _ * F, t[4] = u * N + m * B + x * G, t[5] = g * N + y * B + S * G, t[6] = h * N + C * B + D * G, t[7] = v * N + T * B + _ * G, t[8] = u * Z + m * H + x * ne, t[9] = g * Z + y * H + S * ne, t[10] = h * Z + C * H + D * ne, t[11] = v * Z + T * H + _ * ne, e !== t && (t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
    }
    function A3(t, e, n) {
        var r = Math.sin(n), i = Math.cos(n), a = e[4], o = e[5], s = e[6], c = e[7], l = e[8], f = e[9], u = e[10], g = e[11];
        return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = a * i + l * r, t[5] = o * i + f * r, t[6] = s * i + u * r, t[7] = c * i + g * r, t[8] = l * i - a * r, t[9] = f * i - o * r, t[10] = u * i - s * r, t[11] = g * i - c * r, t;
    }
    function k3(t, e, n) {
        var r = Math.sin(n), i = Math.cos(n), a = e[0], o = e[1], s = e[2], c = e[3], l = e[8], f = e[9], u = e[10], g = e[11];
        return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i - l * r, t[1] = o * i - f * r, t[2] = s * i - u * r, t[3] = c * i - g * r, t[8] = a * r + l * i, t[9] = o * r + f * i, t[10] = s * r + u * i, t[11] = c * r + g * i, t;
    }
    function U3(t, e, n) {
        var r = Math.sin(n), i = Math.cos(n), a = e[0], o = e[1], s = e[2], c = e[3], l = e[4], f = e[5], u = e[6], g = e[7];
        return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = a * i + l * r, t[1] = o * i + f * r, t[2] = s * i + u * r, t[3] = c * i + g * r, t[4] = l * i - a * r, t[5] = f * i - o * r, t[6] = u * i - s * r, t[7] = g * i - c * r, t;
    }
    function Yd(t, e) {
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t;
    }
    function F3(t, e) {
        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function B3(t, e, n) {
        var r = n[0], i = n[1], a = n[2], o = Math.hypot(r, i, a), s, c, l;
        return o < hn ? null : (o = 1 / o, r *= o, i *= o, a *= o, s = Math.sin(e), c = Math.cos(e), l = 1 - c, t[0] = r * r * l + c, t[1] = i * r * l + a * s, t[2] = a * r * l - i * s, t[3] = 0, t[4] = r * i * l - a * s, t[5] = i * i * l + c, t[6] = a * i * l + r * s, t[7] = 0, t[8] = r * a * l + i * s, t[9] = i * a * l - r * s, t[10] = a * a * l + c, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);
    }
    function xV(t, e) {
        var n = Math.sin(e), r = Math.cos(e);
        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = r, t[6] = n, t[7] = 0, t[8] = 0, t[9] = -n, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function SV(t, e) {
        var n = Math.sin(e), r = Math.cos(e);
        return t[0] = r, t[1] = 0, t[2] = -n, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = n, t[9] = 0, t[10] = r, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function EV(t, e) {
        var n = Math.sin(e), r = Math.cos(e);
        return t[0] = r, t[1] = n, t[2] = 0, t[3] = 0, t[4] = -n, t[5] = r, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function sx(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = r + r, c = i + i, l = a + a, f = r * s, u = r * c, g = r * l, h = i * c, v = i * l, m = a * l, y = o * s, C = o * c, T = o * l;
        return t[0] = 1 - (h + m), t[1] = u + T, t[2] = g - C, t[3] = 0, t[4] = u - T, t[5] = 1 - (f + m), t[6] = v + y, t[7] = 0, t[8] = g + C, t[9] = v - y, t[10] = 1 - (f + h), t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t;
    }
    function DV(t, e) {
        var n = new Br(3), r = -e[0], i = -e[1], a = -e[2], o = e[3], s = e[4], c = e[5], l = e[6], f = e[7], u = r * r + i * i + a * a + o * o;
        return u > 0 ? (n[0] = (s * o + f * r + c * a - l * i) * 2 / u, n[1] = (c * o + f * i + l * r - s * a) * 2 / u, n[2] = (l * o + f * a + s * i - c * r) * 2 / u) : (n[0] = (s * o + f * r + c * a - l * i) * 2, n[1] = (c * o + f * i + l * r - s * a) * 2, n[2] = (l * o + f * a + s * i - c * r) * 2), sx(t, e, n), t;
    }
    function _V(t, e) {
        return t[0] = e[12], t[1] = e[13], t[2] = e[14], t;
    }
    function cx(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[4], o = e[5], s = e[6], c = e[8], l = e[9], f = e[10];
        return t[0] = Math.hypot(n, r, i), t[1] = Math.hypot(a, o, s), t[2] = Math.hypot(c, l, f), t;
    }
    function _v(t, e) {
        var n = new Br(3);
        cx(n, e);
        var r = 1 / n[0], i = 1 / n[1], a = 1 / n[2], o = e[0] * r, s = e[1] * i, c = e[2] * a, l = e[4] * r, f = e[5] * i, u = e[6] * a, g = e[8] * r, h = e[9] * i, v = e[10] * a, m = o + f + v, y = 0;
        return m > 0 ? (y = Math.sqrt(m + 1) * 2, t[3] = .25 * y, t[0] = (u - h) / y, t[1] = (g - c) / y, t[2] = (s - l) / y) : o > f && o > v ? (y = Math.sqrt(1 + o - f - v) * 2, t[3] = (u - h) / y, t[0] = .25 * y, t[1] = (s + l) / y, t[2] = (g + c) / y) : f > v ? (y = Math.sqrt(1 + f - o - v) * 2, t[3] = (g - c) / y, t[0] = (s + l) / y, t[1] = .25 * y, t[2] = (u + h) / y) : (y = Math.sqrt(1 + v - o - f) * 2, t[3] = (s - l) / y, t[0] = (g + c) / y, t[1] = (u + h) / y, t[2] = .25 * y), t;
    }
    function lx(t, e, n, r) {
        var i = e[0], a = e[1], o = e[2], s = e[3], c = i + i, l = a + a, f = o + o, u = i * c, g = i * l, h = i * f, v = a * l, m = a * f, y = o * f, C = s * c, T = s * l, x = s * f, S = r[0], D = r[1], _ = r[2];
        return t[0] = (1 - (v + y)) * S, t[1] = (g + x) * S, t[2] = (h - T) * S, t[3] = 0, t[4] = (g - x) * D, t[5] = (1 - (u + y)) * D, t[6] = (m + C) * D, t[7] = 0, t[8] = (h + T) * _, t[9] = (m - C) * _, t[10] = (1 - (u + v)) * _, t[11] = 0, t[12] = n[0], t[13] = n[1], t[14] = n[2], t[15] = 1, t;
    }
    function RV(t, e, n, r, i) {
        var a = e[0], o = e[1], s = e[2], c = e[3], l = a + a, f = o + o, u = s + s, g = a * l, h = a * f, v = a * u, m = o * f, y = o * u, C = s * u, T = c * l, x = c * f, S = c * u, D = r[0], _ = r[1], M = r[2], P = i[0], F = i[1], N = i[2], B = (1 - (m + C)) * D, G = (h + S) * D, Z = (v - x) * D, H = (h - S) * _, ne = (1 - (g + C)) * _, ae = (y + T) * _, ue = (v + x) * M, le = (y - T) * M, oe = (1 - (g + m)) * M;
        return t[0] = B, t[1] = G, t[2] = Z, t[3] = 0, t[4] = H, t[5] = ne, t[6] = ae, t[7] = 0, t[8] = ue, t[9] = le, t[10] = oe, t[11] = 0, t[12] = n[0] + P - (B * P + H * F + ue * N), t[13] = n[1] + F - (G * P + ne * F + le * N), t[14] = n[2] + N - (Z * P + ae * F + oe * N), t[15] = 1, t;
    }
    function Wh(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = n + n, s = r + r, c = i + i, l = n * o, f = r * o, u = r * s, g = i * o, h = i * s, v = i * c, m = a * o, y = a * s, C = a * c;
        return t[0] = 1 - u - v, t[1] = f + C, t[2] = g - y, t[3] = 0, t[4] = f - C, t[5] = 1 - l - v, t[6] = h + m, t[7] = 0, t[8] = g + y, t[9] = h - m, t[10] = 1 - l - u, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
    }
    function OV(t, e, n, r, i, a, o) {
        var s = 1 / (n - e), c = 1 / (i - r), l = 1 / (a - o);
        return t[0] = a * 2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a * 2 * c, t[6] = 0, t[7] = 0, t[8] = (n + e) * s, t[9] = (i + r) * c, t[10] = (o + a) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = o * a * 2 * l, t[15] = 0, t;
    }
    function ux(t, e, n, r, i) {
        var a = 1 / Math.tan(e / 2), o;
        return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = (i + r) * o, t[14] = 2 * i * r * o) : (t[10] = -1, t[14] = -2 * r), t;
    }
    var IV = ux;
    function MV(t, e, n, r, i) {
        var a = 1 / Math.tan(e / 2), o;
        return t[0] = a / n, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, i != null && i !== 1 / 0 ? (o = 1 / (r - i), t[10] = i * o, t[14] = i * r * o) : (t[10] = -1, t[14] = -r), t;
    }
    function bV(t, e, n, r) {
        var i = Math.tan(e.upDegrees * Math.PI / 180), a = Math.tan(e.downDegrees * Math.PI / 180), o = Math.tan(e.leftDegrees * Math.PI / 180), s = Math.tan(e.rightDegrees * Math.PI / 180), c = 2 / (o + s), l = 2 / (i + a);
        return t[0] = c, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = l, t[6] = 0, t[7] = 0, t[8] = -((o - s) * c * .5), t[9] = (i - a) * l * .5, t[10] = r / (n - r), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = r * n / (n - r), t[15] = 0, t;
    }
    function fx(t, e, n, r, i, a, o) {
        var s = 1 / (e - n), c = 1 / (r - i), l = 1 / (a - o);
        return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * c, t[14] = (o + a) * l, t[15] = 1, t;
    }
    var G3 = fx;
    function LV(t, e, n, r, i, a, o) {
        var s = 1 / (e - n), c = 1 / (r - i), l = 1 / (a - o);
        return t[0] = -2 * s, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * c, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = l, t[11] = 0, t[12] = (e + n) * s, t[13] = (i + r) * c, t[14] = a * l, t[15] = 1, t;
    }
    function dx(t, e, n, r) {
        var i, a, o, s, c, l, f, u, g, h, v = e[0], m = e[1], y = e[2], C = r[0], T = r[1], x = r[2], S = n[0], D = n[1], _ = n[2];
        return Math.abs(v - S) < hn && Math.abs(m - D) < hn && Math.abs(y - _) < hn ? Ot(t) : (f = v - S, u = m - D, g = y - _, h = 1 / Math.hypot(f, u, g), f *= h, u *= h, g *= h, i = T * g - x * u, a = x * f - C * g, o = C * u - T * f, h = Math.hypot(i, a, o), h ? (h = 1 / h, i *= h, a *= h, o *= h) : (i = 0, a = 0, o = 0), s = u * o - g * a, c = g * i - f * o, l = f * a - u * i, h = Math.hypot(s, c, l), h ? (h = 1 / h, s *= h, c *= h, l *= h) : (s = 0, c = 0, l = 0), t[0] = i, t[1] = s, t[2] = f, t[3] = 0, t[4] = a, t[5] = c, t[6] = u, t[7] = 0, t[8] = o, t[9] = l, t[10] = g, t[11] = 0, t[12] = -(i * v + a * m + o * y), t[13] = -(s * v + c * m + l * y), t[14] = -(f * v + u * m + g * y), t[15] = 1, t);
    }
    function PV(t, e, n, r) {
        var i = e[0], a = e[1], o = e[2], s = r[0], c = r[1], l = r[2], f = i - n[0], u = a - n[1], g = o - n[2], h = f * f + u * u + g * g;
        h > 0 && (h = 1 / Math.sqrt(h), f *= h, u *= h, g *= h);
        var v = c * g - l * u, m = l * f - s * g, y = s * u - c * f;
        return h = v * v + m * m + y * y, h > 0 && (h = 1 / Math.sqrt(h), v *= h, m *= h, y *= h), t[0] = v, t[1] = m, t[2] = y, t[3] = 0, t[4] = u * y - g * m, t[5] = g * v - f * y, t[6] = f * m - u * v, t[7] = 0, t[8] = f, t[9] = u, t[10] = g, t[11] = 0, t[12] = i, t[13] = a, t[14] = o, t[15] = 1, t;
    }
    function VV(t) {
        return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
    }
    function NV(t) {
        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
    }
    function AV(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t[3] = e[3] + n[3], t[4] = e[4] + n[4], t[5] = e[5] + n[5], t[6] = e[6] + n[6], t[7] = e[7] + n[7], t[8] = e[8] + n[8], t[9] = e[9] + n[9], t[10] = e[10] + n[10], t[11] = e[11] + n[11], t[12] = e[12] + n[12], t[13] = e[13] + n[13], t[14] = e[14] + n[14], t[15] = e[15] + n[15], t;
    }
    function gx(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t[4] = e[4] - n[4], t[5] = e[5] - n[5], t[6] = e[6] - n[6], t[7] = e[7] - n[7], t[8] = e[8] - n[8], t[9] = e[9] - n[9], t[10] = e[10] - n[10], t[11] = e[11] - n[11], t[12] = e[12] - n[12], t[13] = e[13] - n[13], t[14] = e[14] - n[14], t[15] = e[15] - n[15], t;
    }
    function hx(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * n, t[5] = e[5] * n, t[6] = e[6] * n, t[7] = e[7] * n, t[8] = e[8] * n, t[9] = e[9] * n, t[10] = e[10] * n, t[11] = e[11] * n, t[12] = e[12] * n, t[13] = e[13] * n, t[14] = e[14] * n, t[15] = e[15] * n, t;
    }
    function kV(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t[3] = e[3] + n[3] * r, t[4] = e[4] + n[4] * r, t[5] = e[5] + n[5] * r, t[6] = e[6] + n[6] * r, t[7] = e[7] + n[7] * r, t[8] = e[8] + n[8] * r, t[9] = e[9] + n[9] * r, t[10] = e[10] + n[10] * r, t[11] = e[11] + n[11] * r, t[12] = e[12] + n[12] * r, t[13] = e[13] + n[13] * r, t[14] = e[14] + n[14] * r, t[15] = e[15] + n[15] * r, t;
    }
    function UV(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];
    }
    function FV(t, e) {
        var n = t[0], r = t[1], i = t[2], a = t[3], o = t[4], s = t[5], c = t[6], l = t[7], f = t[8], u = t[9], g = t[10], h = t[11], v = t[12], m = t[13], y = t[14], C = t[15], T = e[0], x = e[1], S = e[2], D = e[3], _ = e[4], M = e[5], P = e[6], F = e[7], N = e[8], B = e[9], G = e[10], Z = e[11], H = e[12], ne = e[13], ae = e[14], ue = e[15];
        return Math.abs(n - T) <= hn * Math.max(1, Math.abs(n), Math.abs(T)) && Math.abs(r - x) <= hn * Math.max(1, Math.abs(r), Math.abs(x)) && Math.abs(i - S) <= hn * Math.max(1, Math.abs(i), Math.abs(S)) && Math.abs(a - D) <= hn * Math.max(1, Math.abs(a), Math.abs(D)) && Math.abs(o - _) <= hn * Math.max(1, Math.abs(o), Math.abs(_)) && Math.abs(s - M) <= hn * Math.max(1, Math.abs(s), Math.abs(M)) && Math.abs(c - P) <= hn * Math.max(1, Math.abs(c), Math.abs(P)) && Math.abs(l - F) <= hn * Math.max(1, Math.abs(l), Math.abs(F)) && Math.abs(f - N) <= hn * Math.max(1, Math.abs(f), Math.abs(N)) && Math.abs(u - B) <= hn * Math.max(1, Math.abs(u), Math.abs(B)) && Math.abs(g - G) <= hn * Math.max(1, Math.abs(g), Math.abs(G)) && Math.abs(h - Z) <= hn * Math.max(1, Math.abs(h), Math.abs(Z)) && Math.abs(v - H) <= hn * Math.max(1, Math.abs(v), Math.abs(H)) && Math.abs(m - ne) <= hn * Math.max(1, Math.abs(m), Math.abs(ne)) && Math.abs(y - ae) <= hn * Math.max(1, Math.abs(y), Math.abs(ae)) && Math.abs(C - ue) <= hn * Math.max(1, Math.abs(C), Math.abs(ue));
    }
    var $h = Qt, BV = gx;
    zh = Object.freeze(Object.defineProperty({
        __proto__: null,
        add: AV,
        adjoint: wV,
        clone: yV,
        copy: Ur,
        create: xs,
        determinant: TV,
        equals: FV,
        exactEquals: UV,
        frob: NV,
        fromQuat: Wh,
        fromQuat2: DV,
        fromRotation: B3,
        fromRotationTranslation: sx,
        fromRotationTranslationScale: lx,
        fromRotationTranslationScaleOrigin: RV,
        fromScaling: F3,
        fromTranslation: Yd,
        fromValues: N3,
        fromXRotation: xV,
        fromYRotation: SV,
        fromZRotation: EV,
        frustum: OV,
        getRotation: _v,
        getScaling: cx,
        getTranslation: _V,
        identity: Ot,
        invert: Xr,
        lookAt: dx,
        mul: $h,
        multiply: Qt,
        multiplyScalar: hx,
        multiplyScalarAndAdd: kV,
        ortho: G3,
        orthoNO: fx,
        orthoZO: LV,
        perspective: IV,
        perspectiveFromFieldOfView: bV,
        perspectiveNO: ux,
        perspectiveZO: MV,
        rotate: fs,
        rotateX: A3,
        rotateY: k3,
        rotateZ: U3,
        scale: nc,
        set: CV,
        str: VV,
        sub: BV,
        subtract: gx,
        targetTo: PV,
        translate: qr,
        transpose: cn
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function Xe() {
        var t = new Br(3);
        return Br != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;
    }
    function px(t) {
        var e = new Br(3);
        return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
    }
    function Xa(t) {
        var e = t[0], n = t[1], r = t[2];
        return Math.hypot(e, n, r);
    }
    function en(t, e, n) {
        var r = new Br(3);
        return r[0] = t, r[1] = e, r[2] = n, r;
    }
    function GV(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
    }
    function Sn(t, e, n, r) {
        return t[0] = e, t[1] = n, t[2] = r, t;
    }
    Qc = function(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t[2] = e[2] + n[2], t;
    };
    kr = function(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t;
    };
    function WV(t, e, n) {
        return t[0] = e[0] * n[0], t[1] = e[1] * n[1], t[2] = e[2] * n[2], t;
    }
    function $V(t, e, n) {
        return t[0] = e[0] / n[0], t[1] = e[1] / n[1], t[2] = e[2] / n[2], t;
    }
    function zV(t, e) {
        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t;
    }
    Ys = function(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t;
    };
    function $i(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t[2] = e[2] + n[2] * r, t;
    }
    function rc(t, e) {
        var n = e[0] - t[0], r = e[1] - t[1], i = e[2] - t[2];
        return Math.hypot(n, r, i);
    }
    function jc(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
    }
    function mx(t, e) {
        return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;
    }
    jn = function(t, e) {
        var n = e[0], r = e[1], i = e[2], a = n * n + r * r + i * i;
        return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t;
    };
    xt = function(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
    };
    function bn(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = n[0], s = n[1], c = n[2];
        return t[0] = i * c - a * s, t[1] = a * o - r * c, t[2] = r * s - i * o, t;
    }
    pn = function(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = n[3] * r + n[7] * i + n[11] * a + n[15];
        return o = o || 1, t[0] = (n[0] * r + n[4] * i + n[8] * a + n[12]) / o, t[1] = (n[1] * r + n[5] * i + n[9] * a + n[13]) / o, t[2] = (n[2] * r + n[6] * i + n[10] * a + n[14]) / o, t;
    };
    function ih(t, e, n) {
        var r = e[0], i = e[1], a = e[2];
        return t[0] = r * n[0] + i * n[3] + a * n[6], t[1] = r * n[1] + i * n[4] + a * n[7], t[2] = r * n[2] + i * n[5] + a * n[8], t;
    }
    function vx(t, e) {
        var n = t[0], r = t[1], i = t[2], a = e[0], o = e[1], s = e[2], c = Math.sqrt(n * n + r * r + i * i), l = Math.sqrt(a * a + o * o + s * s), f = c * l, u = f && xt(t, e) / f;
        return Math.acos(Math.min(Math.max(u, -1), 1));
    }
    function jV(t) {
        return t[0] = 0, t[1] = 0, t[2] = 0, t;
    }
    function D9(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
    }
    function _9(t, e) {
        var n = t[0], r = t[1], i = t[2], a = e[0], o = e[1], s = e[2];
        return Math.abs(n - a) <= hn * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(r - o) <= hn * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(i - s) <= hn * Math.max(1, Math.abs(i), Math.abs(s));
    }
    var In = kr, HV = WV, jh = Xa;
    (function() {
        var t = Xe();
        return function(e, n, r, i, a, o) {
            var s, c;
            for(n || (n = 3), r || (r = 0), i ? c = Math.min(i * n + r, e.length) : c = e.length, s = r; s < c; s += n)t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], a(t, t, o), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2];
            return e;
        };
    })();
    function yx() {
        var t = new Br(4);
        return Br != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;
    }
    function ah(t, e, n, r) {
        var i = new Br(4);
        return i[0] = t, i[1] = e, i[2] = n, i[3] = r, i;
    }
    function R9(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t[2] = e[2] - n[2], t[3] = e[3] - n[3], t;
    }
    function KV(t, e) {
        var n = e[0], r = e[1], i = e[2], a = e[3], o = n * n + r * r + i * i + a * a;
        return o > 0 && (o = 1 / Math.sqrt(o)), t[0] = n * o, t[1] = r * o, t[2] = i * o, t[3] = a * o, t;
    }
    function O9(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
    }
    function Ll(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3];
        return t[0] = n[0] * r + n[4] * i + n[8] * a + n[12] * o, t[1] = n[1] * r + n[5] * i + n[9] * a + n[13] * o, t[2] = n[2] * r + n[6] * i + n[10] * a + n[14] * o, t[3] = n[3] * r + n[7] * i + n[11] * a + n[15] * o, t;
    }
    (function() {
        var t = yx();
        return function(e, n, r, i, a, o) {
            var s, c;
            for(n || (n = 4), r || (r = 0), i ? c = Math.min(i * n + r, e.length) : c = e.length, s = r; s < c; s += n)t[0] = e[s], t[1] = e[s + 1], t[2] = e[s + 2], t[3] = e[s + 3], a(t, t, o), e[s] = t[0], e[s + 1] = t[1], e[s + 2] = t[2], e[s + 3] = t[3];
            return e;
        };
    })();
    function G0() {
        var t = new Br(4);
        return Br != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;
    }
    function W3(t, e, n) {
        n = n * .5;
        var r = Math.sin(n);
        return t[0] = r * e[0], t[1] = r * e[1], t[2] = r * e[2], t[3] = Math.cos(n), t;
    }
    function qV(t, e) {
        var n = Math.acos(e[3]) * 2, r = Math.sin(n / 2);
        return r > hn ? (t[0] = e[0] / r, t[1] = e[1] / r, t[2] = e[2] / r) : (t[0] = 1, t[1] = 0, t[2] = 0), n;
    }
    function I9(t, e, n) {
        var r = e[0], i = e[1], a = e[2], o = e[3], s = n[0], c = n[1], l = n[2], f = n[3];
        return t[0] = r * f + o * s + i * l - a * c, t[1] = i * f + o * c + a * s - r * l, t[2] = a * f + o * l + r * c - i * s, t[3] = o * f - r * s - i * c - a * l, t;
    }
    function oh(t, e, n, r) {
        var i = e[0], a = e[1], o = e[2], s = e[3], c = n[0], l = n[1], f = n[2], u = n[3], g, h, v, m, y;
        return h = i * c + a * l + o * f + s * u, h < 0 && (h = -h, c = -c, l = -l, f = -f, u = -u), 1 - h > hn ? (g = Math.acos(h), v = Math.sin(g), m = Math.sin((1 - r) * g) / v, y = Math.sin(r * g) / v) : (m = 1 - r, y = r), t[0] = m * i + y * c, t[1] = m * a + y * l, t[2] = m * o + y * f, t[3] = m * s + y * u, t;
    }
    function XV(t, e) {
        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
    }
    function YV(t, e) {
        var n = e[0] + e[4] + e[8], r;
        if (n > 0) r = Math.sqrt(n + 1), t[3] = .5 * r, r = .5 / r, t[0] = (e[5] - e[7]) * r, t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r;
        else {
            var i = 0;
            e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
            var a = (i + 1) % 3, o = (i + 2) % 3;
            r = Math.sqrt(e[i * 3 + i] - e[a * 3 + a] - e[o * 3 + o] + 1), t[i] = .5 * r, r = .5 / r, t[3] = (e[a * 3 + o] - e[o * 3 + a]) * r, t[a] = (e[a * 3 + i] + e[i * 3 + a]) * r, t[o] = (e[o * 3 + i] + e[i * 3 + o]) * r;
        }
        return t;
    }
    var M9 = ah, Cx = KV;
    (function() {
        var t = Xe(), e = en(1, 0, 0), n = en(0, 1, 0);
        return function(r, i, a) {
            var o = xt(i, a);
            return o < -.999999 ? (bn(t, e, i), jh(t) < 1e-6 && bn(t, n, i), jn(t, t), W3(r, t, Math.PI), r) : o > .999999 ? (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r) : (bn(t, i, a), r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = 1 + o, Cx(r, r));
        };
    })();
    (function() {
        var t = G0(), e = G0();
        return function(n, r, i, a, o, s) {
            return oh(t, r, o, s), oh(e, i, a, s), oh(n, t, e, 2 * s * (1 - s)), n;
        };
    })();
    (function() {
        var t = P3();
        return function(e, n, r, i) {
            return t[0] = r[0], t[3] = r[1], t[6] = r[2], t[1] = i[0], t[4] = i[1], t[7] = i[2], t[2] = -n[0], t[5] = -n[1], t[8] = -n[2], Cx(e, YV(e, t));
        };
    })();
    function sn() {
        var t = new Br(2);
        return Br != Float32Array && (t[0] = 0, t[1] = 0), t;
    }
    function b9(t, e) {
        var n = new Br(2);
        return n[0] = t, n[1] = e, n;
    }
    function qo(t, e, n) {
        return t[0] = e, t[1] = n, t;
    }
    function $3(t, e, n) {
        return t[0] = e[0] + n[0], t[1] = e[1] + n[1], t;
    }
    function yi(t, e, n) {
        return t[0] = e[0] - n[0], t[1] = e[1] - n[1], t;
    }
    function L9(t, e, n) {
        return t[0] = e[0] * n, t[1] = e[1] * n, t;
    }
    function id(t, e, n, r) {
        return t[0] = e[0] + n[0] * r, t[1] = e[1] + n[1] * r, t;
    }
    function Or(t, e) {
        var n = e[0] - t[0], r = e[1] - t[1];
        return Math.hypot(n, r);
    }
    function Pl(t, e) {
        var n = e[0] - t[0], r = e[1] - t[1];
        return n * n + r * r;
    }
    function Rv(t) {
        var e = t[0], n = t[1];
        return Math.hypot(e, n);
    }
    function Ou(t, e) {
        var n = e[0], r = e[1], i = n * n + r * r;
        return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t;
    }
    function kc(t, e) {
        return t[0] * e[0] + t[1] * e[1];
    }
    function ZV(t, e, n, r) {
        var i = e[0] - n[0], a = e[1] - n[1], o = Math.sin(r), s = Math.cos(r);
        return t[0] = i * s - a * o + n[0], t[1] = i * o + a * s + n[1], t;
    }
    var Yu = yi, z3 = Or;
    (function() {
        var t = sn();
        return function(e, n, r, i, a, o) {
            var s, c;
            for(n || (n = 2), r || (r = 0), i ? c = Math.min(i * n + r, e.length) : c = e.length, s = r; s < c; s += n)t[0] = e[s], t[1] = e[s + 1], a(t, t, o), e[s] = t[0], e[s + 1] = t[1];
            return e;
        };
    })();
    function ur(t) {
        const e = t.indexOf(":");
        return t.substring(e + 1);
    }
    function wx(t) {
        let e = 2166136261;
        for(let n = 0; n < t.length; n++)e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
        return (e >>> 0).toString(36);
    }
    const JV = 1073741824;
    class QV {
        constructor(){
            this._imageCache = new Map, this._volumeCache = new Map, this._imageIdsToVolumeIdCache = new Map, this._referencedImageIdToImageIdCache = new Map, this._geometryCache = new Map, this._imageCacheSize = 0, this._maxCacheSize = 3 * JV, this._geometryCacheSize = 0, this.setMaxCacheSize = (e)=>{
                if (!e || typeof e != "number") {
                    const n = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
                    throw new Error(n);
                }
                this._maxCacheSize = e;
            }, this.isCacheable = (e)=>{
                const n = this.getBytesAvailable(), r = Array.from(this._imageCache.values()).reduce((a, o)=>o.sharedCacheKey ? a : a + o.sizeInBytes, 0);
                return n + r >= e;
            }, this.getMaxCacheSize = ()=>this._maxCacheSize, this.getCacheSize = ()=>this._imageCacheSize, this._decacheImage = (e, n = !1)=>{
                const r = this._imageCache.get(e);
                if (!r) return;
                if (r.sharedCacheKey && !n) throw new Error("Cannot decache an image with a shared cache key. You need to manually decache the volume first.");
                const { imageLoadObject: i } = r;
                r.image?.referencedImageId && this._referencedImageIdToImageIdCache.delete(r.image.referencedImageId), i?.cancelFn && i.cancelFn(), i?.decache && i.decache(), this._imageCache.delete(e);
            }, this._decacheVolume = (e)=>{
                const n = this._volumeCache.get(e);
                if (!n) return;
                const { volumeLoadObject: r, volume: i } = n;
                i && (i.cancelLoading && i.cancelLoading(), i.imageData && i.imageData.delete(), r.cancelFn && r.cancelFn(), i.imageIds && i.imageIds.forEach((a)=>{
                    const o = this._imageCache.get(a);
                    o && o.sharedCacheKey === e && (o.sharedCacheKey = void 0);
                }), this._volumeCache.delete(e));
            }, this.purgeCache = ()=>{
                const e = this._imageCache.keys();
                for(this.purgeVolumeCache();;){
                    const { value: n, done: r } = e.next();
                    if (r) break;
                    this.removeImageLoadObject(n, {
                        force: !0
                    }), We(Ke, Ge.IMAGE_CACHE_IMAGE_REMOVED, {
                        imageId: n
                    });
                }
            }, this.purgeVolumeCache = ()=>{
                const e = this._volumeCache.keys();
                for(;;){
                    const { value: n, done: r } = e.next();
                    if (r) break;
                    this.removeVolumeLoadObject(n), We(Ke, Ge.VOLUME_CACHE_VOLUME_REMOVED, {
                        volumeId: n
                    });
                }
            }, this.getVolumeLoadObject = (e)=>{
                if (e === void 0) throw new Error("getVolumeLoadObject: volumeId must not be undefined");
                const n = this._volumeCache.get(e);
                if (n) return n.timeStamp = Date.now(), n.volumeLoadObject;
            }, this.putGeometryLoadObject = (e, n)=>{
                if (e === void 0) throw new Error("putGeometryLoadObject: geometryId must not be undefined");
                if (n.promise === void 0) throw new Error("putGeometryLoadObject: geometryLoadObject.promise must not be undefined");
                if (this._geometryCache.has(e)) throw new Error("putGeometryLoadObject: geometryId already present in geometryCache");
                if (n.cancelFn && typeof n.cancelFn != "function") throw new Error("putGeometryLoadObject: geometryLoadObject.cancel must be a function");
                const r = {
                    loaded: !1,
                    geometryId: e,
                    geometryLoadObject: n,
                    timeStamp: Date.now(),
                    sizeInBytes: 0
                };
                return this._geometryCache.set(e, r), n.promise.then((i)=>{
                    try {
                        this._putGeometryCommon(e, i, r);
                    } catch (a) {
                        throw console.debug(`Error in _putGeometryCommon for geometry ${e}:`, a), a;
                    }
                }).catch((i)=>{
                    throw console.debug(`Error caching geometry ${e}:`, i), this._geometryCache.delete(e), i;
                });
            }, this.getGeometry = (e)=>{
                if (e === void 0) throw new Error("getGeometry: geometryId must not be undefined");
                const n = this._geometryCache.get(e);
                if (n) return n.timeStamp = Date.now(), n.geometry;
            }, this.removeGeometryLoadObject = (e)=>{
                if (e === void 0) throw new Error("removeGeometryLoadObject: geometryId must not be undefined");
                const n = this._geometryCache.get(e);
                if (!n) throw new Error("removeGeometryLoadObject: geometryId was not present in geometryCache");
                this.decrementGeometryCacheSize(n.sizeInBytes);
                const r = {
                    geometry: n,
                    geometryId: e
                };
                We(Ke, Ge.GEOMETRY_CACHE_GEOMETRY_REMOVED, r), this._decacheGeometry(e);
            }, this._decacheGeometry = (e)=>{
                const n = this._geometryCache.get(e);
                if (!n) return;
                const { geometryLoadObject: r } = n;
                r.cancelFn && r.cancelFn(), r.decache && r.decache(), this._geometryCache.delete(e);
            }, this.incrementGeometryCacheSize = (e)=>{
                this._geometryCacheSize += e;
            }, this.decrementGeometryCacheSize = (e)=>{
                this._geometryCacheSize -= e;
            }, this.getImageByReferencedImageId = (e)=>{
                const n = this._referencedImageIdToImageIdCache.get(e);
                if (n) return this._imageCache.get(n)?.image;
            }, this.getImage = (e, n = To.FAR_REPLICATE)=>{
                if (e === void 0) throw new Error("getImage: imageId must not be undefined");
                const r = this._imageCache.get(e);
                if (r && (r.timeStamp = Date.now(), !(r.image?.imageQualityStatus < n))) return r.image;
            }, this.getVolume = (e, n = !1)=>{
                if (e === void 0) throw new Error("getVolume: volumeId must not be undefined");
                const r = this._volumeCache.get(e);
                return r ? (r.timeStamp = Date.now(), r.volume) : n ? [
                    ...this._volumeCache.values()
                ].find((i)=>i.volumeId.includes(e))?.volume : void 0;
            }, this.getVolumes = ()=>Array.from(this._volumeCache.values()).map((n)=>n.volume), this.filterVolumesByReferenceId = (e)=>this.getVolumes().filter((r)=>r.referencedVolumeId === e), this.removeImageLoadObject = (e, { force: n = !1 } = {})=>{
                if (e === void 0) throw new Error("removeImageLoadObject: imageId must not be undefined");
                const r = this._imageCache.get(e);
                if (!r) throw new Error("removeImageLoadObject: imageId was not present in imageCache");
                this._decacheImage(e, n), this.incrementImageCacheSize(-r.sizeInBytes);
                const i = {
                    image: r,
                    imageId: e
                };
                We(Ke, Ge.IMAGE_CACHE_IMAGE_REMOVED, i);
            }, this.removeVolumeLoadObject = (e)=>{
                if (e === void 0) throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
                const n = this._volumeCache.get(e);
                if (!n) throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
                const r = {
                    volume: n,
                    volumeId: e
                };
                We(Ke, Ge.VOLUME_CACHE_VOLUME_REMOVED, r), this._decacheVolume(e);
            }, this.incrementImageCacheSize = (e)=>{
                this._imageCacheSize += e;
            }, this.decrementImageCacheSize = (e)=>{
                this._imageCacheSize -= e;
            }, this.getGeometryLoadObject = (e)=>{
                if (e === void 0) throw new Error("getGeometryLoadObject: geometryId must not be undefined");
                const n = this._geometryCache.get(e);
                if (n) return n.timeStamp = Date.now(), n.geometryLoadObject;
            };
        }
        generateVolumeId(e) {
            const n = e.map(ur).sort();
            let r = 2166136261;
            for (const i of n){
                const a = wx(i);
                for(let o = 0; o < a.length; o++)r ^= a.charCodeAt(o), r += (r << 1) + (r << 4) + (r << 7) + (r << 8) + (r << 24);
            }
            return `volume-${(r >>> 0).toString(36)}`;
        }
        getImageIdsForVolumeId(e) {
            return Array.from(this._imageIdsToVolumeIdCache.entries()).filter(([n, r])=>r === e).map(([n])=>n);
        }
        getBytesAvailable() {
            return this.getMaxCacheSize() - this.getCacheSize();
        }
        decacheIfNecessaryUntilBytesAvailable(e, n) {
            let r = this.getBytesAvailable();
            if (r >= e) return r;
            const i = Array.from(this._imageCache.values()).filter((c)=>!c.sharedCacheKey);
            function a(c, l) {
                return c.timeStamp > l.timeStamp ? 1 : c.timeStamp < l.timeStamp ? -1 : 0;
            }
            i.sort(a);
            const o = i.map((c)=>c.imageId);
            let s = o;
            n && (s = o.filter((c)=>!n.includes(c)));
            for (const c of s)if (this.removeImageLoadObject(c), We(Ke, Ge.IMAGE_CACHE_IMAGE_REMOVED, {
                imageId: c
            }), r = this.getBytesAvailable(), r >= e) return r;
            for (const c of o)if (this.removeImageLoadObject(c), We(Ke, Ge.IMAGE_CACHE_IMAGE_REMOVED, {
                imageId: c
            }), r = this.getBytesAvailable(), r >= e) return r;
        }
        _putImageCommon(e, n, r) {
            if (!this._imageCache.has(e)) {
                console.warn("The image was purged from the cache before it completed loading.");
                return;
            }
            if (!n) {
                console.warn("Image is undefined");
                return;
            }
            if (n.sizeInBytes === void 0 || Number.isNaN(n.sizeInBytes)) throw new Error("_putImageCommon: image.sizeInBytes must not be undefined");
            if (n.sizeInBytes.toFixed === void 0) throw new Error("_putImageCommon: image.sizeInBytes is not a number");
            if (!this.isCacheable(n.sizeInBytes)) throw new Error(Ge.CACHE_SIZE_EXCEEDED);
            this.decacheIfNecessaryUntilBytesAvailable(n.sizeInBytes), r.loaded = !0, r.image = n, r.sizeInBytes = n.sizeInBytes, this.incrementImageCacheSize(r.sizeInBytes);
            const i = {
                image: r
            };
            n.referencedImageId && this._referencedImageIdToImageIdCache.set(n.referencedImageId, e), We(Ke, Ge.IMAGE_CACHE_IMAGE_ADDED, i), r.sharedCacheKey = n.sharedCacheKey;
        }
        async putImageLoadObject(e, n) {
            if (e === void 0) throw console.error("putImageLoadObject: imageId must not be undefined"), new Error("putImageLoadObject: imageId must not be undefined");
            if (n.promise === void 0) throw console.error("putImageLoadObject: imageLoadObject.promise must not be undefined"), new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
            const r = this._imageCache.get(e);
            if (r?.imageLoadObject) throw console.warn(`putImageLoadObject: imageId ${e} already in cache`), new Error("putImageLoadObject: imageId already in cache");
            if (n.cancelFn && typeof n.cancelFn != "function") throw console.error("putImageLoadObject: imageLoadObject.cancel must be a function"), new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
            const i = {
                ...r,
                loaded: !1,
                imageId: e,
                sharedCacheKey: void 0,
                imageLoadObject: n,
                timeStamp: Date.now(),
                sizeInBytes: 0
            };
            return this._imageCache.set(e, i), this._imageCache.set(e, i), n.promise.then((a)=>{
                try {
                    this._putImageCommon(e, a, i);
                } catch (o) {
                    throw console.debug(`Error in _putImageCommon for image ${e}:`, o), o;
                }
            }).catch((a)=>{
                throw console.debug(`Error caching image ${e}:`, a), this._imageCache.delete(e), a;
            });
        }
        putImageSync(e, n) {
            if (e === void 0) throw new Error("putImageSync: imageId must not be undefined");
            if (this._imageCache.has(e)) throw new Error("putImageSync: imageId already in cache");
            const r = {
                loaded: !1,
                imageId: e,
                sharedCacheKey: void 0,
                imageLoadObject: {
                    promise: Promise.resolve(n)
                },
                timeStamp: Date.now(),
                sizeInBytes: 0
            };
            this._imageCache.set(e, r);
            try {
                this._putImageCommon(e, n, r);
            } catch (i) {
                throw this._imageCache.delete(e), i;
            }
        }
        getImageLoadObject(e) {
            if (e === void 0) throw new Error("getImageLoadObject: imageId must not be undefined");
            const n = this._imageCache.get(e);
            if (n) return n.timeStamp = Date.now(), n.imageLoadObject;
        }
        isLoaded(e) {
            const n = this._imageCache.get(e);
            return n ? n.loaded : !1;
        }
        getVolumeContainingImageId(e) {
            const n = Array.from(this._volumeCache.keys()), r = ur(e);
            for (const i of n){
                const a = this._volumeCache.get(i);
                if (!a) return;
                const { volume: o } = a;
                if (!o.imageIds.length) return;
                const s = o.getImageURIIndex(r);
                if (s > -1) return {
                    volume: o,
                    imageIdIndex: s
                };
            }
        }
        getCachedImageBasedOnImageURI(e) {
            const n = ur(e), i = Array.from(this._imageCache.keys()).find((a)=>ur(a) === n);
            if (i) return this._imageCache.get(i);
        }
        _putVolumeCommon(e, n, r) {
            if (!this._volumeCache.get(e)) {
                console.warn("The volume was purged from the cache before it completed loading.");
                return;
            }
            r.loaded = !0, r.volume = n, n.imageIds?.forEach((a)=>{
                const o = this._imageCache.get(a);
                o && (o.sharedCacheKey = e);
            });
            const i = {
                volume: r
            };
            We(Ke, Ge.VOLUME_CACHE_VOLUME_ADDED, i);
        }
        putVolumeSync(e, n) {
            if (e === void 0) throw new Error("putVolumeSync: volumeId must not be undefined");
            if (this._volumeCache.has(e)) throw new Error("putVolumeSync: volumeId already in cache");
            const r = {
                loaded: !1,
                volumeId: e,
                volumeLoadObject: {
                    promise: Promise.resolve(n)
                },
                timeStamp: Date.now(),
                sizeInBytes: 0
            };
            this._volumeCache.set(e, r);
            try {
                this._putVolumeCommon(e, n, r);
            } catch (i) {
                throw this._volumeCache.delete(e), i;
            }
        }
        async putVolumeLoadObject(e, n) {
            if (e === void 0) throw new Error("putVolumeLoadObject: volumeId must not be undefined");
            if (n.promise === void 0) throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
            if (this._volumeCache.has(e)) throw new Error(`putVolumeLoadObject: volumeId:${e} already in cache`);
            if (n.cancelFn && typeof n.cancelFn != "function") throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
            const r = {
                loaded: !1,
                volumeId: e,
                volumeLoadObject: n,
                timeStamp: Date.now(),
                sizeInBytes: 0
            };
            return this._volumeCache.set(e, r), n.promise.then((i)=>{
                try {
                    this._putVolumeCommon(e, i, r);
                } catch (a) {
                    throw console.error(`Error in _putVolumeCommon for volume ${e}:`, a), this._volumeCache.delete(e), a;
                }
            }).catch((i)=>{
                throw this._volumeCache.delete(e), i;
            });
        }
        _putGeometryCommon(e, n, r) {
            if (!this._geometryCache.get(e)) {
                console.warn("The geometry was purged from the cache before it completed loading.");
                return;
            }
            if (!n) {
                console.warn("Geometry is undefined");
                return;
            }
            if (n.sizeInBytes === void 0 || Number.isNaN(n.sizeInBytes)) throw new Error("_putGeometryCommon: geometry.sizeInBytes must not be undefined");
            if (n.sizeInBytes.toFixed === void 0) throw new Error("_putGeometryCommon: geometry.sizeInBytes is not a number");
            if (!this.isCacheable(n.sizeInBytes)) throw new Error(Ge.CACHE_SIZE_EXCEEDED);
            this.decacheIfNecessaryUntilBytesAvailable(n.sizeInBytes), r.loaded = !0, r.geometry = n, r.sizeInBytes = n.sizeInBytes, this.incrementGeometryCacheSize(r.sizeInBytes);
            const i = {
                geometry: r
            };
            We(Ke, Ge.GEOMETRY_CACHE_GEOMETRY_ADDED, i);
        }
        putGeometrySync(e, n) {
            if (e === void 0) throw new Error("putGeometrySync: geometryId must not be undefined");
            if (this._geometryCache.has(e)) throw new Error("putGeometrySync: geometryId already in cache");
            const r = {
                loaded: !1,
                geometryId: e,
                geometryLoadObject: {
                    promise: Promise.resolve(n)
                },
                timeStamp: Date.now(),
                sizeInBytes: 0
            };
            this._geometryCache.set(e, r);
            try {
                this._putGeometryCommon(e, n, r);
            } catch (i) {
                throw this._geometryCache.delete(e), i;
            }
        }
        setPartialImage(e, n) {
            const r = this._imageCache.get(e);
            if (!r) {
                n && this._imageCache.set(e, {
                    image: n,
                    imageId: e,
                    loaded: !1,
                    timeStamp: Date.now(),
                    sizeInBytes: 0
                });
                return;
            }
            r.loaded && (r.loaded = !1, r.imageLoadObject = null, this.incrementImageCacheSize(-r.sizeInBytes), r.sizeInBytes = 0), r.image = n || r.image;
        }
        getImageQuality(e) {
            const n = this._imageCache.get(e)?.image;
            return n ? n.imageQualityStatus || To.FULL_RESOLUTION : void 0;
        }
    }
    ot = new QV;
    function Tx(t, e, n) {
        return Math.abs(t - e) <= n;
    }
    function eN(t, e, n = 1e-5) {
        if (t.length !== e.length) return !1;
        for(let r = 0; r < t.length; r++)if (!Tx(t[r], e[r], n)) return !1;
        return !0;
    }
    function P9(t) {
        return typeof t == "number";
    }
    function V9(t) {
        return t && typeof t == "object" && "length" in t && typeof t.length == "number" && t.length > 0 && typeof t[0] == "number";
    }
    function lr(t, e, n = 1e-5) {
        return typeof t != typeof e || t === null || e === null ? !1 : P9(t) && P9(e) ? Tx(t, e, n) : V9(t) && V9(e) ? eN(t, e, n) : !1;
    }
    const xx = (t)=>typeof t == "number" ? -t : t?.map ? t.map(xx) : !t, Ov = (t)=>typeof t == "number" ? Math.abs(t) : t?.map ? t.map(Ov) : t, Sx = (t, e, n = void 0)=>lr(t, xx(e), n), tN = (t, e, n = void 0)=>lr(Ov(t), Ov(e), n);
    function cr(t) {
        return Array.isArray(t) ? cr(t[0]) : isFinite(t) && !isNaN(t);
    }
    function ps(t) {
        return Ya(t, "vtkVolume") || Ya(t, "vtkImageSlice");
    }
    function Ya(t, e) {
        const n = "isA" in t ? t : t.actor;
        return n ? !!n.isA(e) : !1;
    }
    const j3 = new Map;
    function nN(t) {
        t.name = t.name || t.Name, j3.set(t.name, t);
    }
    function Md(t) {
        return j3.get(t);
    }
    function Ex() {
        return Array.from(j3.keys());
    }
    function H3(t, e) {
        const n = Id.rgbPresetNames.map((s)=>Id.getPresetByName(s)), r = Ex().map((s)=>Md(s)), a = n.concat(r).find((s)=>{
            const { RGBPoints: c } = s;
            if (c.length !== t.length) return !1;
            for(let l = 0; l < c.length; l += 4)if (!lr(c.slice(l + 1, l + 4), t.slice(l + 1, l + 4))) return !1;
            return !0;
        });
        if (!a) return null;
        const o = [];
        if (Ya(e, "vtkVolume")) {
            const s = e.getProperty().getScalarOpacity(0).getDataPointer();
            if (!s) return {
                name: a.Name
            };
            for(let c = 0; c < s.length; c += 2)o.push({
                value: s[c],
                opacity: s[c + 1]
            });
        }
        return {
            name: a.Name,
            opacity: o
        };
    }
    function rN(t) {
        const { volumeActor: e, preset: n, opacity: r = .9, threshold: i = null, colorRange: a = [
            0,
            5
        ] } = t;
        e.getMapper().setSampleDistance(1);
        const s = Jc.newInstance(), c = n || Id.getPresetByName("hsv");
        s.applyColorMap(c), s.setMappingRange(a[0], a[1]), e.getProperty().setRGBTransferFunction(0, s), K3(e, r, i);
    }
    function Dx(t, e) {
        const n = q3(t);
        K3(t, e, n);
    }
    function _x(t, e) {
        const n = X3(t);
        K3(t, n, e);
    }
    function K3(t, e, n) {
        const r = t.getMapper().getInputData().get("voxelManager");
        if (!r?.voxelManager) throw new Error("No voxel manager was found for the volume actor, or you cannot yet update opacity with a threshold using stacked images");
        const i = r.voxelManager.getRange(), a = B0.newInstance();
        if (n !== null) {
            const o = Math.abs(i[1] - i[0]) * .001, s = Math.max(i[0], Math.min(i[1], n));
            a.addPoint(i[0], 0), a.addPoint(s - o, 0), a.addPoint(s, e), a.addPoint(i[1], e);
        } else a.addPoint(i[0], e), a.addPoint(i[1], e);
        t.getProperty().setScalarOpacity(0, a);
    }
    function q3(t) {
        const e = t.getProperty().getScalarOpacity(0);
        if (!e) return null;
        const n = e.getDataPointer();
        if (!n || n.length <= 4) return null;
        for(let r = 0; r < n.length - 2; r += 2){
            n[r];
            const i = n[r + 1], a = n[r + 2], o = n[r + 3];
            if (i === 0 && o > 0) return a;
        }
        return null;
    }
    function X3(t) {
        const e = t.getProperty().getScalarOpacity(0);
        if (!e) return 1;
        const n = e.getDataPointer();
        if (!n || n.length === 0) return 1;
        let r = 0;
        for(let i = 1; i < n.length; i += 2)n[i] > r && (r = n[i]);
        return r;
    }
    const iN = Object.freeze(Object.defineProperty({
        __proto__: null,
        findMatchingColormap: H3,
        getColormap: Md,
        getColormapNames: Ex,
        getMaxOpacity: X3,
        getThresholdValue: q3,
        registerColormap: nN,
        setColorMapTransferFunctionForVolumeActor: rN,
        updateOpacity: Dx,
        updateThreshold: _x
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function pd(t) {
        if (!t) return;
        const e = t.getSize();
        for(let n = 0; n < e; n++){
            const r = [];
            t.getNodeValue(n, r), r[1] = 1 - r[1], r[2] = 1 - r[2], r[3] = 1 - r[3], t.setNodeValue(n, r);
        }
    }
    const Iv = (t, e, n)=>e - n / 4 * Math.log((1 - t) / t);
    function Zd(t, e) {
        const n = Math.abs(e - t) + 1, r = (t + e + 1) / 2;
        return {
            windowWidth: n,
            windowCenter: r
        };
    }
    function Fu(t, e, n = zi.LINEAR) {
        if (n === zi.LINEAR) return {
            lower: e - .5 - (t - 1) / 2,
            upper: e - .5 + (t - 1) / 2
        };
        if (n === zi.LINEAR_EXACT) return {
            lower: e - t / 2,
            upper: e + t / 2
        };
        if (n === zi.SAMPLED_SIGMOID) {
            const r = Iv(.01, e, t), i = Iv(.99, e, t);
            return {
                lower: r,
                upper: i
            };
        } else throw new Error("Invalid VOI LUT function");
    }
    const aN = Object.freeze(Object.defineProperty({
        __proto__: null,
        toLowHighRange: Fu,
        toWindowLevel: Zd
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function Y3(t, e = 1024) {
        const { windowWidth: n, windowCenter: r } = Zd(t.lower, t.upper), a = Array.from({
            length: e
        }, (s, c)=>(c + 1) / (e + 2)).flatMap((s)=>[
                Iv(s, r, n),
                s,
                s,
                s,
                .5,
                0
            ]), o = Jc.newInstance();
        return o.buildFunctionFromArray(Wt.newInstance({
            values: a,
            numberOfComponents: 6
        })), o;
    }
    function Co(t, e) {
        return t.worldToIndex(e).map(Math.round);
    }
    function sh(t, e) {
        return t.worldToIndex(e);
    }
    function Hh(t) {
        const e = t.getSize(), n = [];
        for(let r = 0; r < e; r++){
            const i = [];
            t.getNodeValue(r, i), n.push(i);
        }
        return n;
    }
    function bp(t, e) {
        e?.length && (t.removeAllPoints(), e.forEach((n)=>{
            t.addRGBPoint(...n);
        }));
    }
    const oN = Object.freeze(Object.defineProperty({
        __proto__: null,
        getTransferFunctionNodes: Hh,
        setTransferFunctionNodes: bp
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function sN(t, e) {
        e.classHierarchy.push("vtkImplicitFunction"), t.functionValue = (n)=>{
            if (!e.transform) return t.evaluateFunction(n);
            const r = [];
            return e.transform.transformPoint(n, r), t.evaluateFunction(r);
        }, t.evaluateFunction = (n)=>{
            K.vtkErrorMacro("not implemented");
        };
    }
    const cN = {};
    function Rx(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, cN, n), K.obj(t, e), K.setGet(t, e, [
            "transform"
        ]), sN(t, e);
    }
    const lN = K.newInstance(Rx, "vtkImplicitFunction");
    var uN = {
        newInstance: lN,
        extend: Rx
    };
    const Mv = 1e-6, Ox = "coincide", Ix = "disjoint";
    function fN(t, e, n) {
        return t[0] * (n[0] - e[0]) + t[1] * (n[1] - e[1]) + t[2] * (n[2] - e[2]);
    }
    function Mx(t, e, n) {
        const r = n[0] * (t[0] - e[0]) + n[1] * (t[1] - e[1]) + n[2] * (t[2] - e[2]);
        return Math.abs(r);
    }
    function bx(t, e, n, r) {
        const i = [];
        zc(t, e, i);
        const a = $t(n, i);
        r[0] = t[0] - a * n[0], r[1] = t[1] - a * n[1], r[2] = t[2] - a * n[2];
    }
    function Lx(t, e, n) {
        const r = $t(t, e);
        let i = $t(e, e);
        return i === 0 && (i = 1), n[0] = t[0] - r * e[0] / i, n[1] = t[1] - r * e[1] / i, n[2] = t[2] - r * e[2] / i, n;
    }
    function Px(t, e, n, r) {
        const i = [];
        zc(t, e, i);
        const a = $t(n, i), o = $t(n, n);
        o !== 0 ? (r[0] = t[0] - a * n[0] / o, r[1] = t[1] - a * n[1] / o, r[2] = t[2] - a * n[2] / o) : (r[0] = t[0], r[1] = t[1], r[2] = t[2]);
    }
    function Vx(t, e, n, r) {
        const i = {
            intersection: !1,
            betweenPoints: !1,
            t: Number.MAX_VALUE,
            x: []
        }, a = [], o = [];
        zc(e, t, a), zc(n, t, o);
        const s = $t(r, o), c = $t(r, a);
        let l, f;
        return c < 0 ? l = -c : l = c, s < 0 ? f = -s * Mv : f = s * Mv, l <= f || (i.t = s / c, i.x[0] = t[0] + i.t * a[0], i.x[1] = t[1] + i.t * a[1], i.x[2] = t[2] + i.t * a[2], i.intersection = !0, i.betweenPoints = i.t >= 0 && i.t <= 1), i;
    }
    function Nx(t, e, n, r) {
        const i = {
            intersection: !1,
            l0: [],
            l1: [],
            error: null
        }, a = [];
        tc(e, r, a);
        const o = a.map((u)=>Math.abs(u));
        if (o[0] + o[1] + o[2] < Mv) {
            const u = [];
            return zc(t, n, u), $t(e, u) === 0 ? i.error = Ox : i.error = Ix, i;
        }
        let s;
        o[0] > o[1] && o[0] > o[2] ? s = "x" : o[1] > o[2] ? s = "y" : s = "z";
        const c = [], l = -$t(e, t), f = -$t(r, n);
        switch(s){
            case "x":
                c[0] = 0, c[1] = (f * e[2] - l * r[2]) / a[0], c[2] = (l * r[1] - f * e[1]) / a[0];
                break;
            case "y":
                c[0] = (l * r[2] - f * e[2]) / a[1], c[1] = 0, c[2] = (f * e[0] - l * r[0]) / a[1];
                break;
            case "z":
                c[0] = (f * e[1] - l * r[1]) / a[2], c[1] = (l * r[0] - f * e[0]) / a[2], c[2] = 0;
                break;
        }
        return i.l0 = c, Uh(c, a, i.l1), i.intersection = !0, i;
    }
    const dN = {
        evaluate: fN,
        distanceToPlane: Mx,
        projectPoint: bx,
        projectVector: Lx,
        generalizedProjectPoint: Px,
        intersectWithLine: Vx,
        intersectWithPlane: Nx,
        DISJOINT: Ix,
        COINCIDE: Ox
    };
    function gN(t, e) {
        e.classHierarchy.push("vtkPlane"), t.distanceToPlane = (n)=>Mx(n, e.origin, e.normal), t.projectPoint = (n, r)=>{
            bx(n, e.origin, e.normal, r);
        }, t.projectVector = (n, r)=>Lx(n, e.normal, r), t.push = (n)=>{
            if (n !== 0) for(let r = 0; r < 3; r++)e.origin[r] += n * e.normal[r];
        }, t.generalizedProjectPoint = (n, r)=>{
            Px(n, e.origin, e.normal, r);
        }, t.evaluateFunction = (n, r, i)=>Array.isArray(n) ? e.normal[0] * (n[0] - e.origin[0]) + e.normal[1] * (n[1] - e.origin[1]) + e.normal[2] * (n[2] - e.origin[2]) : e.normal[0] * (n - e.origin[0]) + e.normal[1] * (r - e.origin[1]) + e.normal[2] * (i - e.origin[2]), t.evaluateGradient = (n)=>[
                e.normal[0],
                e.normal[1],
                e.normal[2]
            ], t.intersectWithLine = (n, r)=>Vx(n, r, e.origin, e.normal), t.intersectWithPlane = (n, r)=>Nx(n, r, e.origin, e.normal);
    }
    const hN = {
        normal: [
            0,
            0,
            1
        ],
        origin: [
            0,
            0,
            0
        ]
    };
    function Ax(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, hN, n), uN.extend(t, e, n), K.setGetArray(t, e, [
            "normal",
            "origin"
        ], 3), gN(t, e);
    }
    const pN = K.newInstance(Ax, "vtkPlane");
    var ca = {
        newInstance: pN,
        extend: Ax,
        ...dN
    };
    const Lp = [
        Number.MAX_VALUE,
        -Number.MAX_VALUE,
        Number.MAX_VALUE,
        -Number.MAX_VALUE,
        Number.MAX_VALUE,
        -Number.MAX_VALUE
    ];
    function kx(t, e) {
        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5];
    }
    function el(t) {
        return t?.length >= 6 && t[0] <= t[1] && t[2] <= t[3] && t[4] <= t[5];
    }
    function Z3(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;
    }
    function J3(t) {
        return Z3(t, Lp);
    }
    function Kh(t, e, n, r) {
        const [i, a, o, s, c, l] = t;
        return t[0] = i < e ? i : e, t[1] = a > e ? a : e, t[2] = o < n ? o : n, t[3] = s > n ? s : n, t[4] = c < r ? c : r, t[5] = l > r ? l : r, t;
    }
    function Q3(t, e) {
        if (e.length === 0) return t;
        if (Array.isArray(e[0])) for(let n = 0; n < e.length; ++n)Kh(t, ...e[n]);
        else for(let n = 0; n < e.length; n += 3)Kh(t, ...e.slice(n, n + 3));
        return t;
    }
    function Ux(t, e, n, r, i, a, o) {
        const [s, c, l, f, u, g] = t;
        return o === void 0 ? (t[0] = Math.min(e[0], s), t[1] = Math.max(e[1], c), t[2] = Math.min(e[2], l), t[3] = Math.max(e[3], f), t[4] = Math.min(e[4], u), t[5] = Math.max(e[5], g)) : (t[0] = Math.min(e, s), t[1] = Math.max(n, c), t[2] = Math.min(r, l), t[3] = Math.max(i, f), t[4] = Math.min(a, u), t[5] = Math.max(o, g)), t;
    }
    function Fx(t, e, n, r) {
        const [i, a, o, s, c, l] = t;
        return t[0] = e, t[1] = e > a ? e : a, t[2] = n, t[3] = n > s ? n : s, t[4] = r, t[5] = r > l ? r : l, i !== e || o !== n || c !== r;
    }
    function Bx(t, e, n, r) {
        const [i, a, o, s, c, l] = t;
        return t[0] = e < i ? e : i, t[1] = e, t[2] = n < o ? n : o, t[3] = n, t[4] = r < c ? r : c, t[5] = r, a !== e || s !== n || l !== r;
    }
    function Gx(t, e) {
        return t[0] -= e, t[1] += e, t[2] -= e, t[3] += e, t[4] -= e, t[5] += e, t;
    }
    function e4(t, e, n, r) {
        return el(t) ? (e >= 0 ? (t[0] *= e, t[1] *= e) : (t[0] = e * t[1], t[1] = e * t[0]), n >= 0 ? (t[2] *= n, t[3] *= n) : (t[2] = n * t[3], t[3] = n * t[2]), r >= 0 ? (t[4] *= r, t[5] *= r) : (t[4] = r * t[5], t[5] = r * t[4]), !0) : !1;
    }
    function t4(t) {
        return [
            .5 * (t[0] + t[1]),
            .5 * (t[2] + t[3]),
            .5 * (t[4] + t[5])
        ];
    }
    function mN(t, e, n, r) {
        if (!el(t)) return !1;
        const i = t4(t);
        return t[0] -= i[0], t[1] -= i[0], t[2] -= i[1], t[3] -= i[1], t[4] -= i[2], t[5] -= i[2], e4(t, e, n, r), t[0] += i[0], t[1] += i[0], t[2] += i[1], t[3] += i[1], t[4] += i[2], t[5] += i[2], !0;
    }
    function md(t, e) {
        return t[e * 2 + 1] - t[e * 2];
    }
    function Pp(t) {
        return [
            md(t, 0),
            md(t, 1),
            md(t, 2)
        ];
    }
    function Wx(t) {
        return t.slice(0, 2);
    }
    function $x(t) {
        return t.slice(2, 4);
    }
    function zx(t) {
        return t.slice(4, 6);
    }
    function jx(t) {
        const e = Pp(t);
        return e[0] > e[1] ? e[0] > e[2] ? e[0] : e[2] : e[1] > e[2] ? e[1] : e[2];
    }
    function Hx(t) {
        if (el(t)) {
            const e = Pp(t);
            return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
        }
        return null;
    }
    function n4(t) {
        return [
            t[0],
            t[2],
            t[4]
        ];
    }
    function r4(t) {
        return [
            t[1],
            t[3],
            t[5]
        ];
    }
    function v1(t, e) {
        return t <= 0 && e >= 0 || t >= 0 && e <= 0;
    }
    function i4(t, e) {
        let n = 0;
        for(let r = 0; r < 2; r++)for(let i = 2; i < 4; i++)for(let a = 4; a < 6; a++)e[n++] = [
            t[r],
            t[i],
            t[a]
        ];
        return e;
    }
    function Kx(t, e, n) {
        return e[0] = t[0], e[1] = t[2], e[2] = t[4], n[0] = t[1], n[1] = t[3], n[2] = t[5], e;
    }
    function qx(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        const r = i4(t, []);
        for(let i = 0; i < r.length; ++i)pn(r[i], r[i], e);
        return J3(n), Q3(n, r);
    }
    function Xx(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        return e[0] = .5 * (t[1] - t[0]), e[1] = .5 * (t[3] - t[2]), e[2] = .5 * (t[5] - t[4]), e;
    }
    function Yx(t, e, n, r) {
        const i = [].concat(Lp), a = t.getData();
        for(let o = 0; o < a.length; o += 3){
            const s = [
                a[o],
                a[o + 1],
                a[o + 2]
            ], c = $t(s, e);
            i[0] = Math.min(c, i[0]), i[1] = Math.max(c, i[1]);
            const l = $t(s, n);
            i[2] = Math.min(l, i[2]), i[3] = Math.max(l, i[3]);
            const f = $t(s, r);
            i[4] = Math.min(f, i[4]), i[5] = Math.max(f, i[5]);
        }
        return i;
    }
    function Zx(t, e, n, r, i) {
        let a = !0;
        const o = [];
        let s = 0;
        const c = [], l = [
            0,
            0,
            0
        ], f = 0, u = 1, g = 2;
        for(let h = 0; h < 3; h++)e[h] < t[2 * h] ? (o[h] = u, l[h] = t[2 * h], a = !1) : e[h] > t[2 * h + 1] ? (o[h] = f, l[h] = t[2 * h + 1], a = !1) : o[h] = g;
        if (a) return r[0] = e[0], r[1] = e[1], r[2] = e[2], i[0] = 0, 1;
        for(let h = 0; h < 3; h++)o[h] !== g && n[h] !== 0 ? c[h] = (l[h] - e[h]) / n[h] : c[h] = -1;
        for(let h = 0; h < 3; h++)c[s] < c[h] && (s = h);
        if (c[s] > 1 || c[s] < 0) return 0;
        i[0] = c[s];
        for(let h = 0; h < 3; h++)if (s !== h) {
            if (r[h] = e[h] + c[s] * n[h], r[h] < t[2 * h] || r[h] > t[2 * h + 1]) return 0;
        } else r[h] = l[h];
        return 1;
    }
    function Jx(t, e, n) {
        const r = [];
        let i = 0, a = 1, o = 1;
        for(let s = 4; s <= 5; ++s){
            r[2] = t[s];
            for(let c = 2; c <= 3; ++c){
                r[1] = t[c];
                for(let l = 0; l <= 1; ++l)if (r[0] = t[l], i = ca.evaluate(n, e, r), o && (a = i >= 0 ? 1 : -1, o = 0), i === 0 || a > 0 && i < 0 || a < 0 && i > 0) return 1;
            }
        }
        return 0;
    }
    function Qx(t, e) {
        if (!(el(t) && el(e))) return !1;
        const n = [
            0,
            0,
            0,
            0,
            0,
            0
        ];
        let r;
        for(let i = 0; i < 3; i++)if (r = !1, e[i * 2] >= t[i * 2] && e[i * 2] <= t[i * 2 + 1] ? (r = !0, n[i * 2] = e[i * 2]) : t[i * 2] >= e[i * 2] && t[i * 2] <= e[i * 2 + 1] && (r = !0, n[i * 2] = t[i * 2]), e[i * 2 + 1] >= t[i * 2] && e[i * 2 + 1] <= t[i * 2 + 1] ? (r = !0, n[i * 2 + 1] = e[2 * i + 1]) : t[i * 2 + 1] >= e[i * 2] && t[i * 2 + 1] <= e[i * 2 + 1] && (r = !0, n[i * 2 + 1] = t[i * 2 + 1]), !r) return !1;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], !0;
    }
    function qh(t, e) {
        if (!(el(t) && el(e))) return !1;
        for(let n = 0; n < 3; n++)if (!(e[n * 2] >= t[n * 2] && e[n * 2] <= t[n * 2 + 1]) && !(t[n * 2] >= e[n * 2] && t[n * 2] <= e[n * 2 + 1]) && !(e[n * 2 + 1] >= t[n * 2] && e[n * 2 + 1] <= t[n * 2 + 1]) && !(t[n * 2 + 1] >= e[n * 2] && t[n * 2 + 1] <= e[n * 2 + 1])) return !1;
        return !0;
    }
    function Xh(t, e, n, r) {
        return !(e < t[0] || e > t[1] || n < t[2] || n > t[3] || r < t[4] || r > t[5]);
    }
    function vN(t, e) {
        return !(!qh(t, e) || !Xh(t, ...n4(e)) || !Xh(t, ...r4(e)));
    }
    function eS(t, e, n) {
        const r = [
            [
                0,
                1,
                2,
                3,
                4,
                5,
                6,
                7
            ],
            [
                0,
                1,
                4,
                5,
                2,
                3,
                6,
                7
            ],
            [
                0,
                2,
                4,
                6,
                1,
                3,
                5,
                7
            ]
        ], i = [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ];
        let a = 0;
        for(let u = 0; u < 2; u++)for(let g = 2; g < 4; g++)for(let h = 4; h < 6; h++){
            const v = [
                t[u],
                t[g],
                t[h]
            ];
            i[a++] = ca.evaluate(n, e, v);
        }
        let o = 2;
        for(; o-- && !(v1(i[r[o][0]], i[r[o][4]]) && v1(i[r[o][1]], i[r[o][5]]) && v1(i[r[o][2]], i[r[o][6]]) && v1(i[r[o][3]], i[r[o][7]])););
        if (o < 0) return !1;
        const s = Math.sign(n[o]), c = Math.abs((t[o * 2 + 1] - t[o * 2]) * n[o]);
        let l = s > 0 ? 1 : 0;
        for(let u = 0; u < 4; u++){
            if (c === 0) continue;
            const g = Math.abs(i[r[o][u]]) / c;
            s > 0 && g < l && (l = g), s < 0 && g > l && (l = g);
        }
        const f = (1 - l) * t[o * 2] + l * t[o * 2 + 1];
        return s > 0 ? t[o * 2] = f : t[o * 2 + 1] = f, !0;
    }
    class yN {
        constructor(e){
            this.bounds = e, this.bounds || (this.bounds = new Float64Array(Lp));
        }
        getBounds() {
            return this.bounds;
        }
        equals(e) {
            return kx(this.bounds, e);
        }
        isValid() {
            return el(this.bounds);
        }
        setBounds(e) {
            return Z3(this.bounds, e);
        }
        reset() {
            return J3(this.bounds);
        }
        addPoint() {
            for(var e = arguments.length, n = new Array(e), r = 0; r < e; r++)n[r] = arguments[r];
            return Kh(this.bounds, ...n);
        }
        addPoints(e) {
            return Q3(this.bounds, e);
        }
        addBounds(e, n, r, i, a, o) {
            return Ux(this.bounds, e, n, r, i, a, o);
        }
        setMinPoint(e, n, r) {
            return Fx(this.bounds, e, n, r);
        }
        setMaxPoint(e, n, r) {
            return Bx(this.bounds, e, n, r);
        }
        inflate(e) {
            return Gx(this.bounds, e);
        }
        scale(e, n, r) {
            return e4(this.bounds, e, n, r);
        }
        getCenter() {
            return t4(this.bounds);
        }
        getLength(e) {
            return md(this.bounds, e);
        }
        getLengths() {
            return Pp(this.bounds);
        }
        getMaxLength() {
            return jx(this.bounds);
        }
        getDiagonalLength() {
            return Hx(this.bounds);
        }
        getMinPoint() {
            return n4(this.bounds);
        }
        getMaxPoint() {
            return r4(this.bounds);
        }
        getXRange() {
            return Wx(this.bounds);
        }
        getYRange() {
            return $x(this.bounds);
        }
        getZRange() {
            return zx(this.bounds);
        }
        getCorners(e) {
            return i4(this.bounds, e);
        }
        computeCornerPoints(e, n) {
            return Kx(this.bounds, e, n);
        }
        computeLocalBounds(e, n, r) {
            return Yx(this.bounds, e, n, r);
        }
        transformBounds(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            return qx(this.bounds, e, n);
        }
        computeScale3(e) {
            return Xx(this.bounds, e);
        }
        cutWithPlane(e, n) {
            return eS(this.bounds, e, n);
        }
        intersectBox(e, n, r, i) {
            return Zx(this.bounds, e, n, r, i);
        }
        intersectPlane(e, n) {
            return Jx(this.bounds, e, n);
        }
        intersect(e) {
            return Qx(this.bounds, e);
        }
        intersects(e) {
            return qh(this.bounds, e);
        }
        containsPoint(e, n, r) {
            return Xh(this.bounds, e, n, r);
        }
        contains(e) {
            return qh(this.bounds, e);
        }
    }
    function CN(t) {
        const e = t && t.bounds;
        return new yN(e);
    }
    const wN = {
        equals: kx,
        isValid: el,
        setBounds: Z3,
        reset: J3,
        addPoint: Kh,
        addPoints: Q3,
        addBounds: Ux,
        setMinPoint: Fx,
        setMaxPoint: Bx,
        inflate: Gx,
        scale: e4,
        scaleAboutCenter: mN,
        getCenter: t4,
        getLength: md,
        getLengths: Pp,
        getMaxLength: jx,
        getDiagonalLength: Hx,
        getMinPoint: n4,
        getMaxPoint: r4,
        getXRange: Wx,
        getYRange: $x,
        getZRange: zx,
        getCorners: i4,
        computeCornerPoints: Kx,
        computeLocalBounds: Yx,
        transformBounds: qx,
        computeScale3: Xx,
        cutWithPlane: eS,
        intersectBox: Zx,
        intersectPlane: Jx,
        intersect: Qx,
        intersects: qh,
        containsPoint: Xh,
        contains: vN,
        INIT_BOUNDS: Lp
    };
    zn = {
        newInstance: CN,
        ...wN
    };
    const TN = {
        DISPLAY: 0,
        WORLD: 1
    };
    var tS = {
        CoordinateSystem: TN
    };
    const { CoordinateSystem: bv } = tS;
    function N9(t) {
        return ()=>K.vtkErrorMacro(`vtkProp::${t} - NOT IMPLEMENTED`);
    }
    function xN(t, e) {
        e.classHierarchy.push("vtkProp"), t.getMTime = ()=>{
            let n = e.mtime;
            for(let r = 0; r < e.textures.length; ++r){
                const i = e.textures[r].getMTime();
                i > n && (n = i);
            }
            return n;
        }, t.processSelectorPixelBuffers = (n, r)=>{}, t.getNestedProps = ()=>null, t.getActors = ()=>[], t.getActors2D = ()=>[], t.getVolumes = ()=>[], t.pick = N9("pick"), t.hasKey = N9("hasKey"), t.getNestedVisibility = ()=>e.visibility && (!e._parentProp || e._parentProp.getNestedVisibility()), t.getNestedPickable = ()=>e.pickable && (!e._parentProp || e._parentProp.getNestedPickable()), t.getNestedDragable = ()=>e.dragable && (!e._parentProp || e._parentProp.getNestedDragable()), t.getRedrawMTime = ()=>e.mtime, t.setEstimatedRenderTime = (n)=>{
            e.estimatedRenderTime = n, e.savedEstimatedRenderTime = n;
        }, t.restoreEstimatedRenderTime = ()=>{
            e.estimatedRenderTime = e.savedEstimatedRenderTime;
        }, t.addEstimatedRenderTime = (n)=>{
            e.estimatedRenderTime += n;
        }, t.setAllocatedRenderTime = (n)=>{
            e.allocatedRenderTime = n, e.savedEstimatedRenderTime = e.estimatedRenderTime, e.estimatedRenderTime = 0;
        }, t.getSupportsSelection = ()=>!1, t.getTextures = ()=>e.textures, t.hasTexture = (n)=>e.textures.indexOf(n) !== -1, t.addTexture = (n)=>{
            n && !t.hasTexture(n) && (e.textures = e.textures.concat(n), t.modified());
        }, t.removeTexture = (n)=>{
            const r = e.textures.filter((i)=>i !== n);
            e.textures.length !== r.length && (e.textures = r, t.modified());
        }, t.removeAllTextures = ()=>{
            e.textures = [], t.modified();
        }, t.setCoordinateSystemToWorld = ()=>t.setCoordinateSystem(bv.WORLD), t.setCoordinateSystemToDisplay = ()=>t.setCoordinateSystem(bv.DISPLAY);
    }
    const SN = {
        allocatedRenderTime: 10,
        coordinateSystem: bv.WORLD,
        dragable: !0,
        estimatedRenderTime: 0,
        paths: null,
        pickable: !0,
        renderTimeMultiplier: 1,
        savedEstimatedRenderTime: 0,
        textures: [],
        useBounds: !0,
        visibility: !0
    };
    function nS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, SN, n), K.obj(t, e), K.get(t, e, [
            "estimatedRenderTime",
            "allocatedRenderTime"
        ]), K.setGet(t, e, [
            "_parentProp",
            "coordinateSystem",
            "dragable",
            "pickable",
            "renderTimeMultiplier",
            "useBounds",
            "visibility"
        ]), K.moveToProtected(t, e, [
            "parentProp"
        ]), xN(t, e);
    }
    const EN = K.newInstance(nS, "vtkProp");
    rS = {
        newInstance: EN,
        extend: nS,
        ...tS
    };
    const DN = 1e-6;
    function _N(t, e) {
        e.classHierarchy.push("vtkProp3D"), t.addPosition = (r)=>{
            e.position = e.position.map((i, a)=>i + r[a]), t.modified();
        }, t.getOrientationWXYZ = ()=>{
            const r = G0();
            _v(r, e.rotation);
            const i = new Float64Array(3), a = qV(i, r);
            return [
                kh(a),
                i[0],
                i[1],
                i[2]
            ];
        }, t.getOrientationQuaternion = function() {
            let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            return _v(r, e.rotation);
        }, t.rotateX = (r)=>{
            r !== 0 && (A3(e.rotation, e.rotation, Sr(r)), t.modified());
        }, t.rotateY = (r)=>{
            r !== 0 && (k3(e.rotation, e.rotation, Sr(r)), t.modified());
        }, t.rotateZ = (r)=>{
            r !== 0 && (U3(e.rotation, e.rotation, Sr(r)), t.modified());
        }, t.rotateWXYZ = (r, i, a, o)=>{
            if (r === 0 || i === 0 && a === 0 && o === 0) return;
            const s = Sr(r), c = G0();
            W3(c, [
                i,
                a,
                o
            ], s);
            const l = new Float64Array(16);
            Wh(l, c), Qt(e.rotation, e.rotation, l), t.modified();
        }, t.rotateQuaternion = (r)=>{
            if (Math.abs(r[3]) >= 1 - DN) return;
            const i = Wh(new Float64Array(16), r);
            Qt(e.rotation, e.rotation, i), t.modified();
        }, t.setOrientation = (r, i, a)=>r === e.orientation[0] && i === e.orientation[1] && a === e.orientation[2] ? !1 : (e.orientation = [
                r,
                i,
                a
            ], Ot(e.rotation), t.rotateZ(a), t.rotateX(r), t.rotateY(i), t.modified(), !0), t.setUserMatrix = (r)=>Kd(e.userMatrix, r) ? !1 : (Ur(e.userMatrix, r), t.modified(), !0), t.getMatrix = ()=>(t.computeMatrix(), e.matrix), t.computeMatrix = ()=>{
            if (t.getMTime() > e.matrixMTime.getMTime()) {
                Ot(e.matrix), e.userMatrix && Qt(e.matrix, e.matrix, e.userMatrix), qr(e.matrix, e.matrix, e.origin), qr(e.matrix, e.matrix, e.position), Qt(e.matrix, e.matrix, e.rotation), nc(e.matrix, e.matrix, e.scale), qr(e.matrix, e.matrix, [
                    -e.origin[0],
                    -e.origin[1],
                    -e.origin[2]
                ]), cn(e.matrix, e.matrix), e.isIdentity = !0;
                for(let r = 0; r < 4; ++r)for(let i = 0; i < 4; ++i)(r === i ? 1 : 0) !== e.matrix[r + i * 4] && (e.isIdentity = !1);
                e.matrixMTime.modified();
            }
        }, t.getCenter = ()=>zn.getCenter(e.bounds), t.getLength = ()=>zn.getLength(e.bounds), t.getXRange = ()=>zn.getXRange(e.bounds), t.getYRange = ()=>zn.getYRange(e.bounds), t.getZRange = ()=>zn.getZRange(e.bounds), t.getUserMatrix = ()=>e.userMatrix;
        function n() {
            t.computeMatrix();
        }
        t.onModified(n);
    }
    const RN = {
        origin: [
            0,
            0,
            0
        ],
        position: [
            0,
            0,
            0
        ],
        orientation: [
            0,
            0,
            0
        ],
        rotation: null,
        scale: [
            1,
            1,
            1
        ],
        bounds: [
            1,
            -1,
            1,
            -1,
            1,
            -1
        ],
        userMatrix: null,
        userMatrixMTime: null,
        cachedProp3D: null,
        isIdentity: !0,
        matrixMTime: null
    };
    function iS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, RN, n), rS.extend(t, e, n), e.matrixMTime = {}, K.obj(e.matrixMTime), K.get(t, e, [
            "bounds",
            "isIdentity"
        ]), K.getArray(t, e, [
            "orientation"
        ]), K.setGetArray(t, e, [
            "origin",
            "position",
            "scale"
        ], 3), e.matrix = Ot(new Float64Array(16)), e.rotation = Ot(new Float64Array(16)), e.userMatrix = Ot(new Float64Array(16)), e.transform = null, _N(t, e);
    }
    const ON = K.newInstance(iS, "vtkProp3D");
    var a4 = {
        newInstance: ON,
        extend: iS
    };
    const Lv = {
        NEAREST: 0,
        LINEAR: 1,
        FAST_LINEAR: 2
    }, aS = {
        FRACTIONAL: 0,
        PROPORTIONAL: 1
    }, ch = {
        CUSTOM: 0,
        ADDITIVE: 1,
        COLORIZE: 2
    };
    var oS = {
        InterpolationType: Lv,
        OpacityMode: aS,
        ColorMixPreset: ch
    };
    const { InterpolationType: ad, OpacityMode: IN } = oS, { vtkErrorMacro: d5 } = K, lh = 4;
    function MN(t, e) {
        e.classHierarchy.push("vtkVolumeProperty"), t.getMTime = ()=>{
            let i = e.mtime, a;
            for(let o = 0; o < lh; o++)e.componentData[o].colorChannels === 1 ? e.componentData[o].grayTransferFunction && (a = e.componentData[o].grayTransferFunction.getMTime(), i = i > a ? i : a) : e.componentData[o].colorChannels === 3 && e.componentData[o].rGBTransferFunction && (a = e.componentData[o].rGBTransferFunction.getMTime(), i = i > a ? i : a), e.componentData[o].scalarOpacity && (a = e.componentData[o].scalarOpacity.getMTime(), i = i > a ? i : a), e.componentData[o].gradientOpacity && (e.componentData[o].disableGradientOpacity || (a = e.componentData[o].gradientOpacity.getMTime(), i = i > a ? i : a));
            return i;
        }, t.getColorChannels = (i)=>i < 0 || i > 3 ? (d5("Bad index - must be between 0 and 3"), 0) : e.componentData[i].colorChannels, t.setGrayTransferFunction = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, o = !1;
            return e.componentData[i].grayTransferFunction !== a && (e.componentData[i].grayTransferFunction = a, o = !0), e.componentData[i].colorChannels !== 1 && (e.componentData[i].colorChannels = 1, o = !0), o && t.modified(), o;
        }, t.getGrayTransferFunction = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.componentData[i].grayTransferFunction === null && (e.componentData[i].grayTransferFunction = B0.newInstance(), e.componentData[i].grayTransferFunction.addPoint(0, 0), e.componentData[i].grayTransferFunction.addPoint(1024, 1), e.componentData[i].colorChannels !== 1 && (e.componentData[i].colorChannels = 1), t.modified()), e.componentData[i].grayTransferFunction;
        }, t.setRGBTransferFunction = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, o = !1;
            return e.componentData[i].rGBTransferFunction !== a && (e.componentData[i].rGBTransferFunction = a, o = !0), e.componentData[i].colorChannels !== 3 && (e.componentData[i].colorChannels = 3, o = !0), o && t.modified(), o;
        }, t.getRGBTransferFunction = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.componentData[i].rGBTransferFunction === null && (e.componentData[i].rGBTransferFunction = Jc.newInstance(), e.componentData[i].rGBTransferFunction.addRGBPoint(0, 0, 0, 0), e.componentData[i].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1), e.componentData[i].colorChannels !== 3 && (e.componentData[i].colorChannels = 3), t.modified()), e.componentData[i].rGBTransferFunction;
        }, t.setScalarOpacity = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return e.componentData[i].scalarOpacity !== a ? (e.componentData[i].scalarOpacity = a, t.modified(), !0) : !1;
        }, t.getScalarOpacity = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.componentData[i].scalarOpacity === null && (e.componentData[i].scalarOpacity = B0.newInstance(), e.componentData[i].scalarOpacity.addPoint(0, 1), e.componentData[i].scalarOpacity.addPoint(1024, 1), t.modified()), e.componentData[i].scalarOpacity;
        }, t.setComponentWeight = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            if (i < 0 || i >= lh) return d5("Invalid index"), !1;
            const o = Math.min(1, Math.max(0, a));
            return e.componentData[i].componentWeight !== o ? (e.componentData[i].componentWeight = o, t.modified(), !0) : !1;
        }, t.getComponentWeight = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return i < 0 || i >= lh ? (d5("Invalid index"), 0) : e.componentData[i].componentWeight;
        }, t.setInterpolationTypeToNearest = ()=>t.setInterpolationType(ad.NEAREST), t.setInterpolationTypeToLinear = ()=>t.setInterpolationType(ad.LINEAR), t.setInterpolationTypeToFastLinear = ()=>t.setInterpolationType(ad.FAST_LINEAR), t.getInterpolationTypeAsString = ()=>K.enumToString(ad, e.interpolationType), [
            "useGradientOpacity",
            "scalarOpacityUnitDistance",
            "gradientOpacityMinimumValue",
            "gradientOpacityMinimumOpacity",
            "gradientOpacityMaximumValue",
            "gradientOpacityMaximumOpacity",
            "opacityMode",
            "forceNearestInterpolation"
        ].forEach((i)=>{
            const a = K.capitalize(i);
            t[`set${a}`] = (o, s)=>e.componentData[o][`${i}`] !== s ? (e.componentData[o][`${i}`] = s, t.modified(), !0) : !1;
        }), [
            "useGradientOpacity",
            "scalarOpacityUnitDistance",
            "gradientOpacityMinimumValue",
            "gradientOpacityMinimumOpacity",
            "gradientOpacityMaximumValue",
            "gradientOpacityMaximumOpacity",
            "opacityMode",
            "forceNearestInterpolation"
        ].forEach((i)=>{
            const a = K.capitalize(i);
            t[`get${a}`] = (o)=>e.componentData[o][`${i}`];
        });
    }
    const bN = {
        colorMixPreset: null,
        independentComponents: !0,
        interpolationType: ad.FAST_LINEAR,
        shade: !1,
        ambient: .1,
        diffuse: .7,
        specular: .2,
        specularPower: 10,
        useLabelOutline: !1,
        labelOutlineThickness: [
            1
        ],
        labelOutlineOpacity: 1
    };
    function LN(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (Object.assign(e, bN, n), K.obj(t, e), !e.componentData) {
            e.componentData = [];
            for(let r = 0; r < lh; ++r)e.componentData.push({
                colorChannels: 1,
                grayTransferFunction: null,
                rGBTransferFunction: null,
                scalarOpacity: null,
                scalarOpacityUnitDistance: 1,
                opacityMode: IN.FRACTIONAL,
                gradientOpacityMinimumValue: 0,
                gradientOpacityMinimumOpacity: 0,
                gradientOpacityMaximumValue: 1,
                gradientOpacityMaximumOpacity: 1,
                useGradientOpacity: !1,
                componentWeight: 1,
                forceNearestInterpolation: !1
            });
        }
        K.setGet(t, e, [
            "colorMixPreset",
            "independentComponents",
            "interpolationType",
            "shade",
            "ambient",
            "diffuse",
            "specular",
            "specularPower",
            "useLabelOutline",
            "labelOutlineOpacity"
        ]), K.setGetArray(t, e, [
            "labelOutlineThickness"
        ]), MN(t, e);
    }
    const PN = K.newInstance(LN, "vtkVolumeProperty");
    var VN = {
        newInstance: PN,
        ...oS
    };
    const { vtkDebugMacro: NN } = K;
    function AN(t, e) {
        e.classHierarchy.push("vtkVolume"), t.getVolumes = ()=>t, t.makeProperty = VN.newInstance, t.getProperty = ()=>(e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = ()=>{
            if (e.mapper === null) return e.bounds;
            const n = e.mapper.getBounds();
            if (!n || n.length !== 6) return n;
            if (n[0] > n[1]) return e.mapperBounds = n.concat(), e.bounds = [
                1,
                -1,
                1,
                -1,
                1,
                -1
            ], e.boundsMTime.modified(), n;
            const r = (i)=>i[0].map((a, o)=>i.map((s)=>s[o]));
            if (!e.mapperBounds || !r([
                n,
                e.mapperBounds
            ]).reduce((i, a)=>i && a[0] === a[1], !0) || t.getMTime() > e.boundsMTime.getMTime()) {
                NN("Recomputing bounds..."), e.mapperBounds = n.map((o)=>o);
                const i = [];
                zn.getCorners(n, i), t.computeMatrix();
                const a = new Float64Array(16);
                cn(a, e.matrix), i.forEach((o)=>pn(o, o, a)), e.bounds[0] = e.bounds[2] = e.bounds[4] = Number.MAX_VALUE, e.bounds[1] = e.bounds[3] = e.bounds[5] = -Number.MAX_VALUE, e.bounds = e.bounds.map((o, s)=>s % 2 === 0 ? i.reduce((c, l)=>c > l[s / 2] ? l[s / 2] : c, o) : i.reduce((c, l)=>c < l[(s - 1) / 2] ? l[(s - 1) / 2] : c, o)), e.boundsMTime.modified();
            }
            return e.bounds;
        }, t.getMTime = ()=>{
            let n = e.mtime;
            if (e.property !== null) {
                const r = e.property.getMTime();
                n = r > n ? r : n;
            }
            return n;
        }, t.getRedrawMTime = ()=>{
            let n = e.mtime;
            if (e.mapper !== null) {
                let r = e.mapper.getMTime();
                n = r > n ? r : n, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), r = e.mapper.getInput().getMTime(), n = r > n ? r : n);
            }
            return n;
        };
    }
    const kN = {
        mapper: null,
        property: null,
        bounds: [
            1,
            -1,
            1,
            -1,
            1,
            -1
        ]
    };
    function sS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, kN, n), a4.extend(t, e, n), e.boundsMTime = {}, K.obj(e.boundsMTime), K.set(t, e, [
            "property"
        ]), K.setGet(t, e, [
            "mapper"
        ]), K.getArray(t, e, [
            "bounds"
        ], 6), AN(t, e);
    }
    const UN = K.newInstance(sS, "vtkVolume");
    var FN = {
        newInstance: UN,
        extend: sS
    };
    const { vtkErrorMacro: BN } = K, GN = [
        "Build",
        "Render"
    ];
    function WN(t, e) {
        e.classHierarchy.push("vtkViewNode"), t.build = (r)=>{}, t.render = (r)=>{}, t.traverse = (r)=>{
            const i = r.getTraverseOperation(), a = t[i];
            if (a) {
                a(r);
                return;
            }
            t.apply(r, !0);
            for(let o = 0; o < e.children.length; o++)e.children[o].traverse(r);
            t.apply(r, !1);
        }, t.apply = (r, i)=>{
            const a = t[r.getOperation()];
            a && a(i, r);
        }, t.getViewNodeFor = (r)=>{
            if (e.renderable === r) return t;
            for(let i = 0; i < e.children.length; ++i){
                const o = e.children[i].getViewNodeFor(r);
                if (o) return o;
            }
        }, t.getFirstAncestorOfType = (r)=>e._parent ? e._parent.isA(r) ? e._parent : e._parent.getFirstAncestorOfType(r) : null, t.getLastAncestorOfType = (r)=>{
            if (!e._parent) return null;
            const i = e._parent.getLastAncestorOfType(r);
            return i || (e._parent.isA(r) ? e._parent : null);
        }, t.addMissingNode = (r)=>{
            if (!r) return;
            const i = e._renderableChildMap.get(r);
            if (i !== void 0) return i.setVisited(!0), i;
            const a = t.createViewNode(r);
            if (a) return a.setParent(t), a.setVisited(!0), e._renderableChildMap.set(r, a), e.children.push(a), a;
        }, t.addMissingNodes = (r)=>{
            if (!(!r || !r.length)) for(let i = 0; i < r.length; ++i){
                const a = r[i];
                t.addMissingNode(a);
            }
        }, t.addMissingChildren = (r)=>{
            if (!(!r || !r.length)) for(let i = 0; i < r.length; ++i){
                const a = r[i];
                if (e.children.indexOf(a) === -1) {
                    a.setParent(t), e.children.push(a);
                    const s = a.getRenderable();
                    s && e._renderableChildMap.set(s, a);
                }
                a.setVisited(!0);
            }
        }, t.removeNode = (r)=>{
            const i = e.children.findIndex((o)=>o === r);
            if (i < 0) return !1;
            const a = r.getRenderable();
            return a && e._renderableChildMap.delete(a), r.delete(), e.children.splice(i, 1), !0;
        }, t.prepareNodes = ()=>{
            for(let r = 0; r < e.children.length; ++r)e.children[r].setVisited(!1);
        }, t.setVisited = (r)=>{
            e.visited = r;
        }, t.removeUnusedNodes = ()=>{
            let r = 0;
            for(let i = 0; i < e.children.length; ++i){
                const a = e.children[i];
                if (a.getVisited()) e.children[r++] = a, a.setVisited(!1);
                else {
                    const s = a.getRenderable();
                    s && e._renderableChildMap.delete(s), a.delete();
                }
            }
            e.children.length = r;
        }, t.createViewNode = (r)=>{
            if (!e.myFactory) return BN("Cannot create view nodes without my own factory"), null;
            const i = e.myFactory.createNode(r);
            return i && i.setRenderable(r), i;
        };
        const n = t.delete;
        t.delete = ()=>{
            for(let r = 0; r < e.children.length; r++)e.children[r].delete();
            n();
        };
    }
    const $N = {
        renderable: null,
        myFactory: null,
        children: [],
        visited: !1
    };
    function cS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, $N, n), K.obj(t, e), K.event(t, e, "event"), e._renderableChildMap = new Map, K.get(t, e, [
            "visited"
        ]), K.setGet(t, e, [
            "_parent",
            "renderable",
            "myFactory"
        ]), K.getArray(t, e, [
            "children"
        ]), K.moveToProtected(t, e, [
            "parent"
        ]), WN(t, e);
    }
    const zN = K.newInstance(cS, "vtkViewNode");
    Yr = {
        newInstance: zN,
        extend: cS,
        PASS_TYPES: GN
    };
    function jN(t, e) {
        e.overrides || (e.overrides = {}), e.classHierarchy.push("vtkViewNodeFactory"), t.createNode = (n)=>{
            if (n.isDeleted()) return null;
            let r = 0, i = n.getClassName(r++), a = !1;
            const o = Object.keys(e.overrides);
            for(; i && !a;)o.indexOf(i) !== -1 ? a = !0 : i = n.getClassName(r++);
            if (!a) return null;
            const s = e.overrides[i]();
            return s.setMyFactory(t), s;
        };
    }
    const HN = {};
    function lS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, HN, n), K.obj(t, e), jN(t, e);
    }
    const KN = K.newInstance(lS, "vtkViewNodeFactory");
    var o4 = {
        newInstance: KN,
        extend: lS
    };
    const uS = Object.create(null);
    bi = function(t, e) {
        uS[t] = e;
    };
    function qN(t, e) {
        e.classHierarchy.push("vtkOpenGLViewNodeFactory");
    }
    const XN = {};
    function fS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, XN, n), e.overrides = uS, o4.extend(t, e, n), qN(t, e);
    }
    const YN = K.newInstance(fS, "vtkOpenGLViewNodeFactory");
    var ZN = {
        newInstance: YN,
        extend: fS
    };
    function JN(t, e) {
        e.classHierarchy.push("vtkOpenGLCamera"), t.buildPass = (n)=>{
            n && (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext());
        }, t.opaquePass = (n)=>{
            if (n) {
                const r = e._openGLRenderer.getTiledSizeAndOrigin();
                e.context.viewport(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize), e.context.scissor(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize);
            }
        }, t.translucentPass = t.opaquePass, t.zBufferPass = t.opaquePass, t.opaqueZBufferPass = t.opaquePass, t.volumePass = t.opaquePass, t.getKeyMatrices = (n)=>{
            if (n !== e.lastRenderer || e._openGLRenderWindow.getMTime() > e.keyMatrixTime.getMTime() || t.getMTime() > e.keyMatrixTime.getMTime() || n.getMTime() > e.keyMatrixTime.getMTime() || e.renderable.getMTime() > e.keyMatrixTime.getMTime()) {
                Ur(e.keyMatrices.wcvc, e.renderable.getViewMatrix()), Mp(e.keyMatrices.normalMatrix, e.keyMatrices.wcvc), Xd(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), cn(e.keyMatrices.wcvc, e.keyMatrices.wcvc);
                const r = e._openGLRenderer.getAspectRatio();
                Ur(e.keyMatrices.vcpc, e.renderable.getProjectionMatrix(r, -1, 1)), cn(e.keyMatrices.vcpc, e.keyMatrices.vcpc), Qt(e.keyMatrices.wcpc, e.keyMatrices.vcpc, e.keyMatrices.wcvc), e.keyMatrixTime.modified(), e.lastRenderer = n;
            }
            return e.keyMatrices;
        };
    }
    const QN = {
        context: null,
        lastRenderer: null,
        keyMatrixTime: null,
        keyMatrices: null
    };
    function eA(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, QN, n), Yr.extend(t, e, n), e.keyMatrixTime = {}, tr(e.keyMatrixTime), e.keyMatrices = {
            normalMatrix: new Float64Array(9),
            vcpc: new Float64Array(16),
            wcvc: new Float64Array(16),
            wcpc: new Float64Array(16)
        }, si(t, e, [
            "context",
            "keyMatrixTime"
        ]), JN(t, e);
    }
    const dS = kn(eA);
    var tA = {
        newInstance: dS
    };
    bi("vtkCamera", dS);
    const { vtkDebugMacro: nA } = da;
    function rA(t, e) {
        e.classHierarchy.push("vtkOpenGLRenderer"), t.buildPass = (n)=>{
            if (n) {
                if (!e.renderable) return;
                t.updateLights(), t.prepareNodes(), t.addMissingNode(e.renderable.getActiveCamera()), t.addMissingNodes(e.renderable.getViewPropsWithNestedProps()), t.removeUnusedNodes();
            }
        }, t.updateLights = ()=>{
            let n = 0;
            const r = e.renderable.getLightsByReference();
            for(let i = 0; i < r.length; ++i)r[i].getSwitch() > 0 && n++;
            return n || (nA("No lights are on, creating one."), e.renderable.createLight()), n;
        }, t.zBufferPass = (n)=>{
            if (n) {
                let r = 0;
                const i = e.context;
                e.renderable.getTransparent() || (e.context.clearColor(1, 0, 0, 1), r |= i.COLOR_BUFFER_BIT), e.renderable.getPreserveDepthBuffer() || (i.clearDepth(1), r |= i.DEPTH_BUFFER_BIT, e.context.depthMask(!0));
                const a = t.getTiledSizeAndOrigin();
                i.enable(i.SCISSOR_TEST), i.scissor(a.lowerLeftU, a.lowerLeftV, a.usize, a.vsize), i.viewport(a.lowerLeftU, a.lowerLeftV, a.usize, a.vsize), i.colorMask(!0, !0, !0, !0), r && i.clear(r), i.enable(i.DEPTH_TEST);
            }
        }, t.opaqueZBufferPass = (n)=>t.zBufferPass(n), t.cameraPass = (n)=>{
            n && t.clear();
        }, t.getAspectRatio = ()=>{
            const n = e._parent.getSizeByReference(), r = e.renderable.getViewportByReference();
            return n[0] * (r[2] - r[0]) / ((r[3] - r[1]) * n[1]);
        }, t.getTiledSizeAndOrigin = ()=>{
            const n = e.renderable.getViewportByReference(), r = [
                0,
                0,
                1,
                1
            ], i = n[0] - r[0], a = n[1] - r[1], o = e._parent.normalizedDisplayToDisplay(i, a), s = Math.round(o[0]), c = Math.round(o[1]), l = n[2] - r[0], f = n[3] - r[1], u = e._parent.normalizedDisplayToDisplay(l, f);
            let g = Math.round(u[0]) - s, h = Math.round(u[1]) - c;
            return g < 0 && (g = 0), h < 0 && (h = 0), {
                usize: g,
                vsize: h,
                lowerLeftU: s,
                lowerLeftV: c
            };
        }, t.clear = ()=>{
            let n = 0;
            const r = e.context;
            if (!e.renderable.getTransparent()) {
                const a = e.renderable.getBackgroundByReference();
                r.clearColor(a[0], a[1], a[2], a[3]), n |= r.COLOR_BUFFER_BIT;
            }
            e.renderable.getPreserveDepthBuffer() || (r.clearDepth(1), n |= r.DEPTH_BUFFER_BIT, r.depthMask(!0)), r.colorMask(!0, !0, !0, !0);
            const i = t.getTiledSizeAndOrigin();
            r.enable(r.SCISSOR_TEST), r.scissor(i.lowerLeftU, i.lowerLeftV, i.usize, i.vsize), r.viewport(i.lowerLeftU, i.lowerLeftV, i.usize, i.vsize), n && r.clear(n), r.enable(r.DEPTH_TEST);
        }, t.releaseGraphicsResources = ()=>{
            e.selector !== null && e.selector.releaseGraphicsResources(), e.renderable && e.renderable.getViewProps().forEach((n)=>{
                n.modified();
            });
        }, t.setOpenGLRenderWindow = (n)=>{
            e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
        };
    }
    const iA = {
        context: null,
        _openGLRenderWindow: null,
        selector: null
    };
    function aA(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, iA, n), Yr.extend(t, e, n), La(t, e, [
            "shaderCache"
        ]), si(t, e, [
            "selector"
        ]), zd(t, e, [
            "openGLRenderWindow"
        ]), rA(t, e);
    }
    const gS = kn(aA, "vtkOpenGLRenderer");
    var oA = {
        newInstance: gS
    };
    bi("vtkRenderer", gS);
    function hS(t) {
        let e = 0;
        return t.filter((n, r)=>r === e ? (e += n + 1, !0) : !1);
    }
    function pS(t) {
        let e = 0;
        for(let n = 0; n < t.length;)n += t[n] + 1, e++;
        return e;
    }
    const sA = {
        extractCellSizes: hS,
        getNumberOfCells: pS
    };
    function cA(t, e) {
        e.classHierarchy.push("vtkCellArray");
        const n = {
            ...t
        };
        t.getNumberOfCells = (r)=>(e.numberOfCells !== void 0 && !r || (e.cellSizes ? e.numberOfCells = e.cellSizes.length : e.numberOfCells = pS(t.getData())), e.numberOfCells), t.getCellSizes = (r)=>(e.cellSizes !== void 0 && !r || (e.cellSizes = hS(t.getData())), e.cellSizes), t.resize = (r)=>{
            const i = t.getNumberOfTuples();
            n.resize(r);
            const a = t.getNumberOfTuples();
            a < i && (a === 0 ? (e.numberOfCells = 0, e.cellSizes = []) : (e.numberOfCells = void 0, e.cellSizes = void 0));
        }, t.setData = (r)=>{
            n.setData(r, 1), e.numberOfCells = void 0, e.cellSizes = void 0;
        }, t.getCell = (r)=>{
            let i = r;
            const a = e.values[i++];
            return e.values.subarray(i, i + a);
        }, t.insertNextCell = (r)=>{
            const i = t.getNumberOfCells();
            return t.insertNextTuples([
                r.length,
                ...r
            ]), ++e.numberOfCells, e.cellSizes != null && e.cellSizes.push(r.length), i;
        };
    }
    function lA(t) {
        return {
            empty: !0,
            numberOfComponents: 1,
            dataType: qt.UNSIGNED_INT,
            ...t
        };
    }
    function mS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Wt.extend(t, e, lA(n)), cA(t, e);
    }
    const uA = K.newInstance(mS, "vtkCellArray");
    var W0 = {
        newInstance: uA,
        extend: mS,
        ...sA
    };
    const { vtkErrorMacro: fA } = K, dA = [
        1,
        -1,
        1,
        -1,
        1,
        -1
    ];
    function gA(t, e) {
        e.classHierarchy.push("vtkPoints"), t.getNumberOfPoints = t.getNumberOfTuples, t.setNumberOfPoints = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
            t.getNumberOfPoints() !== n && (e.size = n * r, e.values = K.newTypedArray(e.dataType, e.size), t.setNumberOfComponents(r), t.modified());
        }, t.setPoint = function(n) {
            for(var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a];
            t.setTuple(n, i);
        }, t.getPoint = t.getTuple, t.findPoint = t.findTuple, t.insertNextPoint = (n, r, i)=>t.insertNextTuple([
                n,
                r,
                i
            ]), t.getBounds = ()=>{
            if (t.getNumberOfComponents() === 3) {
                const i = t.getRange(0);
                e.bounds[0] = i[0], e.bounds[1] = i[1];
                const a = t.getRange(1);
                e.bounds[2] = a[0], e.bounds[3] = a[1];
                const o = t.getRange(2);
                return e.bounds[4] = o[0], e.bounds[5] = o[1], e.bounds;
            }
            if (t.getNumberOfComponents() !== 2) return fA(`getBounds called on an array with components of
        ${t.getNumberOfComponents()}`), dA;
            const n = t.getRange(0);
            e.bounds[0] = n[0], e.bounds[1] = n[1];
            const r = t.getRange(1);
            return e.bounds[2] = r[0], e.bounds[3] = r[1], e.bounds[4] = 0, e.bounds[5] = 0, e.bounds;
        }, t.computeBounds = t.getBounds, t.setNumberOfComponents(e.numberOfComponents < 2 ? 3 : e.numberOfComponents);
    }
    const hA = {
        empty: !0,
        numberOfComponents: 3,
        dataType: qt.FLOAT,
        bounds: [
            1,
            -1,
            1,
            -1,
            1,
            -1
        ]
    };
    function vS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, hA, n), Wt.extend(t, e, n), gA(t, e);
    }
    const pA = K.newInstance(vS, "vtkPoints");
    Pv = {
        newInstance: pA,
        extend: vS
    };
    function mA(t, e) {
        e.classHierarchy.push("vtkCell"), t.initialize = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (r) {
                e.pointsIds = r;
                let i = e.points.getData();
                i.length !== 3 * e.pointsIds.length && (i = K.newTypedArray(n.getDataType(), 3 * e.pointsIds.length));
                const a = n.getData();
                e.pointsIds.forEach((o, s)=>{
                    let c = 3 * o, l = 3 * s;
                    i[l] = a[c], i[++l] = a[++c], i[++l] = a[++c];
                }), e.points.setData(i);
            } else {
                e.points = n, e.pointsIds = new Array(n.getNumberOfPoints());
                for(let i = n.getNumberOfPoints() - 1; i >= 0; --i)e.pointsIds[i] = i;
            }
        }, t.getBounds = ()=>{
            const n = e.points.getNumberOfPoints(), r = [];
            if (n) {
                e.points.getPoint(0, r), e.bounds[0] = r[0], e.bounds[1] = r[0], e.bounds[2] = r[1], e.bounds[3] = r[1], e.bounds[4] = r[2], e.bounds[5] = r[2];
                for(let i = 1; i < n; i++)e.points.getPoint(i, r), e.bounds[0] = r[0] < e.bounds[0] ? r[0] : e.bounds[0], e.bounds[1] = r[0] > e.bounds[1] ? r[0] : e.bounds[1], e.bounds[2] = r[1] < e.bounds[2] ? r[1] : e.bounds[2], e.bounds[3] = r[1] > e.bounds[3] ? r[1] : e.bounds[3], e.bounds[4] = r[2] < e.bounds[4] ? r[2] : e.bounds[4], e.bounds[5] = r[2] > e.bounds[5] ? r[2] : e.bounds[5];
            } else af(e.bounds);
            return e.bounds;
        }, t.getLength2 = ()=>{
            t.getBounds();
            let n = 0, r = 0;
            for(let i = 0; i < 3; i++)r = e.bounds[2 * i + 1] - e.bounds[2 * i], n += r * r;
            return n;
        }, t.getParametricDistance = (n)=>{
            let r, i = 0;
            for(let a = 0; a < 3; a++)n[a] < 0 ? r = -n[a] : n[a] > 1 ? r = n[a] - 1 : r = 0, r > i && (i = r);
            return i;
        }, t.getNumberOfPoints = ()=>e.points.getNumberOfPoints(), t.deepCopy = (n)=>{
            n.initialize(e.points, e.pointsIds);
        }, t.getCellDimension = ()=>{}, t.intersectWithLine = (n, r, i, a, o, s, c)=>{}, t.evaluatePosition = (n, r, i, a, o, s)=>{
            K.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
        };
    }
    const vA = {
        bounds: [
            -1,
            -1,
            -1,
            -1,
            -1,
            -1
        ],
        pointsIds: []
    };
    function yS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, vA, n), K.obj(t, e), e.points || (e.points = Pv.newInstance()), K.get(t, e, [
            "points",
            "pointsIds"
        ]), mA(t, e);
    }
    const yA = K.newInstance(yS, "vtkCell");
    var Yh = {
        newInstance: yA,
        extend: yS
    };
    function CA(t, e) {
        let n = e;
        for(e >= t.array.length && (n += t.array.length); n > t.array.length;)t.array.push({
            ncells: 0,
            cells: null
        });
        t.array.length = n;
    }
    function wA(t, e) {
        e.classHierarchy.push("vtkCellLinks"), t.buildLinks = (n)=>{
            const r = n.getPoints().getNumberOfPoints(), i = n.getNumberOfCells(), a = new Uint32Array(r);
            if (n.isA("vtkPolyData")) {
                for(let o = 0; o < i; ++o){
                    const { cellPointIds: s } = n.getCellPoints(o);
                    s.forEach((c)=>{
                        t.incrementLinkCount(c);
                    });
                }
                t.allocateLinks(r), e.maxId = r - 1;
                for(let o = 0; o < i; ++o){
                    const { cellPointIds: s } = n.getCellPoints(o);
                    s.forEach((c)=>{
                        t.insertCellReference(c, a[c]++, o);
                    });
                }
            } else {
                for(let o = 0; o < i; o++)Yh.newInstance().getPointsIds().forEach((c)=>{
                    t.incrementLinkCount(c);
                });
                t.allocateLinks(r), e.maxId = r - 1;
                for(let o = 0; o < i; ++o)Yh.newInstance().getPointsIds().forEach((c)=>{
                    t.insertCellReference(c, a[c]++, o);
                });
            }
        }, t.allocate = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
            e.array = Array(n).fill().map(()=>({
                    ncells: 0,
                    cells: null
                })), e.extend = r, e.maxId = -1;
        }, t.initialize = ()=>{
            e.array = null;
        }, t.getLink = (n)=>e.array[n], t.getNcells = (n)=>e.array[n].ncells, t.getCells = (n)=>e.array[n].cells, t.insertNextPoint = (n)=>{
            e.array.push({
                ncells: n,
                cells: Array(n)
            }), ++e.maxId;
        }, t.insertNextCellReference = (n, r)=>{
            e.array[n].cells[e.array[n].ncells++] = r;
        }, t.deletePoint = (n)=>{
            e.array[n].ncells = 0, e.array[n].cells = null;
        }, t.removeCellReference = (n, r)=>{
            e.array[r].cells = e.array[r].cells.filter((i)=>i !== n), e.array[r].ncells = e.array[r].cells.length;
        }, t.addCellReference = (n, r)=>{
            e.array[r].cells[e.array[r].ncells++] = n;
        }, t.resizeCellList = (n, r)=>{
            e.array[n].cells.length = r;
        }, t.squeeze = ()=>{
            CA(e, e.maxId + 1);
        }, t.reset = ()=>{
            e.maxId = -1;
        }, t.deepCopy = (n)=>{
            e.array = [
                ...n.array
            ], e.extend = n.extend, e.maxId = n.maxId;
        }, t.incrementLinkCount = (n)=>{
            ++e.array[n].ncells;
        }, t.allocateLinks = (n)=>{
            for(let r = 0; r < n; ++r)e.array[r].cells = new Array(e.array[r].ncells);
        }, t.insertCellReference = (n, r, i)=>{
            e.array[n].cells[r] = i;
        };
    }
    const TA = {
        array: null,
        maxId: 0,
        extend: 0
    };
    function CS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, TA, n), K.obj(t, e), wA(t, e);
    }
    const xA = K.newInstance(CS, "vtkCellLinks");
    var SA = {
        newInstance: xA,
        extend: CS
    };
    const Zn = {
        VTK_EMPTY_CELL: 0,
        VTK_VERTEX: 1,
        VTK_POLY_VERTEX: 2,
        VTK_LINE: 3,
        VTK_POLY_LINE: 4,
        VTK_TRIANGLE: 5,
        VTK_TRIANGLE_STRIP: 6,
        VTK_POLYGON: 7,
        VTK_QUAD: 9,
        VTK_QUADRATIC_EDGE: 21,
        VTK_CONVEX_POINT_SET: 41,
        VTK_POLYHEDRON: 42
    }, Vv = [
        "vtkEmptyCell",
        "vtkVertex",
        "vtkPolyVertex",
        "vtkLine",
        "vtkPolyLine",
        "vtkTriangle",
        "vtkTriangleStrip",
        "vtkPolygon",
        "vtkPixel",
        "vtkQuad",
        "vtkTetra",
        "vtkVoxel",
        "vtkHexahedron",
        "vtkWedge",
        "vtkPyramid",
        "vtkPentagonalPrism",
        "vtkHexagonalPrism",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "vtkQuadraticEdge",
        "vtkQuadraticTriangle",
        "vtkQuadraticQuad",
        "vtkQuadraticTetra",
        "vtkQuadraticHexahedron",
        "vtkQuadraticWedge",
        "vtkQuadraticPyramid",
        "vtkBiQuadraticQuad",
        "vtkTriQuadraticHexahedron",
        "vtkQuadraticLinearQuad",
        "vtkQuadraticLinearWedge",
        "vtkBiQuadraticQuadraticWedge",
        "vtkBiQuadraticQuadraticHexahedron",
        "vtkBiQuadraticTriangle",
        "vtkCubicLine",
        "vtkQuadraticPolygon",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "vtkConvexPointSet",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "vtkParametricCurve",
        "vtkParametricSurface",
        "vtkParametricTriSurface",
        "vtkParametricQuadSurface",
        "vtkParametricTetraRegion",
        "vtkParametricHexRegion",
        "UnknownClass",
        "UnknownClass",
        "UnknownClass",
        "vtkHigherOrderEdge",
        "vtkHigherOrderTriangle",
        "vtkHigherOrderQuad",
        "vtkHigherOrderPolygon",
        "vtkHigherOrderTetrahedron",
        "vtkHigherOrderWedge",
        "vtkHigherOrderPyramid",
        "vtkHigherOrderHexahedron"
    ];
    function EA(t) {
        return t < Vv.length ? Vv[t] : "UnknownClass";
    }
    function DA(t) {
        return Vv.findIndex(t);
    }
    function _A(t) {
        return t < Zn.VTK_QUADRATIC_EDGE || t === Zn.VTK_CONVEX_POINT_SET || t === Zn.VTK_POLYHEDRON;
    }
    function RA(t) {
        return t === Zn.VTK_TRIANGLE_STRIP || t === Zn.VTK_POLY_LINE || t === Zn.VTK_POLY_VERTEX;
    }
    const OA = {
        getClassNameFromTypeId: EA,
        getTypeIdFromClassName: DA,
        isLinear: _A,
        hasSubCells: RA
    };
    function IA(t, e) {
        e.classHierarchy.push("vtkCellTypes"), t.allocate = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
            e.size = n > 0 ? n : 1, e.extend = r > 0 ? r : 1, e.maxId = -1, e.typeArray = new Uint8Array(n), e.locationArray = new Uint32Array(n);
        }, t.insertCell = (n, r, i)=>{
            e.typeArray[n] = r, e.locationArray[n] = i, n > e.maxId && (e.maxId = n);
        }, t.insertNextCell = (n, r)=>(t.insertCell(++e.maxId, n, r), e.maxId), t.setCellTypes = (n, r, i)=>{
            e.size = n, e.typeArray = r, e.locationArray = i, e.maxId = n - 1;
        }, t.getCellLocation = (n)=>e.locationArray[n], t.deleteCell = (n)=>{
            e.typeArray[n] = Zn.VTK_EMPTY_CELL;
        }, t.getNumberOfTypes = ()=>e.maxId + 1, t.isType = (n)=>{
            const r = t.getNumberOfTypes();
            for(let i = 0; i < r; ++i)if (n === t.getCellType(i)) return !0;
            return !1;
        }, t.insertNextType = (n)=>t.insertNextCell(n, -1), t.getCellType = (n)=>e.typeArray[n], t.reset = ()=>{
            e.maxId = -1;
        }, t.deepCopy = (n)=>{
            t.allocate(n.getSize(), n.getExtend()), e.typeArray.set(n.getTypeArray()), e.locationArray.set(n.getLocationArray()), e.maxId = n.getMaxId();
        };
    }
    const MA = {
        size: 0,
        maxId: -1,
        extend: 1e3
    };
    function wS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, MA, n), K.obj(t, e), K.get(t, e, [
            "size",
            "maxId",
            "extend"
        ]), K.getArray(t, e, [
            "typeArray",
            "locationArray"
        ]), IA(t, e);
    }
    const bA = K.newInstance(wS, "vtkCellTypes");
    var LA = {
        newInstance: bA,
        extend: wS,
        ...OA
    };
    const PA = {
        NO_INTERSECTION: 0,
        YES_INTERSECTION: 1,
        ON_LINE: 2
    };
    var TS = {
        IntersectionState: PA
    };
    const { IntersectionState: uh } = TS;
    function Iu(t, e, n) {
        let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        const i = {
            t: Number.MIN_VALUE,
            distance: 0
        }, a = [];
        let o;
        a[0] = n[0] - e[0], a[1] = n[1] - e[1], a[2] = n[2] - e[2];
        const s = a[0] * (t[0] - e[0]) + a[1] * (t[1] - e[1]) + a[2] * (t[2] - e[2]), c = $t(a, a);
        let l = 1e-5 * s;
        return c !== 0 && (i.t = s / c), l < 0 && (l = -l), -l < c && c < l || c <= 0 || i.t < 0 ? o = e : i.t > 1 ? o = n : (o = a, a[0] = e[0] + i.t * a[0], a[1] = e[1] + i.t * a[1], a[2] = e[2] + i.t * a[2]), r && (r[0] = o[0], r[1] = o[1], r[2] = o[2]), i.distance = Hs(o, t), i;
    }
    function xS(t, e, n, r, i, a) {
        const o = [], s = [], c = [];
        i[0] = 0, a[0] = 0, zc(e, t, o), zc(r, n, s), zc(n, t, c);
        const l = [
            $t(o, o),
            -$t(o, s),
            -$t(o, s),
            $t(s, s)
        ], f = [];
        if (f[0] = $t(o, c), f[1] = -$t(s, c), WT(l, f, 2) === 0) {
            let u = Number.MAX_VALUE;
            const g = [
                t,
                e,
                n,
                r
            ], h = [
                n,
                n,
                t,
                t
            ], v = [
                r,
                r,
                e,
                e
            ];
            a[0], a[0], i[0], i[0], i[0], i[0], a[0], a[0];
            let m;
            for(let y = 0; y < 4; y++)m = Iu(g[y], h[y], v[y]), m.distance < u && (u = m.distance, m.t);
            return uh.ON_LINE;
        }
        return i[0] = f[0], a[0] = f[1], i[0] >= 0 && i[0] <= 1 && a[0] >= 0 && a[0] <= 1 ? uh.YES_INTERSECTION : uh.NO_INTERSECTION;
    }
    const VA = {
        distanceToLine: Iu,
        intersection: xS
    };
    function NA(t, e) {
        e.classHierarchy.push("vtkLine");
        function n(r) {
            return r >= 0 && r <= 1;
        }
        t.getCellDimension = ()=>1, t.intersectWithLine = (r, i, a, o, s)=>{
            const c = {
                intersect: 0,
                t: Number.MAX_VALUE,
                subId: 0,
                betweenPoints: null
            };
            s[1] = 0, s[2] = 0;
            const l = [], f = [], u = [];
            e.points.getPoint(0, f), e.points.getPoint(1, u);
            const g = [], h = [], v = xS(r, i, f, u, g, h);
            if (c.t = g[0], c.betweenPoints = n(c.t), s[0] = h[0], v === uh.YES_INTERSECTION) {
                for(let m = 0; m < 3; m++)o[m] = f[m] + s[0] * (u[m] - f[m]), l[m] = r[m] + c.t * (i[m] - r[m]);
                if (Hs(o, l) <= a * a) return c.intersect = 1, c;
            } else {
                let m;
                if (c.t < 0) return m = Iu(r, f, u, o), m.distance <= a * a && (c.t = 0, c.intersect = 1, c.betweenPoints = !0), c;
                if (c.t > 1) return m = Iu(i, f, u, o), m.distance <= a * a && (c.t = 1, c.intersect = 1, c.betweenPoints = !0), c;
                if (s[0] < 0) return s[0] = 0, m = Iu(f, r, i, o), c.t = m.t, m.distance <= a * a && (c.intersect = 1), c;
                if (s[0] > 1) return s[0] = 1, m = Iu(u, r, i, o), c.t = m.t, m.distance <= a * a && (c.intersect = 1), c;
            }
            return c;
        }, t.evaluateLocation = (r, i, a)=>{
            const o = [], s = [];
            e.points.getPoint(0, o), e.points.getPoint(1, s);
            for(let c = 0; c < 3; c++)i[c] = o[c] + r[0] * (s[c] - o[c]);
            a[0] = 1 - r[0], a[1] = r[0];
        }, t.evaluateOrientation = (r, i, a)=>e.orientations ? (oh(i, e.orientations[0], e.orientations[1], r[0]), a[0] = 1 - r[0], a[1] = r[0], !0) : !1;
    }
    const AA = {
        orientations: null
    };
    function SS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, AA, n), Yh.extend(t, e, n), K.setGet(t, e, [
            "orientations"
        ]), NA(t, e);
    }
    const kA = K.newInstance(SS, "vtkLine");
    var Ko = {
        newInstance: kA,
        extend: SS,
        ...VA,
        ...TS
    };
    const { vtkErrorMacro: A9, vtkWarningMacro: UA } = K;
    function FA(t, e) {
        e.classHierarchy.push("vtkFieldData");
        const n = t.getState;
        e.arrays && (e.arrays = e.arrays.map((r)=>({
                data: vs(r.data)
            }))), t.initialize = ()=>{
            t.initializeFields(), t.copyAllOn(), t.clearFieldFlags();
        }, t.initializeFields = ()=>{
            e.arrays = [], e.copyFieldFlags = {}, t.modified();
        }, t.copyStructure = (r)=>{
            t.initializeFields(), e.copyFieldFlags = r.getCopyFieldFlags().map((i)=>i), e.arrays = r.arrays().map((i)=>({
                    array: i
                }));
        }, t.getNumberOfArrays = ()=>e.arrays.length, t.getNumberOfActiveArrays = ()=>e.arrays.length, t.addArray = (r)=>{
            const i = r.getName(), { array: a, index: o } = t.getArrayWithIndex(i);
            return a != null ? (e.arrays[o] = {
                data: r
            }, o) : (e.arrays = [].concat(e.arrays, {
                data: r
            }), e.arrays.length - 1);
        }, t.removeAllArrays = ()=>{
            e.arrays = [];
        }, t.removeArray = (r)=>{
            const i = e.arrays.findIndex((a)=>a.data.getName() === r);
            return t.removeArrayByIndex(i);
        }, t.removeArrayByIndex = (r)=>r !== -1 && r < e.arrays.length ? (e.arrays.splice(r, 1), !0) : !1, t.getArrays = ()=>e.arrays.map((r)=>r.data), t.getArray = (r)=>typeof r == "number" ? t.getArrayByIndex(r) : t.getArrayByName(r), t.getArrayByName = (r)=>e.arrays.reduce((i, a, o)=>a.data.getName() === r ? a.data : i, null), t.getArrayWithIndex = (r)=>{
            const i = e.arrays.findIndex((a)=>a.data.getName() === r);
            return {
                array: i !== -1 ? e.arrays[i].data : null,
                index: i
            };
        }, t.getArrayByIndex = (r)=>r >= 0 && r < e.arrays.length ? e.arrays[r].data : null, t.hasArray = (r)=>t.getArrayWithIndex(r).index >= 0, t.getArrayName = (r)=>{
            const i = e.arrays[r];
            return i ? i.data.getName() : "";
        }, t.getCopyFieldFlags = ()=>e.copyFieldFlags, t.getFlag = (r)=>e.copyFieldFlags[r], t.passData = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
            r.getArrays().forEach((o)=>{
                const s = t.getFlag(o.getName());
                if (s !== !1 && !(e.doCopyAllOff && s !== !0) && o) {
                    let c = t.getArrayByName(o.getName());
                    if (c) if (o.getNumberOfComponents() === c.getNumberOfComponents()) if (i > -1 && i < o.getNumberOfTuples()) {
                        const l = a > -1 ? a : i;
                        c.insertTuple(l, o.getTuple(i));
                    } else c.insertTuples(0, o.getTuples());
                    else A9("Unhandled case in passData");
                    else if (i < 0 || i > o.getNumberOfTuples()) t.addArray(o), r.getAttributes(o).forEach((l)=>{
                        t.setAttribute(o, l);
                    });
                    else {
                        const l = o.getNumberOfComponents();
                        let f = o.getNumberOfValues();
                        const u = a > -1 ? a : i;
                        f <= u * l && (f = (u + 1) * l), c = Wt.newInstance({
                            name: o.getName(),
                            dataType: o.getDataType(),
                            numberOfComponents: l,
                            values: K.newTypedArray(o.getDataType(), f),
                            size: 0
                        }), c.insertTuple(u, o.getTuple(i)), t.addArray(c), r.getAttributes(o).forEach((g)=>{
                            t.setAttribute(c, g);
                        });
                    }
                }
            });
        }, t.interpolateData = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : .5;
            r.getArrays().forEach((c)=>{
                const l = t.getFlag(c.getName());
                if (l !== !1 && !(e.doCopyAllOff && l !== !0) && c) {
                    let f = t.getArrayByName(c.getName());
                    if (f) if (c.getNumberOfComponents() === f.getNumberOfComponents()) if (i > -1 && i < c.getNumberOfTuples()) {
                        const u = o > -1 ? o : i;
                        f.interpolateTuple(u, c, i, c, a, s), UA("Unexpected case in interpolateData");
                    } else f.insertTuples(c.getTuples());
                    else A9("Unhandled case in interpolateData");
                    else if (i < 0 || a < 0 || i > c.getNumberOfTuples()) t.addArray(c), r.getAttributes(c).forEach((u)=>{
                        t.setAttribute(c, u);
                    });
                    else {
                        const u = c.getNumberOfComponents();
                        let g = c.getNumberOfValues();
                        const h = o > -1 ? o : i;
                        g <= h * u && (g = (h + 1) * u), f = Wt.newInstance({
                            name: c.getName(),
                            dataType: c.getDataType(),
                            numberOfComponents: u,
                            values: K.newTypedArray(c.getDataType(), g),
                            size: 0
                        }), f.interpolateTuple(h, c, i, c, a, s), t.addArray(f), r.getAttributes(c).forEach((v)=>{
                            t.setAttribute(f, v);
                        });
                    }
                }
            });
        }, t.copyFieldOn = (r)=>{
            e.copyFieldFlags[r] = !0;
        }, t.copyFieldOff = (r)=>{
            e.copyFieldFlags[r] = !1;
        }, t.copyAllOn = ()=>{
            (!e.doCopyAllOn || e.doCopyAllOff) && (e.doCopyAllOn = !0, e.doCopyAllOff = !1, t.modified());
        }, t.copyAllOff = ()=>{
            (e.doCopyAllOn || !e.doCopyAllOff) && (e.doCopyAllOn = !1, e.doCopyAllOff = !0, t.modified());
        }, t.clearFieldFlags = ()=>{
            e.copyFieldFlags = {};
        }, t.deepCopy = (r)=>{
            e.arrays = r.getArrays().map((i)=>{
                const a = i.newClone();
                return a.deepCopy(i), {
                    data: a
                };
            });
        }, t.copyFlags = (r)=>r.getCopyFieldFlags().map((i)=>i), t.reset = ()=>e.arrays.forEach((r)=>r.data.reset()), t.getMTime = ()=>e.arrays.reduce((r, i)=>i.data.getMTime() > r ? i.data.getMTime() : r, e.mtime), t.getNumberOfComponents = ()=>e.arrays.reduce((r, i)=>r + i.data.getNumberOfComponents(), 0), t.getNumberOfTuples = ()=>e.arrays.length > 0 ? e.arrays[0].getNumberOfTuples() : 0, t.getState = ()=>{
            const r = n();
            return r && (r.arrays = e.arrays.map((i)=>({
                    data: i.data.getState()
                }))), r;
        };
    }
    const BA = {
        arrays: [],
        copyFieldFlags: [],
        doCopyAllOn: !0,
        doCopyAllOff: !1
    };
    function ES(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, BA, n), K.obj(t, e), FA(t, e);
    }
    const GA = K.newInstance(ES, "vtkFieldData");
    var WA = {
        newInstance: GA,
        extend: ES
    };
    const $A = {
        SCALARS: 0,
        VECTORS: 1,
        NORMALS: 2,
        TCOORDS: 3,
        TENSORS: 4,
        GLOBALIDS: 5,
        PEDIGREEIDS: 6,
        EDGEFLAG: 7,
        NUM_ATTRIBUTES: 8
    }, zA = {
        MAX: 0,
        EXACT: 1,
        NOLIMIT: 2
    }, jA = {
        DUPLICATECELL: 1,
        HIGHCONNECTIVITYCELL: 2,
        LOWCONNECTIVITYCELL: 4,
        REFINEDCELL: 8,
        EXTERIORCELL: 16,
        HIDDENCELL: 32
    }, HA = {
        DUPLICATEPOINT: 1,
        HIDDENPOINT: 2
    }, KA = {
        COPYTUPLE: 0,
        INTERPOLATE: 1,
        PASSDATA: 2,
        ALLCOPY: 3
    }, qA = "vtkGhostType", XA = {
        DEFAULT: 0,
        SINGLE: 1,
        DOUBLE: 2
    };
    var DS = {
        AttributeCopyOperations: KA,
        AttributeLimitTypes: zA,
        AttributeTypes: $A,
        CellGhostTypes: jA,
        DesiredOutputPrecision: XA,
        PointGhostTypes: HA,
        ghostArrayName: qA
    };
    const { AttributeTypes: vl, AttributeCopyOperations: d0 } = DS, { vtkWarningMacro: y1 } = K;
    function YA(t, e) {
        const n = [
            "Scalars",
            "Vectors",
            "Normals",
            "TCoords",
            "Tensors",
            "GlobalIds",
            "PedigreeIds"
        ];
        function r(o) {
            let s = n.find((c)=>vl[c.toUpperCase()] === o || typeof o != "number" && c.toLowerCase() === o.toLowerCase());
            return typeof s > "u" && (s = null), s;
        }
        e.classHierarchy.push("vtkDataSetAttributes");
        const i = {
            ...t
        };
        t.checkNumberOfComponents = (o)=>!0, t.setAttribute = (o, s)=>{
            const c = r(s);
            if (o && c.toUpperCase() === "PEDIGREEIDS" && !o.isA("vtkDataArray")) return y1(`Cannot set attribute ${c}. The attribute must be a vtkDataArray.`), -1;
            if (o && !t.checkNumberOfComponents(o, c)) return y1(`Cannot set attribute ${c}. Incorrect number of components.`), -1;
            let l = e[`active${c}`];
            if (l >= 0 && l < e.arrays.length) {
                if (e.arrays[l] === o) return l;
                t.removeArrayByIndex(l);
            }
            return o ? (l = t.addArray(o), e[`active${c}`] = l) : e[`active${c}`] = -1, t.modified(), e[`active${c}`];
        }, t.getAttributes = (o)=>n.filter((s)=>t[`get${s}`]() === o), t.setActiveAttributeByName = (o, s)=>t.setActiveAttributeByIndex(t.getArrayWithIndex(o).index, s), t.setActiveAttributeByIndex = (o, s)=>{
            const c = r(s);
            if (o >= 0 && o < e.arrays.length) {
                if (c.toUpperCase() !== "PEDIGREEIDS") {
                    const l = t.getArrayByIndex(o);
                    if (!l.isA("vtkDataArray")) return y1(`Cannot set attribute ${c}. Only vtkDataArray subclasses can be set as active attributes.`), -1;
                    if (!t.checkNumberOfComponents(l, c)) return y1(`Cannot set attribute ${c}. Incorrect number of components.`), -1;
                }
                return e[`active${c}`] = o, t.modified(), o;
            }
            return o === -1 && (e[`active${c}`] = o, t.modified()), -1;
        }, t.getActiveAttribute = (o)=>{
            const s = r(o);
            return t[`get${s}`]();
        }, t.removeAllArrays = ()=>{
            n.forEach((o)=>{
                e[`active${o}`] = -1;
            }), i.removeAllArrays();
        }, t.removeArrayByIndex = (o)=>(o !== -1 && n.forEach((s)=>{
                o === e[`active${s}`] ? e[`active${s}`] = -1 : o < e[`active${s}`] && (e[`active${s}`] -= 1);
            }), i.removeArrayByIndex(o)), n.forEach((o)=>{
            const s = `active${o}`;
            t[`get${o}`] = ()=>t.getArrayByIndex(e[s]), t[`set${o}`] = (c)=>t.setAttribute(c, o), t[`setActive${o}`] = (c)=>t.setActiveAttributeByIndex(t.getArrayWithIndex(c).index, o), t[`copy${o}Off`] = ()=>{
                const c = o.toUpperCase();
                e.copyAttributeFlags[d0.PASSDATA][vl[c]] = !1;
            }, t[`copy${o}On`] = ()=>{
                const c = o.toUpperCase();
                e.copyAttributeFlags[d0.PASSDATA][vl[c]] = !0;
            };
        }), t.initializeAttributeCopyFlags = ()=>{
            e.copyAttributeFlags = [], Object.keys(d0).filter((o)=>o !== "ALLCOPY").forEach((o)=>{
                e.copyAttributeFlags[d0[o]] = Object.keys(vl).filter((s)=>s !== "NUM_ATTRIBUTES").reduce((s, c)=>(s[vl[c]] = !0, s), []);
            }), e.copyAttributeFlags[d0.COPYTUPLE][vl.GLOBALIDS] = !1, e.copyAttributeFlags[d0.INTERPOLATE][vl.GLOBALIDS] = !1, e.copyAttributeFlags[d0.COPYTUPLE][vl.PEDIGREEIDS] = !1;
        }, t.initialize = K.chain(t.initialize, t.initializeAttributeCopyFlags), e.dataArrays && Object.keys(e.dataArrays).length && Object.keys(e.dataArrays).forEach((o)=>{
            !e.dataArrays[o].ref && e.dataArrays[o].type === "vtkDataArray" && t.addArray(Wt.newInstance(e.dataArrays[o]));
        });
        const a = t.shallowCopy;
        t.shallowCopy = (o, s)=>{
            a(o, s), e.arrays = o.getArrays().map((c)=>{
                const l = c.newClone();
                return l.shallowCopy(c, s), {
                    data: l
                };
            });
        }, t.initializeAttributeCopyFlags();
    }
    const ZA = {
        activeScalars: -1,
        activeVectors: -1,
        activeTensors: -1,
        activeNormals: -1,
        activeTCoords: -1,
        activeGlobalIds: -1,
        activePedigreeIds: -1
    };
    function _S(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, ZA, n), WA.extend(t, e, n), K.setGet(t, e, [
            "activeScalars",
            "activeNormals",
            "activeTCoords",
            "activeVectors",
            "activeTensors",
            "activeGlobalIds",
            "activePedigreeIds"
        ]), e.arrays || (e.arrays = {}), YA(t, e);
    }
    const JA = K.newInstance(_S, "vtkDataSetAttributes");
    var k9 = {
        newInstance: JA,
        extend: _S,
        ...DS
    };
    const QA = {
        UNIFORM: 0,
        DATA_OBJECT_FIELD: 0,
        COORDINATE: 1,
        POINT_DATA: 1,
        POINT: 2,
        POINT_FIELD_DATA: 2,
        CELL: 3,
        CELL_FIELD_DATA: 3,
        VERTEX: 4,
        VERTEX_FIELD_DATA: 4,
        EDGE: 5,
        EDGE_FIELD_DATA: 5,
        ROW: 6,
        ROW_DATA: 6
    }, ek = {
        FIELD_ASSOCIATION_POINTS: 0,
        FIELD_ASSOCIATION_CELLS: 1,
        FIELD_ASSOCIATION_NONE: 2,
        FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
        FIELD_ASSOCIATION_VERTICES: 4,
        FIELD_ASSOCIATION_EDGES: 5,
        FIELD_ASSOCIATION_ROWS: 6,
        NUMBER_OF_ASSOCIATIONS: 7
    };
    var tk = {
        FieldDataTypes: QA,
        FieldAssociations: ek
    };
    const Nv = [
        "pointData",
        "cellData",
        "fieldData"
    ];
    function nk(t, e) {
        e.classHierarchy.push("vtkDataSet"), Nv.forEach((r)=>{
            e[r] ? e[r] = vs(e[r]) : e[r] = k9.newInstance();
        });
        const n = t.shallowCopy;
        t.shallowCopy = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            n(r, i), Nv.forEach((a)=>{
                e[a] = k9.newInstance(), e[a].shallowCopy(r.getReferenceByName(a));
            });
        };
    }
    const rk = {};
    function RS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, rk, n), K.obj(t, e), K.setGet(t, e, Nv), nk(t, e);
    }
    const ik = K.newInstance(RS, "vtkDataSet");
    var of = {
        newInstance: ik,
        extend: RS,
        ...tk
    };
    function ak(t, e) {
        e.classHierarchy.push("vtkPointSet"), e.points ? e.points = vs(e.points) : e.points = Pv.newInstance(), t.getNumberOfPoints = ()=>e.points.getNumberOfPoints(), t.getBounds = ()=>e.points.getBounds(), t.computeBounds = ()=>{
            t.getBounds();
        };
        const n = t.shallowCopy;
        t.shallowCopy = function(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            n(r, i), e.points = Pv.newInstance(), e.points.shallowCopy(r.getPoints());
        };
    }
    const ok = {};
    function OS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, ok, n), of.extend(t, e, n), K.setGet(t, e, [
            "points"
        ]), ak(t, e);
    }
    const sk = K.newInstance(OS, "vtkPointSet");
    var ck = {
        newInstance: sk,
        extend: OS
    };
    function s4(t, e, n, r) {
        const i = n[0] - e[0], a = n[1] - e[1], o = n[2] - e[2], s = t[0] - e[0], c = t[1] - e[1], l = t[2] - e[2];
        r[0] = a * l - o * c, r[1] = o * s - i * l, r[2] = i * c - a * s;
    }
    function Zh(t, e, n, r) {
        s4(t, e, n, r);
        const i = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]);
        i !== 0 && (r[0] /= i, r[1] /= i, r[2] /= i);
    }
    function lk(t, e, n, r, i, a) {
        let o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6, s = !1;
        const c = [], l = [], f = [], u = [], g = [];
        Zh(t, e, n, u), Zh(r, i, a, g);
        const h = -$t(u, t), v = -$t(g, r), m = [
            $t(g, t) + v,
            $t(g, e) + v,
            $t(g, n) + v
        ];
        if (m[0] * m[1] > o && m[0] * m[2] > o) return {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        };
        const y = [
            $t(u, r) + h,
            $t(u, i) + h,
            $t(u, a) + h
        ];
        if (y[0] * y[1] > o && y[0] * y[2] > o) return {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        };
        if (Math.abs(u[0] - g[0]) < 1e-9 && Math.abs(u[1] - g[1]) < 1e-9 && Math.abs(u[2] - g[2]) < 1e-9 && Math.abs(h - v) < 1e-9) return s = !0, {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        };
        const C = [
            t,
            e,
            n
        ], T = [
            r,
            i,
            a
        ], x = $t(u, g), S = (h - v * x) / (x * x - 1), D = (v - h * x) / (x * x - 1), _ = [
            S * u[0] + D * g[0],
            S * u[1] + D * g[1],
            S * u[2] + D * g[2]
        ], M = tc(u, g, []);
        F0(M);
        let P = 0, F = 0;
        const N = [], B = [];
        let G = 50, Z = 50;
        for(let ae = 0; ae < 3; ae++){
            const ue = ae, le = (ae + 1) % 3, oe = ca.intersectWithLine(C[ue], C[le], r, g);
            oe.intersection && oe.t > 0 - o && oe.t < 1 + o && (oe.t < 1 + o && oe.t > 1 - o && (G = P), N[P++] = $t(oe.x, M) - $t(_, M));
            const re = ca.intersectWithLine(T[ue], T[le], t, u);
            re.intersection && re.t > 0 - o && re.t < 1 + o && (re.t < 1 + o && re.t > 1 - o && (Z = F), B[F++] = $t(re.x, M) - $t(_, M));
        }
        if (P > 2) {
            P--;
            const ae = N[2];
            N[2] = N[G], N[G] = ae;
        }
        if (F > 2) {
            F--;
            const ae = B[2];
            B[2] = B[Z], B[Z] = ae;
        }
        if (P !== 2 || F !== 2) return {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        };
        if (Number.isNaN(N[0]) || Number.isNaN(N[1]) || Number.isNaN(B[0]) || Number.isNaN(B[1])) return {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        };
        if (N[0] > N[1]) {
            const ae = N[1];
            N[1] = N[0], N[0] = ae;
        }
        if (B[0] > B[1]) {
            const ae = B[1];
            B[1] = B[0], B[0] = ae;
        }
        let H, ne;
        return N[1] < B[0] || B[1] < N[0] ? {
            intersect: !1,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        } : (N[0] < B[0] ? N[1] < B[1] ? (f[0] = 2, f[1] = 1, H = B[0], ne = N[1]) : (f[0] = 2, f[1] = 2, H = B[0], ne = B[1]) : N[1] < B[1] ? (f[0] = 1, f[1] = 1, H = N[0], ne = N[1]) : (f[0] = 1, f[1] = 2, H = N[0], ne = B[1]), vv(_, M, H, c), vv(_, M, ne, l), {
            intersect: !0,
            coplanar: s,
            pt1: c,
            pt2: l,
            surfaceId: f
        });
    }
    const uk = {
        computeNormalDirection: s4,
        computeNormal: Zh,
        intersectWithTriangle: lk
    };
    function fk(t, e) {
        e.classHierarchy.push("vtkTriangle"), t.getCellDimension = ()=>2, t.intersectWithLine = (n, r, i, a, o)=>{
            const s = {
                subId: 0,
                t: Number.MAX_VALUE,
                intersect: 0,
                betweenPoints: !1
            };
            o[2] = 0;
            const c = [], l = i * i, f = [], u = [], g = [];
            e.points.getPoint(0, f), e.points.getPoint(1, u), e.points.getPoint(2, g);
            const h = [], v = [];
            if (Zh(f, u, g, h), h[0] !== 0 || h[1] !== 0 || h[2] !== 0) {
                const x = ca.intersectWithLine(n, r, f, h);
                if (s.betweenPoints = x.betweenPoints, s.t = x.t, a[0] = x.x[0], a[1] = x.x[1], a[2] = x.x[2], !x.intersection) return o[0] = 0, o[1] = 0, s.intersect = 0, s;
                const S = t.evaluatePosition(a, c, o, v);
                if (S.evaluation >= 0) return S.dist2 <= l ? (s.intersect = 1, s) : (s.intersect = S.evaluation, s);
            }
            const m = Hs(f, u), y = Hs(u, g), C = Hs(g, f);
            e.line || (e.line = Ko.newInstance()), m > y && m > C ? (e.line.getPoints().setPoint(0, f), e.line.getPoints().setPoint(1, u)) : y > C && y > m ? (e.line.getPoints().setPoint(0, u), e.line.getPoints().setPoint(1, g)) : (e.line.getPoints().setPoint(0, g), e.line.getPoints().setPoint(1, f));
            const T = e.line.intersectWithLine(n, r, i, a, o);
            if (s.betweenPoints = T.betweenPoints, s.t = T.t, T.intersect) {
                const x = [], S = [], D = [];
                for(let _ = 0; _ < 3; _++)x[_] = f[_] - g[_], S[_] = u[_] - g[_], D[_] = a[_] - g[_];
                return o[0] = $t(D, x) / C, o[1] = $t(D, S) / y, s.intersect = 1, s;
            }
            return o[0] = 0, o[1] = 0, s.intersect = 0, s;
        }, t.evaluatePosition = (n, r, i, a)=>{
            const o = {
                subId: 0,
                dist2: 0,
                evaluation: -1
            };
            let s, c;
            const l = [], f = [], u = [], g = [];
            let h;
            const v = [], m = [], y = [];
            let C = 0, T = 0;
            const x = [];
            let S, D, _, M = [];
            const P = [], F = [], N = [];
            o.subId = 0, i[2] = 0, e.points.getPoint(1, l), e.points.getPoint(2, f), e.points.getPoint(0, u), s4(l, f, u, g), ca.generalizedProjectPoint(n, l, g, N);
            let B = 0;
            for(s = 0; s < 3; s++)g[s] < 0 ? h = -g[s] : h = g[s], h > B && (B = h, T = s);
            for(c = 0, s = 0; s < 3; s++)s !== T && (x[c++] = s);
            for(s = 0; s < 2; s++)v[s] = N[x[s]] - u[x[s]], m[s] = l[x[s]] - u[x[s]], y[s] = f[x[s]] - u[x[s]];
            if (C = Dr(m, y), C === 0) return i[0] = 0, i[1] = 0, o.evaluation = -1, o;
            if (i[0] = Dr(v, y) / C, i[1] = Dr(m, v) / C, a[0] = 1 - (i[0] + i[1]), a[1] = i[0], a[2] = i[1], a[0] >= 0 && a[0] <= 1 && a[1] >= 0 && a[1] <= 1 && a[2] >= 0 && a[2] <= 1) r && (o.dist2 = Hs(N, n), r[0] = N[0], r[1] = N[1], r[2] = N[2]), o.evaluation = 1;
            else {
                let G;
                if (r) {
                    if (a[1] < 0 && a[2] < 0) for(S = Hs(n, u), D = Ko.distanceToLine(n, l, u, G, P), _ = Ko.distanceToLine(n, u, f, G, F), S < D ? (o.dist2 = S, M = u) : (o.dist2 = D, M = P), _ < o.dist2 && (o.dist2 = _, M = F), s = 0; s < 3; s++)r[s] = M[s];
                    else if (a[2] < 0 && a[0] < 0) for(S = Hs(n, l), D = Ko.distanceToLine(n, l, u, G, P), _ = Ko.distanceToLine(n, l, f, G, F), S < D ? (o.dist2 = S, M = l) : (o.dist2 = D, M = P), _ < o.dist2 && (o.dist2 = _, M = F), s = 0; s < 3; s++)r[s] = M[s];
                    else if (a[1] < 0 && a[0] < 0) for(S = Hs(n, f), D = Ko.distanceToLine(n, f, u, G, P), _ = Ko.distanceToLine(n, l, f, G, F), S < D ? (o.dist2 = S, M = f) : (o.dist2 = D, M = P), _ < o.dist2 && (o.dist2 = _, M = F), s = 0; s < 3; s++)r[s] = M[s];
                    else if (a[0] < 0) {
                        const Z = Ko.distanceToLine(n, l, f, r);
                        o.dist2 = Z.distance;
                    } else if (a[1] < 0) {
                        const Z = Ko.distanceToLine(n, f, u, r);
                        o.dist2 = Z.distance;
                    } else if (a[2] < 0) {
                        const Z = Ko.distanceToLine(n, l, u, r);
                        o.dist2 = Z.distance;
                    }
                }
                o.evaluation = 0;
            }
            return o;
        }, t.evaluateLocation = (n, r, i)=>{
            const a = [], o = [], s = [];
            e.points.getPoint(0, a), e.points.getPoint(1, o), e.points.getPoint(2, s);
            const c = 1 - n[0] - n[1];
            for(let l = 0; l < 3; l++)r[l] = a[l] * c + o[l] * n[0] + s[l] * n[1];
            i[0] = c, i[1] = n[0], i[2] = n[1];
        }, t.getParametricDistance = (n)=>{
            let r, i = 0;
            const a = [];
            a[0] = n[0], a[1] = n[1], a[2] = 1 - n[0] - n[1];
            for(let o = 0; o < 3; o++)a[o] < 0 ? r = -a[o] : a[o] > 1 ? r = a[o] - 1 : r = 0, r > i && (i = r);
            return i;
        };
    }
    const dk = {};
    function IS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, dk, n), Yh.extend(t, e, n), fk(t, e);
    }
    const gk = K.newInstance(IS, "vtkTriangle");
    hk = {
        newInstance: gk,
        extend: IS,
        ...uk
    };
    const g5 = [
        "verts",
        "lines",
        "polys",
        "strips"
    ], { vtkWarningMacro: U9 } = K, pk = {
        [Zn.VTK_LINE]: Ko,
        [Zn.VTK_POLY_LINE]: Ko,
        [Zn.VTK_TRIANGLE]: hk
    };
    function mk(t, e) {
        e.classHierarchy.push("vtkPolyData");
        function n(i) {
            return i.replace(/(?:^\w|[A-Z]|\b\w)/g, (a)=>a.toUpperCase()).replace(/\s+/g, "");
        }
        g5.forEach((i)=>{
            t[`getNumberOf${n(i)}`] = ()=>e[i].getNumberOfCells(), e[i] ? e[i] = vs(e[i]) : e[i] = W0.newInstance();
        }), t.getNumberOfCells = ()=>g5.reduce((i, a)=>i + e[a].getNumberOfCells(), 0);
        const r = t.shallowCopy;
        t.shallowCopy = function(i) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            r(i, a), g5.forEach((o)=>{
                e[o] = W0.newInstance(), e[o].shallowCopy(i.getReferenceByName(o));
            });
        }, t.buildCells = ()=>{
            const i = t.getNumberOfVerts(), a = t.getNumberOfLines(), o = t.getNumberOfPolys(), s = t.getNumberOfStrips(), c = i + a + o + s, l = new Uint8Array(c);
            let f = l;
            const u = new Uint32Array(c);
            let g = u;
            if (i) {
                let h = 0;
                e.verts.getCellSizes().forEach((v, m)=>{
                    g[m] = h, f[m] = v > 1 ? Zn.VTK_POLY_VERTEX : Zn.VTK_VERTEX, h += v + 1;
                }), g = g.subarray(i), f = f.subarray(i);
            }
            if (a) {
                let h = 0;
                e.lines.getCellSizes().forEach((v, m)=>{
                    g[m] = h, f[m] = v > 2 ? Zn.VTK_POLY_LINE : Zn.VTK_LINE, v === 1 && U9("Building VTK_LINE ", m, " with only one point, but VTK_LINE needs at least two points. Check the input."), h += v + 1;
                }), g = g.subarray(a), f = f.subarray(a);
            }
            if (o) {
                let h = 0;
                e.polys.getCellSizes().forEach((v, m)=>{
                    switch(g[m] = h, v){
                        case 3:
                            f[m] = Zn.VTK_TRIANGLE;
                            break;
                        case 4:
                            f[m] = Zn.VTK_QUAD;
                            break;
                        default:
                            f[m] = Zn.VTK_POLYGON;
                            break;
                    }
                    v < 3 && U9("Building VTK_TRIANGLE ", m, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."), h += v + 1;
                }), g += g.subarray(o), f += f.subarray(o);
            }
            if (s) {
                let h = 0;
                f.fill(Zn.VTK_TRIANGLE_STRIP, 0, s), e.strips.getCellSizes().forEach((v, m)=>{
                    g[m] = h, h += v + 1;
                });
            }
            e.cells = LA.newInstance(), e.cells.setCellTypes(c, l, u);
        }, t.buildLinks = function() {
            let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            e.cells === void 0 && t.buildCells(), e.links = SA.newInstance(), i > 0 ? e.links.allocate(i) : e.links.allocate(t.getPoints().getNumberOfPoints()), e.links.buildLinks(t);
        }, t.getCellType = (i)=>e.cells.getCellType(i), t.getCellPoints = (i)=>{
            const a = t.getCellType(i);
            let o = null;
            switch(a){
                case Zn.VTK_VERTEX:
                case Zn.VTK_POLY_VERTEX:
                    o = e.verts;
                    break;
                case Zn.VTK_LINE:
                case Zn.VTK_POLY_LINE:
                    o = e.lines;
                    break;
                case Zn.VTK_TRIANGLE:
                case Zn.VTK_QUAD:
                case Zn.VTK_POLYGON:
                    o = e.polys;
                    break;
                case Zn.VTK_TRIANGLE_STRIP:
                    o = e.strips;
                    break;
                default:
                    return o = null, {
                        type: 0,
                        cellPointIds: null
                    };
            }
            const s = e.cells.getCellLocation(i), c = o.getCell(s);
            return {
                cellType: a,
                cellPointIds: c
            };
        }, t.getPointCells = (i)=>e.links.getCells(i), t.getCellEdgeNeighbors = (i, a, o)=>{
            const s = e.links.getLink(a), c = e.links.getLink(o);
            return s.cells.filter((l)=>l !== i && c.cells.indexOf(l) !== -1);
        }, t.getCell = function(i) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            const o = t.getCellPoints(i), s = a || pk[o.cellType].newInstance();
            return s.initialize(t.getPoints(), o.cellPointIds), s;
        };
    }
    const vk = {};
    function MS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, vk, n), ck.extend(t, e, n), K.get(t, e, [
            "cells",
            "links"
        ]), K.setGet(t, e, [
            "verts",
            "lines",
            "polys",
            "strips"
        ]), mk(t, e);
    }
    const yk = K.newInstance(MS, "vtkPolyData");
    Hc = {
        newInstance: yk,
        extend: MS
    };
    const { vtkErrorMacro: Ck } = K;
    class wk {
        constructor(){
            this.segmentMapping = {}, this.segments = [
                null
            ], this.faces = [];
        }
        addSegment(e) {
            const n = e[0], r = e[e.length - 1];
            if (n === r || e.length < 2) return;
            const i = this.segmentMapping[n], a = this.segmentMapping[r];
            if (i !== void 0 && a !== void 0) if (Math.abs(i) === Math.abs(a)) {
                const o = i < a ? a : i, s = this.segments[o];
                if (i > 0) for(let c = 1; c < e.length - 1; c++)s.push(e[c]);
                else for(let c = 1; c < e.length - 1; c++)s.unshift(e[e.length - 1 - c]);
                this.faces.push(s), this.segments[o] = null, this.segmentMapping[n] = void 0, this.segmentMapping[r] = void 0;
            } else {
                const o = Math.abs(i), s = Math.abs(a), c = this.segments[o], l = this.segments[s];
                this.segments[o] = null, this.segments[s] = null, this.segmentMapping[c[0]] = void 0, this.segmentMapping[l[0]] = void 0, this.segmentMapping[c[c.length - 1]] = void 0, this.segmentMapping[l[l.length - 1]] = void 0, this.addSegment(e), this.addSegment(c), this.addSegment(l);
            }
            else if (i !== void 0) {
                if (i > 0) {
                    const o = this.segments[i];
                    for(let s = 1; s < e.length; s++)o.push(e[s]);
                    this.segmentMapping[r] = i;
                } else {
                    const o = this.segments[-i];
                    this.segmentMapping[r] = i;
                    for(let s = 1; s < e.length; s++)o.unshift(e[s]);
                }
                this.segmentMapping[n] = void 0;
            } else if (a !== void 0) {
                if (a > 0) {
                    const o = this.segments[a];
                    for(let s = 1; s < e.length; s++)o.push(e[e.length - 1 - s]);
                    this.segmentMapping[n] = a;
                } else {
                    const o = this.segments[-a];
                    this.segmentMapping[n] = a;
                    for(let s = 1; s < e.length; s++)o.unshift(e[e.length - s - 1]);
                }
                this.segmentMapping[r] = void 0;
            } else {
                const o = this.segments.length;
                this.segments.push(e), this.segmentMapping[n] = -o, this.segmentMapping[r] = o;
            }
        }
    }
    function Tk(t, e) {
        e.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"), t.requestData = (n, r)=>{
            const i = n[0];
            if (!i) {
                Ck("Invalid or missing input");
                return;
            }
            const a = Hc.newInstance();
            a.shallowCopy(i);
            const o = new wk, s = i.getLines().getData();
            let c = 0;
            for(; c < s.length;){
                const g = s[c++], h = [];
                for(let v = 0; v < g; v++)h.push(s[c + v]);
                o.addSegment(h), c += g;
            }
            const { faces: l } = o;
            let f = l.length;
            for(let g = 0; g < l.length; g++)f += l[g].length;
            const u = new Uint16Array(f);
            c = 0;
            for(let g = 0; g < l.length; g++){
                const h = l[g];
                u[c++] = h.length;
                for(let v = 0; v < h.length; v++)u[c++] = h[v];
            }
            a.setPolys(W0.newInstance({
                values: u,
                name: "faces"
            })), r[0] = a;
        };
    }
    const xk = {};
    function bS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, xk, n), K.obj(t, e), K.algo(t, e, 1, 1), Tk(t, e);
    }
    const Sk = K.newInstance(bS, "vtkClosedPolyLineToSurfaceFilter");
    var Ek = {
        newInstance: Sk,
        extend: bS
    };
    const { vtkErrorMacro: F9 } = da;
    function Dk(t) {
        const e = t.getPolys().getData(), n = t.getStrips().getData(), r = {
            cellSize: 0,
            cell: [],
            done: !1,
            polyIdx: 0,
            stripIdx: 0,
            remainingStripLength: 0,
            next () {
                if (r.polyIdx < e.length) {
                    r.cellSize = e[r.polyIdx];
                    const i = r.polyIdx + 1, a = i + r.cellSize;
                    r.polyIdx = a;
                    let o = 0;
                    for(let s = i; s < a; ++s)r.cell[o++] = e[s];
                } else if (r.stripIdx < n.length) {
                    r.cellSize = 3, r.remainingStripLength === 0 && (r.remainingStripLength = n[r.stripIdx] - 2, r.stripIdx += 3);
                    const i = r.stripIdx - 2, a = r.stripIdx + 1;
                    r.stripIdx++, r.remainingStripLength--;
                    let o = 0;
                    for(let s = i; s < a; ++s)r.cell[o++] = n[s];
                } else if (!r.done) r.done = !0;
                else throw new Error("Iterator is done");
            }
        };
        return r.next(), r;
    }
    function _k(t, e) {
        e.classHierarchy.push("vtkCutter");
        const n = {
            ...t
        };
        t.getMTime = ()=>{
            let i = n.getMTime();
            return e.cutFunction && (i = Math.max(i, e.cutFunction.getMTime())), i;
        };
        function r(i, a) {
            const o = i.getPoints(), s = o.getData(), c = o.getNumberOfPoints(), l = [], f = [], u = [];
            (!e.cutScalars || e.cutScalars.length < c) && (e.cutScalars = new Float32Array(c));
            let g = 0, h = 0;
            for(; g < s.length;)e.cutScalars[h++] = e.cutFunction.evaluateFunction(s[g++], s[g++], s[g++]);
            const v = [], m = new Array(3), y = new Array(3), C = [];
            for(const x = Dk(i); !x.done; x.next()){
                if (x.cellSize <= 2) continue;
                for(let P = 0; P < x.cellSize;)C[P] = e.cutScalars[x.cell[P++]];
                const S = C[0] > 0;
                let D = !0;
                for(let P = 1; P < x.cell.length; P++)if (C[P] > 0 !== S) {
                    D = !1;
                    break;
                }
                if (D) continue;
                const _ = [];
                for(let P = 0; P < x.cellSize; P++){
                    const F = P + 1 === x.cellSize ? 0 : P + 1, N = C[P] > 0;
                    if (C[F] > 0 === N) continue;
                    let G = P, Z = F, H = C[Z] - C[G];
                    H <= 0 && (G = F, Z = P, H *= -1);
                    let ne = 0;
                    H !== 0 && (ne = (e.cutValue - C[G]) / H);
                    const ae = x.cell[G], ue = x.cell[Z];
                    m[0] = s[ae * 3], m[1] = s[ae * 3 + 1], m[2] = s[ae * 3 + 2], y[0] = s[ue * 3], y[1] = s[ue * 3 + 1], y[2] = s[ue * 3 + 2];
                    const le = [
                        m[0] + ne * (y[0] - m[0]),
                        m[1] + ne * (y[1] - m[1]),
                        m[2] + ne * (y[2] - m[2])
                    ];
                    _.push({
                        pointEdge1: ae,
                        pointEdge2: ue,
                        intersectedPoint: le,
                        newPointID: -1
                    });
                }
                for(let P = 0; P < _.length; P++){
                    const F = _[P];
                    let N = !1;
                    for(let B = 0; B < v.length; B++){
                        const G = v[B], Z = F.pointEdge1 === G.pointEdge1 && F.pointEdge2 === G.pointEdge2, H = F.intersectedPoint[0] === G.intersectedPoint[0] && F.intersectedPoint[1] === G.intersectedPoint[1] && F.intersectedPoint[2] === G.intersectedPoint[2];
                        if (Z || H) {
                            N = !0, _[P].newPointID = v[B].newPointID;
                            break;
                        }
                    }
                    N || (l.push(F.intersectedPoint[0]), l.push(F.intersectedPoint[1]), l.push(F.intersectedPoint[2]), _[P].newPointID = l.length / 3 - 1, v.push(_[P]));
                }
                const M = _.length;
                M === 2 ? f.push(M, _[0].newPointID, _[1].newPointID) : M > 2 && (u.push(M), _.forEach((P)=>{
                    u.push(P.newPointID);
                }));
            }
            a.getPoints().setData(Rp(o.getDataType(), l), 3), f.length !== 0 && a.getLines().setData(Uint16Array.from(f)), u.length !== 0 && a.getPolys().setData(Uint16Array.from(u));
        }
        t.requestData = (i, a)=>{
            const o = i[0];
            if (!o) {
                F9("Invalid or missing input");
                return;
            }
            if (!e.cutFunction) {
                F9("Missing cut function");
                return;
            }
            const s = Hc.newInstance();
            r(o, s), a[0] = s;
        };
    }
    const Rk = {
        cutFunction: null,
        cutScalars: null,
        cutValue: 0
    };
    function LS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Rk, n), tr(t, e), y3(t, e, 1, 1), si(t, e, [
            "cutFunction",
            "cutValue"
        ]), _k(t, e);
    }
    const Ok = kn(LS, "vtkCutter");
    var Ik = {
        newInstance: Ok,
        extend: LS
    };
    const Kc = {
        ARRAY_BUFFER: 0,
        ELEMENT_ARRAY_BUFFER: 1,
        TEXTURE_BUFFER: 2
    };
    var PS = {
        ObjectType: Kc
    };
    const { ObjectType: fh } = PS, Mk = {};
    function bk(t, e) {
        e.classHierarchy.push("vtkOpenGLBufferObject");
        function n(s) {
            switch(s){
                case fh.ELEMENT_ARRAY_BUFFER:
                    return e.context.ELEMENT_ARRAY_BUFFER;
                case fh.TEXTURE_BUFFER:
                    if ("TEXTURE_BUFFER" in e.context) return e.context.TEXTURE_BUFFER;
                case fh.ARRAY_BUFFER:
                default:
                    return e.context.ARRAY_BUFFER;
            }
        }
        let r = null, i = null, a = !0, o = "";
        t.getType = ()=>r, t.setType = (s)=>{
            r = s;
        }, t.getHandle = ()=>i, t.isReady = ()=>a === !1, t.generateBuffer = (s)=>{
            const c = n(s);
            return i === null && (i = e.context.createBuffer(), r = s), n(r) === c;
        }, t.upload = (s, c)=>t.generateBuffer(c) ? (e.context.bindBuffer(n(r), i), e.context.bufferData(n(r), s, e.context.STATIC_DRAW), e.allocatedGPUMemoryInBytes = s.length * s.BYTES_PER_ELEMENT, a = !1, !0) : (o = "Trying to upload array buffer to incompatible buffer.", !1), t.bind = ()=>i ? (e.context.bindBuffer(n(r), i), !0) : !1, t.release = ()=>i ? (e.context.bindBuffer(n(r), null), !0) : !1, t.releaseGraphicsResources = ()=>{
            i !== null && (e.context.bindBuffer(n(r), null), e.context.deleteBuffer(i), i = null, e.allocatedGPUMemoryInBytes = 0);
        }, t.setOpenGLRenderWindow = (s)=>{
            e._openGLRenderWindow !== s && (t.releaseGraphicsResources(), e._openGLRenderWindow = s, e.context = null, s && (e.context = e._openGLRenderWindow.getContext()));
        }, t.getError = ()=>o;
    }
    const Lk = {
        objectType: fh.ARRAY_BUFFER,
        context: null,
        allocatedGPUMemoryInBytes: 0
    };
    function VS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Lk, n), K.obj(t, e), K.get(t, e, [
            "_openGLRenderWindow",
            "allocatedGPUMemoryInBytes"
        ]), K.moveToProtected(t, e, [
            "openGLRenderWindow"
        ]), bk(t, e);
    }
    const Pk = K.newInstance(VS);
    var $c = {
        newInstance: Pk,
        extend: VS,
        ...Mk,
        ...PS
    };
    let NS, Vk;
    NS = {
        FLAT: 0,
        GOURAUD: 1,
        PHONG: 2
    };
    Yo = {
        POINTS: 0,
        WIREFRAME: 1,
        SURFACE: 2
    };
    Vk = NS;
    var AS = {
        Shading: NS,
        Representation: Yo,
        Interpolation: Vk
    };
    const { vtkErrorMacro: B9 } = K;
    function Nk(t, e) {
        const n = new Float64Array(3);
        mx(n, e);
        const r = new Float64Array(16);
        return lx(r, G0(), t, n), r;
    }
    function Ak(t, e) {
        return t === null || e === null ? !1 : !(D9(t, [
            0,
            0,
            0
        ]) && D9(e, [
            1,
            1,
            1
        ]));
    }
    function kk(t, e) {
        e.classHierarchy.push("vtkOpenGLCellArrayBufferObject"), t.setType(Kc.ARRAY_BUFFER), t.createVBO = function(n, r, i, a) {
            let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
            if (!n.getData() || !n.getData().length) return e.elementCount = 0, 0;
            e.blockSize = 3, e.vertexOffset = 0, e.normalOffset = 0, e.tCoordOffset = 0, e.tCoordComponents = 0, e.colorComponents = 0, e.colorOffset = 0, e.customData = [];
            const s = a.points.getData();
            let c = null, l = null, f = null;
            const u = a.colors ? a.colors.getNumberOfComponents() : 0, g = a.tcoords ? a.tcoords.getNumberOfComponents() : 0;
            a.normals && (e.normalOffset = 4 * e.blockSize, e.blockSize += 3, c = a.normals.getData()), a.customAttributes && a.customAttributes.forEach((oe)=>{
                oe && (e.customData.push({
                    data: oe.getData(),
                    offset: 4 * e.blockSize,
                    components: oe.getNumberOfComponents(),
                    name: oe.getName()
                }), e.blockSize += oe.getNumberOfComponents());
            }), a.tcoords && (e.tCoordOffset = 4 * e.blockSize, e.tCoordComponents = g, e.blockSize += g, l = a.tcoords.getData()), a.colors ? (e.colorComponents = a.colors.getNumberOfComponents(), e.colorOffset = 0, f = a.colors.getData(), e.colorBO || (e.colorBO = $c.newInstance()), e.colorBO.setOpenGLRenderWindow(e._openGLRenderWindow)) : e.colorBO = null, e.stride = 4 * e.blockSize;
            let h = 0, v = 0, m = 0, y = 0, C = 0, T = 0, x;
            const S = {
                anythingToPoints (oe, re, X, ie) {
                    for(let he = 0; he < oe; ++he)x(re[X + he], ie);
                },
                linesToWireframe (oe, re, X, ie) {
                    for(let he = 0; he < oe - 1; ++he)x(re[X + he], ie), x(re[X + he + 1], ie);
                },
                polysToWireframe (oe, re, X, ie) {
                    if (oe > 2) for(let he = 0; he < oe; ++he)x(re[X + he], ie), x(re[X + (he + 1) % oe], ie);
                },
                stripsToWireframe (oe, re, X, ie) {
                    if (oe > 2) {
                        for(let he = 0; he < oe - 1; ++he)x(re[X + he], ie), x(re[X + he + 1], ie);
                        for(let he = 0; he < oe - 2; he++)x(re[X + he], ie), x(re[X + he + 2], ie);
                    }
                },
                polysToSurface (oe, re, X, ie) {
                    for(let he = 0; he < oe - 2; he++)x(re[X + 0], ie), x(re[X + he + 1], ie), x(re[X + he + 2], ie);
                },
                stripsToSurface (oe, re, X, ie) {
                    for(let he = 0; he < oe - 2; he++)x(re[X + he], ie), x(re[X + he + 1 + he % 2], ie), x(re[X + he + 1 + (he + 1) % 2], ie);
                }
            }, D = {
                anythingToPoints (oe, re) {
                    return oe;
                },
                linesToWireframe (oe, re) {
                    return oe > 1 ? (oe - 1) * 2 : 0;
                },
                polysToWireframe (oe, re) {
                    return oe > 2 ? oe * 2 : 0;
                },
                stripsToWireframe (oe, re) {
                    return oe > 2 ? oe * 4 - 6 : 0;
                },
                polysToSurface (oe, re) {
                    return oe > 2 ? (oe - 2) * 3 : 0;
                },
                stripsToSurface (oe, re, X) {
                    return oe > 2 ? (oe - 2) * 3 : 0;
                }
            };
            let _ = null, M = null;
            i === Yo.POINTS || r === "verts" ? (_ = S.anythingToPoints, M = D.anythingToPoints) : i === Yo.WIREFRAME || r === "lines" ? (_ = S[`${r}ToWireframe`], M = D[`${r}ToWireframe`]) : (_ = S[`${r}ToSurface`], M = D[`${r}ToSurface`]);
            const P = n.getData(), F = P.length;
            let N = 0;
            for(let oe = 0; oe < F;)N += M(P[oe], P), oe += P[oe] + 1;
            let B = null;
            const G = new Float32Array(N * e.blockSize);
            f && (B = new Uint8Array(N * 4));
            let Z = 0, H = 0, ne = 0, ae = 0;
            for(let oe = 0; oe < 3; ++oe){
                const re = a.points.getRange(oe), X = re[1] - re[0];
                ne += X * X;
                const ie = .5 * (re[1] + re[0]);
                ae += ie * ie;
            }
            if (ne > 0 && (Math.abs(ae) / ne > 1e6 || Math.abs(Math.log10(ne)) > 3 || ne === 0 && ae > 1e6)) {
                const oe = new Float64Array(3), re = new Float64Array(3);
                for(let X = 0; X < 3; ++X){
                    const ie = a.points.getRange(X), he = ie[1] - ie[0];
                    oe[X] = .5 * (ie[1] + ie[0]), re[X] = he > 0 ? 1 / he : 1;
                }
                t.setCoordShiftAndScale(oe, re);
            } else e.coordShiftAndScaleEnabled === !0 && t.setCoordShiftAndScale(null, null);
            if (o) if (!o.points && !o.cells) o.points = new Int32Array(N), o.cells = new Int32Array(N);
            else {
                const oe = new Int32Array(N + o.points.length);
                oe.set(o.points), o.points = oe;
                const re = new Int32Array(N + o.cells.length);
                re.set(o.cells), o.cells = re;
            }
            let le = a.vertexOffset;
            x = function(re, X) {
                if (o && (o.points[le] = re, o.cells[le] = T + a.cellOffset), ++le, h = re * 3, e.coordShiftAndScaleEnabled ? (G[Z++] = (s[h++] - e.coordShift[0]) * e.coordScale[0], G[Z++] = (s[h++] - e.coordShift[1]) * e.coordScale[1], G[Z++] = (s[h++] - e.coordShift[2]) * e.coordScale[2]) : (G[Z++] = s[h++], G[Z++] = s[h++], G[Z++] = s[h++]), c !== null && (a.haveCellNormals ? v = (T + a.cellOffset) * 3 : v = re * 3, G[Z++] = c[v++], G[Z++] = c[v++], G[Z++] = c[v++]), e.customData.forEach((ie)=>{
                    C = re * ie.components;
                    for(let he = 0; he < ie.components; ++he)G[Z++] = ie.data[C++];
                }), l !== null) {
                    a.useTCoordsPerCell ? m = X * g : m = re * g;
                    for(let ie = 0; ie < g; ++ie)G[Z++] = l[m++];
                }
                f !== null && (a.haveCellScalars ? y = (T + a.cellOffset) * u : y = re * u, B[H++] = f[y++], B[H++] = f[y++], B[H++] = f[y++], B[H++] = u === 4 ? f[y++] : 255);
            };
            for(let oe = 0; oe < F; oe += P[oe] + 1, T++)_(P[oe], P, oe + 1, T + a.cellOffset);
            return e.elementCount = N, t.upload(G, Kc.ARRAY_BUFFER), e.colorBO && (e.colorBOStride = 4, e.colorBO.upload(B, Kc.ARRAY_BUFFER)), T;
        }, t.setCoordShiftAndScale = (n, r)=>{
            if (n !== null && (n.constructor !== Float64Array || n.length !== 3)) {
                B9("Wrong type for coordShift, expected vec3 or null");
                return;
            }
            if (r !== null && (r.constructor !== Float64Array || r.length !== 3)) {
                B9("Wrong type for coordScale, expected vec3 or null");
                return;
            }
            (e.coordShift === null || n === null || !_9(n, e.coordShift)) && (e.coordShift = n), (e.coordScale === null || r === null || !_9(r, e.coordScale)) && (e.coordScale = r), e.coordShiftAndScaleEnabled = Ak(e.coordShift, e.coordScale), e.coordShiftAndScaleEnabled ? e.inverseShiftAndScaleMatrix = Nk(e.coordShift, e.coordScale) : e.inverseShiftAndScaleMatrix = null;
        };
    }
    const Uk = {
        elementCount: 0,
        stride: 0,
        colorBOStride: 0,
        vertexOffset: 0,
        normalOffset: 0,
        tCoordOffset: 0,
        tCoordComponents: 0,
        colorOffset: 0,
        colorComponents: 0,
        tcoordBO: null,
        customData: [],
        coordShift: null,
        coordScale: null,
        coordShiftAndScaleEnabled: !1,
        inverseShiftAndScaleMatrix: null
    };
    function kS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Uk, n), $c.extend(t, e, n), K.setGet(t, e, [
            "colorBO",
            "elementCount",
            "stride",
            "colorBOStride",
            "vertexOffset",
            "normalOffset",
            "tCoordOffset",
            "tCoordComponents",
            "colorOffset",
            "colorComponents",
            "customData"
        ]), K.get(t, e, [
            "coordShift",
            "coordScale",
            "coordShiftAndScaleEnabled",
            "inverseShiftAndScaleMatrix"
        ]), kk(t, e);
    }
    const Fk = K.newInstance(kS);
    var Bk = {
        newInstance: Fk,
        extend: kS
    };
    const { vtkErrorMacro: Gk } = K;
    function Wk(t, e) {
        e.classHierarchy.push("vtkShader"), t.compile = ()=>{
            let n = e.context.VERTEX_SHADER;
            if (!e.source || !e.source.length || e.shaderType === "Unknown") return !1;
            switch(e.handle !== 0 && (e.context.deleteShader(e.handle), e.handle = 0), e.shaderType){
                case "Fragment":
                    n = e.context.FRAGMENT_SHADER;
                    break;
                case "Vertex":
                default:
                    n = e.context.VERTEX_SHADER;
                    break;
            }
            if (e.handle = e.context.createShader(n), e.context.shaderSource(e.handle, e.source), e.context.compileShader(e.handle), !e.context.getShaderParameter(e.handle, e.context.COMPILE_STATUS)) {
                const i = e.context.getShaderInfoLog(e.handle);
                return Gk(`Error compiling shader '${e.source}': ${i}`), e.context.deleteShader(e.handle), e.handle = 0, !1;
            }
            return !0;
        }, t.cleanup = ()=>{
            e.shaderType === "Unknown" || e.handle === 0 || (e.context.deleteShader(e.handle), e.handle = 0, e.dirty = !0);
        };
    }
    const $k = {
        shaderType: "Unknown",
        source: "",
        error: "",
        handle: 0,
        dirty: !1,
        context: null
    };
    function US(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, $k, n), K.obj(t, e), K.setGet(t, e, [
            "shaderType",
            "source",
            "error",
            "handle",
            "context"
        ]), Wk(t, e);
    }
    const zk = K.newInstance(US, "vtkShader");
    var h5 = {
        newInstance: zk,
        extend: US
    };
    const { vtkErrorMacro: $s } = K;
    function jk(t, e, n, r) {
        const i = typeof n == "string" ? n : n.join(`
`), a = r === !1 ? e : new RegExp(e, "g"), o = t.replace(a, i);
        return {
            replace: o !== i,
            result: o
        };
    }
    function Hk(t, e) {
        e.classHierarchy.push("vtkShaderProgram"), t.compileShader = ()=>e.vertexShader.compile() ? e.fragmentShader.compile() ? !t.attachShader(e.vertexShader) || !t.attachShader(e.fragmentShader) ? ($s(e.error), 0) : t.link() ? (t.setCompiled(!0), 1) : ($s(`Links failed: ${e.error}`), 0) : ($s(e.fragmentShader.getSource().split(`
`).map((n, r)=>`${r}: ${n}`).join(`
`)), $s(e.fragmentShader.getError()), 0) : ($s(e.vertexShader.getSource().split(`
`).map((n, r)=>`${r}: ${n}`).join(`
`)), $s(e.vertexShader.getError()), 0), t.cleanup = ()=>{
            e.shaderType === "Unknown" || e.handle === 0 || (t.release(), e.vertexShaderHandle !== 0 && (e.context.detachShader(e.handle, e.vertexShaderHandle), e.vertexShaderHandle = 0), e.fragmentShaderHandle !== 0 && (e.context.detachShader(e.handle, e.fragmentShaderHandle), e.fragmentShaderHandle = 0), e.context.deleteProgram(e.handle), e.handle = 0, t.setCompiled(!1));
        }, t.bind = ()=>!e.linked && !t.link() ? !1 : (e.context.useProgram(e.handle), t.setBound(!0), !0), t.isBound = ()=>!!e.bound, t.release = ()=>{
            e.context.useProgram(null), t.setBound(!1);
        }, t.setContext = (n)=>{
            e.vertexShader.setContext(n), e.fragmentShader.setContext(n), e.geometryShader.setContext(n);
        }, t.link = ()=>{
            if (e.linked) return !0;
            if (e.handle === 0) return e.error = "Program has not been initialized, and/or does not have shaders.", !1;
            if (e.uniformLocs = {}, e.context.linkProgram(e.handle), !e.context.getProgramParameter(e.handle, e.context.LINK_STATUS)) {
                const r = e.context.getProgramInfoLog(e.handle);
                return $s(`Error linking shader ${r}`), e.handle = 0, !1;
            }
            return t.setLinked(!0), e.attributeLocs = {}, !0;
        }, t.setUniformMatrix = (n, r)=>{
            const i = t.findUniform(n);
            if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            const a = new Float32Array(r);
            return e.context.uniformMatrix4fv(i, !1, a), !0;
        }, t.setUniformMatrix3x3 = (n, r)=>{
            const i = t.findUniform(n);
            if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            const a = new Float32Array(r);
            return e.context.uniformMatrix3fv(i, !1, a), !0;
        }, t.setUniformf = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform1f(i, r), !0);
        }, t.setUniformfv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform1fv(i, r), !0);
        }, t.setUniformi = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform1i(i, r), !0);
        }, t.setUniformiv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform1iv(i, r), !0);
        }, t.setUniform2f = (n, r, i)=>{
            const a = t.findUniform(n);
            if (a === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            if (i === void 0) throw new RangeError("Invalid number of values for array");
            return e.context.uniform2f(a, r, i), !0;
        }, t.setUniform2fv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform2fv(i, r), !0);
        }, t.setUniform2i = (n, r, i)=>{
            const a = t.findUniform(n);
            if (a === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            if (i === void 0) throw new RangeError("Invalid number of values for array");
            return e.context.uniform2i(a, r, i), !0;
        }, t.setUniform2iv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform2iv(i, r), !0);
        }, t.setUniform3f = (n, r, i, a)=>{
            const o = t.findUniform(n);
            if (o === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            if (a === void 0) throw new RangeError("Invalid number of values for array");
            return e.context.uniform3f(o, r, i, a), !0;
        }, t.setUniform3fArray = (n, r)=>{
            const i = t.findUniform(n);
            if (i === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            if (!Array.isArray(r) || r.length !== 3) throw new RangeError("Invalid number of values for array");
            return e.context.uniform3f(i, r[0], r[1], r[2]), !0;
        }, t.setUniform3fv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform3fv(i, r), !0);
        }, t.setUniform3i = function(n) {
            const r = t.findUniform(n);
            if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            for(var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)a[o - 1] = arguments[o];
            let s = a;
            if (s.length === 1 && Array.isArray(s[0]) && (s = s[0]), s.length !== 3) throw new RangeError("Invalid number of values for array");
            return e.context.uniform3i(r, s[0], s[1], s[2]), !0;
        }, t.setUniform3iv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform3iv(i, r), !0);
        }, t.setUniform4f = function(n) {
            const r = t.findUniform(n);
            if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            for(var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)a[o - 1] = arguments[o];
            let s = a;
            if (s.length === 1 && Array.isArray(s[0]) && (s = s[0]), s.length !== 4) throw new RangeError("Invalid number of values for array");
            return e.context.uniform4f(r, s[0], s[1], s[2], s[3]), !0;
        }, t.setUniform4fv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform4fv(i, r), !0);
        }, t.setUniform4i = function(n) {
            const r = t.findUniform(n);
            if (r === -1) return e.error = `Could not set uniform ${n} . No such uniform.`, !1;
            for(var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)a[o - 1] = arguments[o];
            let s = a;
            if (s.length === 1 && Array.isArray(s[0]) && (s = s[0]), s.length !== 4) throw new RangeError("Invalid number of values for array");
            return e.context.uniform4i(r, s[0], s[1], s[2], s[3]), !0;
        }, t.setUniform4iv = (n, r)=>{
            const i = t.findUniform(n);
            return i === -1 ? (e.error = `Could not set uniform ${n} . No such uniform.`, !1) : (e.context.uniform4iv(i, r), !0);
        }, t.findUniform = (n)=>{
            if (!n || !e.linked) return -1;
            let r = e.uniformLocs[n];
            return r !== void 0 ? r : (r = e.context.getUniformLocation(e.handle, n), r === null ? (e.error = `Uniform ${n} not found in current shader program.`, e.uniformLocs[n] = -1, -1) : (e.uniformLocs[n] = r, r));
        }, t.isUniformUsed = (n)=>{
            if (!n) return !1;
            let r = e.uniformLocs[n];
            return r !== void 0 ? r !== null : e.linked ? (r = e.context.getUniformLocation(e.handle, n), e.uniformLocs[n] = r, r !== null) : ($s("attempt to find uniform when the shader program is not linked"), !1);
        }, t.isAttributeUsed = (n)=>{
            if (!n) return !1;
            if (n in e.attributeLocs) return !0;
            if (!e.linked) return $s("attempt to find uniform when the shader program is not linked"), !1;
            const r = e.context.getAttribLocation(e.handle, n);
            return r === -1 ? !1 : (e.attributeLocs[n] = r, !0);
        }, t.attachShader = (n)=>{
            if (n.getHandle() === 0) return e.error = "Shader object was not initialized, cannot attach it.", !1;
            if (n.getShaderType() === "Unknown") return e.error = "Shader object is of type Unknown and cannot be used.", !1;
            if (e.handle === 0) {
                const r = e.context.createProgram();
                if (r === 0) return e.error = "Could not create shader program.", !1;
                e.handle = r, e.linked = !1;
            }
            return n.getShaderType() === "Vertex" && (e.vertexShaderHandle !== 0 && e.context.detachShader(e.handle, e.vertexShaderHandle), e.vertexShaderHandle = n.getHandle()), n.getShaderType() === "Fragment" && (e.fragmentShaderHandle !== 0 && e.context.detachShader(e.handle, e.fragmentShaderHandle), e.fragmentShaderHandle = n.getHandle()), e.context.attachShader(e.handle, n.getHandle()), t.setLinked(!1), !0;
        }, t.detachShader = (n)=>{
            if (n.getHandle() === 0) return e.error = "shader object was not initialized, cannot attach it.", !1;
            if (n.getShaderType() === "Unknown") return e.error = "Shader object is of type Unknown and cannot be used.", !1;
            switch(e.handle === 0 && (e.error = "This shader program has not been initialized yet."), n.getShaderType()){
                case "Vertex":
                    return e.vertexShaderHandle !== n.getHandle() ? (e.error = "The supplied shader was not attached to this program.", !1) : (e.context.detachShader(e.handle, n.getHandle()), e.vertexShaderHandle = 0, e.linked = !1, !0);
                case "Fragment":
                    return e.fragmentShaderHandle !== n.getHandle() ? (e.error = "The supplied shader was not attached to this program.", !1) : (e.context.detachShader(e.handle, n.getHandle()), e.fragmentShaderHandle = 0, e.linked = !1, !0);
                default:
                    return !1;
            }
        }, t.setContext = (n)=>{
            e.context = n, e.vertexShader.setContext(n), e.fragmentShader.setContext(n), e.geometryShader.setContext(n);
        }, t.setLastCameraMTime = (n)=>{
            e.lastCameraMTime = n;
        };
    }
    const Kk = {
        vertexShaderHandle: 0,
        fragmentShaderHandle: 0,
        geometryShaderHandle: 0,
        vertexShader: null,
        fragmentShader: null,
        geometryShader: null,
        linked: !1,
        bound: !1,
        compiled: !1,
        error: "",
        handle: 0,
        numberOfOutputs: 0,
        attributesLocs: null,
        uniformLocs: null,
        md5Hash: 0,
        context: null,
        lastCameraMTime: null
    };
    function FS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Kk, n), e.attributesLocs = {}, e.uniformLocs = {}, e.vertexShader = h5.newInstance(), e.vertexShader.setShaderType("Vertex"), e.fragmentShader = h5.newInstance(), e.fragmentShader.setShaderType("Fragment"), e.geometryShader = h5.newInstance(), e.geometryShader.setShaderType("Geometry"), K.obj(t, e), K.get(t, e, [
            "lastCameraMTime"
        ]), K.setGet(t, e, [
            "error",
            "handle",
            "compiled",
            "bound",
            "md5Hash",
            "vertexShader",
            "fragmentShader",
            "geometryShader",
            "linked"
        ]), Hk(t, e);
    }
    const qk = K.newInstance(FS, "vtkShaderProgram");
    Te = {
        newInstance: qk,
        extend: FS,
        substitute: jk
    };
    function Xk(t, e) {
        e.classHierarchy.push("vtkOpenGLVertexArrayObject"), t.exposedMethod = ()=>{}, t.initialize = ()=>{
            e.instancingExtension = null, e._openGLRenderWindow.getWebgl2() || (e.instancingExtension = e.context.getExtension("ANGLE_instanced_arrays")), !e.forceEmulation && e._openGLRenderWindow && e._openGLRenderWindow.getWebgl2() ? (e.extension = null, e.supported = !0, e.handleVAO = e.context.createVertexArray()) : (e.extension = e.context.getExtension("OES_vertex_array_object"), !e.forceEmulation && e.extension ? (e.supported = !0, e.handleVAO = e.extension.createVertexArrayOES()) : e.supported = !1);
        }, t.isReady = ()=>e.handleVAO !== 0 || e.supported === !1, t.bind = ()=>{
            if (t.isReady() || t.initialize(), t.isReady() && e.supported) e.extension ? e.extension.bindVertexArrayOES(e.handleVAO) : e.context.bindVertexArray(e.handleVAO);
            else if (t.isReady()) {
                const n = e.context;
                for(let r = 0; r < e.buffers.length; ++r){
                    const i = e.buffers[r];
                    e.context.bindBuffer(n.ARRAY_BUFFER, i.buffer);
                    for(let a = 0; a < i.attributes.length; ++a){
                        const o = i.attributes[a], s = o.isMatrix ? o.size : 1;
                        for(let c = 0; c < s; ++c)n.enableVertexAttribArray(o.index + c), n.vertexAttribPointer(o.index + c, o.size, o.type, o.normalize, o.stride, o.offset + o.stride * c / o.size), o.divisor > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(o.index + c, 1) : n.vertexAttribDivisor(o.index + c, 1));
                    }
                }
            }
        }, t.release = ()=>{
            if (t.isReady() && e.supported) e.extension ? e.extension.bindVertexArrayOES(null) : e.context.bindVertexArray(null);
            else if (t.isReady()) {
                const n = e.context;
                for(let r = 0; r < e.buffers.length; ++r){
                    const i = e.buffers[r];
                    e.context.bindBuffer(n.ARRAY_BUFFER, i.buffer);
                    for(let a = 0; a < i.attributes.length; ++a){
                        const o = i.attributes[a], s = o.isMatrix ? o.size : 1;
                        for(let c = 0; c < s; ++c)n.enableVertexAttribArray(o.index + c), n.vertexAttribPointer(o.index + c, o.size, o.type, o.normalize, o.stride, o.offset + o.stride * c / o.size), o.divisor > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(o.index + c, 0) : n.vertexAttribDivisor(o.index + c, 0)), n.disableVertexAttribArray(o.index + c);
                    }
                }
            }
        }, t.shaderProgramChanged = ()=>{
            t.release(), e.handleVAO && (e.extension ? e.extension.deleteVertexArrayOES(e.handleVAO) : e.context.deleteVertexArray(e.handleVAO)), e.handleVAO = 0, e.handleProgram = 0;
        }, t.releaseGraphicsResources = ()=>{
            t.shaderProgramChanged(), e.handleVAO && (e.extension ? e.extension.deleteVertexArrayOES(e.handleVAO) : e.context.deleteVertexArray(e.handleVAO)), e.handleVAO = 0, e.supported = !0, e.handleProgram = 0;
        }, t.addAttributeArray = (n, r, i, a, o, s, c, l)=>t.addAttributeArrayWithDivisor(n, r, i, a, o, s, c, l, 0, !1), t.addAttributeArrayWithDivisor = (n, r, i, a, o, s, c, l, f, u)=>{
            if (!n || !n.isBound() || r.getHandle() === 0 || r.getType() !== Kc.ARRAY_BUFFER || (e.handleProgram === 0 && (e.handleProgram = n.getHandle()), t.isReady() || t.initialize(), !t.isReady() || e.handleProgram !== n.getHandle())) return !1;
            const g = e.context, h = {};
            if (h.name = i, h.index = g.getAttribLocation(e.handleProgram, i), h.offset = a, h.stride = o, h.type = s, h.size = c, h.normalize = l, h.isMatrix = u, h.divisor = f, h.Index === -1) return !1;
            if (r.bind(), g.enableVertexAttribArray(h.index), g.vertexAttribPointer(h.index, h.size, h.type, h.normalize, h.stride, h.offset), f > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(h.index, 1) : g.vertexAttribDivisor(h.index, 1)), h.buffer = r.getHandle(), !e.supported) {
                let v = !1;
                for(let m = 0; m < e.buffers.length; ++m){
                    const y = e.buffers[m];
                    if (y.buffer === h.buffer) {
                        v = !0;
                        let C = !1;
                        for(let T = 0; T < y.attributes.length; ++T)y.attributes[T].name === i && (C = !0, y.attributes[T] = h);
                        C || y.attributes.push(h);
                    }
                }
                v || e.buffers.push({
                    buffer: h.buffer,
                    attributes: [
                        h
                    ]
                });
            }
            return !0;
        }, t.addAttributeMatrixWithDivisor = (n, r, i, a, o, s, c, l, f)=>{
            const u = t.addAttributeArrayWithDivisor(n, r, i, a, o, s, c, l, f, !0);
            if (!u) return u;
            const g = e.context, h = g.getAttribLocation(e.handleProgram, i);
            for(let v = 1; v < c; v++)g.enableVertexAttribArray(h + v), g.vertexAttribPointer(h + v, c, s, l, o, a + o * v / c), f > 0 && (e.instancingExtension ? e.instancingExtension.vertexAttribDivisorANGLE(h + v, 1) : g.vertexAttribDivisor(h + v, 1));
            return !0;
        }, t.removeAttributeArray = (n)=>{
            if (!t.isReady() || e.handleProgram === 0) return !1;
            if (!e.supported) for(let r = 0; r < e.buffers.length; ++r){
                const i = e.buffers[r];
                for(let a = 0; a < i.attributes.length; ++a)if (i.attributes[a].name === n) return i.attributes.splice(a, 1), i.attributes.length || e.buffers.splice(r, 1), !0;
            }
            return !0;
        }, t.setOpenGLRenderWindow = (n)=>{
            e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
        };
    }
    const Yk = {
        forceEmulation: !1,
        handleVAO: 0,
        handleProgram: 0,
        supported: !0,
        buffers: null,
        context: null
    };
    function BS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Yk, n), e.buffers = [], K.obj(t, e), K.get(t, e, [
            "supported"
        ]), K.setGet(t, e, [
            "forceEmulation"
        ]), Xk(t, e);
    }
    const Zk = K.newInstance(BS, "vtkOpenGLVertexArrayObject");
    var c4 = {
        newInstance: Zk,
        extend: BS
    };
    const Tl = {
        Start: 0,
        Points: 0,
        Lines: 1,
        Tris: 2,
        TriStrips: 3,
        TrisEdges: 4,
        TriStripsEdges: 5,
        End: 6
    };
    function Jk(t, e) {
        e.classHierarchy.push("vtkOpenGLHelper"), t.setOpenGLRenderWindow = (n)=>{
            e.context = n.getContext(), e.program.setContext(e.context), e.VAO.setOpenGLRenderWindow(n), e.CABO.setOpenGLRenderWindow(n);
        }, t.releaseGraphicsResources = (n)=>{
            e.VAO.releaseGraphicsResources(), e.CABO.releaseGraphicsResources(), e.CABO.setElementCount(0);
        }, t.drawArrays = (n, r, i, a)=>{
            if (e.CABO.getElementCount()) {
                const o = t.getOpenGLMode(i), s = t.haveWideLines(n, r), c = e.context, l = c.getParameter(c.DEPTH_WRITEMASK);
                e.pointPicking && c.depthMask(!1), o === c.LINES && s ? (t.updateShaders(n, r, a), c.drawArraysInstanced(o, 0, e.CABO.getElementCount(), 2 * Math.ceil(r.getProperty().getLineWidth()))) : (c.lineWidth(r.getProperty().getLineWidth()), t.updateShaders(n, r, a), c.drawArrays(o, 0, e.CABO.getElementCount()), c.lineWidth(1));
                const u = (o === c.POINTS ? 1 : 0) || (o === c.LINES ? 2 : 3);
                return e.pointPicking && c.depthMask(l), e.CABO.getElementCount() / u;
            }
            return 0;
        }, t.getOpenGLMode = (n)=>{
            if (e.pointPicking) return e.context.POINTS;
            const r = e.primitiveType;
            return n === Yo.POINTS || r === Tl.Points ? e.context.POINTS : n === Yo.WIREFRAME || r === Tl.Lines || r === Tl.TrisEdges || r === Tl.TriStripsEdges ? e.context.LINES : e.context.TRIANGLES;
        }, t.haveWideLines = (n, r)=>r.getProperty().getLineWidth() > 1 ? !(e.CABO.getOpenGLRenderWindow() && e.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= r.getProperty().getLineWidth()) : !1, t.getNeedToRebuildShaders = (n, r, i)=>!!(i.getNeedToRebuildShaders(t, n, r) || t.getProgram() === 0 || t.getShaderSourceTime().getMTime() < i.getMTime() || t.getShaderSourceTime().getMTime() < r.getMTime()), t.updateShaders = (n, r, i)=>{
            if (t.getNeedToRebuildShaders(n, r, i)) {
                const a = {
                    Vertex: null,
                    Fragment: null,
                    Geometry: null
                };
                i.buildShaders(a, n, r);
                const o = e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex, a.Fragment, a.Geometry);
                o !== t.getProgram() && (t.setProgram(o), t.getVAO().releaseGraphicsResources()), t.getShaderSourceTime().modified();
            } else e.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(t.getProgram());
            t.getVAO().bind(), i.setMapperShaderParameters(t, n, r), i.setPropertyShaderParameters(t, n, r), i.setCameraShaderParameters(t, n, r), i.setLightingShaderParameters(t, n, r), i.invokeShaderCallbacks(t, n, r);
        }, t.setMapperShaderParameters = (n, r, i)=>{
            if (t.haveWideLines(n, r)) {
                t.getProgram().setUniform2f("viewportSize", i.usize, i.vsize);
                const a = parseFloat(r.getProperty().getLineWidth()), o = a / 2;
                t.getProgram().setUniformf("lineWidthStepSize", a / Math.ceil(a)), t.getProgram().setUniformf("halfLineWidth", o);
            }
            e.primitiveType === Tl.Points || r.getProperty().getRepresentation() === Yo.POINTS ? t.getProgram().setUniformf("pointSize", r.getProperty().getPointSize()) : e.pointPicking && t.getProgram().setUniformf("pointSize", t.getPointPickingPrimitiveSize());
        }, t.replaceShaderPositionVC = (n, r, i)=>{
            let a = n.Vertex;
            a = Te.substitute(a, "//VTK::PositionVC::Dec", [
                "//VTK::PositionVC::Dec",
                "uniform float pointSize;"
            ]).result, a = Te.substitute(a, "//VTK::PositionVC::Impl", [
                "//VTK::PositionVC::Impl",
                "  gl_PointSize = pointSize;"
            ], !1).result, t.getOpenGLMode(i.getProperty().getRepresentation()) === e.context.LINES && t.haveWideLines(r, i) && (a = Te.substitute(a, "//VTK::PositionVC::Dec", [
                "//VTK::PositionVC::Dec",
                "uniform vec2 viewportSize;",
                "uniform float lineWidthStepSize;",
                "uniform float halfLineWidth;"
            ]).result, a = Te.substitute(a, "//VTK::PositionVC::Impl", [
                "//VTK::PositionVC::Impl",
                " if (halfLineWidth > 0.0)",
                "   {",
                "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;",
                "   vec4 tmpPos = gl_Position;",
                "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;",
                "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];",
                "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];",
                "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
                "   }"
            ]).result), n.Vertex = a;
        }, t.getPointPickingPrimitiveSize = ()=>e.primitiveType === Tl.Points ? 2 : e.primitiveType === Tl.Lines ? 4 : 6, t.getAllocatedGPUMemoryInBytes = ()=>t.getCABO().getAllocatedGPUMemoryInBytes();
    }
    const Qk = {
        context: null,
        program: null,
        shaderSourceTime: null,
        VAO: null,
        attributeUpdateTime: null,
        CABO: null,
        primitiveType: 0,
        pointPicking: !1
    };
    function GS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Qk, n), K.obj(t, e), e.shaderSourceTime = {}, K.obj(e.shaderSourceTime), e.attributeUpdateTime = {}, K.obj(e.attributeUpdateTime), K.setGet(t, e, [
            "program",
            "shaderSourceTime",
            "VAO",
            "attributeUpdateTime",
            "CABO",
            "primitiveType",
            "pointPicking"
        ]), e.program = Te.newInstance(), e.VAO = c4.newInstance(), e.CABO = Bk.newInstance(), Jk(t, e);
    }
    const eU = K.newInstance(GS);
    Yl = {
        newInstance: eU,
        extend: GS,
        primTypes: Tl
    };
    const tU = (t)=>t, G9 = 1e-6;
    let WS = class {
        constructor(){
            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            this.matrix = Ot(new Float64Array(16)), this.tmp = new Float64Array(3), this.angleConv = e ? qP : tU;
        }
        rotateFromDirections(e, n) {
            const r = new Float64Array(3), i = new Float64Array(3), a = new Float64Array(16);
            Sn(r, e[0], e[1], e[2]), Sn(i, n[0], n[1], n[2]), jn(r, r), jn(i, i);
            const o = xt(r, i);
            return o >= 1 ? this : (bn(this.tmp, r, i), Xa(this.tmp) < G9 && (bn(this.tmp, [
                1,
                0,
                0
            ], e), Xa(this.tmp) < G9 && bn(this.tmp, [
                0,
                1,
                0
            ], e)), B3(a, Math.acos(o), this.tmp), Qt(this.matrix, this.matrix, a), this);
        }
        rotate(e, n) {
            return Sn(this.tmp, ...n), jn(this.tmp, this.tmp), fs(this.matrix, this.matrix, this.angleConv(e), this.tmp), this;
        }
        rotateX(e) {
            return A3(this.matrix, this.matrix, this.angleConv(e)), this;
        }
        rotateY(e) {
            return k3(this.matrix, this.matrix, this.angleConv(e)), this;
        }
        rotateZ(e) {
            return U3(this.matrix, this.matrix, this.angleConv(e)), this;
        }
        translate(e, n, r) {
            return Sn(this.tmp, e, n, r), qr(this.matrix, this.matrix, this.tmp), this;
        }
        scale(e, n, r) {
            return Sn(this.tmp, e, n, r), nc(this.matrix, this.matrix, this.tmp), this;
        }
        multiply(e) {
            return Qt(this.matrix, this.matrix, e), this;
        }
        multiply3x3(e) {
            return Qt(this.matrix, this.matrix, [
                e[0],
                e[1],
                e[2],
                0,
                e[3],
                e[4],
                e[5],
                0,
                e[6],
                e[7],
                e[8],
                0,
                0,
                0,
                0,
                1
            ]), this;
        }
        invert() {
            return Xr(this.matrix, this.matrix), this;
        }
        identity() {
            return Ot(this.matrix), this;
        }
        apply(e) {
            let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
            if (Kd(x3, this.matrix)) return this;
            const i = r === -1 ? e.length : n + r * 3;
            for(let a = n; a < i; a += 3)Sn(this.tmp, e[a], e[a + 1], e[a + 2]), pn(this.tmp, this.tmp, this.matrix), e[a] = this.tmp[0], e[a + 1] = this.tmp[1], e[a + 2] = this.tmp[2];
            return this;
        }
        getMatrix() {
            return this.matrix;
        }
        setMatrix(e) {
            return e && e.length === 16 && Ur(this.matrix, e), this;
        }
    };
    function nU() {
        return new WS(!0);
    }
    function rU() {
        return new WS(!1);
    }
    M0 = {
        buildFromDegree: nU,
        buildFromRadian: rU
    };
    const iU = [
        2,
        0,
        1,
        2,
        2,
        3,
        2,
        4,
        5,
        2,
        6,
        7,
        2,
        0,
        2,
        2,
        1,
        3,
        2,
        4,
        6,
        2,
        5,
        7,
        2,
        0,
        4,
        2,
        1,
        5,
        2,
        2,
        6,
        2,
        3,
        7
    ], aU = [
        4,
        0,
        1,
        3,
        2,
        4,
        4,
        6,
        7,
        5,
        4,
        8,
        10,
        11,
        9,
        4,
        12,
        13,
        15,
        14,
        4,
        16,
        18,
        19,
        17,
        4,
        20,
        21,
        23,
        22
    ];
    function oU(t, e) {
        e.classHierarchy.push("vtkCubeSource");
        function n(r, i) {
            if (e.deleted) return;
            const a = Hc.newInstance();
            i[0] = a;
            const o = 24, s = K.newTypedArray(e.pointType, o * 3);
            a.getPoints().setData(s, 3);
            const c = K.newTypedArray(e.pointType, o * 3), l = Wt.newInstance({
                name: "Normals",
                values: c,
                numberOfComponents: 3
            });
            a.getPointData().setNormals(l);
            let f = 2;
            e.generate3DTextureCoordinates === !0 && (f = 3);
            const u = K.newTypedArray(e.pointType, o * f), g = Wt.newInstance({
                name: "TextureCoordinates",
                values: u,
                numberOfComponents: f
            });
            a.getPointData().setTCoords(g);
            const h = [
                0,
                0,
                0
            ], v = [
                0,
                0,
                0
            ], m = [
                0,
                0
            ];
            let y = 0;
            h[0] = -e.xLength / 2, v[0] = -1, v[1] = 0, v[2] = 0;
            for(let C = 0; C < 2; C++){
                h[1] = -e.yLength / 2;
                for(let T = 0; T < 2; T++){
                    m[1] = h[1] + .5, h[2] = -e.zLength / 2;
                    for(let x = 0; x < 2; x++)m[0] = (h[2] + .5) * (1 - 2 * C), s[y * 3] = h[0], s[y * 3 + 1] = h[1], s[y * 3 + 2] = h[2], c[y * 3] = v[0], c[y * 3 + 1] = v[1], c[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * C - 1, u[y * f + 1] = 2 * T - 1, u[y * f + 2] = 2 * x - 1), y++, h[2] += e.zLength;
                    h[1] += e.yLength;
                }
                h[0] += e.xLength, v[0] += 2;
            }
            h[1] = -e.yLength / 2, v[1] = -1, v[0] = 0, v[2] = 0;
            for(let C = 0; C < 2; C++){
                h[0] = -e.xLength / 2;
                for(let T = 0; T < 2; T++){
                    m[0] = (h[0] + .5) * (2 * C - 1), h[2] = -e.zLength / 2;
                    for(let x = 0; x < 2; x++)m[1] = (h[2] + .5) * -1, s[y * 3] = h[0], s[y * 3 + 1] = h[1], s[y * 3 + 2] = h[2], c[y * 3] = v[0], c[y * 3 + 1] = v[1], c[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * T - 1, u[y * f + 1] = 2 * C - 1, u[y * f + 2] = 2 * x - 1), y++, h[2] += e.zLength;
                    h[0] += e.xLength;
                }
                h[1] += e.yLength, v[1] += 2;
            }
            h[2] = -e.zLength / 2, v[2] = -1, v[0] = 0, v[1] = 0;
            for(let C = 0; C < 2; C++){
                h[1] = -e.yLength / 2;
                for(let T = 0; T < 2; T++){
                    m[1] = h[1] + .5, h[0] = -e.xLength / 2;
                    for(let x = 0; x < 2; x++)m[0] = (h[0] + .5) * (2 * C - 1), s[y * 3] = h[0], s[y * 3 + 1] = h[1], s[y * 3 + 2] = h[2], c[y * 3] = v[0], c[y * 3 + 1] = v[1], c[y * 3 + 2] = v[2], f === 2 ? (u[y * f] = m[0], u[y * f + 1] = m[1]) : (u[y * f] = 2 * x - 1, u[y * f + 1] = 2 * T - 1, u[y * f + 2] = 2 * C - 1), y++, h[0] += e.xLength;
                    h[1] += e.yLength;
                }
                h[2] += e.zLength, v[2] += 2;
            }
            if (e.rotations && M0.buildFromDegree().rotateX(e.rotations[0]).rotateY(e.rotations[1]).rotateZ(e.rotations[2]).apply(s).apply(c), e.center && M0.buildFromRadian().translate(...e.center).apply(s), e.matrix) {
                M0.buildFromRadian().setMatrix(e.matrix).apply(s);
                const C = [
                    e.matrix[0],
                    e.matrix[1],
                    e.matrix[2],
                    0,
                    e.matrix[4],
                    e.matrix[5],
                    e.matrix[6],
                    0,
                    e.matrix[8],
                    e.matrix[9],
                    e.matrix[10],
                    0,
                    0,
                    0,
                    0,
                    1
                ];
                M0.buildFromRadian().setMatrix(C).apply(c);
            }
            e.generateFaces ? a.getPolys().deepCopy(e._polys) : a.getPolys().initialize(), e.generateLines ? (a.getLines().deepCopy(e._lineCells), a.getPointData().setNormals(null)) : a.getLines().initialize(), a.modified();
        }
        t.setBounds = function() {
            let r = [];
            if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) r = arguments.length <= 0 ? void 0 : arguments[0];
            else for(let i = 0; i < arguments.length; i++)r.push(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
            r.length === 6 && (t.setXLength(r[1] - r[0]), t.setYLength(r[3] - r[2]), t.setZLength(r[5] - r[4]), t.setCenter([
                (r[0] + r[1]) / 2,
                (r[2] + r[3]) / 2,
                (r[4] + r[5]) / 2
            ]));
        }, t.requestData = n;
    }
    const sU = {
        xLength: 1,
        yLength: 1,
        zLength: 1,
        pointType: "Float64Array",
        generate3DTextureCoordinates: !1,
        generateFaces: !0,
        generateLines: !1
    };
    function $S(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, sU, n), K.obj(t, e), K.setGet(t, e, [
            "xLength",
            "yLength",
            "zLength",
            "generate3DTextureCoordinates",
            "generateFaces",
            "generateLines"
        ]), K.setGetArray(t, e, [
            "center",
            "rotations"
        ], 3), K.setGetArray(t, e, [
            "matrix"
        ], 16), e._polys = W0.newInstance({
            values: Uint16Array.from(aU)
        }), e._lineCells = W0.newInstance({
            values: Uint16Array.from(iU)
        }), K.moveToProtected(t, e, [
            "polys",
            "lineCells"
        ]), K.algo(t, e, 0, 1), oU(t, e);
    }
    const cU = K.newInstance($S, "vtkCubeSource");
    var lU = {
        newInstance: cU,
        extend: $S
    };
    const { vtkErrorMacro: W9 } = K;
    function uU(t, e) {
        e.classHierarchy.push("vtkImageDataOutlineFilter");
        const n = {
            ...t
        };
        t.requestData = (r, i)=>{
            const a = r[0];
            if (!a || !a.isA("vtkImageData")) {
                W9("Invalid or missing input");
                return;
            }
            const o = a.getSpatialExtent();
            if (!o) {
                W9("Unable to fetch spatial extents of input image.");
                return;
            }
            e._cubeSource.setBounds(o), e._cubeSource.setMatrix(a.getIndexToWorld()), i[0] = e._cubeSource.getOutputData();
        }, t.getMTime = ()=>Math.max(n.getMTime(), e._cubeSource.getMTime()), t.setGenerateFaces = e._cubeSource.setGenerateFaces, t.setGenerateLines = e._cubeSource.setGenerateLines, t.getGenerateFaces = e._cubeSource.getGenerateFaces, t.getGenerateLines = e._cubeSource.getGenerateLines;
    }
    const fU = {};
    function zS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, fU, n), K.obj(t, e), K.algo(t, e, 1, 1), e._cubeSource = lU.newInstance(), K.moveToProtected(t, e, [
            "cubeSource",
            "tmpOut"
        ]), uU(t, e);
    }
    const dU = K.newInstance(zS, "vtkImageDataOutlineFilter");
    var gU = {
        newInstance: dU,
        extend: zS
    };
    const bd = {
        CLAMP_TO_EDGE: 0,
        REPEAT: 1,
        MIRRORED_REPEAT: 2
    }, Tt = {
        NEAREST: 0,
        LINEAR: 1,
        NEAREST_MIPMAP_NEAREST: 2,
        NEAREST_MIPMAP_LINEAR: 3,
        LINEAR_MIPMAP_NEAREST: 4,
        LINEAR_MIPMAP_LINEAR: 5
    };
    var jS = {
        Wrap: bd,
        Filter: Tt
    };
    const HS = new Float32Array(1), hU = new Int32Array(HS.buffer);
    function pU(t) {
        HS[0] = t;
        const e = hU[0];
        let n = e >> 16 & 32768, r = e >> 12 & 2047;
        const i = e >> 23 & 255;
        return i < 103 ? n : i > 142 ? (n |= 31744, n |= (i === 255 ? 0 : 1) && e & 8388607, n) : i < 113 ? (r |= 2048, n |= (r >> 114 - i) + (r >> 113 - i & 1), n) : (n |= i - 112 << 10 | r >> 1, n += r & 1, n);
    }
    function mU(t) {
        const e = (t & 32768) >> 15, n = (t & 31744) >> 10, r = t & 1023;
        return n === 0 ? (e ? -1 : 1) * 2 ** -14 * (r / 2 ** 10) : n === 31 ? r ? NaN : (e ? -1 : 1) * (1 / 0) : (e ? -1 : 1) * 2 ** (n - 15) * (1 + r / 2 ** 10);
    }
    _u = {
        fromHalf: mU,
        toHalf: pU
    };
    function vU() {
        try {
            const r = new Int16Array([
                0,
                32767
            ]), i = [
                1,
                1
            ], a = document.createElement("canvas");
            a.width = 4, a.height = 4;
            const o = a.getContext("webgl2");
            if (!o) return !1;
            const s = o.getExtension("EXT_texture_norm16");
            if (!s) return !1;
            const c = `#version 300 es
    void main() {
      gl_PointSize = ${4..toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `, l = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `, f = o.createShader(o.VERTEX_SHADER);
            if (o.shaderSource(f, c), o.compileShader(f), !o.getShaderParameter(f, o.COMPILE_STATUS)) return !1;
            const u = o.createShader(o.FRAGMENT_SHADER);
            if (o.shaderSource(u, l), o.compileShader(u), !o.getShaderParameter(u, o.COMPILE_STATUS)) return !1;
            const g = o.createProgram();
            if (o.attachShader(g, f), o.attachShader(g, u), o.linkProgram(g), !o.getProgramParameter(g, o.LINK_STATUS)) return !1;
            const h = o.createTexture();
            o.bindTexture(o.TEXTURE_2D, h), o.texImage2D(o.TEXTURE_2D, 0, s.R16_SNORM_EXT, 2, 1, 0, o.RED, o.SHORT, r), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.LINEAR), o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.LINEAR), o.useProgram(g), o.drawArrays(o.POINTS, 0, 1);
            const v = new Uint8Array(4);
            o.readPixels(i[0], i[1], 1, 1, o.RGBA, o.UNSIGNED_BYTE, v);
            const [m, y, C] = v, T = o.getExtension("WEBGL_lose_context");
            return T && T.loseContext(), m === y && y === C && m !== 0;
        } catch  {
            return !1;
        }
    }
    let p5;
    function yU() {
        return p5 === void 0 && (p5 = vU()), p5;
    }
    const { Wrap: Uc, Filter: mi } = jS, { VtkDataTypes: vn } = Wt, { vtkDebugMacro: m5, vtkErrorMacro: gu, vtkWarningMacro: $9 } = da, { toHalf: CU } = _u;
    function wU(t, e) {
        e.classHierarchy.push("vtkOpenGLTexture");
        function n() {
            return {
                internalFormat: e.internalFormat,
                format: e.format,
                openGLDataType: e.openGLDataType,
                width: e.width,
                height: e.height
            };
        }
        t.render = function() {
            let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            if (v ? e._openGLRenderWindow = v : (e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")), e.context = e._openGLRenderWindow.getContext(), e.renderable.getInterpolate() ? (e.generateMipmap ? t.setMinificationFilter(mi.LINEAR_MIPMAP_LINEAR) : t.setMinificationFilter(mi.LINEAR), t.setMagnificationFilter(mi.LINEAR)) : (t.setMinificationFilter(mi.NEAREST), t.setMagnificationFilter(mi.NEAREST)), e.renderable.getRepeat() && (t.setWrapR(Uc.REPEAT), t.setWrapS(Uc.REPEAT), t.setWrapT(Uc.REPEAT)), e.renderable.getInputData() && e.renderable.setImage(null), !e.handle || e.renderable.getMTime() > e.textureBuildTime.getMTime()) {
                if (e.renderable.getImage() !== null && (e.renderable.getInterpolate() && (e.generateMipmap = !0, t.setMinificationFilter(mi.LINEAR_MIPMAP_LINEAR)), e.renderable.getImage() && e.renderable.getImageLoaded() && (t.create2DFromImage(e.renderable.getImage()), t.activate(), t.sendParameters(), e.textureBuildTime.modified())), e.renderable.getCanvas() !== null) {
                    e.renderable.getInterpolate() && (e.generateMipmap = !0, t.setMinificationFilter(mi.LINEAR_MIPMAP_LINEAR));
                    const y = e.renderable.getCanvas();
                    t.create2DFromRaw(y.width, y.height, 4, vn.UNSIGNED_CHAR, y, !0), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
                }
                if (e.renderable.getJsImageData() !== null) {
                    const y = e.renderable.getJsImageData();
                    e.renderable.getInterpolate() && (e.generateMipmap = !0, t.setMinificationFilter(mi.LINEAR_MIPMAP_LINEAR)), t.create2DFromRaw(y.width, y.height, 4, vn.UNSIGNED_CHAR, y.data, !0), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
                }
                const m = e.renderable.getInputData(0);
                if (m && m.getPointData().getScalars()) {
                    const y = m.getExtent(), C = m.getPointData().getScalars(), T = [];
                    for(let x = 0; x < e.renderable.getNumberOfInputPorts(); ++x){
                        const S = e.renderable.getInputData(x), D = S ? S.getPointData().getScalars().getData() : null;
                        D && T.push(D);
                    }
                    e.renderable.getInterpolate() && C.getNumberOfComponents() === 4 && (e.generateMipmap = !0, t.setMinificationFilter(mi.LINEAR_MIPMAP_LINEAR)), T.length % 6 === 0 ? t.createCubeFromRaw(y[1] - y[0] + 1, y[3] - y[2] + 1, C.getNumberOfComponents(), C.getDataType(), T) : t.create2DFromRaw(y[1] - y[0] + 1, y[3] - y[2] + 1, C.getNumberOfComponents(), C.getDataType(), C.getData()), t.activate(), t.sendParameters(), e.textureBuildTime.modified();
                }
            }
            e.handle && t.activate();
        };
        const r = ()=>{
            if (!((e.minificationFilter === mi.LINEAR || e.magnificationFilter === mi.LINEAR) && !yU())) return e.oglNorm16Ext;
        };
        t.destroyTexture = ()=>{
            t.deactivate(), e.context && e.handle && e.context.deleteTexture(e.handle), e._prevTexParams = null, e.handle = 0, e.numberOfDimensions = 0, e.target = 0, e.components = 0, e.width = 0, e.height = 0, e.depth = 0, t.resetFormatAndType();
        }, t.createTexture = ()=>{
            e.handle || (e.handle = e.context.createTexture(), e.target && (e.context.bindTexture(e.target, e.handle), e.context.texParameteri(e.target, e.context.TEXTURE_MIN_FILTER, t.getOpenGLFilterMode(e.minificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_MAG_FILTER, t.getOpenGLFilterMode(e.magnificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_S, t.getOpenGLWrapMode(e.wrapS)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_T, t.getOpenGLWrapMode(e.wrapT)), e._openGLRenderWindow.getWebgl2() && e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_R, t.getOpenGLWrapMode(e.wrapR)), e.context.bindTexture(e.target, null)));
        }, t.getTextureUnit = ()=>e._openGLRenderWindow ? e._openGLRenderWindow.getTextureUnitForTexture(t) : -1, t.activate = ()=>{
            e._openGLRenderWindow.activateTexture(t), t.bind();
        }, t.deactivate = ()=>{
            e._openGLRenderWindow && e._openGLRenderWindow.deactivateTexture(t);
        }, t.releaseGraphicsResources = (v)=>{
            v && e.handle && (v.activateTexture(t), v.deactivateTexture(t), e.context.deleteTexture(e.handle), e._prevTexParams = null, e.handle = 0, e.numberOfDimensions = 0, e.target = 0, e.internalFormat = 0, e.format = 0, e.openGLDataType = 0, e.components = 0, e.width = 0, e.height = 0, e.depth = 0, e.allocatedGPUMemoryInBytes = 0), e.shaderProgram && (e.shaderProgram.releaseGraphicsResources(v), e.shaderProgram = null);
        }, t.bind = ()=>{
            e.context.bindTexture(e.target, e.handle), e.autoParameters && t.getMTime() > e.sendParametersTime.getMTime() && t.sendParameters();
        }, t.isBound = ()=>{
            let v = !1;
            if (e.context && e.handle) {
                let m = 0;
                switch(e.target){
                    case e.context.TEXTURE_2D:
                        m = e.context.TEXTURE_BINDING_2D;
                        break;
                    default:
                        $9("impossible case");
                        break;
                }
                v = e.context.getIntegerv(m) === e.handle;
            }
            return v;
        }, t.sendParameters = ()=>{
            e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_S, t.getOpenGLWrapMode(e.wrapS)), e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_T, t.getOpenGLWrapMode(e.wrapT)), e._openGLRenderWindow.getWebgl2() && e.context.texParameteri(e.target, e.context.TEXTURE_WRAP_R, t.getOpenGLWrapMode(e.wrapR)), e.context.texParameteri(e.target, e.context.TEXTURE_MIN_FILTER, t.getOpenGLFilterMode(e.minificationFilter)), e.context.texParameteri(e.target, e.context.TEXTURE_MAG_FILTER, t.getOpenGLFilterMode(e.magnificationFilter)), e._openGLRenderWindow.getWebgl2() && (e.context.texParameteri(e.target, e.context.TEXTURE_BASE_LEVEL, e.baseLevel), e.context.texParameteri(e.target, e.context.TEXTURE_MAX_LEVEL, e.maxLevel)), e.sendParametersTime.modified();
        }, t.getInternalFormat = (v, m)=>(e._forceInternalFormat || (e.internalFormat = t.getDefaultInternalFormat(v, m)), e.internalFormat || m5(`Unable to find suitable internal format for T=${v} NC= ${m}`), [
                e.context.R32F,
                e.context.RG32F,
                e.context.RGB32F,
                e.context.RGBA32F
            ].includes(e.internalFormat) && !e.context.getExtension("OES_texture_float_linear") && $9("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."), e.internalFormat), t.getDefaultInternalFormat = (v, m)=>{
            let y = 0;
            return y = e._openGLRenderWindow.getDefaultTextureInternalFormat(v, m, r(), t.useHalfFloat()), y || (y || (m5("Unsupported internal texture type!"), m5(`Unable to find suitable internal format for T=${v} NC= ${m}`)), y);
        }, t.useHalfFloat = ()=>e.enableUseHalfFloat && e.canUseHalfFloat, t.setInternalFormat = (v)=>{
            e._forceInternalFormat = !0, v !== e.internalFormat && (e.internalFormat = v, t.modified());
        }, t.getFormat = (v, m)=>(e.format = t.getDefaultFormat(v, m), e.format), t.getDefaultFormat = (v, m)=>{
            if (e._openGLRenderWindow.getWebgl2()) switch(m){
                case 1:
                    return e.context.RED;
                case 2:
                    return e.context.RG;
                case 3:
                    return e.context.RGB;
                case 4:
                    return e.context.RGBA;
                default:
                    return e.context.RGB;
            }
            else switch(m){
                case 1:
                    return e.context.LUMINANCE;
                case 2:
                    return e.context.LUMINANCE_ALPHA;
                case 3:
                    return e.context.RGB;
                case 4:
                    return e.context.RGBA;
                default:
                    return e.context.RGB;
            }
        }, t.resetFormatAndType = ()=>{
            e._prevTexParams = null, e.format = 0, e.internalFormat = 0, e._forceInternalFormat = !1, e.openGLDataType = 0;
        }, t.getDefaultDataType = (v)=>{
            const m = t.useHalfFloat();
            if (e._openGLRenderWindow.getWebgl2()) switch(v){
                case vn.UNSIGNED_CHAR:
                    return e.context.UNSIGNED_BYTE;
                case (r() && !m && vn.SHORT):
                    return e.context.SHORT;
                case (r() && !m && vn.UNSIGNED_SHORT):
                    return e.context.UNSIGNED_SHORT;
                case (m && vn.SHORT):
                    return e.context.HALF_FLOAT;
                case (m && vn.UNSIGNED_SHORT):
                    return e.context.HALF_FLOAT;
                case vn.FLOAT:
                case vn.VOID:
                default:
                    return e.context.FLOAT;
            }
            switch(v){
                case vn.UNSIGNED_CHAR:
                    return e.context.UNSIGNED_BYTE;
                case vn.FLOAT:
                case vn.VOID:
                default:
                    if (e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) return e.context.FLOAT;
                    {
                        const y = e.context.getExtension("OES_texture_half_float");
                        if (y && e.context.getExtension("OES_texture_half_float_linear")) return y.HALF_FLOAT_OES;
                    }
                    return e.context.UNSIGNED_BYTE;
            }
        }, t.getOpenGLDataType = function(v) {
            let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return (!e.openGLDataType || m) && (e.openGLDataType = t.getDefaultDataType(v)), e.openGLDataType;
        }, t.getShiftAndScale = ()=>{
            let v = 0, m = 1;
            switch(e.openGLDataType){
                case e.context.BYTE:
                    m = 127.5, v = m - 128;
                    break;
                case e.context.UNSIGNED_BYTE:
                    m = 255, v = 0;
                    break;
                case e.context.SHORT:
                    m = 32767.5, v = m - 32768;
                    break;
                case e.context.UNSIGNED_SHORT:
                    m = 65536, v = 0;
                    break;
                case e.context.INT:
                    m = 21474836475e-1, v = m - 2147483648;
                    break;
                case e.context.UNSIGNED_INT:
                    m = 4294967295, v = 0;
                    break;
                case e.context.FLOAT:
            }
            return {
                shift: v,
                scale: m
            };
        }, t.getOpenGLFilterMode = (v)=>{
            switch(v){
                case mi.NEAREST:
                    return e.context.NEAREST;
                case mi.LINEAR:
                    return e.context.LINEAR;
                case mi.NEAREST_MIPMAP_NEAREST:
                    return e.context.NEAREST_MIPMAP_NEAREST;
                case mi.NEAREST_MIPMAP_LINEAR:
                    return e.context.NEAREST_MIPMAP_LINEAR;
                case mi.LINEAR_MIPMAP_NEAREST:
                    return e.context.LINEAR_MIPMAP_NEAREST;
                case mi.LINEAR_MIPMAP_LINEAR:
                    return e.context.LINEAR_MIPMAP_LINEAR;
                default:
                    return e.context.NEAREST;
            }
        }, t.getOpenGLWrapMode = (v)=>{
            switch(v){
                case Uc.CLAMP_TO_EDGE:
                    return e.context.CLAMP_TO_EDGE;
                case Uc.REPEAT:
                    return e.context.REPEAT;
                case Uc.MIRRORED_REPEAT:
                    return e.context.MIRRORED_REPEAT;
                default:
                    return e.context.CLAMP_TO_EDGE;
            }
        };
        function i(v) {
            const [m, y, C, T, x, S] = v;
            return [
                y - m + 1,
                T - C + 1,
                S - x + 1
            ];
        }
        function a(v) {
            const [m, y, C] = i(v);
            return m * y * C;
        }
        function o(v, m, y, C, T) {
            const [x, S, D, _, M, P] = y, [F, N] = m, B = F * N;
            let G = T;
            for(let Z = M; Z <= P; Z++){
                const H = Z * B;
                for(let ne = D; ne <= _; ne++){
                    const ae = H + ne * F;
                    for(let ue = ae + x, le = ae + S; ue <= le; ue++, G++)C[G] = v[ue];
                }
            }
        }
        function s(v, m) {
            const C = (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null) || v.constructor, T = m.reduce((_, M)=>_ + a(M), 0), x = new C(T), S = [
                e.width,
                e.height,
                e.depth
            ];
            let D = 0;
            return m.forEach((_)=>{
                o(v, S, _, x, D), D += a(_);
            }), x;
        }
        t.updateArrayDataTypeForGL = function(v, m) {
            let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, C = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
            const T = [];
            let x = e.width * e.height * e.components;
            y && (x *= e.depth);
            const S = !!C.length;
            if (v !== vn.FLOAT && e.openGLDataType === e.context.FLOAT) for(let _ = 0; _ < m.length; _++)if (m[_]) if (S) T.push(s(m[_], C, Float32Array));
            else {
                const M = m[_].length > x ? m[_].subarray(0, x) : m[_];
                T.push(new Float32Array(M));
            }
            else T.push(null);
            if (v !== vn.UNSIGNED_CHAR && e.openGLDataType === e.context.UNSIGNED_BYTE) for(let _ = 0; _ < m.length; _++)if (m[_]) if (S) T.push(s(m[_], C, Uint8Array));
            else {
                const M = m[_].length > x ? m[_].subarray(0, x) : m[_];
                T.push(new Uint8Array(M));
            }
            else T.push(null);
            let D = !1;
            if (e._openGLRenderWindow.getWebgl2()) D = e.openGLDataType === e.context.HALF_FLOAT;
            else {
                const _ = e.context.getExtension("OES_texture_half_float");
                D = _ && e.openGLDataType === _.HALF_FLOAT_OES;
            }
            if (D) for(let _ = 0; _ < m.length; _++)if (m[_]) {
                const M = S ? s(m[_], C) : m[_], P = new Uint16Array(S ? M.length : x), F = P.length;
                for(let N = 0; N < F; N++)P[N] = CU(M[N]);
                T.push(P);
            } else T.push(null);
            if (T.length === 0) for(let _ = 0; _ < m.length; _++)T.push(S && m[_] ? s(m[_], C) : m[_]);
            return T;
        };
        function c(v) {
            if (e._openGLRenderWindow.getWebgl2()) return v;
            const m = [], y = e.width, C = e.height, T = e.components;
            if (v && (!td(y) || !td(C))) {
                const x = e.context.getExtension("OES_texture_half_float"), S = El(y), D = El(C), _ = S * D * e.components;
                for(let M = 0; M < v.length; M++)if (v[M] !== null) {
                    let P = null;
                    const F = C / D, N = y / S;
                    let B = !1;
                    e.openGLDataType === e.context.FLOAT ? P = new Float32Array(_) : x && e.openGLDataType === x.HALF_FLOAT_OES ? (P = new Uint16Array(_), B = !0) : P = new Uint8Array(_);
                    for(let G = 0; G < D; G++){
                        const Z = G * S * T, H = G * F;
                        let ne = Math.floor(H), ae = Math.ceil(H);
                        ae >= C && (ae = C - 1);
                        const ue = H - ne, le = 1 - ue;
                        ne = ne * y * T, ae = ae * y * T;
                        for(let oe = 0; oe < S; oe++){
                            const re = oe * T, X = oe * N;
                            let ie = Math.floor(X), he = Math.ceil(X);
                            he >= y && (he = y - 1);
                            const $e = X - ie;
                            ie *= T, he *= T;
                            for(let je = 0; je < T; je++)B ? P[Z + re + je] = _u.toHalf(_u.fromHalf(v[M][ne + ie + je]) * le * (1 - $e) + _u.fromHalf(v[M][ne + he + je]) * le * $e + _u.fromHalf(v[M][ae + ie + je]) * ue * (1 - $e) + _u.fromHalf(v[M][ae + he + je]) * ue * $e) : P[Z + re + je] = v[M][ne + ie + je] * le * (1 - $e) + v[M][ne + he + je] * le * $e + v[M][ae + ie + je] * ue * (1 - $e) + v[M][ae + he + je] * ue * $e;
                        }
                    }
                    m.push(P), e.width = S, e.height = D;
                } else m.push(null);
            }
            if (m.length === 0) for(let x = 0; x < v.length; x++)m.push(v[x]);
            return m;
        }
        function l(v) {
            return e._openGLRenderWindow ? e.resizable || e.renderable?.getResizable() ? !1 : e._openGLRenderWindow.getWebgl2() ? !(e._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && r() && (v === vn.UNSIGNED_SHORT || v === vn.SHORT)) : !1 : !1;
        }
        t.create2DFromRaw = function(v, m, y, C, T) {
            let x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
            if (t.getOpenGLDataType(C, !0), t.getInternalFormat(C, y), t.getFormat(C, y), !e.internalFormat || !e.format || !e.openGLDataType) return gu("Failed to determine texture parameters."), !1;
            e.target = e.context.TEXTURE_2D, e.components = y, e.width = v, e.height = m, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind();
            const S = [
                T
            ], D = t.updateArrayDataTypeForGL(C, S), _ = c(D);
            return e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL, x), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), l(C) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), _[0] != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, _[0])) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, _[0]), e.generateMipmap && e.context.generateMipmap(e.target), x && e.context.pixelStorei(e.context.UNPACK_FLIP_Y_WEBGL, !1), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * y * e._openGLRenderWindow.getDefaultTextureByteSize(C, r(), t.useHalfFloat()), t.deactivate(), !0;
        }, t.createCubeFromRaw = (v, m, y, C, T)=>{
            if (t.getOpenGLDataType(C), t.getInternalFormat(C, y), t.getFormat(C, y), !e.internalFormat || !e.format || !e.openGLDataType) return gu("Failed to determine texture parameters."), !1;
            e.target = e.context.TEXTURE_CUBE_MAP, e.components = y, e.width = v, e.height = m, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), e.maxLevel = T.length / 6 - 1, t.createTexture(), t.bind();
            const x = t.updateArrayDataTypeForGL(C, T), S = c(x), D = [];
            let _ = e.width, M = e.height;
            for(let P = 0; P < S.length; P++){
                P % 6 === 0 && P !== 0 && (_ /= 2, M /= 2), D[P] = nf(C, M * _ * e.components);
                for(let F = 0; F < M; ++F){
                    const N = F * _ * e.components, B = (M - F - 1) * _ * e.components;
                    D[P].set(S[P].slice(B, B + _ * e.components), N);
                }
            }
            e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), l(C) && e.context.texStorage2D(e.target, 6, e.internalFormat, e.width, e.height);
            for(let P = 0; P < 6; P++){
                let F = 0, N = e.width, B = e.height;
                for(; N >= 1 && B >= 1;){
                    let G = null;
                    F <= e.maxLevel && (G = D[6 * F + P]), l(C) ? G != null && e.context.texSubImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X + P, F, 0, 0, N, B, e.format, e.openGLDataType, G) : e.context.texImage2D(e.context.TEXTURE_CUBE_MAP_POSITIVE_X + P, F, e.internalFormat, N, B, 0, e.format, e.openGLDataType, G), F++, N /= 2, B /= 2;
                }
            }
            return e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * y * e._openGLRenderWindow.getDefaultTextureByteSize(C, r(), t.useHalfFloat()), t.deactivate(), !0;
        }, t.createDepthFromRaw = (v, m, y, C)=>(t.getOpenGLDataType(y), e.format = e.context.DEPTH_COMPONENT, e._openGLRenderWindow.getWebgl2() ? y === vn.FLOAT ? e.internalFormat = e.context.DEPTH_COMPONENT32F : e.internalFormat = e.context.DEPTH_COMPONENT16 : e.internalFormat = e.context.DEPTH_COMPONENT, !e.internalFormat || !e.format || !e.openGLDataType ? (gu("Failed to determine texture parameters."), !1) : (e.target = e.context.TEXTURE_2D, e.components = 1, e.width = v, e.height = m, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), l(y) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), C != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, C)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, C), e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(y, r(), t.useHalfFloat()), t.deactivate(), !0)), t.create2DFromImage = (v)=>{
            if (t.getOpenGLDataType(vn.UNSIGNED_CHAR), t.getInternalFormat(vn.UNSIGNED_CHAR, 4), t.getFormat(vn.UNSIGNED_CHAR, 4), !e.internalFormat || !e.format || !e.openGLDataType) return gu("Failed to determine texture parameters."), !1;
            e.target = e.context.TEXTURE_2D, e.components = 4, e.depth = 1, e.numberOfDimensions = 2, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1);
            const m = !e._openGLRenderWindow.getWebgl2() && (!td(v.width) || !td(v.height)), y = document.createElement("canvas");
            y.width = m ? El(v.width) : v.width, y.height = m ? El(v.height) : v.height, e.width = y.width, e.height = y.height;
            const C = y.getContext("2d");
            C.translate(0, y.height), C.scale(1, -1), C.drawImage(v, 0, 0, v.width, v.height, 0, 0, y.width, y.height);
            const T = y;
            return l(vn.UNSIGNED_CHAR) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), T != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, T)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, T), e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(vn.UNSIGNED_CHAR, r(), t.useHalfFloat()), t.deactivate(), !0;
        };
        function f(v, m, y) {
            const C = new Array(y), T = new Array(y);
            for(let x = 0; x < y; ++x)C[x] = v[x], T[x] = m[x] - v[x] || 1;
            return {
                scale: T,
                offset: C
            };
        }
        function u(v, m) {
            for(let y = 0; y < v.length; y++){
                const C = v[y], T = m[y] + C;
                if (C < -2048 || C > 2048 || T < -2048 || T > 2048) return !1;
            }
            return !0;
        }
        function g(v, m, y, C) {
            t.getOpenGLDataType(v);
            const T = u(m, y) || C;
            let x = !1;
            if (e._openGLRenderWindow.getWebgl2()) x = e.openGLDataType === e.context.FLOAT && e.context.getExtension("OES_texture_float_linear") === null && T || e.openGLDataType === e.context.HALF_FLOAT;
            else {
                const S = e.context.getExtension("OES_texture_half_float");
                x = S && e.openGLDataType === S.HALF_FLOAT_OES;
            }
            e.canUseHalfFloat = x && T;
        }
        function h(v, m) {
            const y = v.getNumberOfComponents(), C = v.getDataType(), T = v.getData(), x = new Array(y), S = new Array(y);
            for(let _ = 0; _ < y; ++_){
                const [M, P] = v.getRange(_);
                x[_] = M, S[_] = P;
            }
            const D = f(x, S, y);
            return g(C, D.offset, D.scale, m), t.useHalfFloat() || t.getOpenGLDataType(C, !0), {
                numComps: y,
                dataType: C,
                data: T,
                scaleOffsets: D
            };
        }
        t.create2DFilterableFromRaw = function(v, m, y, C, T) {
            let x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0;
            return t.create2DFilterableFromDataArray(v, m, Wt.newInstance({
                numberOfComponents: y,
                dataType: C,
                values: T,
                ranges: S
            }), x);
        }, t.create2DFilterableFromDataArray = function(v, m, y) {
            let C = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            const { numComps: T, dataType: x, data: S } = h(y, C);
            t.create2DFromRaw(v, m, T, x, S);
        }, t.updateVolumeInfoForGL = (v, m)=>{
            let y = !1;
            const C = t.useHalfFloat();
            (!e.volumeInfo?.scale || !e.volumeInfo?.offset) && (e.volumeInfo = {
                scale: new Array(m),
                offset: new Array(m)
            });
            for(let T = 0; T < m; ++T)e.volumeInfo.scale[T] = 1, e.volumeInfo.offset[T] = 0;
            if (r() && !C && v === vn.SHORT) {
                for(let T = 0; T < m; ++T)e.volumeInfo.scale[T] = 32767;
                y = !0;
            }
            if (r() && !C && v === vn.UNSIGNED_SHORT) {
                for(let T = 0; T < m; ++T)e.volumeInfo.scale[T] = 65535;
                y = !0;
            }
            if (v === vn.UNSIGNED_CHAR) {
                for(let T = 0; T < m; ++T)e.volumeInfo.scale[T] = 255;
                y = !0;
            }
            return (v === vn.FLOAT || C && (v === vn.SHORT || v === vn.UNSIGNED_SHORT)) && (y = !0), y;
        }, t.create3DFromRaw = function(v, m, y, C, T, x) {
            let S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : [], D = T, _ = x;
            if (!t.updateVolumeInfoForGL(D, C) && _) {
                const Z = v * m * y, H = structuredClone(e.volumeInfo), ne = new Float32Array(Z * C);
                e.volumeInfo.offset = H.offset, e.volumeInfo.scale = H.scale;
                let ae = 0;
                const ue = H.scale.map((le)=>1 / le);
                for(let le = 0; le < Z; le++)for(let oe = 0; oe < C; oe++)ne[ae] = (_[ae] - H.offset[oe]) * ue[oe], ae++;
                D = vn.FLOAT, _ = ne;
            }
            if (t.getOpenGLDataType(D), t.getInternalFormat(D, C), t.getFormat(D, C), !e.internalFormat || !e.format || !e.openGLDataType) return gu("Failed to determine texture parameters."), !1;
            e.target = e.context.TEXTURE_3D, e.components = C, e.width = v, e.height = m, e.depth = y, e.numberOfDimensions = 3, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind();
            const M = S.length > 0, P = !M || !h3(e._prevTexParams, n()), F = [
                _
            ], B = t.updateArrayDataTypeForGL(D, F, !0, P ? [] : S), G = c(B);
            if (e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), P) l(D) ? (e.context.texStorage3D(e.target, 1, e.internalFormat, e.width, e.height, e.depth), G[0] != null && e.context.texSubImage3D(e.target, 0, 0, 0, 0, e.width, e.height, e.depth, e.format, e.openGLDataType, G[0])) : e.context.texImage3D(e.target, 0, e.internalFormat, e.width, e.height, e.depth, 0, e.format, e.openGLDataType, G[0]), e._prevTexParams = n();
            else if (M) {
                const Z = G[0];
                let H = 0;
                for(let ne = 0; ne < S.length; ne++){
                    const ae = S[ne], ue = i(ae), le = a(ae), oe = new Z.constructor(Z.buffer, H, le);
                    H += oe.byteLength, e.context.texSubImage3D(e.target, 0, ae[0], ae[2], ae[4], ue[0], ue[1], ue[2], e.format, e.openGLDataType, oe);
                }
            }
            return e.generateMipmap && e.context.generateMipmap(e.target), e.allocatedGPUMemoryInBytes = e.width * e.height * e.depth * e.components * e._openGLRenderWindow.getDefaultTextureByteSize(D, r(), t.useHalfFloat()), t.deactivate(), !0;
        }, t.create3DFilterableFromRaw = function(v, m, y, C, T, x) {
            let S = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, D = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0, _ = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : [];
            return t.create3DFilterableFromDataArray(v, m, y, Wt.newInstance({
                numberOfComponents: C,
                dataType: T,
                values: x,
                ranges: D
            }), S, _);
        }, t.create3DFilterableFromDataArray = function(v, m, y, C) {
            let T = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
            const { numComps: S, dataType: D, data: _, scaleOffsets: M } = h(C, T), P = [], F = [];
            for(let He = 0; He < S; ++He)P[He] = 0, F[He] = 1;
            if (e.volumeInfo = {
                scale: F,
                offset: P,
                dataComputedScale: M.scale,
                dataComputedOffset: M.offset,
                width: v,
                height: m,
                depth: y
            }, e._openGLRenderWindow.getWebgl2()) return t.create3DFromRaw(v, m, y, S, D, _, x);
            const N = v * m * y, B = structuredClone(M);
            let G = (He, rt, Qe, et, St)=>{
                He[rt] = Qe;
            }, Z = vn.UNSIGNED_CHAR;
            if (D === vn.UNSIGNED_CHAR) for(let He = 0; He < S; ++He)B.offset[He] = 0, B.scale[He] = 255;
            else e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear") ? (Z = vn.FLOAT, G = (He, rt, Qe, et, St)=>{
                He[rt] = (Qe - et) / St;
            }) : (Z = vn.UNSIGNED_CHAR, G = (He, rt, Qe, et, St)=>{
                He[rt] = 255 * (Qe - et) / St;
            });
            if (t.getOpenGLDataType(Z), t.getInternalFormat(Z, S), t.getFormat(Z, S), !e.internalFormat || !e.format || !e.openGLDataType) return gu("Failed to determine texture parameters."), !1;
            e.target = e.context.TEXTURE_2D, e.components = S, e.depth = 1, e.numberOfDimensions = 2;
            let H = e.context.getParameter(e.context.MAX_TEXTURE_SIZE);
            H > 4096 && (Z === vn.FLOAT || S >= 3) && (H = 4096);
            let ne = 1, ae = 1;
            N > H * H && (ne = Math.ceil(Math.sqrt(N / (H * H))), ae = ne);
            let ue = Math.sqrt(N) / ne;
            ue = El(ue);
            const le = Math.floor(ue * ne / v), oe = Math.ceil(y / le), re = El(m * oe / ae);
            e.width = ue, e.height = re, e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), e.volumeInfo.xreps = le, e.volumeInfo.yreps = oe, e.volumeInfo.xstride = ne, e.volumeInfo.ystride = ae, e.volumeInfo.offset = B.offset, e.volumeInfo.scale = B.scale;
            let X;
            const ie = ue * re * S;
            Z === vn.FLOAT ? X = new Float32Array(ie) : X = new Uint8Array(ie);
            let he = 0;
            const $e = Math.floor(v / ne), je = Math.floor(m / ae);
            for(let He = 0; He < oe; He++){
                const rt = Math.min(le, y - He * le), Qe = S * (e.width - rt * Math.floor(v / ne));
                for(let et = 0; et < je; et++){
                    for(let St = 0; St < rt; St++){
                        const Ln = S * ((He * le + St) * v * m + ae * et * v);
                        for(let Nn = 0; Nn < $e; Nn++)for(let zt = 0; zt < S; zt++)G(X, he, _[Ln + ne * Nn * S + zt], B.offset[zt], B.scale[zt]), he++;
                    }
                    he += Qe;
                }
            }
            return e.context.pixelStorei(e.context.UNPACK_ALIGNMENT, 1), l(Z) ? (e.context.texStorage2D(e.target, 1, e.internalFormat, e.width, e.height), X != null && e.context.texSubImage2D(e.target, 0, 0, 0, e.width, e.height, e.format, e.openGLDataType, X)) : e.context.texImage2D(e.target, 0, e.internalFormat, e.width, e.height, 0, e.format, e.openGLDataType, X), t.deactivate(), !0;
        }, t.setOpenGLRenderWindow = (v)=>{
            e._openGLRenderWindow !== v && (t.releaseGraphicsResources(), e._openGLRenderWindow = v, e.context = null, v && (e.context = e._openGLRenderWindow.getContext()));
        }, t.getMaximumTextureSize = (v)=>v && v.isCurrent() ? v.getIntegerv(v.MAX_TEXTURE_SIZE) : -1, t.enableUseHalfFloat = (v)=>{
            e.enableUseHalfFloat = v;
        };
    }
    const TU = {
        _openGLRenderWindow: null,
        _forceInternalFormat: !1,
        _prevTexParams: null,
        context: null,
        handle: 0,
        sendParametersTime: null,
        textureBuildTime: null,
        numberOfDimensions: 0,
        target: 0,
        format: 0,
        openGLDataType: 0,
        components: 0,
        width: 0,
        height: 0,
        depth: 0,
        autoParameters: !0,
        wrapS: Uc.CLAMP_TO_EDGE,
        wrapT: Uc.CLAMP_TO_EDGE,
        wrapR: Uc.CLAMP_TO_EDGE,
        minificationFilter: mi.NEAREST,
        magnificationFilter: mi.NEAREST,
        minLOD: -1e3,
        maxLOD: 1e3,
        baseLevel: 0,
        maxLevel: 1e3,
        generateMipmap: !1,
        oglNorm16Ext: null,
        allocatedGPUMemoryInBytes: 0,
        enableUseHalfFloat: !0,
        canUseHalfFloat: !1
    };
    function KS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, TU, n), Yr.extend(t, e, n), e.sendParametersTime = {}, tr(e.sendParametersTime, {
            mtime: 0
        }), e.textureBuildTime = {}, tr(e.textureBuildTime, {
            mtime: 0
        }), $d(t, e, [
            "format",
            "openGLDataType"
        ]), si(t, e, [
            "keyMatrixTime",
            "minificationFilter",
            "magnificationFilter",
            "wrapS",
            "wrapT",
            "wrapR",
            "generateMipmap",
            "oglNorm16Ext"
        ]), La(t, e, [
            "width",
            "height",
            "volumeInfo",
            "components",
            "handle",
            "target",
            "allocatedGPUMemoryInBytes"
        ]), zd(t, e, [
            "openGLRenderWindow"
        ]), wU(t, e);
    }
    const qS = kn(KS, "vtkOpenGLTexture");
    var Qn = {
        newInstance: qS,
        extend: KS,
        ...jS
    };
    bi("vtkTexture", qS);
    function xU(t, e) {
        t.replaceShaderCoincidentOffset = (n, r, i)=>{
            const a = t.getCoincidentParameters(r, i);
            if (a && (a.factor !== 0 || a.offset !== 0)) {
                let o = n.Fragment;
                o = Te.substitute(o, "//VTK::Coincident::Dec", [
                    "uniform float cfactor;",
                    "uniform float coffset;"
                ]).result, e.context.getExtension("EXT_frag_depth") && (a.factor !== 0 ? (o = Te.substitute(o, "//VTK::UniformFlow::Impl", [
                    "float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));",
                    "//VTK::UniformFlow::Impl"
                ], !1).result, o = Te.substitute(o, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result) : o = Te.substitute(o, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result), e._openGLRenderWindow.getWebgl2() && (a.factor !== 0 ? (o = Te.substitute(o, "//VTK::UniformFlow::Impl", [
                    "float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));",
                    "//VTK::UniformFlow::Impl"
                ], !1).result, o = Te.substitute(o, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result) : o = Te.substitute(o, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result), n.Fragment = o;
            }
        };
    }
    function SU(t, e) {
        t.applyShaderReplacements = (n, r, i)=>{
            let a = null;
            if (r && (a = r.ShaderReplacements), a) for(let o = 0; o < a.length; o++){
                const s = a[o];
                if (i && s.replaceFirst || !i && !s.replaceFirst) {
                    const c = s.shaderType, l = n[c], f = Te.substitute(l, s.originalValue, s.replacementValue, s.replaceAll);
                    n[c] = f.result;
                }
            }
        }, t.buildShaders = (n, r, i)=>{
            t.getReplacedShaderTemplate(n, r, i), e.lastRenderPassShaderReplacement = e.currentRenderPass ? e.currentRenderPass.getShaderReplacement() : null, e.lastRenderPassShaderReplacement && e.lastRenderPassShaderReplacement(n);
            const a = e.renderable.getViewSpecificProperties().OpenGL;
            t.applyShaderReplacements(n, a, !0), t.replaceShaderValues(n, r, i), t.applyShaderReplacements(n, a);
        }, t.getReplacedShaderTemplate = (n, r, i)=>{
            const a = e.renderable.getViewSpecificProperties().OpenGL;
            t.getShaderTemplate(n, r, i);
            let o = n.Vertex;
            if (a) {
                const l = a.VertexShaderCode;
                l !== void 0 && l !== "" && (o = l);
            }
            n.Vertex = o;
            let s = n.Fragment;
            if (a) {
                const l = a.FragmentShaderCode;
                l !== void 0 && l !== "" && (s = l);
            }
            n.Fragment = s;
            let c = n.Geometry;
            if (a) {
                const l = a.GeometryShaderCode;
                l !== void 0 && (c = l);
            }
            n.Geometry = c;
        };
    }
    Wl = {
        implementReplaceShaderCoincidentOffset: xU,
        implementBuildShadersWithReplacements: SU
    };
    let l4;
    function EU(t, e) {
        e.classHierarchy.push("vtkAbstractTransform", "vtkHomogeneousTransform", "vtkTransform"), t.transformPoint = (n, r)=>(pn(r, n, e.matrix), r), t.transformPoints = (n, r)=>{
            const i = new Float64Array(3), a = new Float64Array(3);
            for(let o = 0; o < n.length; o += 3)i[0] = n[o], i[1] = n[o + 1], i[2] = n[o + 2], pn(a, i, e.matrix), r[o] = a[0], r[o + 1] = a[1], r[o + 2] = a[2];
            return r;
        }, t.preMultiply = ()=>{
            t.setPreMultiplyFlag(!0);
        }, t.postMultiply = ()=>{
            t.setPreMultiplyFlag(!1);
        }, t.transformMatrix = (n, r)=>(e.preMultiplyFlag ? Qt(r, e.matrix, n) : Qt(r, n, e.matrix), r), t.transformMatrices = (n, r)=>{
            const i = new Float64Array(16), a = new Float64Array(16), o = e.preMultiplyFlag ? ()=>Qt(a, e.matrix, i) : ()=>Qt(a, i, e.matrix);
            for(let s = 0; s < n.length; s += 16){
                for(let c = 0; c < 16; ++c)i[c] = n[s + c];
                o();
                for(let c = 0; c < 16; ++c)r[s + c] = a[c];
            }
            return r;
        }, t.getInverse = ()=>l4({
                matrix: Xo.invertMatrix(Array.from(e.matrix), [], 4),
                preMultiplyFlag: e.preMultiplyFlag
            });
    }
    const DU = {
        preMultiplyFlag: !1,
        matrix: [
            ...x3
        ]
    };
    function XS(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, DU, n), K.obj(t, e), K.setGet(t, e, [
            "preMultiplyFlag"
        ]), K.setGetArray(t, e, [
            "matrix"
        ], 16), EU(t, e);
    }
    l4 = K.newInstance(XS, "vtkTransform");
    var _U = {
        newInstance: l4,
        extend: XS
    };
    function ic(t, e, n) {
        return t ? `${t.getMTime()}-${e}-${n}` : "0";
    }
    function u4(t, e) {
        return `${t.getMTime()}A${e.getMTime()}`;
    }
    var RU = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

// all variables that represent positions or directions have a suffix
// indicating the coordinate system they are in. The possible values are
// MC - Model coordinates
// WC - World coordinates
// VC - View coordinates
// DC - Display coordinates
// TC - Texture coordinates

// frag position in VC
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// camera and actor matrix values
//VTK::Camera::Dec

void main()
{
  //VTK::PositionVC::Impl

  //VTK::TCoord::Impl

  //VTK::Picking::Impl
}
`, OU = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkImageResliceMapperFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the gpu image mapper fragment shader

// VC position of this fragment
//VTK::PositionVC::Dec

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

// the output of this shader
//VTK::Output::Dec

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  //VTK::TCoord::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;
    const b0 = {
        NEAREST: 0,
        LINEAR: 1
    };
    var IU = {
        InterpolationType: b0
    };
    const Ds = {
        Off: 0,
        PolygonOffset: 1
    };
    let Av = Ds.PolygonOffset, Jh = Ds.Off;
    const MU = [
        "VTK_RESOLVE_OFF",
        "VTK_RESOLVE_POLYGON_OFFSET"
    ];
    function bU() {
        return Av;
    }
    function LU(t) {
        const e = Av === t;
        return Av = t, e;
    }
    function PU() {
        return Jh;
    }
    function Vp() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        const e = Jh === t;
        return Jh = t, e;
    }
    function VU() {
        return Vp(Ds.Off);
    }
    function NU() {
        return Vp(Ds.Off);
    }
    function AU() {
        return Vp(Ds.PolygonOffset);
    }
    function kU() {
        return MU[Jh];
    }
    var kv = {
        Resolve: Ds,
        getResolveCoincidentTopologyAsString: kU,
        getResolveCoincidentTopologyPolygonOffsetFaces: bU,
        getResolveCoincidentTopology: PU,
        setResolveCoincidentTopology: Vp,
        setResolveCoincidentTopologyPolygonOffsetFaces: LU,
        setResolveCoincidentTopologyToDefault: VU,
        setResolveCoincidentTopologyToOff: NU,
        setResolveCoincidentTopologyToPolygonOffset: AU
    };
    function YS(t, e, n) {
        n.forEach((r)=>{
            t[`get${r.method}`] = ()=>e[r.key], t[`set${r.method}`] = K.objectSetterMap.object(t, e, {
                name: r.key,
                params: [
                    "factor",
                    "offset"
                ]
            });
        });
    }
    const f4 = [
        "Polygon",
        "Line",
        "Point"
    ], UU = {
        Polygon: {
            factor: 2,
            offset: 0
        },
        Line: {
            factor: 1,
            offset: -1
        },
        Point: {
            factor: 0,
            offset: -2
        }
    }, FU = ()=>{}, O0 = {
        modified: FU
    };
    YS(O0, UU, f4.map((t)=>({
            key: t,
            method: `ResolveCoincidentTopology${t}OffsetParameters`
        })));
    function BU(t, e) {
        e.resolveCoincidentTopology === void 0 && (e.resolveCoincidentTopology = !1), K.setGet(t, e, [
            "resolveCoincidentTopology"
        ]), e.topologyOffset = {
            Polygon: {
                factor: 0,
                offset: 0
            },
            Line: {
                factor: 0,
                offset: 0
            },
            Point: {
                factor: 0,
                offset: 0
            }
        }, Object.keys(kv).forEach((n)=>{
            t[n] = kv[n];
        }), Object.keys(O0).filter((n)=>n !== "modified").forEach((n)=>{
            t[n] = O0[n];
        }), YS(t, e.topologyOffset, f4.map((n)=>({
                key: n,
                method: `RelativeCoincidentTopology${n}OffsetParameters`
            }))), t.getCoincidentTopologyPolygonOffsetParameters = ()=>{
            const n = O0.getResolveCoincidentTopologyPolygonOffsetParameters(), r = t.getRelativeCoincidentTopologyPolygonOffsetParameters();
            return {
                factor: n.factor + r.factor,
                offset: n.offset + r.offset
            };
        }, t.getCoincidentTopologyLineOffsetParameters = ()=>{
            const n = O0.getResolveCoincidentTopologyLineOffsetParameters(), r = t.getRelativeCoincidentTopologyLineOffsetParameters();
            return {
                factor: n.factor + r.factor,
                offset: n.offset + r.offset
            };
        }, t.getCoincidentTopologyPointOffsetParameter = ()=>{
            const n = O0.getResolveCoincidentTopologyPointOffsetParameters(), r = t.getRelativeCoincidentTopologyPointOffsetParameters();
            return {
                factor: n.factor + r.factor,
                offset: n.offset + r.offset
            };
        };
    }
    var Np = {
        implementCoincidentTopologyMethods: BU,
        staticOffsetAPI: O0,
        otherStaticMethods: kv,
        CATEGORIES: f4,
        Resolve: Ds
    };
    const { vtkErrorMacro: g0 } = da;
    function z9(t, e, n) {
        return e.identity(n), t.reduce((r, i, a)=>a === 0 ? i ? e.copy(r, i) : e.identity(r) : i ? e.multiply(r, r, i) : r, n);
    }
    function GU(t, e) {
        e.classHierarchy.push("vtkOpenGLImageResliceMapper");
        function n(i) {
            [
                e._scalars,
                e._colorTransferFunc,
                e._pwFunc
            ].forEach((a)=>i.unregisterGraphicsResourceUser(a, t));
        }
        t.buildPass = (i)=>{
            if (i) {
                e.currentRenderPass = null, e._openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
                const a = e._openGLRenderer.getRenderable();
                e._openGLCamera = e._openGLRenderer.getViewNodeFor(a.getActiveCamera());
                const o = e._openGLRenderWindow;
                e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"), o && !o.isDeleted() && o !== e._openGLRenderWindow && n(o), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);
            }
        }, t.translucentPass = (i, a)=>{
            i && (e.currentRenderPass = a, t.render());
        }, t.zBufferPass = (i)=>{
            i && (e.haveSeenDepthRequest = !0, e.renderDepth = !0, t.render(), e.renderDepth = !1);
        }, t.opaqueZBufferPass = (i)=>t.zBufferPass(i), t.opaquePass = (i)=>{
            i && t.render();
        }, t.getCoincidentParameters = (i, a)=>e.renderable.getResolveCoincidentTopology() == Ds.PolygonOffset ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = ()=>{
            const i = e._openGLImageSlice.getRenderable(), a = e._openGLRenderer.getRenderable();
            t.renderPiece(a, i);
        }, t.renderPiece = (i, a)=>{
            if (t.invokeEvent({
                type: "StartEvent"
            }), e.renderable.update(), e.currentInput = e.renderable.getInputData(), !e.currentInput) {
                g0("No input!");
                return;
            }
            t.updateResliceGeometry(), t.renderPieceStart(i, a), t.renderPieceDraw(i, a), t.renderPieceFinish(i, a), t.invokeEvent({
                type: "EndEvent"
            });
        }, t.renderPieceStart = (i, a)=>{
            t.updateBufferObjects(i, a), a.getProperty().getInterpolationType() === b0.NEAREST ? (e.openGLTexture.setMinificationFilter(Tt.NEAREST), e.openGLTexture.setMagnificationFilter(Tt.NEAREST), e.colorTexture.setMinificationFilter(Tt.NEAREST), e.colorTexture.setMagnificationFilter(Tt.NEAREST), e.pwfTexture.setMinificationFilter(Tt.NEAREST), e.pwfTexture.setMagnificationFilter(Tt.NEAREST)) : (e.openGLTexture.setMinificationFilter(Tt.LINEAR), e.openGLTexture.setMagnificationFilter(Tt.LINEAR), e.colorTexture.setMinificationFilter(Tt.LINEAR), e.colorTexture.setMagnificationFilter(Tt.LINEAR), e.pwfTexture.setMinificationFilter(Tt.LINEAR), e.pwfTexture.setMagnificationFilter(Tt.LINEAR)), e.lastBoundBO = null;
        }, t.renderPieceDraw = (i, a)=>{
            const o = e.context;
            e.openGLTexture.activate(), e.colorTexture.activate(), e.pwfTexture.activate(), t.updateShaders(e.tris, i, a), o.drawArrays(o.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.openGLTexture.deactivate(), e.colorTexture.deactivate(), e.pwfTexture.deactivate();
        }, t.renderPieceFinish = (i, a)=>{}, t.updateBufferObjects = (i, a)=>{
            t.getNeedToRebuildBufferObjects(i, a) && t.buildBufferObjects(i, a);
        }, t.getNeedToRebuildBufferObjects = (i, a)=>e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < a.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < a.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime() || e.VBOBuildTime.getMTime() < e.resliceGeom.getMTime() || !e.openGLTexture?.getHandle() || !e.colorTexture?.getHandle() || !e.pwfTexture?.getHandle(), t.buildBufferObjects = (i, a)=>{
            const o = e.currentInput;
            if (!o) return;
            const s = o.getPointData()?.getScalars();
            if (!s) return;
            const c = s.getNumberOfComponents();
            let l = u4(o, s);
            const f = e._openGLRenderWindow.getGraphicsResourceForObject(s), u = !f?.oglObject?.getHandle() || f?.hash !== l, g = e.renderable.getUpdatedExtents(), h = !!g.length;
            if (u && !h) {
                e.openGLTexture = Qn.newInstance(), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.openGLTexture.resetFormatAndType();
                const F = o.getDimensions();
                e.openGLTexture.create3DFilterableFromDataArray(F[0], F[1], F[2], s, !1, g), e._openGLRenderWindow.setGraphicsResourceForObject(s, e.openGLTexture, l), s !== e._scalars && (e._openGLRenderWindow.registerGraphicsResourceUser(s, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars, t)), e._scalars = s;
            } else e.openGLTexture = f.oglObject;
            if (h) {
                e.renderable.setUpdatedExtents([]);
                const F = o.getDimensions();
                e.openGLTexture.create3DFilterableFromDataArray(F[0], F[1], F[2], s, !1, g);
            }
            const v = a.getProperty(), m = v.getIndependentComponents(), y = m ? c : 1, C = m ? 2 * y : 1, T = v.getRGBTransferFunction();
            l = ic(T, m, y);
            const x = e._openGLRenderWindow.getGraphicsResourceForObject(T);
            if (!x?.oglObject?.getHandle() || x?.hash !== l) {
                const N = 1024 * C * 3, B = new Uint8ClampedArray(N);
                if (e.colorTexture = Qn.newInstance(), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow), T) {
                    const G = new Float32Array(3072);
                    for(let Z = 0; Z < y; Z++){
                        const H = v.getRGBTransferFunction(Z), ne = H.getRange();
                        if (H.getTable(ne[0], ne[1], 1024, G, 1), m) for(let ae = 0; ae < 1024 * 3; ae++)B[Z * 1024 * 6 + ae] = 255 * G[ae], B[Z * 1024 * 6 + ae + 1024 * 3] = 255 * G[ae];
                        else for(let ae = 0; ae < 1024 * 3; ae++)B[Z * 1024 * 6 + ae] = 255 * G[ae];
                    }
                    e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, C, 3, qt.UNSIGNED_CHAR, B);
                } else {
                    for(let G = 0; G < 1024 * 3; ++G)B[G] = 255 * G / (1023 * 3), B[G + 1] = 255 * G / (1023 * 3), B[G + 2] = 255 * G / (1023 * 3);
                    e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, 1, 3, qt.UNSIGNED_CHAR, B);
                }
                T && (e._openGLRenderWindow.setGraphicsResourceForObject(T, e.colorTexture, l), T !== e._colorTransferFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(T, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc, t)), e._colorTransferFunc = T);
            } else e.colorTexture = x.oglObject;
            const D = v.getPiecewiseFunction();
            l = ic(D, m, y);
            const _ = e._openGLRenderWindow.getGraphicsResourceForObject(D);
            if (!_?.oglObject?.getHandle() || _?.hash !== l) {
                const N = 1024 * C, B = new Uint8ClampedArray(N);
                if (e.pwfTexture = Qn.newInstance(), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow), D) {
                    const G = new Float32Array(N), Z = new Float32Array(1024);
                    for(let H = 0; H < y; ++H){
                        const ne = v.getPiecewiseFunction(H);
                        if (ne === null) G.fill(1);
                        else {
                            const ae = ne.getRange();
                            if (ne.getTable(ae[0], ae[1], 1024, Z, 1), m) for(let ue = 0; ue < 1024; ue++)G[H * 1024 * 2 + ue] = Z[ue], G[H * 1024 * 2 + ue + 1024] = Z[ue];
                            else for(let ue = 0; ue < 1024; ue++)G[H * 1024 * 2 + ue] = Z[ue];
                        }
                    }
                    e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, C, 1, qt.FLOAT, G);
                } else B.fill(255), e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, 1, 1, qt.UNSIGNED_CHAR, B);
                D && (e._openGLRenderWindow.setGraphicsResourceForObject(D, e.pwfTexture, l), D !== e._pwFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(D, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc, t)), e._pwFunc = D);
            } else e.pwfTexture = _.oglObject;
            const P = `${e.resliceGeom.getMTime()}A${e.renderable.getSlabThickness()}`;
            if (!e.tris.getCABO().getElementCount() || e.VBOBuildString !== P) {
                const F = Wt.newInstance({
                    numberOfComponents: 3,
                    values: e.resliceGeom.getPoints().getData()
                });
                F.setName("points");
                const N = Wt.newInstance({
                    numberOfComponents: 1,
                    values: e.resliceGeom.getPolys().getData()
                }), B = {
                    points: F,
                    cellOffset: 0
                };
                if (e.renderable.getSlabThickness() > 0) {
                    const G = e.resliceGeom.getPointData().getNormals();
                    G ? B.normals = G : g0("Slab mode requested without normals");
                }
                e.tris.getCABO().createVBO(N, "polys", Yo.SURFACE, B);
            }
            e.VBOBuildString = P, e.VBOBuildTime.modified();
        }, t.updateShaders = (i, a, o)=>{
            if (e.lastBoundBO = i, t.getNeedToRebuildShaders(i, a, o)) {
                const s = {
                    Vertex: null,
                    Fragment: null,
                    Geometry: null
                };
                t.buildShaders(s, a, o);
                const c = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex, s.Fragment, s.Geometry);
                c !== i.getProgram() && (i.setProgram(c), i.getVAO().releaseGraphicsResources()), i.getShaderSourceTime().modified();
            } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(i.getProgram());
            i.getVAO().bind(), t.setMapperShaderParameters(i, a, o), t.setCameraShaderParameters(i, a, o), t.setPropertyShaderParameters(i, a, o);
        }, t.setMapperShaderParameters = (i, a, o)=>{
            const s = i.getProgram();
            if (i.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > i.getAttributeUpdateTime().getMTime() || i.getShaderSourceTime().getMTime() > i.getAttributeUpdateTime().getMTime())) {
                s.isUniformUsed("texture1") && s.setUniformi("texture1", e.openGLTexture.getTextureUnit()), s.isAttributeUsed("vertexWC") && (i.getVAO().addAttributeArray(s, i.getCABO(), "vertexWC", i.getCABO().getVertexOffset(), i.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || g0("Error setting vertexWC in shader VAO.")), s.isAttributeUsed("normalWC") && (i.getVAO().addAttributeArray(s, i.getCABO(), "normalWC", i.getCABO().getNormalOffset(), i.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || g0("Error setting normalWC in shader VAO.")), s.isUniformUsed("slabThickness") && s.setUniformf("slabThickness", e.renderable.getSlabThickness()), s.isUniformUsed("spacing") && s.setUniform3fv("spacing", e.currentInput.getSpacing()), s.isUniformUsed("slabType") && s.setUniformi("slabType", e.renderable.getSlabType()), s.isUniformUsed("slabType") && s.setUniformi("slabType", e.renderable.getSlabType()), s.isUniformUsed("slabTrapezoid") && s.setUniformi("slabTrapezoid", e.renderable.getSlabTrapezoidIntegration());
                const l = i.getCABO().getCoordShiftAndScaleEnabled() ? i.getCABO().getInverseShiftAndScaleMatrix() : null;
                if (s.isUniformUsed("WCTCMatrix")) {
                    const f = e.currentInput, u = f.getDimensions();
                    Ur(e.tmpMat4, f.getIndexToWorld()), qr(e.tmpMat4, e.tmpMat4, [
                        -.5,
                        -.5,
                        -.5
                    ]), nc(e.tmpMat4, e.tmpMat4, u), Xr(e.tmpMat4, e.tmpMat4), l && Qt(e.tmpMat4, e.tmpMat4, l), s.setUniformMatrix("WCTCMatrix", e.tmpMat4);
                }
                s.isUniformUsed("vboScaling") && s.setUniform3fv("vboScaling", i.getCABO().getCoordScale() ?? [
                    1,
                    1,
                    1
                ]), i.getAttributeUpdateTime().modified();
            }
            if (e.haveSeenDepthRequest && i.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), i.getProgram().isUniformUsed("coffset")) {
                const c = t.getCoincidentParameters(a, o);
                i.getProgram().setUniformf("coffset", c.offset), i.getProgram().isUniformUsed("cfactor") && i.getProgram().setUniformf("cfactor", c.factor);
            }
        }, t.setCameraShaderParameters = (i, a, o)=>{
            const s = e._openGLCamera.getKeyMatrices(a), c = e._openGLImageSlice.getKeyMatrices(), f = i.getCABO().getCoordShiftAndScaleEnabled() ? i.getCABO().getInverseShiftAndScaleMatrix() : null, u = i.getProgram();
            u.isUniformUsed("MCPCMatrix") && (Ot(e.tmpMat4), u.setUniformMatrix("MCPCMatrix", z9([
                s.wcpc,
                c.mcwc,
                f
            ], zh, e.tmpMat4))), u.isUniformUsed("MCVCMatrix") && (Ot(e.tmpMat4), u.setUniformMatrix("MCVCMatrix", z9([
                s.wcvc,
                c.mcwc,
                f
            ], zh, e.tmpMat4)));
        }, t.setPropertyShaderParameters = (i, a, o)=>{
            const s = i.getProgram(), c = o.getProperty(), l = c.getOpacity();
            s.setUniformf("opacity", l);
            const f = e.openGLTexture.getComponents(), u = c.getIndependentComponents();
            if (u) for(let m = 0; m < f; ++m)s.setUniformf(`mix${m}`, c.getComponentWeight(m));
            const g = e.openGLTexture.getVolumeInfo();
            for(let m = 0; m < f; m++){
                let y = c.getColorWindow(), C = c.getColorLevel();
                const T = u ? m : 0, x = c.getRGBTransferFunction(T);
                if (x && c.getUseLookupTableScalarRange()) {
                    const _ = x.getRange();
                    y = _[1] - _[0], C = .5 * (_[1] + _[0]);
                }
                const S = g.scale[m] / y, D = (g.offset[m] - C) / y + .5;
                s.setUniformf(`cshift${m}`, D), s.setUniformf(`cscale${m}`, S);
            }
            const h = e.colorTexture.getTextureUnit();
            s.setUniformi("colorTexture1", h);
            for(let m = 0; m < f; m++){
                let y = 1, C = 0;
                const T = u ? m : 0, x = c.getPiecewiseFunction(T);
                if (x) {
                    const S = x.getRange(), D = S[1] - S[0], _ = .5 * (S[0] + S[1]);
                    y = g.scale[m] / D, C = (g.offset[m] - _) / D + .5;
                }
                s.setUniformf(`pwfshift${m}`, C), s.setUniformf(`pwfscale${m}`, y);
            }
            const v = e.pwfTexture.getTextureUnit();
            s.setUniformi("pwfTexture1", v), s.setUniform4fv("backgroundColor", e.renderable.getBackgroundColor());
        }, t.getNeedToRebuildShaders = (i, a, o)=>{
            const s = e.openGLTexture.getComponents(), c = o.getProperty().getIndependentComponents(), l = e.renderable.getSlabThickness(), f = e.renderable.getSlabType(), u = e.renderable.getSlabTrapezoidIntegration();
            let g = !1;
            return (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (g = !0), g || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || i.getProgram()?.getHandle() === 0 || e.lastTextureComponents !== s || e.lastIndependentComponents !== c || e.lastSlabThickness !== l || e.lastSlabType !== f || e.lastSlabTrapezoidIntegration !== u ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = s, e.lastIndependentComponents = c, e.lastSlabThickness = l, e.lastSlabType = f, e.lastSlabTrapezoidIntegration = u, !0) : !1;
        }, t.getShaderTemplate = (i, a, o)=>{
            i.Vertex = RU, i.Fragment = OU, i.Geometry = "";
        }, t.replaceShaderValues = (i, a, o)=>{
            if (t.replaceShaderTCoord(i, a, o), t.replaceShaderPositionVC(i, a, o), e.haveSeenDepthRequest) {
                let s = i.Fragment;
                s = Te.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = Te.substitute(s, "//VTK::ZBuffer::Impl", [
                    "if (depthRequest == 1) {",
                    "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
                    "float rf = floor(iz/256.0)/255.0;",
                    "float gf = mod(iz,256.0)/255.0;",
                    "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
                ]).result, i.Fragment = s;
            }
            t.replaceShaderCoincidentOffset(i, a, o);
        }, t.replaceShaderTCoord = (i, a, o)=>{
            let s = i.Vertex;
            const c = i.Geometry;
            let l = i.Fragment;
            const f = [
                "uniform mat4 WCTCMatrix;",
                "out vec3 fragTexCoord;"
            ], u = e.renderable.getSlabThickness();
            s = Te.substitute(s, "//VTK::TCoord::Dec", f).result;
            const g = [
                "fragTexCoord = (WCTCMatrix * vertexWC).xyz;"
            ];
            s = Te.substitute(s, "//VTK::TCoord::Impl", g).result;
            const h = e.openGLTexture.getComponents(), v = o.getProperty().getIndependentComponents();
            let m = [
                "in vec3 fragTexCoord;",
                "uniform highp sampler3D texture1;",
                "uniform mat4 WCTCMatrix;",
                "uniform float cshift0;",
                "uniform float cscale0;",
                "uniform float pwfshift0;",
                "uniform float pwfscale0;",
                "uniform sampler2D colorTexture1;",
                "uniform sampler2D pwfTexture1;",
                "uniform float opacity;",
                "uniform vec4 backgroundColor;"
            ];
            if (v) {
                for(let C = 1; C < h; C++)m = m.concat([
                    `uniform float cshift${C};`,
                    `uniform float cscale${C};`,
                    `uniform float pwfshift${C};`,
                    `uniform float pwfscale${C};`
                ]);
                switch(h){
                    case 1:
                        m = m.concat([
                            "uniform float mix0;",
                            "#define height0 0.5"
                        ]);
                        break;
                    case 2:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "#define height0 0.25",
                            "#define height1 0.75"
                        ]);
                        break;
                    case 3:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "#define height0 0.17",
                            "#define height1 0.5",
                            "#define height2 0.83"
                        ]);
                        break;
                    case 4:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "uniform float mix3;",
                            "#define height0 0.125",
                            "#define height1 0.375",
                            "#define height2 0.625",
                            "#define height3 0.875"
                        ]);
                        break;
                    default:
                        g0("Unsupported number of independent coordinates.");
                }
            }
            u > 0 && (m = m.concat([
                "uniform vec3 spacing;",
                "uniform float slabThickness;",
                "uniform int slabType;",
                "uniform int slabTrapezoid;",
                "uniform vec3 vboScaling;"
            ]), m = m.concat([
                "vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)",
                "{",
                "  vec4 retVal = vec4(1.0);",
                "  if (slabType == 0) // min",
                "  {",
                "    retVal = min(currVal, valToComp);",
                "  }",
                "  else if (slabType == 1) // max",
                "  {",
                "    retVal = max(currVal, valToComp);",
                "  }",
                "  else if (slabType == 3) // sum",
                "  {",
                "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ",
                "  }",
                "  else // mean",
                "  {",
                "    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ",
                "  }",
                "  return retVal;",
                "}"
            ])), l = Te.substitute(l, "//VTK::TCoord::Dec", m).result;
            let y = [
                "if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))",
                "{",
                "  // set the background color and exit",
                "  gl_FragData[0] = backgroundColor;",
                "  return;",
                "}",
                "vec4 tvalue = texture(texture1, fragTexCoord);"
            ];
            if (u > 0 && (y = y.concat([
                "// Get the first and last samples",
                "int numSlices = 1;",
                "float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;",
                "vec3 normalxspacing = scaling * normalWCVSOutput;",
                "float distTraveled = length(normalxspacing);",
                "int trapezoid = 0;",
                "while (distTraveled < slabThickness * 0.5)",
                "{",
                "  distTraveled += length(normalxspacing);",
                "  float fnumSlices = float(numSlices);",
                "  if (distTraveled > slabThickness * 0.5)",
                "  {",
                "    // Before stepping outside the slab, sample at the boundaries",
                "    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;",
                "    trapezoid = slabTrapezoid;",
                "  }",
                "  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;",
                "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))",
                "  {",
                "    vec4 newVal = texture(texture1, fragTCoordNeg);",
                "    tvalue = compositeValue(tvalue, newVal, trapezoid);",
                "    numSlices += 1;",
                "  }",
                "  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;",
                "  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))",
                "  {",
                "    vec4 newVal = texture(texture1, fragTCoordPos);",
                "    tvalue = compositeValue(tvalue, newVal, trapezoid);",
                "    numSlices += 1;",
                "  }",
                "}",
                "// Finally, if slab type is *mean*, divide the sum by the numSlices",
                "if (slabType == 2)",
                "{",
                "  tvalue = tvalue / float(numSlices);",
                "}"
            ])), v) {
                const C = [
                    "r",
                    "g",
                    "b",
                    "a"
                ];
                for(let T = 0; T < h; ++T)y = y.concat([
                    `vec3 tcolor${T} = mix${T} * texture2D(colorTexture1, vec2(tvalue.${C[T]} * cscale${T} + cshift${T}, height${T})).rgb;`,
                    `float compWeight${T} = mix${T} * texture2D(pwfTexture1, vec2(tvalue.${C[T]} * pwfscale${T} + pwfshift${T}, height${T})).r;`
                ]);
                switch(h){
                    case 1:
                        y = y.concat([
                            "gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"
                        ]);
                        break;
                    case 2:
                        y = y.concat([
                            "float weightSum = compWeight0 + compWeight1;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
                        ]);
                        break;
                    case 3:
                        y = y.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
                        ]);
                        break;
                    case 4:
                        y = y.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
                        ]);
                        break;
                    default:
                        g0("Unsupported number of independent coordinates.");
                }
            } else switch(h){
                case 1:
                    y = y.concat([
                        "// Dependent components",
                        "float intensity = tvalue.r;",
                        "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;",
                        "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;",
                        "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"
                    ]);
                    break;
                case 2:
                    y = y.concat([
                        "float intensity = tvalue.r*cscale0 + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"
                    ]);
                    break;
                case 3:
                    y = y.concat([
                        "vec4 tcolor = cscale0*tvalue + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
                    ]);
                    break;
                default:
                    y = y.concat([
                        "vec4 tcolor = cscale0*tvalue + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
                    ]);
            }
            l = Te.substitute(l, "//VTK::TCoord::Impl", y).result, i.Vertex = s, i.Fragment = l, i.Geometry = c;
        }, t.replaceShaderPositionVC = (i, a, o)=>{
            let s = i.Vertex;
            const c = i.Geometry;
            let l = i.Fragment;
            const f = e.renderable.getSlabThickness();
            let u = [
                "attribute vec4 vertexWC;"
            ];
            u = u.concat([
                `//${t.getMTime()}${e.resliceGeomUpdateString}`
            ]), f > 0 && (u = u.concat([
                "attribute vec3 normalWC;",
                "varying vec3 normalWCVSOutput;",
                "varying vec4 vertexWCVSOutput;"
            ])), s = Te.substitute(s, "//VTK::PositionVC::Dec", u).result;
            let g = [
                "gl_Position = MCPCMatrix * vertexWC;"
            ];
            f > 0 && (g = g.concat([
                "normalWCVSOutput = normalWC;",
                "vertexWCVSOutput = vertexWC;"
            ])), s = Te.substitute(s, "//VTK::PositionVC::Impl", g).result, s = Te.substitute(s, "//VTK::Camera::Dec", [
                "uniform mat4 MCPCMatrix;",
                "uniform mat4 MCVCMatrix;"
            ]).result;
            let h = [];
            f > 0 && (h = h.concat([
                "varying vec3 normalWCVSOutput;",
                "varying vec4 vertexWCVSOutput;"
            ])), l = Te.substitute(l, "//VTK::PositionVC::Dec", h).result, i.Vertex = s, i.Geometry = c, i.Fragment = l;
        };
        function r(i) {
            Xo.normalize(i);
            const a = [
                0,
                0,
                0
            ];
            for(let o = 0; o < 3; ++o){
                jV(a), a[o] = 1;
                const s = Xo.dot(i, a);
                if (s < -.999999 || s > .999999) return [
                    !0,
                    o
                ];
            }
            return [
                !1,
                2
            ];
        }
        t.updateResliceGeometry = ()=>{
            let i = "";
            const a = e.currentInput, o = a?.getBounds();
            let s = !0, c = 2;
            const l = e.renderable.getSlicePolyData(), f = e.renderable.getSlicePlane();
            if (l) i = i.concat(`PolyData${l.getMTime()}`);
            else if (f) {
                i = i.concat(`Plane${f.getMTime()}`);
                const u = P3();
                a && (i = i.concat(`Image${a.getMTime()}`), ax(u, ...a.getDirection()), Xd(u, u));
                const g = [
                    ...f.getNormal()
                ];
                ih(g, g, u), [s, c] = r(g);
            } else {
                const u = ca.newInstance();
                u.setNormal(0, 0, 1);
                let g = [
                    0,
                    1,
                    0,
                    1,
                    0,
                    1
                ];
                a && (g = o), u.setOrigin(g[0], g[2], .5 * (g[5] + g[4])), e.renderable.setSlicePlane(u), i = i.concat(`Plane${f?.getMTime()}`), a && (i = i.concat(`Image${a.getMTime()}`));
            }
            if (!e.resliceGeom || e.resliceGeomUpdateString !== i) {
                if (l) e.resliceGeom || (e.resliceGeom = Hc.newInstance()), e.resliceGeom.getPoints().setData(l.getPoints().getData(), 3), e.resliceGeom.getPolys().setData(l.getPolys().getData(), 1), e.resliceGeom.getPointData().setNormals(l.getPointData().getNormals());
                else if (f) if (s) {
                    const u = new Float32Array(12), g = a.worldToIndex(f.getOrigin(), [
                        0,
                        0,
                        0
                    ]), h = [
                        (c + 1) % 3,
                        (c + 2) % 3
                    ].sort(), v = a.getSpatialExtent();
                    let m = 0;
                    for(let S = 0; S < 2; ++S)for(let D = 0; D < 2; ++D)u[m + c] = g[c], u[m + h[0]] = v[2 * h[0] + D], u[m + h[1]] = v[2 * h[1] + S], m += 3;
                    e.transform.setMatrix(a.getIndexToWorld()), e.transform.transformPoints(u, u);
                    const y = new Uint16Array(8);
                    y[0] = 3, y[1] = 0, y[2] = 1, y[3] = 3, y[4] = 3, y[5] = 0, y[6] = 3, y[7] = 2;
                    const C = f.getNormal();
                    Xo.normalize(C);
                    const T = new Float32Array(12);
                    for(let S = 0; S < 4; ++S)T[3 * S] = C[0], T[3 * S + 1] = C[1], T[3 * S + 2] = C[2];
                    e.resliceGeom || (e.resliceGeom = Hc.newInstance()), e.resliceGeom.getPoints().setData(u, 3), e.resliceGeom.getPolys().setData(y, 1);
                    const x = Wt.newInstance({
                        numberOfComponents: 3,
                        values: T,
                        name: "Normals"
                    });
                    e.resliceGeom.getPointData().setNormals(x);
                } else {
                    e.outlineFilter.setInputData(a), e.cutter.setInputConnection(e.outlineFilter.getOutputPort()), e.cutter.setCutFunction(f), e.lineToSurfaceFilter.setInputConnection(e.cutter.getOutputPort()), e.lineToSurfaceFilter.update(), e.resliceGeom || (e.resliceGeom = Hc.newInstance());
                    const u = e.lineToSurfaceFilter.getOutputData();
                    e.resliceGeom.getPoints().setData(u.getPoints().getData(), 3), e.resliceGeom.getPolys().setData(u.getPolys().getData(), 1), e.resliceGeom.getPointData().setNormals(u.getPointData().getNormals());
                    const g = f.getNormal(), h = e.resliceGeom.getNumberOfPoints();
                    Xo.normalize(g);
                    const v = new Float32Array(h * 3);
                    for(let y = 0; y < h; ++y)v[3 * y] = g[0], v[3 * y + 1] = g[1], v[3 * y + 2] = g[2];
                    const m = Wt.newInstance({
                        numberOfComponents: 3,
                        values: v,
                        name: "Normals"
                    });
                    e.resliceGeom.getPointData().setNormals(m);
                }
                else g0("Something went wrong.", "A default slice plane should have been created in the beginning of", "updateResliceGeometry.");
                e.resliceGeomUpdateString = i, e.resliceGeom?.modified();
            }
        }, t.setOpenGLTexture = (i)=>{
            i && (e.openGLTexture = i, e._externalOpenGLTexture = !0);
        }, t.delete = jd(()=>{
            e._openGLRenderWindow && n(e._openGLRenderWindow);
        }, t.delete);
    }
    const WU = {
        VBOBuildTime: {},
        VBOBuildString: null,
        haveSeenDepthRequest: !1,
        lastHaveSeenDepthRequest: !1,
        lastIndependentComponents: !1,
        lastTextureComponents: 0,
        lastSlabThickness: 0,
        lastSlabTrapezoidIntegration: 0,
        lastSlabType: -1,
        openGLTexture: null,
        colorTextureString: null,
        pwfTextureString: null,
        resliceGeom: null,
        resliceGeomUpdateString: null,
        tris: null,
        colorTexture: null,
        pwfTexture: null,
        _externalOpenGLTexture: !1
    };
    function $U(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, WU, n), Yr.extend(t, e, n), Wl.implementReplaceShaderCoincidentOffset(t, e, n), Wl.implementBuildShadersWithReplacements(t, e, n), e.tris = Yl.newInstance(), e.openGLTexture = null, e.colorTexture = null, e.pwfTexture = null, e.VBOBuildTime = {}, tr(e.VBOBuildTime), e.tmpMat4 = Ot(new Float64Array(16)), e.outlineFilter = gU.newInstance(), e.outlineFilter.setGenerateFaces(!0), e.outlineFilter.setGenerateLines(!1), e.cubePolyData = Hc.newInstance(), e.cutter = Ik.newInstance(), e.lineToSurfaceFilter = Ek.newInstance(), e.transform = _U.newInstance(), La(t, e, [
            "openGLTexture"
        ]), GU(t, e);
    }
    const zU = kn($U, "vtkOpenGLImageResliceMapper");
    bi("vtkImageResliceMapper", zU);
    const jU = {
        NONE: -1,
        I: 0,
        J: 1,
        K: 2,
        X: 3,
        Y: 4,
        Z: 5
    };
    var Ap = {
        SlicingMode: jU
    }, d4 = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexMC;

// frag position in VC
//VTK::PositionVC::Dec

// optional normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// Texture coordinates
//VTK::TCoord::Dec

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

// Apple Bug
//VTK::PrimID::Dec

// picking support
//VTK::Picking::Dec

void main()
{
  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  //VTK::PrimID::Impl

  //VTK::PositionVC::Impl

  //VTK::Light::Impl

  //VTK::Picking::Impl
}
`, Jd = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the polydata mappers fragment shader

uniform int PrimitiveIDOffset;

// VC position of this fragment
//VTK::PositionVC::Dec

// optional color passed in from the vertex shader, vertexColor
//VTK::Color::Dec

// optional surface normal declaration
//VTK::Normal::Dec

// extra lighting parameters
//VTK::Light::Dec

// define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Texture coordinates
//VTK::TCoord::Dec

// picking support
//VTK::Picking::Dec

// Depth Peeling Support
//VTK::DepthPeeling::Dec

// clipping plane vars
//VTK::Clip::Dec

// label outline 
//VTK::LabelOutline::Dec

// the output of this shader
//VTK::Output::Dec

// Apple Bug
//VTK::PrimID::Dec

// handle coincident offsets
//VTK::Coincident::Dec

//VTK::ZBuffer::Dec

//VTK::LabelOutlineHelperFunction

void main()
{
  // VC position of this fragment. This should not branch/return/discard.
  //VTK::PositionVC::Impl

  // Place any calls that require uniform flow (e.g. dFdx) here.
  //VTK::UniformFlow::Impl

  // Set gl_FragDepth here (gl_FragCoord.z by default)
  //VTK::Depth::Impl

  // Early depth peeling abort:
  //VTK::DepthPeeling::PreColor

  // Apple Bug
  //VTK::PrimID::Impl

  //VTK::Clip::Impl

  //VTK::Color::Impl

  // Generate the normal if we are not passed in one
  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Light::Impl

  if (gl_FragData[0].a <= 0.0)
    {
    discard;
    }

  //VTK::DepthPeeling::Impl

  //VTK::Picking::Impl

  // handle coincident offsets
  //VTK::Coincident::Impl

  //VTK::ZBuffer::Impl

  //VTK::RenderPassFragmentShader::Impl
}
`;
    const { vtkErrorMacro: hu } = da, { SlicingMode: ho } = Ap;
    function HU(t) {
        const e = t.split(`
`), n = [];
        for(let r = 0; r < e.length; ++r){
            const i = e[r].trim();
            i.length > 0 && n.push(i);
        }
        return n;
    }
    function KU(t, e) {
        e.classHierarchy.push("vtkOpenGLImageMapper");
        function n(r) {
            e.openGLTexture.releaseGraphicsResources(r), [
                e._colorTransferFunc,
                e._pwFunc,
                e._labelOutlineThicknessArray
            ].forEach((i)=>r.unregisterGraphicsResourceUser(i, t));
        }
        t.buildPass = (r)=>{
            if (r) {
                e.currentRenderPass = null, e.openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
                const i = e._openGLRenderWindow;
                e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"), i && !i.isDeleted() && i !== e._openGLRenderWindow && n(i), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);
                const a = e._openGLRenderer.getRenderable();
                e.openGLCamera = e._openGLRenderer.getViewNodeFor(a.getActiveCamera()), e.renderable.isA("vtkImageMapper") && e.renderable.getSliceAtFocalPoint() && e.renderable.setSliceFromCamera(a.getActiveCamera());
            }
        }, t.translucentPass = (r, i)=>{
            r && (e.currentRenderPass = i, t.render());
        }, t.zBufferPass = (r)=>{
            r && (e.haveSeenDepthRequest = !0, e.renderDepth = !0, t.render(), e.renderDepth = !1);
        }, t.opaqueZBufferPass = (r)=>t.zBufferPass(r), t.opaquePass = (r)=>{
            r && t.render();
        }, t.getCoincidentParameters = (r, i)=>e.renderable.getResolveCoincidentTopology() == Ds.PolygonOffset ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = ()=>{
            const r = e.openGLImageSlice.getRenderable(), i = e._openGLRenderer.getRenderable();
            t.renderPiece(i, r);
        }, t.getShaderTemplate = (r, i, a)=>{
            r.Vertex = d4, r.Fragment = Jd, r.Geometry = "";
        }, t.replaceShaderValues = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            o = Te.substitute(o, "//VTK::Camera::Dec", [
                "uniform mat4 MCPCMatrix;"
            ]).result, o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                "  gl_Position = MCPCMatrix * vertexMC;"
            ]).result, o = Te.substitute(o, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result, o = Te.substitute(o, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
            const c = e.openGLTexture.getComponents(), l = a.getProperty().getIndependentComponents();
            let f = [
                "varying vec2 tcoordVCVSOutput;",
                "uniform float cshift0;",
                "uniform float cscale0;",
                "uniform float pwfshift0;",
                "uniform float pwfscale0;",
                "uniform sampler2D texture1;",
                "uniform sampler2D colorTexture1;",
                "uniform sampler2D pwfTexture1;",
                "uniform sampler2D labelOutlineTexture1;",
                "uniform float opacity;",
                "uniform float outlineOpacity;"
            ];
            if (l) {
                for(let g = 1; g < c; g++)f = f.concat([
                    `uniform float cshift${g};`,
                    `uniform float cscale${g};`,
                    `uniform float pwfshift${g};`,
                    `uniform float pwfscale${g};`
                ]);
                switch(c){
                    case 1:
                        f = f.concat([
                            "uniform float mix0;",
                            "#define height0 0.5"
                        ]);
                        break;
                    case 2:
                        f = f.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "#define height0 0.25",
                            "#define height1 0.75"
                        ]);
                        break;
                    case 3:
                        f = f.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "#define height0 0.17",
                            "#define height1 0.5",
                            "#define height2 0.83"
                        ]);
                        break;
                    case 4:
                        f = f.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "uniform float mix3;",
                            "#define height0 0.125",
                            "#define height1 0.375",
                            "#define height2 0.625",
                            "#define height3 0.875"
                        ]);
                        break;
                    default:
                        hu("Unsupported number of independent coordinates.");
                }
            }
            if (s = Te.substitute(s, "//VTK::TCoord::Dec", f).result, a.getProperty().getUseLabelOutline() === !0 && (s = Te.substitute(s, "//VTK::LabelOutline::Dec", [
                "uniform int outlineThickness;",
                "uniform float vpWidth;",
                "uniform float vpHeight;",
                "uniform float vpOffsetX;",
                "uniform float vpOffsetY;",
                "uniform mat4 PCWCMatrix;",
                "uniform mat4 vWCtoIDX;",
                "uniform ivec3 imageDimensions;",
                "uniform int sliceAxis;"
            ]).result, s = Te.substitute(s, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result, s = Te.substitute(s, "//VTK::LabelOutlineHelperFunction", [
                "#ifdef vtkImageLabelOutlineOn",
                "vec3 fragCoordToIndexSpace(vec4 fragCoord) {",
                "  vec4 pcPos = vec4(",
                "    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,",
                "    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,",
                "    (fragCoord.z - 0.5) * 2.0,",
                "    1.0);",
                "",
                "  vec4 worldCoord = PCWCMatrix * pcPos;",
                "  vec4 vertex = (worldCoord/worldCoord.w);",
                "",
                "  vec3 index = (vWCtoIDX * vertex).xyz;",
                "",
                "  // half voxel fix for labelmapOutline",
                "  return (index + vec3(0.5)) / vec3(imageDimensions);",
                "}",
                "vec2 getSliceCoords(vec3 coord, int axis) {",
                "  if (axis == 0) return coord.yz;",
                "  if (axis == 1) return coord.xz;",
                "  if (axis == 2) return coord.xy;",
                "}",
                "#endif"
            ]).result), l) {
                const g = [
                    "r",
                    "g",
                    "b",
                    "a"
                ];
                let h = [
                    "vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"
                ];
                for(let v = 0; v < c; v++)h = h.concat([
                    `vec3 tcolor${v} = mix${v} * texture2D(colorTexture1, vec2(tvalue.${g[v]} * cscale${v} + cshift${v}, height${v})).rgb;`,
                    `float compWeight${v} = mix${v} * texture2D(pwfTexture1, vec2(tvalue.${g[v]} * pwfscale${v} + pwfshift${v}, height${v})).r;`
                ]);
                switch(c){
                    case 1:
                        h = h.concat([
                            "gl_FragData[0] = vec4(tcolor0.rgb, opacity);"
                        ]);
                        break;
                    case 2:
                        h = h.concat([
                            "float weightSum = compWeight0 + compWeight1;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
                        ]);
                        break;
                    case 3:
                        h = h.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
                        ]);
                        break;
                    case 4:
                        h = h.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
                        ]);
                        break;
                    default:
                        hu("Unsupported number of independent coordinates.");
                }
                s = Te.substitute(s, "//VTK::TCoord::Impl", h).result;
            } else switch(c){
                case 1:
                    s = Te.substitute(s, "//VTK::TCoord::Impl", [
                        ...HU(`
                #ifdef vtkImageLabelOutlineOn
                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);
                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;
                  bool pixelOnBorder = false;
                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;
                  float opacityToUse = scalarOpacity * opacity;
                  int segmentIndex = int(centerValue * 255.0);
                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;
                  int actualThickness = int(textureValue * 255.0);

                  if (segmentIndex == 0){
                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);
                    return;
                  }

                  for (int i = -actualThickness; i <= actualThickness; i++) {
                    for (int j = -actualThickness; j <= actualThickness; j++) {
                      if (i == 0 || j == 0) {
                        continue;
                      }
                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
                        gl_FragCoord.y + float(j),
                        gl_FragCoord.z, gl_FragCoord.w);
                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;
                      if (value != centerValue) {
                        pixelOnBorder = true;
                        break;
                      }
                    }
                    if (pixelOnBorder == true) {
                      break;
                    }
                  }
                  if (pixelOnBorder == true) {
                    gl_FragData[0] = vec4(tColor, outlineOpacity);
                  }
                  else {
                    gl_FragData[0] = vec4(tColor, opacityToUse);
                  }
                #else
                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;
                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;
                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;
                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);
                #endif
                `)
                    ]).result;
                    break;
                case 2:
                    s = Te.substitute(s, "//VTK::TCoord::Impl", [
                        "vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                        "float intensity = tcolor.r*cscale0 + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"
                    ]).result;
                    break;
                case 3:
                    s = Te.substitute(s, "//VTK::TCoord::Impl", [
                        "vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
                    ]).result;
                    break;
                default:
                    s = Te.substitute(s, "//VTK::TCoord::Impl", [
                        "vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
                    ]).result;
            }
            e.haveSeenDepthRequest && (s = Te.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = Te.substitute(s, "//VTK::ZBuffer::Impl", [
                "if (depthRequest == 1) {",
                "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
                "float rf = floor(iz/256.0)/255.0;",
                "float gf = mod(iz,256.0)/255.0;",
                "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
            ]).result), r.Vertex = o, r.Fragment = s, t.replaceShaderClip(r, i, a), t.replaceShaderCoincidentOffset(r, i, a);
        }, t.replaceShaderClip = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            if (e.renderable.getNumberOfClippingPlanes()) {
                let c = e.renderable.getNumberOfClippingPlanes();
                c > 6 && (Zt("OpenGL has a limit of 6 clipping planes"), c = 6), o = Te.substitute(o, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    "uniform vec4 clipPlanes[6];",
                    "varying float clipDistancesVSOutput[6];"
                ]).result, o = Te.substitute(o, "//VTK::Clip::Impl", [
                    "for (int planeNum = 0; planeNum < 6; planeNum++)",
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
                    "    }"
                ]).result, s = Te.substitute(s, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    "varying float clipDistancesVSOutput[6];"
                ]).result, s = Te.substitute(s, "//VTK::Clip::Impl", [
                    "for (int planeNum = 0; planeNum < 6; planeNum++)",
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
                    "    }"
                ]).result;
            }
            r.Vertex = o, r.Fragment = s;
        }, t.getNeedToRebuildShaders = (r, i, a)=>{
            const o = e.openGLTexture.getComponents(), s = a.getProperty().getIndependentComponents();
            let c = !1;
            return (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (c = !0), c || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || r.getProgram()?.getHandle() === 0 || e.lastTextureComponents !== o || e.lastIndependentComponents !== s ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = o, e.lastIndependentComponents = s, !0) : !1;
        }, t.updateShaders = (r, i, a)=>{
            if (e.lastBoundBO = r, t.getNeedToRebuildShaders(r, i, a)) {
                const o = {
                    Vertex: null,
                    Fragment: null,
                    Geometry: null
                };
                t.buildShaders(o, i, a);
                const s = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(o.Vertex, o.Fragment, o.Geometry);
                s !== r.getProgram() && (r.setProgram(s), r.getVAO().releaseGraphicsResources()), r.getShaderSourceTime().modified();
            } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(r.getProgram());
            r.getVAO().bind(), t.setMapperShaderParameters(r, i, a), t.setCameraShaderParameters(r, i, a), t.setPropertyShaderParameters(r, i, a);
        }, t.setMapperShaderParameters = (r, i, a)=>{
            r.getCABO().getElementCount() && (e.VBOBuildTime > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && (r.getProgram().isAttributeUsed("vertexMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "vertexMC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || hu("Error setting vertexMC in shader VAO.")), r.getProgram().isAttributeUsed("tcoordMC") && r.getCABO().getTCoordOffset() && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "tcoordMC", r.getCABO().getTCoordOffset(), r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getTCoordComponents(), e.context.FALSE) || hu("Error setting tcoordMC in shader VAO.")), r.getAttributeUpdateTime().modified());
            const o = e.openGLTexture.getTextureUnit();
            r.getProgram().setUniformi("texture1", o);
            const s = e.openGLTexture.getComponents(), c = a.getProperty().getIndependentComponents();
            if (c) for(let v = 0; v < s; v++)r.getProgram().setUniformf(`mix${v}`, a.getProperty().getComponentWeight(v));
            const l = e.openGLTexture.getShiftAndScale();
            for(let v = 0; v < s; v++){
                let m = a.getProperty().getColorWindow(), y = a.getProperty().getColorLevel();
                const C = c ? v : 0, T = a.getProperty().getRGBTransferFunction(C);
                if (T && a.getProperty().getUseLookupTableScalarRange()) {
                    const D = T.getRange();
                    m = D[1] - D[0], y = .5 * (D[1] + D[0]);
                }
                const x = l.scale / m, S = (l.shift - y) / m + .5;
                r.getProgram().setUniformf(`cshift${v}`, S), r.getProgram().setUniformf(`cscale${v}`, x);
            }
            for(let v = 0; v < s; v++){
                let m = 1, y = 0;
                const C = c ? v : 0, T = a.getProperty().getPiecewiseFunction(C);
                if (T) {
                    const x = T.getRange(), S = x[1] - x[0], D = .5 * (x[0] + x[1]);
                    m = l.scale / S, y = (l.shift - D) / S + .5;
                }
                r.getProgram().setUniformf(`pwfshift${v}`, y), r.getProgram().setUniformf(`pwfscale${v}`, m);
            }
            if (e.haveSeenDepthRequest && r.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), r.getProgram().isUniformUsed("coffset")) {
                const v = t.getCoincidentParameters(i, a);
                r.getProgram().setUniformf("coffset", v.offset), r.getProgram().isUniformUsed("cfactor") && r.getProgram().setUniformf("cfactor", v.factor);
            }
            const f = e.colorTexture.getTextureUnit();
            r.getProgram().setUniformi("colorTexture1", f);
            const u = e.pwfTexture.getTextureUnit();
            r.getProgram().setUniformi("pwfTexture1", u);
            const g = e.labelOutlineThicknessTexture.getTextureUnit();
            if (r.getProgram().setUniformi("labelOutlineTexture1", g), e.renderable.getNumberOfClippingPlanes()) {
                let v = e.renderable.getNumberOfClippingPlanes();
                v > 6 && (Zt("OpenGL has a limit of 6 clipping planes"), v = 6);
                const y = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, C = y ? Ur(e.imagematinv, a.getMatrix()) : a.getMatrix();
                y && (cn(C, C), Qt(C, C, y), cn(C, C)), cn(e.imagemat, e.currentInput.getIndexToWorld()), Qt(e.imagematinv, C, e.imagemat);
                const T = [];
                for(let x = 0; x < v; x++){
                    const S = [];
                    e.renderable.getClippingPlaneInDataCoords(e.imagematinv, x, S);
                    for(let D = 0; D < 4; D++)T.push(S[D]);
                }
                r.getProgram().setUniformi("numClipPlanes", v), r.getProgram().setUniform4fv("clipPlanes", T);
            }
            if (a.getProperty().getUseLabelOutline() === !0) {
                const v = a.getProperty().getLabelOutlineOpacity();
                r.getProgram().setUniformf("outlineOpacity", v);
            }
        }, t.setCameraShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = e.openGLImageSlice.getKeyMatrices(), c = e.currentInput, l = c.getIndexToWorld();
            Qt(e.imagemat, s.mcwc, l);
            const f = e.openGLCamera.getKeyMatrices(i);
            if (Qt(e.imagemat, f.wcpc, e.imagemat), r.getCABO().getCoordShiftAndScaleEnabled()) {
                const g = r.getCABO().getInverseShiftAndScaleMatrix();
                Qt(e.imagemat, e.imagemat, g);
            }
            if (o.setUniformMatrix("MCPCMatrix", e.imagemat), a.getProperty().getUseLabelOutline() === !0) {
                const g = c.getWorldToIndex(), h = c.getDimensions();
                let v = e.renderable.getClosestIJKAxis().ijkMode;
                v === ho.NONE && (v = ho.K), o.setUniform3i("imageDimensions", h[0], h[1], h[2]), o.setUniformi("sliceAxis", v), o.setUniformMatrix("vWCtoIDX", g);
                const m = e.openGLCamera.getKeyMatrices(i);
                Xr(e.projectionToWorld, m.wcpc), e.openGLCamera.getKeyMatrices(i), o.setUniformMatrix("PCWCMatrix", e.projectionToWorld);
                const y = t.getRenderTargetSize();
                o.setUniformf("vpWidth", y[0]), o.setUniformf("vpHeight", y[1]);
                const C = t.getRenderTargetOffset();
                o.setUniformf("vpOffsetX", C[0] / y[0]), o.setUniformf("vpOffsetY", C[1] / y[1]);
            }
        }, t.setPropertyShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), c = a.getProperty().getOpacity();
            o.setUniformf("opacity", c);
        }, t.renderPieceStart = (r, i)=>{
            t.updateBufferObjects(r, i), e.lastBoundBO = null;
        }, t.renderPieceDraw = (r, i)=>{
            const a = e.context;
            e.openGLTexture.activate(), e.colorTexture.activate(), e.labelOutlineThicknessTexture.activate(), e.pwfTexture.activate(), e.tris.getCABO().getElementCount() && (t.updateShaders(e.tris, r, i), a.drawArrays(a.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release()), e.openGLTexture.deactivate(), e.colorTexture.deactivate(), e.labelOutlineThicknessTexture.deactivate(), e.pwfTexture.deactivate();
        }, t.renderPieceFinish = (r, i)=>{}, t.renderPiece = (r, i)=>{
            if (t.invokeEvent({
                type: "StartEvent"
            }), e.renderable.update(), e.currentInput = e.renderable.getCurrentImage(), t.invokeEvent({
                type: "EndEvent"
            }), !e.currentInput) {
                hu("No input!");
                return;
            }
            t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
        }, t.computeBounds = (r, i)=>{
            if (!t.getInput()) {
                af(e.bounds);
                return;
            }
            e.bounds = t.getInput().getBounds();
        }, t.updateBufferObjects = (r, i)=>{
            t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i);
        }, t.getNeedToRebuildBufferObjects = (r, i)=>e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < i.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < i.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime() || !e.openGLTexture?.getHandle() || !e.colorTexture?.getHandle() || !e.labelOutlineThicknessTexture?.getHandle() || !e.pwfTexture?.getHandle(), t.buildBufferObjects = (r, i)=>{
            const a = e.currentInput;
            if (!a) return;
            const o = a.getPointData() && a.getPointData().getScalars();
            if (!o) return;
            const s = o.getDataType(), c = o.getNumberOfComponents(), l = i.getProperty(), f = l.getInterpolationType(), u = l.getIndependentComponents(), g = u ? c : 1, h = u ? 2 * g : 1, v = l.getRGBTransferFunction(), m = ic(v, u, g), y = e._openGLRenderWindow.getGraphicsResourceForObject(v);
            if (!y?.oglObject?.getHandle() || y?.hash !== m) {
                e.colorTexture = Qn.newInstance({
                    resizable: !0
                }), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const G = 1024, Z = G * h * 3, H = new Uint8ClampedArray(Z);
                if (f === b0.NEAREST ? (e.colorTexture.setMinificationFilter(Tt.NEAREST), e.colorTexture.setMagnificationFilter(Tt.NEAREST)) : (e.colorTexture.setMinificationFilter(Tt.LINEAR), e.colorTexture.setMagnificationFilter(Tt.LINEAR)), v) {
                    const ne = new Float32Array(G * 3);
                    for(let ae = 0; ae < g; ae++){
                        const ue = l.getRGBTransferFunction(ae), le = ue.getRange();
                        if (ue.getTable(le[0], le[1], G, ne, 1), u) for(let oe = 0; oe < G * 3; oe++)H[ae * G * 6 + oe] = 255 * ne[oe], H[ae * G * 6 + oe + G * 3] = 255 * ne[oe];
                        else for(let oe = 0; oe < G * 3; oe++)H[ae * G * 6 + oe] = 255 * ne[oe];
                    }
                    e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(G, h, 3, qt.UNSIGNED_CHAR, H);
                } else {
                    for(let ne = 0; ne < G * 3; ++ne)H[ne] = 255 * ne / ((G - 1) * 3), H[ne + 1] = 255 * ne / ((G - 1) * 3), H[ne + 2] = 255 * ne / ((G - 1) * 3);
                    e.colorTexture.create2DFromRaw(G, 1, 3, qt.UNSIGNED_CHAR, H);
                }
                v && (e._openGLRenderWindow.setGraphicsResourceForObject(v, e.colorTexture, m), v !== e._colorTransferFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(v, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc, t)), e._colorTransferFunc = v);
            } else e.colorTexture = y.oglObject;
            const T = l.getPiecewiseFunction(), x = ic(T, u, g), S = e._openGLRenderWindow.getGraphicsResourceForObject(T);
            if (!S?.oglObject?.getHandle() || S?.hash !== x) {
                const Z = 1024 * h, H = new Uint8ClampedArray(Z);
                if (e.pwfTexture = Qn.newInstance({
                    resizable: !0
                }), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow), f === b0.NEAREST ? (e.pwfTexture.setMinificationFilter(Tt.NEAREST), e.pwfTexture.setMagnificationFilter(Tt.NEAREST)) : (e.pwfTexture.setMinificationFilter(Tt.LINEAR), e.pwfTexture.setMagnificationFilter(Tt.LINEAR)), T) {
                    const ne = new Float32Array(Z), ae = new Float32Array(1024);
                    for(let ue = 0; ue < g; ++ue){
                        const le = l.getPiecewiseFunction(ue);
                        if (le === null) ne.fill(1);
                        else {
                            const oe = le.getRange();
                            if (le.getTable(oe[0], oe[1], 1024, ae, 1), u) for(let re = 0; re < 1024; re++)ne[ue * 1024 * 2 + re] = ae[re], ne[ue * 1024 * 2 + re + 1024] = ae[re];
                            else for(let re = 0; re < 1024; re++)ne[ue * 1024 * 2 + re] = ae[re];
                        }
                    }
                    e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, h, 1, qt.FLOAT, ne);
                } else H.fill(255), e.pwfTexture.create2DFromRaw(1024, 1, 1, qt.UNSIGNED_CHAR, H);
                T && (e._openGLRenderWindow.setGraphicsResourceForObject(T, e.pwfTexture, x), T !== e._pwFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(T, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc, t)), e._pwFunc = T);
            } else e.pwfTexture = S.oglObject;
            t.updatelabelOutlineThicknessTexture(i);
            const { ijkMode: _ } = e.renderable.getClosestIJKAxis();
            let M = e.renderable.getSlice();
            _ !== e.renderable.getSlicingMode() && (M = e.renderable.getSliceAtPosition(M));
            const P = e.renderable.isA("vtkImageArrayMapper") ? e.renderable.getSubSlice() : Math.round(M), F = a.getExtent();
            let N;
            _ === ho.I && (N = P - F[0]), _ === ho.J && (N = P - F[2]), (_ === ho.K || _ === ho.NONE) && (N = P - F[4]);
            const B = `${M}A${a.getMTime()}A${o.getMTime()}B${t.getMTime()}C${e.renderable.getSlicingMode()}D${i.getProperty().getInterpolationType()}`;
            if (e.VBOBuildString !== B) {
                const G = a.getDimensions();
                e.openGLTexture || (e.openGLTexture = Qn.newInstance({
                    resizable: !0
                })), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), f === b0.NEAREST ? (new Set([
                    1,
                    3,
                    4
                ]).has(c) && s === qt.UNSIGNED_CHAR && !u && e.openGLTexture.setGenerateMipmap(!0), e.openGLTexture.setMinificationFilter(Tt.NEAREST), e.openGLTexture.setMagnificationFilter(Tt.NEAREST)) : (c === 4 && s === qt.UNSIGNED_CHAR && !u ? (e.openGLTexture.setGenerateMipmap(!0), e.openGLTexture.setMinificationFilter(Tt.LINEAR_MIPMAP_LINEAR)) : e.openGLTexture.setMinificationFilter(Tt.LINEAR), e.openGLTexture.setMagnificationFilter(Tt.LINEAR)), e.openGLTexture.setWrapS(bd.CLAMP_TO_EDGE), e.openGLTexture.setWrapT(bd.CLAMP_TO_EDGE);
                const Z = G[0] * G[1] * c, H = new Float32Array(12), ne = new Float32Array(8);
                for(let je = 0; je < 4; je++)ne[je * 2] = je % 2 ? 1 : 0, ne[je * 2 + 1] = je > 1 ? 1 : 0;
                const ae = [
                    ho.X,
                    ho.Y,
                    ho.Z
                ].includes(e.renderable.getSlicingMode()) ? M : P, ue = a.getSpatialExtent(), le = o.getData();
                let oe = null;
                if (_ === ho.I) {
                    oe = new le.constructor(G[2] * G[1] * c);
                    let je = 0;
                    for(let He = 0; He < G[2]; He++)for(let rt = 0; rt < G[1]; rt++){
                        let Qe = (N + rt * G[0] + He * G[0] * G[1]) * c;
                        je = (He * G[1] + rt) * c;
                        const et = Qe + c;
                        for(; Qe < et;)oe[je++] = le[Qe++];
                    }
                    G[0] = G[1], G[1] = G[2], H[0] = ae, H[1] = ue[2], H[2] = ue[4], H[3] = ae, H[4] = ue[3], H[5] = ue[4], H[6] = ae, H[7] = ue[2], H[8] = ue[5], H[9] = ae, H[10] = ue[3], H[11] = ue[5];
                } else if (_ === ho.J) {
                    oe = new le.constructor(G[2] * G[0] * c);
                    let je = 0;
                    for(let He = 0; He < G[2]; He++)for(let rt = 0; rt < G[0]; rt++){
                        let Qe = (rt + N * G[0] + He * G[0] * G[1]) * c;
                        je = (He * G[0] + rt) * c;
                        const et = Qe + c;
                        for(; Qe < et;)oe[je++] = le[Qe++];
                    }
                    G[1] = G[2], H[0] = ue[0], H[1] = ae, H[2] = ue[4], H[3] = ue[1], H[4] = ae, H[5] = ue[4], H[6] = ue[0], H[7] = ae, H[8] = ue[5], H[9] = ue[1], H[10] = ae, H[11] = ue[5];
                } else _ === ho.K || _ === ho.NONE ? (oe = le.subarray(N * Z, (N + 1) * Z), H[0] = ue[0], H[1] = ue[2], H[2] = ae, H[3] = ue[1], H[4] = ue[2], H[5] = ae, H[6] = ue[0], H[7] = ue[3], H[8] = ae, H[9] = ue[1], H[10] = ue[3], H[11] = ae) : hu("Reformat slicing not yet supported.");
                const re = o.getRanges();
                e.openGLTexture.resetFormatAndType(), e.openGLTexture.create2DFilterableFromRaw(G[0], G[1], c, o.getDataType(), oe, e.renderable.getPreferSizeOverAccuracy?.(), re), e.openGLTexture.activate(), e.openGLTexture.sendParameters(), e.openGLTexture.deactivate();
                const X = Wt.newInstance({
                    numberOfComponents: 3,
                    values: H
                });
                X.setName("points");
                const ie = Wt.newInstance({
                    numberOfComponents: 2,
                    values: ne
                });
                ie.setName("tcoords");
                const he = new Uint16Array(8);
                he[0] = 3, he[1] = 0, he[2] = 1, he[3] = 3, he[4] = 3, he[5] = 0, he[6] = 3, he[7] = 2;
                const $e = Wt.newInstance({
                    numberOfComponents: 1,
                    values: he
                });
                e.tris.getCABO().createVBO($e, "polys", Yo.SURFACE, {
                    points: X,
                    tcoords: ie,
                    cellOffset: 0
                }), e.VBOBuildTime.modified(), e.VBOBuildString = B;
            }
        }, t.updatelabelOutlineThicknessTexture = (r)=>{
            const i = r.getProperty().getLabelOutlineThicknessByReference(), a = e._openGLRenderWindow.getGraphicsResourceForObject(i), o = `${i.join("-")}`;
            if (!a?.oglObject?.getHandle() || a?.hash !== o) {
                const u = new Uint8Array(1024);
                for(let g = 0; g < 1024; ++g){
                    const h = typeof i[g] < "u" ? i[g] : i[0];
                    u[g] = h;
                }
                e.labelOutlineThicknessTexture = Qn.newInstance({
                    resizable: !1
                }), e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.labelOutlineThicknessTexture.resetFormatAndType(), e.labelOutlineThicknessTexture.setMinificationFilter(Tt.NEAREST), e.labelOutlineThicknessTexture.setMagnificationFilter(Tt.NEAREST), e.labelOutlineThicknessTexture.create2DFromRaw(1024, 1, 1, qt.UNSIGNED_CHAR, u), i && (e._openGLRenderWindow.setGraphicsResourceForObject(i, e.labelOutlineThicknessTexture, o), i !== e._labelOutlineThicknessArray && (e._openGLRenderWindow.registerGraphicsResourceUser(i, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._labelOutlineThicknessArray, t)), e._labelOutlineThicknessArray = i);
            } else e.labelOutlineThicknessTexture = a.oglObject;
        }, t.getRenderTargetSize = ()=>{
            if (e._useSmallViewport) return [
                e._smallViewportWidth,
                e._smallViewportHeight
            ];
            const { usize: r, vsize: i } = e._openGLRenderer.getTiledSizeAndOrigin();
            return [
                r,
                i
            ];
        }, t.getRenderTargetOffset = ()=>{
            const { lowerLeftU: r, lowerLeftV: i } = e._openGLRenderer.getTiledSizeAndOrigin();
            return [
                r,
                i
            ];
        }, t.delete = jd(()=>{
            e._openGLRenderWindow && n(e._openGLRenderWindow);
        }, t.delete);
    }
    const qU = {
        VBOBuildTime: 0,
        VBOBuildString: null,
        openGLTexture: null,
        tris: null,
        imagemat: null,
        imagematinv: null,
        colorTexture: null,
        pwfTexture: null,
        labelOutlineThicknessTexture: null,
        labelOutlineThicknessTextureString: null,
        lastHaveSeenDepthRequest: !1,
        haveSeenDepthRequest: !1,
        lastTextureComponents: 0
    };
    function XU(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, qU, n), Yr.extend(t, e, n), Wl.implementReplaceShaderCoincidentOffset(t, e, n), Wl.implementBuildShadersWithReplacements(t, e, n), e.tris = Yl.newInstance(), e.imagemat = Ot(new Float64Array(16)), e.imagematinv = Ot(new Float64Array(16)), e.projectionToWorld = Ot(new Float64Array(16)), e.idxToView = Ot(new Float64Array(16)), e.idxNormalMatrix = Ts(new Float64Array(9)), e.modelToView = Ot(new Float64Array(16)), e.projectionToView = Ot(new Float64Array(16)), si(t, e, []), e.VBOBuildTime = {}, tr(e.VBOBuildTime), KU(t, e);
    }
    const ZS = kn(XU, "vtkOpenGLImageMapper");
    var YU = {
        newInstance: ZS
    };
    bi("vtkAbstractImageMapper", ZS);
    const h0 = {
        MAX: 0,
        MIN: 1,
        AVERAGE: 2
    }, { vtkErrorMacro: C1 } = K;
    function ZU(t, e) {
        e.classHierarchy.push("vtkOpenGLImageCPRMapper");
        function n(r) {
            [
                e._scalars,
                e._colorTransferFunc,
                e._pwFunc
            ].forEach((i)=>r.unregisterGraphicsResourceUser(i, t));
        }
        t.buildPass = (r)=>{
            if (r) {
                e.currentRenderPass = null, e.openGLImageSlice = t.getFirstAncestorOfType("vtkOpenGLImageSlice"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
                const i = e._openGLRenderWindow;
                e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"), i && !i.isDeleted() && i !== e._openGLRenderWindow && n(i), e.context = e._openGLRenderWindow.getContext(), e.openGLCamera = e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow);
            }
        }, t.opaquePass = (r, i)=>{
            r && (e.currentRenderPass = i, t.render());
        }, t.opaqueZBufferPass = (r)=>{
            r && (e.haveSeenDepthRequest = !0, e.renderDepth = !0, t.render(), e.renderDepth = !1);
        }, t.getCoincidentParameters = (r, i)=>e.renderable.getResolveCoincidentTopology() === Ds.PolygonOffset ? e.renderable.getCoincidentTopologyPolygonOffsetParameters() : null, t.render = ()=>{
            const r = e.openGLImageSlice.getRenderable(), i = e._openGLRenderer.getRenderable();
            t.renderPiece(i, r);
        }, t.renderPiece = (r, i)=>{
            t.invokeEvent({
                type: "StartEvent"
            }), e.renderable.update(), t.invokeEvent({
                type: "EndEvent"
            }), e.renderable.preRenderCheck() && (e.currentImageDataInput = e.renderable.getInputData(0), e.currentCenterlineInput = e.renderable.getOrientedCenterline(), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i));
        }, t.renderPieceStart = (r, i)=>{
            t.updateBufferObjects(r, i);
        }, t.renderPieceDraw = (r, i)=>{
            const a = e.context;
            e.volumeTexture.activate(), e.colorTexture.activate(), e.pwfTexture.activate(), e.tris.getCABO().getElementCount() && (t.updateShaders(e.tris, r, i), a.drawArrays(a.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release()), e.volumeTexture.deactivate(), e.colorTexture.deactivate(), e.pwfTexture.deactivate();
        }, t.renderPieceFinish = (r, i)=>{}, t.updateBufferObjects = (r, i)=>{
            t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i), i.getProperty().getInterpolationType() === b0.NEAREST ? (e.volumeTexture.setMinificationFilter(Tt.NEAREST), e.volumeTexture.setMagnificationFilter(Tt.NEAREST), e.colorTexture.setMinificationFilter(Tt.NEAREST), e.colorTexture.setMagnificationFilter(Tt.NEAREST), e.pwfTexture.setMinificationFilter(Tt.NEAREST), e.pwfTexture.setMagnificationFilter(Tt.NEAREST)) : (e.volumeTexture.setMinificationFilter(Tt.LINEAR), e.volumeTexture.setMagnificationFilter(Tt.LINEAR), e.colorTexture.setMinificationFilter(Tt.LINEAR), e.colorTexture.setMagnificationFilter(Tt.LINEAR), e.pwfTexture.setMinificationFilter(Tt.LINEAR), e.pwfTexture.setMagnificationFilter(Tt.LINEAR));
        }, t.getNeedToRebuildBufferObjects = (r, i)=>{
            const a = e.VBOBuildTime.getMTime();
            return a < t.getMTime() || a < e.renderable.getMTime() || a < i.getMTime() || a < e.currentImageDataInput.getMTime() || a < e.currentCenterlineInput.getMTime() || !e.volumeTexture?.getHandle();
        }, t.buildBufferObjects = (r, i)=>{
            const a = e.currentImageDataInput, o = e.currentCenterlineInput, s = a?.getPointData()?.getScalars();
            if (!s) return;
            const c = e._openGLRenderWindow.getGraphicsResourceForObject(s), l = u4(a, s), f = !c?.oglObject?.getHandle() || c?.hash !== l, u = e.renderable.getUpdatedExtents(), g = !!u.length;
            if (f) {
                e.volumeTexture = Qn.newInstance(), e.volumeTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const N = a.getDimensions();
                e.volumeTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.volumeTexture.resetFormatAndType(), e.volumeTexture.create3DFilterableFromDataArray(N[0], N[1], N[2], s, e.renderable.getPreferSizeOverAccuracy()), e._openGLRenderWindow.setGraphicsResourceForObject(s, e.volumeTexture, l), s !== e._scalars && (e._openGLRenderWindow.registerGraphicsResourceUser(s, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars, t)), e._scalars = s;
            } else e.volumeTexture = c.oglObject;
            if (g) {
                e.renderable.setUpdatedExtents([]);
                const N = a.getDimensions();
                e.volumeTexture.create3DFilterableFromDataArray(N[0], N[1], N[2], s, !1, u);
            }
            const h = s.getNumberOfComponents(), v = i.getProperty(), m = v.getIndependentComponents(), y = m ? h : 1, C = m ? 2 * y : 1, T = v.getRGBTransferFunction(), x = ic(T, m, y), S = e._openGLRenderWindow.getGraphicsResourceForObject(T);
            if (!S?.oglObject?.getHandle() || S?.hash !== x) {
                const B = 1024 * C * 3, G = new Uint8ClampedArray(B);
                if (e.colorTexture = Qn.newInstance(), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow), T) {
                    const Z = new Float32Array(3072);
                    for(let H = 0; H < y; H++){
                        const ne = v.getRGBTransferFunction(H), ae = ne.getRange();
                        if (ne.getTable(ae[0], ae[1], 1024, Z, 1), m) for(let ue = 0; ue < 1024 * 3; ue++)G[H * 1024 * 6 + ue] = 255 * Z[ue], G[H * 1024 * 6 + ue + 1024 * 3] = 255 * Z[ue];
                        else for(let ue = 0; ue < 1024 * 3; ue++)G[H * 1024 * 6 + ue] = 255 * Z[ue];
                    }
                    e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, C, 3, qt.UNSIGNED_CHAR, G);
                } else {
                    for(let Z = 0; Z < 1024 * 3; ++Z)G[Z] = 255 * Z / (1023 * 3), G[Z + 1] = 255 * Z / (1023 * 3), G[Z + 2] = 255 * Z / (1023 * 3);
                    e.colorTexture.resetFormatAndType(), e.colorTexture.create2DFromRaw(1024, 1, 3, qt.UNSIGNED_CHAR, G);
                }
                T && (e._openGLRenderWindow.setGraphicsResourceForObject(T, e.colorTexture, x), T !== e._colorTransferFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(T, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc, t)), e._colorTransferFunc = T);
            } else e.colorTexture = S.oglObject;
            const _ = v.getPiecewiseFunction(), M = ic(_, m, y), P = e._openGLRenderWindow.getGraphicsResourceForObject(_);
            if (!P?.oglObject?.getHandle() || P?.hash !== M) {
                const B = 1024 * C, G = new Uint8ClampedArray(B);
                if (e.pwfTexture = Qn.newInstance(), e.pwfTexture.setOpenGLRenderWindow(e._openGLRenderWindow), _) {
                    const Z = new Float32Array(B), H = new Float32Array(1024);
                    for(let ne = 0; ne < y; ++ne){
                        const ae = v.getPiecewiseFunction(ne);
                        if (ae === null) Z.fill(1);
                        else {
                            const ue = ae.getRange();
                            if (ae.getTable(ue[0], ue[1], 1024, H, 1), m) for(let le = 0; le < 1024; le++)Z[ne * 1024 * 2 + le] = H[le], Z[ne * 1024 * 2 + le + 1024] = H[le];
                            else for(let le = 0; le < 1024; le++)Z[ne * 1024 * 2 + le] = H[le];
                        }
                    }
                    e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, C, 1, qt.FLOAT, Z);
                } else G.fill(255), e.pwfTexture.resetFormatAndType(), e.pwfTexture.create2DFromRaw(1024, 1, 1, qt.UNSIGNED_CHAR, G);
                _ && (e._openGLRenderWindow.setGraphicsResourceForObject(_, e.pwfTexture, M), _ !== e._pwFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(_, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._pwFunc, t)), e._pwFunc = _);
            } else e.pwfTexture = P.oglObject;
            if (e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < o.getMTime()) {
                const N = o.getNumberOfPoints(), B = N <= 1 ? 0 : N - 1, G = o.getDistancesToFirstPoint(), Z = e.renderable.getHeight(), H = 4 * B, ne = new Float32Array(3 * H), ae = e.renderable.getWidth();
                for(let Qe = 0, et = 0; Qe < B; ++Qe)ne.set([
                    0,
                    Z - G[Qe],
                    0
                ], et), et += 3, ne.set([
                    ae,
                    Z - G[Qe],
                    0
                ], et), et += 3, ne.set([
                    ae,
                    Z - G[Qe + 1],
                    0
                ], et), et += 3, ne.set([
                    0,
                    Z - G[Qe + 1],
                    0
                ], et), et += 3;
                const ue = Wt.newInstance({
                    numberOfComponents: 3,
                    values: ne
                });
                ue.setName("points");
                const le = new Uint16Array(5 * B);
                for(let Qe = 0, et = 0, St = 0; Qe < B; ++Qe)le.set([
                    4,
                    St + 3,
                    St + 2,
                    St + 1,
                    St
                ], et), et += 5, St += 4;
                const oe = Wt.newInstance({
                    numberOfComponents: 1,
                    values: le
                }), re = o.getPoints(), X = new Float32Array(3 * H), ie = new Array(3), he = new Array(3);
                for(let Qe = 0, et = 0; Qe < B; ++Qe)re.getPoint(Qe, ie), re.getPoint(Qe + 1, he), X.set(ie, et), et += 3, X.set(ie, et), et += 3, X.set(he, et), et += 3, X.set(he, et), et += 3;
                const $e = Wt.newInstance({
                    numberOfComponents: 3,
                    values: X,
                    name: "centerlinePosition"
                }), je = new Float32Array(H);
                for(let Qe = 0, et = 0; Qe < B; ++Qe)je.set([
                    0,
                    1,
                    3,
                    2
                ], et), et += 4;
                const He = Wt.newInstance({
                    numberOfComponents: 1,
                    values: je,
                    name: "quadIndex"
                }), rt = [
                    $e,
                    He
                ];
                if (!e.renderable.getUseUniformOrientation()) {
                    const Qe = e.renderable.getOrientedCenterline().getOrientations() ?? [], et = new Float32Array(4 * H), St = new Float32Array(4 * H);
                    for(let zt = 0; zt < B; ++zt){
                        const Pe = Qe[zt], Ct = Qe[zt + 1];
                        for(let yt = 0; yt < 4; ++yt){
                            const ln = 4 * (yt + 4 * zt);
                            et.set(Pe, ln), St.set(Ct, ln);
                        }
                    }
                    const Ln = Wt.newInstance({
                        numberOfComponents: 4,
                        values: et,
                        name: "centerlineTopOrientation"
                    }), Nn = Wt.newInstance({
                        numberOfComponents: 4,
                        values: St,
                        name: "centerlineBotOrientation"
                    });
                    rt.push(Ln, Nn);
                }
                e.tris.getCABO().createVBO(oe, "polys", Yo.SURFACE, {
                    points: ue,
                    customAttributes: rt
                }), e.VBOBuildTime.modified();
            }
        }, t.getNeedToRebuildShaders = (r, i, a)=>{
            const o = e.volumeTexture.getComponents(), s = a.getProperty().getIndependentComponents(), c = !!e.renderable.getCenterPoint(), l = e.renderable.getUseUniformOrientation(), f = e.renderable.isProjectionEnabled() && e.renderable.getProjectionMode();
            return r.getProgram() === 0 || e.lastUseCenterPoint !== c || e.lastUseUniformOrientation !== l || e.lastProjectionMode !== f || e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || e.lastTextureComponents !== o || e.lastIndependentComponents !== s ? (e.lastUseCenterPoint = c, e.lastUseUniformOrientation = l, e.lastProjectionMode = f, e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, e.lastTextureComponents = o, e.lastIndependentComponents = s, !0) : !1;
        }, t.buildShaders = (r, i, a)=>{
            t.getShaderTemplate(r, i, a), t.replaceShaderValues(r, i, a);
        }, t.replaceShaderValues = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            const c = [
                "vec3 applyQuaternionToVec(vec4 q, vec3 v) {",
                "  float uvx = q.y * v.z - q.z * v.y;",
                "  float uvy = q.z * v.x - q.x * v.z;",
                "  float uvz = q.x * v.y - q.y * v.x;",
                "  float uuvx = q.y * uvz - q.z * uvy;",
                "  float uuvy = q.z * uvx - q.x * uvz;",
                "  float uuvz = q.x * uvy - q.y * uvx;",
                "  float w2 = q.w * 2.0;",
                "  uvx *= w2;",
                "  uvy *= w2;",
                "  uvz *= w2;",
                "  uuvx *= 2.0;",
                "  uuvy *= 2.0;",
                "  uuvz *= 2.0;",
                "  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);",
                "}"
            ];
            o = Te.substitute(o, "//VTK::Camera::Dec", [
                "uniform mat4 MCPCMatrix;"
            ]).result, o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                "  gl_Position = MCPCMatrix * vertexMC;"
            ]).result;
            const l = [
                "attribute vec3 centerlinePosition;",
                "attribute float quadIndex;",
                "uniform float width;",
                "out vec2 quadOffsetVSOutput;",
                "out vec3 centerlinePosVSOutput;"
            ], f = e.renderable.isProjectionEnabled(), u = e.renderable.getUseUniformOrientation();
            u ? (l.push("out vec3 samplingDirVSOutput;", "uniform vec4 centerlineOrientation;", "uniform vec3 tangentDirection;", ...c), f && l.push("out vec3 projectionDirVSOutput;", "uniform vec3 bitangentDirection;")) : l.push("out vec4 centerlineTopOrientationVSOutput;", "out vec4 centerlineBotOrientationVSOutput;", "attribute vec4 centerlineTopOrientation;", "attribute vec4 centerlineBotOrientation;"), o = Te.substitute(o, "//VTK::Color::Dec", l).result;
            const g = [
                "quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);",
                "centerlinePosVSOutput = centerlinePosition;"
            ];
            u ? (g.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"), f && g.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")) : g.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;", "centerlineBotOrientationVSOutput = centerlineBotOrientation;"), o = Te.substitute(o, "//VTK::Color::Impl", g).result;
            const h = e.volumeTexture.getComponents(), v = a.getProperty().getIndependentComponents();
            let m = [
                "uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates",
                "in vec2 quadOffsetVSOutput;",
                "in vec3 centerlinePosVSOutput;",
                "uniform highp sampler3D volumeTexture;",
                "uniform sampler2D colorTexture1;",
                "uniform sampler2D pwfTexture1;",
                "uniform float opacity;",
                "uniform vec4 backgroundColor;",
                "uniform float cshift0;",
                "uniform float cscale0;",
                "uniform float pwfshift0;",
                "uniform float pwfscale0;"
            ];
            f && m.push("uniform vec3 volumeSizeMC;", "uniform int projectionSlabNumberOfSamples;", "uniform float projectionConstantOffset;", "uniform float projectionStepLength;"), u ? (m.push("in vec3 samplingDirVSOutput;"), f && m.push("in vec3 projectionDirVSOutput;")) : (m.push("uniform vec3 tangentDirection;", "in vec4 centerlineTopOrientationVSOutput;", "in vec4 centerlineBotOrientationVSOutput;", ...c), f && m.push("uniform vec3 bitangentDirection;"));
            const y = e.renderable.getCenterPoint();
            if (y && m.push("uniform vec3 globalCenterPoint;"), v) {
                for(let T = 1; T < h; T++)m = m.concat([
                    `uniform float cshift${T};`,
                    `uniform float cscale${T};`,
                    `uniform float pwfshift${T};`,
                    `uniform float pwfscale${T};`
                ]);
                switch(h){
                    case 1:
                        m = m.concat([
                            "uniform float mix0;",
                            "#define height0 0.5"
                        ]);
                        break;
                    case 2:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "#define height0 0.25",
                            "#define height1 0.75"
                        ]);
                        break;
                    case 3:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "#define height0 0.17",
                            "#define height1 0.5",
                            "#define height2 0.83"
                        ]);
                        break;
                    case 4:
                        m = m.concat([
                            "uniform float mix0;",
                            "uniform float mix1;",
                            "uniform float mix2;",
                            "uniform float mix3;",
                            "#define height0 0.125",
                            "#define height1 0.375",
                            "#define height2 0.625",
                            "#define height3 0.875"
                        ]);
                        break;
                    default:
                        C1("Unsupported number of independent coordinates.");
                }
            }
            s = Te.substitute(s, "//VTK::TCoord::Dec", m).result;
            let C = [];
            if (u ? (C.push("vec3 samplingDirection = samplingDirVSOutput;"), f && C.push("vec3 projectionDirection = projectionDirVSOutput;")) : (C.push("vec4 q0 = centerlineBotOrientationVSOutput;", "vec4 q1 = centerlineTopOrientationVSOutput;", "float qCosAngle = dot(q0, q1);", "vec4 interpolatedOrientation;", "if (qCosAngle > 0.999 || qCosAngle < -0.999) {", "  // Use LERP instead of SLERP when the two quaternions are close or opposite", "  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));", "} else {", "  float omega = acos(qCosAngle);", "  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);", "}", "vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"), f && C.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")), y ? C.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);", "float horizontalOffset = quadOffsetVSOutput.x + baseOffset;") : C.push("float horizontalOffset = quadOffsetVSOutput.x;"), C.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;", "vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;", "if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))", "{", "  // set the background color and exit", "  gl_FragData[0] = backgroundColor;", "  return;", "}"), f) {
                const T = e.renderable.getProjectionMode();
                switch(T){
                    case h0.MIN:
                        C.push("const vec4 initialProjectionTextureValue = vec4(1.0);");
                        break;
                    case h0.MAX:
                    case h0.AVERAGE:
                    default:
                        C.push("const vec4 initialProjectionTextureValue = vec4(0.0);");
                        break;
                }
                switch(C.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;", "vec3 projectionStep = projectionStepLength * projectionScaledDirection;", "vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;", "vec4 tvalue = initialProjectionTextureValue;", "for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {", "  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;", "  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"), T){
                    case h0.MAX:
                        C.push("  tvalue = max(tvalue, sampledTextureValue);");
                        break;
                    case h0.MIN:
                        C.push("  tvalue = min(tvalue, sampledTextureValue);");
                        break;
                    case h0.AVERAGE:
                    default:
                        C.push("  tvalue = tvalue + sampledTextureValue;");
                        break;
                }
                C.push("}"), T === h0.AVERAGE && C.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);");
            } else C.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");
            if (v) {
                const T = [
                    "r",
                    "g",
                    "b",
                    "a"
                ];
                for(let x = 0; x < h; ++x)C = C.concat([
                    `vec3 tcolor${x} = mix${x} * texture2D(colorTexture1, vec2(tvalue.${T[x]} * cscale${x} + cshift${x}, height${x})).rgb;`,
                    `float compWeight${x} = mix${x} * texture2D(pwfTexture1, vec2(tvalue.${T[x]} * pwfscale${x} + pwfshift${x}, height${x})).r;`
                ]);
                switch(h){
                    case 1:
                        C = C.concat([
                            "gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"
                        ]);
                        break;
                    case 2:
                        C = C.concat([
                            "float weightSum = compWeight0 + compWeight1;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"
                        ]);
                        break;
                    case 3:
                        C = C.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"
                        ]);
                        break;
                    case 4:
                        C = C.concat([
                            "float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;",
                            "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"
                        ]);
                        break;
                    default:
                        C1("Unsupported number of independent coordinates.");
                }
            } else switch(h){
                case 1:
                    C = C.concat([
                        "// Dependent components",
                        "float intensity = tvalue.r;",
                        "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;",
                        "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;",
                        "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"
                    ]);
                    break;
                case 2:
                    C = C.concat([
                        "float intensity = tvalue.r*cscale0 + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"
                    ]);
                    break;
                case 3:
                    C = C.concat([
                        "vec4 tcolor = cscale0*tvalue + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"
                    ]);
                    break;
                default:
                    C = C.concat([
                        "vec4 tcolor = cscale0*tvalue + cshift0;",
                        "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,",
                        "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"
                    ]);
            }
            s = Te.substitute(s, "//VTK::TCoord::Impl", C).result, e.haveSeenDepthRequest && (s = Te.substitute(s, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, s = Te.substitute(s, "//VTK::ZBuffer::Impl", [
                "if (depthRequest == 1) {",
                "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
                "float rf = floor(iz/256.0)/255.0;",
                "float gf = mod(iz,256.0)/255.0;",
                "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
            ]).result), r.Vertex = o, r.Fragment = s, t.replaceShaderClip(r, i, a), t.replaceShaderCoincidentOffset(r, i, a);
        }, t.replaceShaderClip = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            if (e.renderable.getNumberOfClippingPlanes()) {
                let c = e.renderable.getNumberOfClippingPlanes();
                c > 6 && (K.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"), c = 6), o = Te.substitute(o, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    "uniform vec4 clipPlanes[6];",
                    "varying float clipDistancesVSOutput[6];"
                ]).result, o = Te.substitute(o, "//VTK::Clip::Impl", [
                    "for (int planeNum = 0; planeNum < 6; planeNum++)",
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
                    "    }"
                ]).result, s = Te.substitute(s, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    "varying float clipDistancesVSOutput[6];"
                ]).result, s = Te.substitute(s, "//VTK::Clip::Impl", [
                    "for (int planeNum = 0; planeNum < 6; planeNum++)",
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
                    "    }"
                ]).result;
            }
            r.Vertex = o, r.Fragment = s;
        }, t.getShaderTemplate = (r, i, a)=>{
            r.Vertex = d4, r.Fragment = Jd, r.Geometry = "";
        }, t.setMapperShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = r.getCABO();
            s.getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && (o.isAttributeUsed("vertexMC") && (r.getVAO().addAttributeArray(o, s, "vertexMC", s.getVertexOffset(), s.getStride(), e.context.FLOAT, 3, e.context.FALSE) || C1("Error setting vertexMC in shader VAO.")), r.getCABO().getCustomData().forEach((h)=>{
                h && o.isAttributeUsed(h.name) && !r.getVAO().addAttributeArray(o, s, h.name, h.offset, s.getStride(), e.context.FLOAT, h.components, e.context.FALSE) && C1(`Error setting ${h.name} in shader VAO.`);
            }), r.getAttributeUpdateTime().modified());
            const c = e.volumeTexture.getTextureUnit();
            if (o.setUniformi("volumeTexture", c), o.setUniformf("width", e.renderable.getWidth()), r.getProgram().setUniform4fv("backgroundColor", e.renderable.getBackgroundColor()), o.isUniformUsed("tangentDirection")) {
                const h = e.renderable.getTangentDirection();
                r.getProgram().setUniform3fArray("tangentDirection", h);
            }
            if (o.isUniformUsed("bitangentDirection")) {
                const h = e.renderable.getBitangentDirection();
                r.getProgram().setUniform3fArray("bitangentDirection", h);
            }
            if (o.isUniformUsed("centerlineOrientation")) {
                const h = e.renderable.getUniformOrientation();
                r.getProgram().setUniform4fv("centerlineOrientation", h);
            }
            if (o.isUniformUsed("globalCenterPoint")) {
                const h = e.renderable.getCenterPoint();
                o.setUniform3fArray("globalCenterPoint", h);
            }
            if (e.renderable.isProjectionEnabled()) {
                const h = e.currentImageDataInput, v = h.getSpacing(), m = h.getDimensions(), y = e.renderable.getProjectionSlabThickness(), C = e.renderable.getProjectionSlabNumberOfSamples(), T = HV([], v, m);
                o.setUniform3fArray("volumeSizeMC", T), o.setUniformi("projectionSlabNumberOfSamples", C);
                const x = -.5 * y;
                o.setUniformf("projectionConstantOffset", x);
                const S = y / (C - 1);
                o.setUniformf("projectionStepLength", S);
            }
            const l = e.currentImageDataInput, f = l.getWorldToIndex(), u = F3(new Float32Array(16), mx([], l.getDimensions())), g = $h(u, u, f);
            if (o.setUniformMatrix("MCTCMatrix", g), e.haveSeenDepthRequest && r.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), e.renderable.getNumberOfClippingPlanes()) {
                let h = e.renderable.getNumberOfClippingPlanes();
                h > 6 && (K.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"), h = 6);
                const m = s.getCoordShiftAndScaleEnabled() ? s.getInverseShiftAndScaleMatrix() : null, y = m ? Ur(e.imagematinv, a.getMatrix()) : a.getMatrix();
                m && (cn(y, y), Qt(y, y, m), cn(y, y)), cn(e.imagemat, e.currentImageDataInput.getIndexToWorld()), Qt(e.imagematinv, y, e.imagemat);
                const C = [];
                for(let T = 0; T < h; T++){
                    const x = [];
                    e.renderable.getClippingPlaneInDataCoords(e.imagematinv, T, x);
                    for(let S = 0; S < 4; S++)C.push(x[S]);
                }
                o.setUniformi("numClipPlanes", h), o.setUniform4fv("clipPlanes", C);
            }
            if (o.isUniformUsed("coffset")) {
                const h = t.getCoincidentParameters(i, a);
                o.setUniformf("coffset", h.offset), o.isUniformUsed("cfactor") && o.setUniformf("cfactor", h.factor);
            }
        }, t.setCameraShaderParameters = (r, i, a)=>{
            const o = e.openGLImageSlice.getKeyMatrices().mcwc, s = e.openGLCamera.getKeyMatrices(i).wcpc;
            if (Qt(e.imagemat, s, o), r.getCABO().getCoordShiftAndScaleEnabled()) {
                const c = r.getCABO().getInverseShiftAndScaleMatrix();
                Qt(e.imagemat, e.imagemat, c);
            }
            r.getProgram().setUniformMatrix("MCPCMatrix", e.imagemat);
        }, t.setPropertyShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = a.getProperty(), c = s.getOpacity();
            o.setUniformf("opacity", c);
            const l = e.volumeTexture.getComponents(), f = s.getIndependentComponents();
            if (f) for(let v = 0; v < l; ++v)o.setUniformf(`mix${v}`, s.getComponentWeight(v));
            const u = e.volumeTexture.getVolumeInfo();
            for(let v = 0; v < l; v++){
                let m = s.getColorWindow(), y = s.getColorLevel();
                const C = f ? v : 0, T = s.getRGBTransferFunction(C);
                if (T && s.getUseLookupTableScalarRange()) {
                    const D = T.getRange();
                    m = D[1] - D[0], y = .5 * (D[1] + D[0]);
                }
                const x = u.scale[v] / m, S = (u.offset[v] - y) / m + .5;
                o.setUniformf(`cshift${v}`, S), o.setUniformf(`cscale${v}`, x);
            }
            const g = e.colorTexture.getTextureUnit();
            o.setUniformi("colorTexture1", g);
            for(let v = 0; v < l; v++){
                let m = 1, y = 0;
                const C = f ? v : 0, T = s.getPiecewiseFunction(C);
                if (T) {
                    const x = T.getRange(), S = x[1] - x[0], D = .5 * (x[0] + x[1]);
                    m = u.scale[v] / S, y = (u.offset[v] - D) / S + .5;
                }
                o.setUniformf(`pwfshift${v}`, y), o.setUniformf(`pwfscale${v}`, m);
            }
            const h = e.pwfTexture.getTextureUnit();
            o.setUniformi("pwfTexture1", h);
        }, t.updateShaders = (r, i, a)=>{
            if (t.getNeedToRebuildShaders(r, i, a)) {
                const o = {
                    Vertex: null,
                    Fragment: null,
                    Geometry: null
                };
                t.buildShaders(o, i, a);
                const s = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(o.Vertex, o.Fragment, o.Geometry);
                s !== r.getProgram() && (r.setProgram(s), r.getVAO().releaseGraphicsResources()), r.getShaderSourceTime().modified();
            } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(r.getProgram());
            r.getVAO().bind(), t.setMapperShaderParameters(r, i, a), t.setCameraShaderParameters(r, i, a), t.setPropertyShaderParameters(r, i, a);
        }, t.delete = K.chain(()=>{
            e._openGLRenderWindow && n(e._openGLRenderWindow);
        }, t.delete);
    }
    const JU = {
        currentRenderPass: null,
        volumeTexture: null,
        colorTexture: null,
        pwfTexture: null,
        tris: null,
        lastHaveSeenDepthRequest: !1,
        haveSeenDepthRequest: !1,
        lastTextureComponents: 0,
        lastIndependentComponents: 0,
        imagemat: null,
        imagematinv: null
    };
    function QU(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, JU, n), Yr.extend(t, e, n), Wl.implementReplaceShaderCoincidentOffset(t, e, n), K.algo(t, e, 2, 0), e.tris = Yl.newInstance(), e.volumeTexture = null, e.colorTexture = null, e.pwfTexture = null, e.imagemat = Ot(new Float64Array(16)), e.imagematinv = Ot(new Float64Array(16)), e.VBOBuildTime = {}, K.obj(e.VBOBuildTime, {
            mtime: 0
        }), ZU(t, e);
    }
    const JS = K.newInstance(QU, "vtkOpenGLImageCPRMapper"), eF = {};
    var tF = {
        newInstance: JS,
        ...eF
    };
    bi("vtkImageCPRMapper", JS);
    function nF(t, e) {
        e.classHierarchy.push("vtkOpenGLImageSlice"), t.buildPass = (n)=>{
            if (!(!e.renderable || !e.renderable.getVisibility()) && n) {
                if (!e.renderable) return;
                e._openGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes();
            }
        }, t.traverseZBufferPass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children.forEach((r)=>{
                r.traverse(n);
            }), t.apply(n, !1));
        }, t.traverseOpaqueZBufferPass = (n)=>t.traverseOpaquePass(n), t.traverseOpaquePass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children.forEach((r)=>{
                r.traverse(n);
            }), t.apply(n, !1));
        }, t.traverseTranslucentPass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children.forEach((r)=>{
                r.traverse(n);
            }), t.apply(n, !1));
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
            }
        }, t.zBufferPass = (n, r)=>t.opaquePass(n, r), t.opaqueZBufferPass = (n, r)=>t.opaquePass(n, r), t.opaquePass = (n, r)=>{
            n && e.context.depthMask(!0);
        }, t.translucentPass = (n, r)=>{
            e.context.depthMask(!n);
        }, t.getKeyMatrices = ()=>(e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (Ur(e.keyMatrices.mcwc, e.renderable.getMatrix()), cn(e.keyMatrices.mcwc, e.keyMatrices.mcwc), e.keyMatrixTime.modified()), e.keyMatrices);
    }
    const rF = {
        context: null,
        keyMatrixTime: null,
        keyMatrices: null
    };
    function iF(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, rF, n), Yr.extend(t, e, n), e.keyMatrixTime = {}, tr(e.keyMatrixTime, {
            mtime: 0
        }), e.keyMatrices = {
            mcwc: Ot(new Float64Array(16))
        }, si(t, e, [
            "context"
        ]), nF(t, e);
    }
    const QS = kn(iF, "vtkOpenGLImageSlice");
    var aF = {
        newInstance: QS
    };
    bi("vtkImageSlice", QS);
    function oF(t, e) {
        e.classHierarchy.push("vtkOpenGLVolume"), t.buildPass = (n)=>{
            !e.renderable || !e.renderable.getVisibility() || n && (e._openGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes());
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                r.incrementVolumeCount();
            }
        }, t.traverseVolumePass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children[0].traverse(n), t.apply(n, !1));
        }, t.volumePass = (n)=>{
            !e.renderable || !e.renderable.getVisibility() || e.context.depthMask(!n);
        }, t.getKeyMatrices = ()=>(e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (e.renderable.computeMatrix(), Ur(e.MCWCMatrix, e.renderable.getMatrix()), cn(e.MCWCMatrix, e.MCWCMatrix), e.renderable.getIsIdentity() ? Ts(e.normalMatrix) : (Mp(e.normalMatrix, e.MCWCMatrix), Xd(e.normalMatrix, e.normalMatrix), V3(e.normalMatrix, e.normalMatrix)), e.keyMatrixTime.modified()), {
                mcwc: e.MCWCMatrix,
                normalMatrix: e.normalMatrix
            });
    }
    const sF = {};
    function cF(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, sF, n), Yr.extend(t, e, n), e.keyMatrixTime = {}, tr(e.keyMatrixTime, {
            mtime: 0
        }), e.normalMatrix = new Float64Array(9), e.MCWCMatrix = new Float64Array(16), si(t, e, [
            "context"
        ]), oF(t, e);
    }
    const eE = kn(cF, "vtkOpenGLVolume");
    var lF = {
        newInstance: eE
    };
    bi("vtkVolume", eE);
    function uF(t, e) {
        e.classHierarchy.push("vtkFramebuffer"), t.getBothMode = ()=>e.context.FRAMEBUFFER, t.saveCurrentBindingsAndBuffers = (n)=>{
            const r = typeof n < "u" ? n : t.getBothMode();
            t.saveCurrentBindings(r), t.saveCurrentBuffers(r);
        }, t.saveCurrentBindings = (n)=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
                return;
            }
            const r = e.context;
            e.previousDrawBinding = r.getParameter(e.context.FRAMEBUFFER_BINDING), e.previousActiveFramebuffer = e._openGLRenderWindow.getActiveFramebuffer();
        }, t.saveCurrentBuffers = (n)=>{}, t.restorePreviousBindingsAndBuffers = (n)=>{
            const r = typeof n < "u" ? n : t.getBothMode();
            t.restorePreviousBindings(r), t.restorePreviousBuffers(r);
        }, t.restorePreviousBindings = (n)=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
                return;
            }
            const r = e.context;
            r.bindFramebuffer(r.FRAMEBUFFER, e.previousDrawBinding), e._openGLRenderWindow.setActiveFramebuffer(e.previousActiveFramebuffer);
        }, t.restorePreviousBuffers = (n)=>{}, t.bind = function() {
            let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            r === null && (r = e.context.FRAMEBUFFER), e.context.bindFramebuffer(r, e.glFramebuffer);
            for(let i = 0; i < e.colorBuffers.length; i++)e.colorBuffers[i].bind();
            e._openGLRenderWindow.setActiveFramebuffer(t);
        }, t.create = (n, r)=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling create");
                return;
            }
            e.glFramebuffer = e.context.createFramebuffer(), e.glFramebuffer.width = n, e.glFramebuffer.height = r;
        }, t.setColorBuffer = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const i = e.context;
            if (!i) {
                Zt("you must set the OpenGLRenderWindow before calling setColorBuffer");
                return;
            }
            let a = i.COLOR_ATTACHMENT0;
            if (r > 0) if (e._openGLRenderWindow.getWebgl2()) a += r;
            else {
                Zt("Using multiple framebuffer attachments requires WebGL 2");
                return;
            }
            e.colorBuffers[r] = n, i.framebufferTexture2D(i.FRAMEBUFFER, a, i.TEXTURE_2D, n.getHandle(), 0);
        }, t.removeColorBuffer = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            const r = e.context;
            if (!r) {
                Zt("you must set the OpenGLRenderWindow before calling removeColorBuffer");
                return;
            }
            let i = r.COLOR_ATTACHMENT0;
            if (n > 0) if (e._openGLRenderWindow.getWebgl2()) i += n;
            else {
                Zt("Using multiple framebuffer attachments requires WebGL 2");
                return;
            }
            r.framebufferTexture2D(r.FRAMEBUFFER, i, r.TEXTURE_2D, null, 0), e.colorBuffers = e.colorBuffers.splice(n, 1);
        }, t.setDepthBuffer = (n)=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling setDepthBuffer");
                return;
            }
            if (e._openGLRenderWindow.getWebgl2()) {
                const r = e.context;
                r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, n.getHandle(), 0);
            } else Zt("Attaching depth buffer textures to fbo requires WebGL 2");
        }, t.removeDepthBuffer = ()=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
                return;
            }
            if (e._openGLRenderWindow.getWebgl2()) {
                const n = e.context;
                n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, null, 0);
            } else Zt("Attaching depth buffer textures to framebuffers requires WebGL 2");
        }, t.getGLFramebuffer = ()=>e.glFramebuffer, t.setOpenGLRenderWindow = (n)=>{
            e._openGLRenderWindow !== n && (t.releaseGraphicsResources(), e._openGLRenderWindow = n, e.context = null, n && (e.context = e._openGLRenderWindow.getContext()));
        }, t.releaseGraphicsResources = ()=>{
            e.glFramebuffer && e.context.deleteFramebuffer(e.glFramebuffer);
        }, t.getSize = ()=>e.glFramebuffer == null ? null : [
                e.glFramebuffer.width,
                e.glFramebuffer.height
            ], t.populateFramebuffer = ()=>{
            if (!e.context) {
                Zt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
                return;
            }
            t.bind();
            const n = e.context, r = Qn.newInstance();
            r.setOpenGLRenderWindow(e._openGLRenderWindow), r.setMinificationFilter(Tt.LINEAR), r.setMagnificationFilter(Tt.LINEAR), r.create2DFromRaw(e.glFramebuffer.width, e.glFramebuffer.height, 4, qt.UNSIGNED_CHAR, null), t.setColorBuffer(r), e.depthTexture = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, e.depthTexture), n.renderbufferStorage(n.RENDERBUFFER, n.DEPTH_COMPONENT16, e.glFramebuffer.width, e.glFramebuffer.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.RENDERBUFFER, e.depthTexture);
        }, t.getColorTexture = ()=>e.colorBuffers[0];
    }
    const fF = {
        glFramebuffer: null,
        colorBuffers: null,
        depthTexture: null,
        previousDrawBinding: 0,
        previousReadBinding: 0,
        previousDrawBuffer: 0,
        previousReadBuffer: 0,
        previousActiveFramebuffer: null
    };
    function tE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, fF, n), tr(t, e), e.colorBuffers && Zt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."), e.colorBuffers = [], rf(t, e, [
            "colorBuffers"
        ]), uF(t, e);
    }
    const dF = kn(tE, "vtkFramebuffer");
    var kp = {
        newInstance: dF,
        extend: tE
    }, gF = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkPolyDataVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

attribute vec4 vertexDC;

varying vec3 vertexVCVSOutput;
uniform mat4 PCVCMatrix;

uniform float dcxmin;
uniform float dcxmax;
uniform float dcymin;
uniform float dcymax;

void main()
{
  // dcsmall is the device coords reduced to the
  // x y area covered by the volume
  vec4 dcsmall = vec4(
    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),
    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),
    vertexDC.z,
    vertexDC.w);
  vec4 vcpos = PCVCMatrix * dcsmall;
  vertexVCVSOutput = vcpos.xyz/vcpos.w;
  gl_Position = dcsmall;
}
`, hF = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define UseIndependentComponents
//VTK::IndependentComponentsOn

// possibly define vtkCustomComponentsColorMix
//VTK::CustomComponentsColorMixOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// possibly define any components that are forced to nearest interpolation
//VTK::vtkForceNearestComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

// Possibly define vtkLabelEdgeProjectionOn
//VTK::LabelEdgeProjectionOn


#ifdef vtkImageLabelOutlineOn
  uniform float outlineOpacity;
  uniform float vpWidth;
  uniform float vpHeight;
  uniform float vpOffsetX;
  uniform float vpOffsetY;
  uniform mat4 PCWCMatrix;
  uniform mat4 vWCtoIDX;

  const int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum
  // bool seenSegmentsByOriginalPos[MAX_SEGMENT_INDEX];
  #define MAX_SEGMENTS 256
  #define UINT_SIZE 32
  #define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)

  uint bitmask[BITMASK_SIZE];

  // Set the corresponding bit in the bitmask
  void setBit(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    bitmask[index] |= 1u << bitIndex;
  }

  // Check if a bit is set in the bitmask
  bool isBitSet(int segmentIndex) {
    int index = segmentIndex / UINT_SIZE;
    int bitIndex = segmentIndex % UINT_SIZE;
    return ((bitmask[index] & (1u << bitIndex)) != 0u);
  }
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

//VTK::VolumeShadowOn
//VTK::SurfaceShadowOn
//VTK::localAmbientOcclusionOn
//VTK::LAO::Dec
//VTK::VolumeShadow::Dec

// define vtkComputeNormalFromOpacity
//VTK::vtkComputeNormalFromOpacity

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#ifdef UseIndependentComponents
#if vtkNumComponents > 1
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents > 2
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#if vtkNumComponents > 3
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

// jitter texture
uniform sampler2D jtexture;
uniform sampler2D ttexture;


// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;
uniform vec3 volumeSpacings; // spacing in the world coorindates


// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef UseIndependentComponents
#if vtkNumComponents == 1
uniform float mix0;
#define height0 0.5
#endif
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

//=======================================================================
// global and custom variables (a temporary section before photorealistics rendering module is complete)
vec3 rayDirVC;
float sampleDistanceISVS;
float sampleDistanceIS;

#define SQRT3    1.7321
#define INV4PI   0.0796
#define EPSILON  0.001
#define PI       3.1415
#define PI2      9.8696

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);

  #if defined(vtkComponent0ForceNearest) || \\
      defined(vtkComponent1ForceNearest) || \\
      defined(vtkComponent2ForceNearest) || \\
      defined(vtkComponent3ForceNearest)
    vec3 nearestPos = (floor(pos * vec3(volumeDimensions)) + 0.5) / vec3(volumeDimensions);
    vec4 nearestValue = texture(texture1, nearestPos);
    #ifdef vtkComponent0ForceNearest
      tmp[0] = nearestValue[0];
    #endif
    #ifdef vtkComponent1ForceNearest
      tmp[1] = nearestValue[1];
    #endif
    #ifdef vtkComponent2ForceNearest
      tmp[2] = nearestValue[2];
    #endif
    #ifdef vtkComponent3ForceNearest
      tmp[3] = nearestValue[3];
    #endif
  #endif

  #ifndef UseIndependentComponents
    #if vtkNumComponents == 1
      tmp.a = tmp.r;
    #endif
    #if vtkNumComponents == 2
      tmp.a = tmp.g;
    #endif
    #if vtkNumComponents == 3
      tmp.a = length(tmp.rgb);
    #endif
  #endif

  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// transformation between VC and IS space

// convert vector position from idx to vc
#if (vtkLightComplexity > 0) || (defined vtkClippingPlanesOn)
vec3 IStoVC(vec3 posIS){
  vec3 posVC = posIS / vVCToIJK;
  return posVC.x * vPlaneNormal0 +
         posVC.y * vPlaneNormal2 +
         posVC.z * vPlaneNormal4 +
         vOriginVC;
}

// convert vector position from vc to idx
vec3 VCtoIS(vec3 posVC){
  posVC = posVC - vOriginVC;
  posVC = vec3(
    dot(posVC, vPlaneNormal0),
    dot(posVC, vPlaneNormal2),
    dot(posVC, vPlaneNormal4));
  return posVC * vVCToIJK;
}
#endif

//Rotate vector to view coordinate
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
void rotateToViewCoord(inout vec3 dirIS){
  dirIS.xyz =
    dirIS.x * vPlaneNormal0 +
    dirIS.y * vPlaneNormal2 +
    dirIS.z * vPlaneNormal4;
}

//Rotate vector to idx coordinate
vec3 rotateToIDX(vec3 dirVC){
  vec3 dirIS;
  dirIS.xyz = vec3(
    dot(dirVC, vPlaneNormal0),
    dot(dirVC, vPlaneNormal2),
    dot(dirVC, vPlaneNormal4));
  return dirIS;
}
#endif

//=======================================================================
// Given a normal compute the gradient opacity factors
float computeGradientOpacityFactor(
  float normalMag, float goscale, float goshift, float gomin, float gomax)
{
  return clamp(normalMag * goscale + goshift, gomin, gomax);
}

//=======================================================================
// compute the normal and gradient magnitude for a position, uses forward difference
#if (vtkLightComplexity > 0) || (defined vtkGradientOpacityOn)
  #ifdef vtkClippingPlanesOn
    void adjustClippedVoxelValues(vec3 pos, vec3 texPos[3], inout vec3 g1)
    {
      vec3 g1VC[3];
      for (int i = 0; i < 3; ++i)
      {
        g1VC[i] = IStoVC(texPos[i]);
      }
      vec3 posVC = IStoVC(pos);
      for (int i = 0; i < clip_numPlanes; ++i)
      {
        for (int j = 0; j < 3; ++j)
        {
          if(dot(vec3(vClipPlaneOrigins[i] - g1VC[j].xyz), vClipPlaneNormals[i]) > 0.0)
          {
            g1[j] = 0.0;
          }
        }
      }
    }
  #endif

  #ifdef vtkComputeNormalFromOpacity
    vec4 computeDensityNormal(vec3 opacityUCoords[2], float opactityTextureHeight, float gradientOpacity) {
      vec3 opacityG1, opacityG2;
      opacityG1.x = texture2D(otexture, vec2(opacityUCoords[0].x, opactityTextureHeight)).r;
      opacityG1.y = texture2D(otexture, vec2(opacityUCoords[0].y, opactityTextureHeight)).r;
      opacityG1.z = texture2D(otexture, vec2(opacityUCoords[0].z, opactityTextureHeight)).r;
      opacityG2.x = texture2D(otexture, vec2(opacityUCoords[1].x, opactityTextureHeight)).r;
      opacityG2.y = texture2D(otexture, vec2(opacityUCoords[1].y, opactityTextureHeight)).r;
      opacityG2.z = texture2D(otexture, vec2(opacityUCoords[1].z, opactityTextureHeight)).r;
      opacityG1.xyz *= gradientOpacity;
      opacityG2.xyz *= gradientOpacity;

      vec4 opacityG = vec4(opacityG1 - opacityG2, 1.0f);
      // divide by spacing
      opacityG.xyz /= vSpacing;
      opacityG.w = length(opacityG.xyz);
      // rotate to View Coords
      rotateToViewCoord(opacityG.xyz);
      if (!all(equal(opacityG.xyz, vec3(0.0)))) {
        return vec4(normalize(opacityG.xyz),opacityG.w);
      } else {
        return vec4(0.0);
      }
    }

    vec4 computeNormalForDensity(vec3 pos, vec3 tstep, out vec3 scalarInterp[2], const int opacityComponent)
    {
      vec3 xvec = vec3(tstep.x, 0.0, 0.0);
      vec3 yvec = vec3(0.0, tstep.y, 0.0);
      vec3 zvec = vec3(0.0, 0.0, tstep.z);
      vec3 texPosPVec[3];
      texPosPVec[0] = pos + xvec;
      texPosPVec[1] = pos + yvec;
      texPosPVec[2] = pos + zvec;
      vec3 texPosNVec[3];
      texPosNVec[0] = pos - xvec;
      texPosNVec[1] = pos - yvec;
      texPosNVec[2] = pos - zvec;
      vec3 g1, g2;

      scalarInterp[0].x = getTextureValue(texPosPVec[0])[opacityComponent];
      scalarInterp[0].y = getTextureValue(texPosPVec[1])[opacityComponent];
      scalarInterp[0].z = getTextureValue(texPosPVec[2])[opacityComponent];
      scalarInterp[1].x = getTextureValue(texPosNVec[0])[opacityComponent];
      scalarInterp[1].y = getTextureValue(texPosNVec[1])[opacityComponent];
      scalarInterp[1].z = getTextureValue(texPosNVec[2])[opacityComponent];

      #ifdef vtkClippingPlanesOn
        adjustClippedVoxelValues(pos, texPosPVec, scalarInterp[0]);
        adjustClippedVoxelValues(pos, texPosNVec, scalarInterp[1]);
      #endif
      vec4 result;
      result.x = scalarInterp[0].x - scalarInterp[1].x;
      result.y = scalarInterp[0].y - scalarInterp[1].y;
      result.z = scalarInterp[0].z - scalarInterp[1].z;
      // divide by spacing
      result.xyz /= vSpacing;
      result.w = length(result.xyz);
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      if (length(result.xyz) > 0.0) {
        return vec4(normalize(result.xyz),result.w);
      } else {
        return vec4(0.0);
      }
    }
  #endif

  // only works with dependent components
  vec4 computeNormal(vec3 pos, vec3 tstep)
  {
    vec3 xvec = vec3(tstep.x, 0.0, 0.0);
    vec3 yvec = vec3(0.0, tstep.y, 0.0);
    vec3 zvec = vec3(0.0, 0.0, tstep.z);
    vec3 texPosPVec[3];
    texPosPVec[0] = pos + xvec;
    texPosPVec[1] = pos + yvec;
    texPosPVec[2] = pos + zvec;
    vec3 texPosNVec[3];
    texPosNVec[0] = pos - xvec;
    texPosNVec[1] = pos - yvec;
    texPosNVec[2] = pos - zvec;
    vec3 g1, g2;
    g1.x = getTextureValue(texPosPVec[0]).a;
    g1.y = getTextureValue(texPosPVec[1]).a;
    g1.z = getTextureValue(texPosPVec[2]).a;
    g2.x = getTextureValue(texPosNVec[0]).a;
    g2.y = getTextureValue(texPosNVec[1]).a;
    g2.z = getTextureValue(texPosNVec[2]).a;
    #ifdef vtkClippingPlanesOn
      adjustClippedVoxelValues(pos, texPosPVec, g1);
      adjustClippedVoxelValues(pos, texPosNVec, g2);
    #endif
    vec4 result;
    result = vec4(g1 - g2, -1.0);
    // divide by spacing
    result.xyz /= vSpacing;
    result.w = length(result.xyz);
    if (result.w > 0.0){
      // rotate to View Coords
      rotateToViewCoord(result.xyz);
      return vec4(normalize(result.xyz),result.w);
    } else {
      return vec4(0.0);
    }
  }
#endif


#ifdef vtkImageLabelOutlineOn
  vec4 fragCoordToPCPos(vec4 fragCoord) {
    return vec4(
      (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
      (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
      (fragCoord.z - 0.5) * 2.0,
      1.0);
  }

  vec4 pcPosToWorldCoord(vec4 pcPos) {
    return PCWCMatrix * pcPos;
  }

  vec3 fragCoordToIndexSpace(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    vec4 vertex = (worldCoord / worldCoord.w);

    vec3 index = (vWCtoIDX * vertex).xyz;

    // half voxel fix for labelmapOutline
    return (index + vec3(0.5)) / vec3(volumeDimensions);
  }

  vec3 fragCoordToWorld(vec4 fragCoord) {
    vec4 pcPos = fragCoordToPCPos(fragCoord);
    vec4 worldCoord = pcPosToWorldCoord(pcPos);
    return worldCoord.xyz;
  }
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// global shadow - secondary ray
#if defined(VolumeShadowOn) || defined(localAmbientOcclusionOn)
float random()
{
  float rand = fract(sin(dot(gl_FragCoord.xy,vec2(12.9898,78.233)))*43758.5453123);
  float jitter=texture2D(jtexture,gl_FragCoord.xy/32.).r;
  uint pcg_state = floatBitsToUint(jitter);
  uint state = pcg_state;
  pcg_state = pcg_state * uint(747796405) + uint(2891336453);
  uint word = ((state >> ((state >> uint(28)) + uint(4))) ^ state) * uint(277803737);
  return (float((((word >> uint(22)) ^ word) >> 1 ))/float(2147483647) + rand)/2.0;
}
#endif

#ifdef VolumeShadowOn
// henyey greenstein phase function
float phase_function(float cos_angle)
{
  // divide by 2.0 instead of 4pi to increase intensity
  return ((1.0-anisotropy2)/pow(1.0+anisotropy2-2.0*anisotropy*cos_angle, 1.5))/2.0;
}

// Computes the intersection between a ray and a box
struct Hit
{
  float tmin;
  float tmax;
};

struct Ray
{
  vec3 origin;
  vec3 dir;
  vec3 invDir;
};

bool BBoxIntersect(vec3 boundMin, vec3 boundMax, const Ray r, out Hit hit)
{
  vec3 tbot = r.invDir * (boundMin - r.origin);
  vec3 ttop = r.invDir * (boundMax - r.origin);
  vec3 tmin = min(ttop, tbot);
  vec3 tmax = max(ttop, tbot);
  vec2 t = max(tmin.xx, tmin.yz);
  float t0 = max(t.x, t.y);
  t = min(tmax.xx, tmax.yz);
  float t1 = min(t.x, t.y);
  hit.tmin = t0;
  hit.tmax = t1;
  return t1 > max(t0,0.0);
}

// As BBoxIntersect requires the inverse of the ray coords,
// this function is used to avoid numerical issues
void safe_0_vector(inout Ray ray)
{
  if(abs(ray.dir.x) < EPSILON) ray.dir.x = sign(ray.dir.x) * EPSILON;
  if(abs(ray.dir.y) < EPSILON) ray.dir.y = sign(ray.dir.y) * EPSILON;
  if(abs(ray.dir.z) < EPSILON) ray.dir.z = sign(ray.dir.z) * EPSILON;
}

float volume_shadow(vec3 posIS, vec3 lightDirNormIS)
{
  float shadow = 1.0;
  float opacity = 0.0;

  // modify sample distance with a random number between 1.5 and 3.0
  float sampleDistanceISVS_jitter = sampleDistanceISVS * mix(1.5, 3.0, random());
  float opacityPrev = texture2D(otexture, vec2(getTextureValue(posIS).r * oscale0 + oshift0, 0.5)).r;

  // in case the first sample near surface has a very tiled light ray, we need to offset start position
  posIS += sampleDistanceISVS_jitter * lightDirNormIS;

  // compute the start and end points for the ray
  Ray ray;
  Hit hit;
  ray.origin = posIS;
  ray.dir = lightDirNormIS;
  safe_0_vector(ray);
  ray.invDir = 1.0/ray.dir;

  if(!BBoxIntersect(vec3(0.0),vec3(1.0), ray, hit))
  {
    return 1.0;
  }
  float maxdist = hit.tmax;

  // interpolate shadow ray length between: 1 unit of sample distance in IS to SQRT3, based on globalIlluminationReach
  float maxgi = mix(sampleDistanceISVS_jitter,SQRT3,giReach);
  maxdist = min(maxdist,maxgi);
  if(maxdist < EPSILON) {
    return 1.0;
  }

  float current_dist = 0.0;
  float current_step = length(sampleDistanceISVS_jitter * lightDirNormIS);
  float clamped_step = 0.0;

  vec4 scalar = vec4(0.0);
  while(current_dist < maxdist)
  {
#ifdef vtkClippingPlanesOn
    vec3 posVC = IStoVC(posIS);
    for (int i = 0; i < clip_numPlanes; ++i)
    {
      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0)
      {
        current_dist = maxdist;
      }
    }
#endif
    scalar = getTextureValue(posIS);
    opacity = texture2D(otexture, vec2(scalar.r * oscale0 + oshift0, 0.5)).r;
    #if defined(vtkGradientOpacityOn) && !defined(UseIndependentComponents)
      vec4 normal = computeNormal(posIS, vec3(1.0/vec3(volumeDimensions)));
      opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
    #endif
    shadow *= 1.0 - opacity;

    // optimization: early termination
    if (shadow < EPSILON){
      return 0.0;
    }

    clamped_step = min(maxdist - current_dist, current_step);
    posIS += clamped_step * lightDirNormIS;
    current_dist += current_step;
  }

  return shadow;
}

vec3 applyShadowRay(vec3 tColor, vec3 posIS, vec3 viewDirectionVC)
{
  vec3 vertLight = vec3(0.0);
  vec3 secondary_contrib = vec3(0.0);
  // here we assume only positional light, no effect of cones
  for (int i = 0; i < lightNum; i++)
  {
    #if(vtkLightComplexity==3)
      if (lightPositional[i] == 1){
        vertLight = lightPositionVC[i] - IStoVC(posIS);
      }else{
        vertLight = - lightDirectionVC[i];
      }
    #else
      vertLight = - lightDirectionVC[i];
    #endif
    // here we assume achromatic light, only intensity
    float dDotL = dot(viewDirectionVC, normalize(vertLight));
    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity
    float phase_attenuation = 0.5;
    if (abs(anisotropy) > EPSILON){
      phase_attenuation = phase_function(dDotL);
    }
    float vol_shadow = volume_shadow(posIS, normalize(rotateToIDX(vertLight)));
    secondary_contrib += tColor * vDiffuse * lightColor[i] * vol_shadow * phase_attenuation;
    secondary_contrib += tColor * vAmbient;
  }
  return secondary_contrib;
}
#endif

//=======================================================================
// local ambient occlusion
#ifdef localAmbientOcclusionOn
vec3 sample_direction_uniform(int i)
{
  float rand = random() * 0.5;
  float theta = PI2 * (kernelSample[i][0] + rand);
  float phi = acos(2.0 * (kernelSample[i][1] + rand) -1.0) / 2.5;
  return normalize(vec3(cos(theta)*sin(phi), sin(theta)*sin(phi), cos(phi)));
}

// return a matrix that transform startDir into z axis; startDir should be normalized
mat3 zBaseRotationalMatrix(vec3 startDir){
  vec3 axis = cross(startDir, vec3(0.0,0.0,1.0));
  float cosA = startDir.z;
  float k = 1.0 / (1.0 + cosA);
  mat3 matrix = mat3((axis.x * axis.x * k) + cosA, (axis.y * axis.x * k) - axis.z, (axis.z * axis.x * k) + axis.y,
              (axis.x * axis.y * k) + axis.z, (axis.y * axis.y * k) + cosA, (axis.z * axis.y * k) - axis.x,
              (axis.x * axis.z * k) - axis.y, (axis.y * axis.z * k) + axis.x, (axis.z * axis.z * k) + cosA);
  return matrix;
}

float computeLAO(vec3 posIS, float op, vec3 lightDir, vec4 normal){
  // apply LAO only at selected locations, otherwise return full brightness
  if (normal.w > 0.0 && op > 0.05){
    float total_transmittance = 0.0;
    mat3 inverseRotateBasis = inverse(zBaseRotationalMatrix(normalize(-normal.xyz)));
    vec3 currPos, randomDirStep;
    float weight, transmittance, opacity;
    for (int i = 0; i < kernelSize; i++)
    {
      randomDirStep = inverseRotateBasis * sample_direction_uniform(i) * sampleDistanceIS;
      weight = 1.0 - dot(normalize(lightDir), normalize(randomDirStep));
      currPos = posIS;
      transmittance = 1.0;
      for (int j = 0; j < kernelRadius ; j++){
        currPos += randomDirStep;
        // check if it's at clipping plane, if so return full brightness
        if (all(greaterThan(currPos, vec3(EPSILON))) && all(lessThan(currPos,vec3(1.0-EPSILON)))){
          opacity = texture2D(otexture, vec2(getTextureValue(currPos).r * oscale0 + oshift0, 0.5)).r;
          #ifdef vtkGradientOpacityOn
             opacity *= computeGradientOpacityFactor(normal.w, goscale0, goshift0, gomin0, gomax0);
          #endif
          transmittance *= 1.0 - opacity;
        }
        else{
          break;
        }
      }
      total_transmittance += transmittance / float(kernelRadius) * weight;

      // early termination if fully translucent
      if (total_transmittance > 1.0 - EPSILON){
        return 1.0;
      }
    }
    // average transmittance and reduce variance
    return clamp(total_transmittance / float(kernelSize), 0.3, 1.0);
  } else {
    return 1.0;
  }
}
#endif

//=======================================================================
// surface light contribution
#if vtkLightComplexity > 0
  void applyLighting(inout vec3 tColor, vec4 normal)
  {
    vec3 diffuse = vec3(0.0, 0.0, 0.0);
    vec3 specular = vec3(0.0, 0.0, 0.0);
    float df, sf = 0.0;
    for (int i = 0; i < lightNum; i++){
        df = abs(dot(normal.rgb, -lightDirectionVC[i]));
        diffuse += df * lightColor[i];
        sf = pow( abs(dot(lightHalfAngleVC[i],normal.rgb)), vSpecularPower);
        specular += sf * lightColor[i];
    }
    tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
  }
  #ifdef SurfaceShadowOn
  #if vtkLightComplexity < 3
    vec3 applyLightingDirectional(vec3 posIS, vec4 tColor, vec4 normal)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float ndotL,vdotR;
        vertLightDirection = lightDirectionVC[i];
        ndotL = dot(normal.xyz, vertLightDirection);
        if (ndotL < 0.0 && twoSidedLighting)
        {
          ndotL = -ndotL;
        }
        if (ndotL > 0.0)
        {
          diffuse += ndotL * lightColor[i];
          //specular
          vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
          if (vdotR > 0.0)
          {
            specular += pow(vdotR, vSpecularPower) * lightColor[i];
          }
        }
        #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
        #endif
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #else
    vec3 applyLightingPositional(vec3 posIS, vec4 tColor, vec4 normal, vec3 posVC)
    {
      // everything in VC
      vec3 diffuse = vec3(0.0);
      vec3 specular = vec3(0.0);
      #ifdef localAmbientOcclusionOn
        vec3 ambient = vec3(0.0);
      #endif
      vec3 vertLightDirection;
      for (int i = 0; i < lightNum; i++){
        float distance,attenuation,ndotL,vdotR;
        vec3 lightDir;
        if (lightPositional[i] == 1){
          lightDir = lightDirectionVC[i];
          vertLightDirection = posVC - lightPositionVC[i];
          distance = length(vertLightDirection);
          vertLightDirection = normalize(vertLightDirection);
          attenuation = 1.0 / (lightAttenuation[i].x
                              + lightAttenuation[i].y * distance
                              + lightAttenuation[i].z * distance * distance);
          // per OpenGL standard cone angle is 90 or less for a spot light
          if (lightConeAngle[i] <= 90.0){
            float coneDot = dot(vertLightDirection, lightDir);
            if (coneDot >= cos(radians(lightConeAngle[i]))){  // if inside cone
              attenuation = attenuation * pow(coneDot, lightExponent[i]);
            }
            else {
              attenuation = 0.0;
            }
          }
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * attenuation * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * attenuation * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        } else {
          vertLightDirection = lightDirectionVC[i];
          ndotL = dot(normal.xyz, vertLightDirection);
          if (ndotL < 0.0 && twoSidedLighting)
          {
            ndotL = -ndotL;
          }
          if (ndotL > 0.0)
          {
            diffuse += ndotL * lightColor[i];
            //specular
            vdotR = dot(-rayDirVC, normalize(2.0 * ndotL * -normal.xyz + vertLightDirection));
            if (vdotR > 0.0)
            {
              specular += pow(vdotR, vSpecularPower) * lightColor[i];
            }
          }
          #ifdef localAmbientOcclusionOn
            ambient += computeLAO(posIS, tColor.a, vertLightDirection, normal);
          #endif
        }
      }
      #ifdef localAmbientOcclusionOn
        return tColor.rgb * (diffuse * vDiffuse + vAmbient * ambient) + specular*vSpecular;
      #else
        return tColor.rgb * (diffuse * vDiffuse + vAmbient) + specular*vSpecular;
      #endif
    }
  #endif
  #endif
#endif

// LAO of surface shadows and volume shadows only work with dependent components
vec3 applyAllLightning(vec3 tColor, float alpha, vec3 posIS, vec4 normalLight) {
  #if vtkLightComplexity > 0
    // surface shadows if needed
    #ifdef SurfaceShadowOn
      #if vtkLightComplexity < 3
        vec3 tColorS = applyLightingDirectional(posIS, vec4(tColor, alpha), normalLight);
      #else
        vec3 tColorS = applyLightingPositional(posIS, vec4(tColor, alpha), normalLight, IStoVC(posIS));
      #endif
    #endif

    // volume shadows if needed
    #ifdef VolumeShadowOn
      vec3 tColorVS = applyShadowRay(tColor, posIS, rayDirVC);
    #endif

    // merge
    #ifdef VolumeShadowOn
      #ifdef SurfaceShadowOn
        // surface shadows + volumetric shadows
        float vol_coef = volumetricScatteringBlending * (1.0 - alpha / 2.0) * (1.0 - atan(normalLight.w) * INV4PI);
        tColor = (1.0-vol_coef) * tColorS + vol_coef * tColorVS;
      #else
        // volumetric shadows only
        tColor = tColorVS;
      #endif
    #else
      #ifdef SurfaceShadowOn
        // surface shadows only
        tColor = tColorS;
      #else
        // no shadows
        applyLighting(tColor, normal3);
      #endif
    #endif
  #endif
  return tColor;
}

  
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{

// If labeloutline and not the edge labelmap, since in the edge labelmap blend
// we need the underlying data to sample through
#if defined(vtkImageLabelOutlineOn) && !defined(vtkLabelEdgeProjectionOn)
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  int segmentIndex = int(centerValue.r * 255.0);
  
  // Use texture sampling for outlineThickness
  float textureCoordinate = float(segmentIndex - 1) / 1024.0;
  float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

  int actualThickness = int(textureValue * 255.0);


  // If it is the background (segment index 0), we should quickly bail out. 
  // Previously, this was determined by tColor.a, which was incorrect as it
  // prevented the outline from appearing when the fill is 0.
  if (segmentIndex == 0){
    return vec4(0, 0, 0, 0);
  }

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  for (int i = -actualThickness; i <= actualThickness; i++) {
    for (int j = -actualThickness; j <= actualThickness; j++) {
      if (i == 0 || j == 0) {
        continue;
      }

      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
        gl_FragCoord.y + float(j),
        gl_FragCoord.z, gl_FragCoord.w);

      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
      vec4 value = getTextureValue(neighborPosIS);

      // If any of my neighbours are not the same value as I
      // am, this means I am on the border of the segment.
      // We can break the loops
      if (any(notEqual(value, centerValue))) {
        pixelOnBorder = true;
        break;
      }
    }

    if (pixelOnBorder == true) {
      break;
    }
  }

  // If I am on the border, I am displayed at full opacity
  if (pixelOnBorder == true) {
    tColor.a = outlineOpacity;
  }

  return tColor;

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4

  #ifdef UseIndependentComponents

    // sample textures
    vec3 tColor0 = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;

    #if vtkNumComponents > 1
      vec3 tColor1 = texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
      float pwfValue1 = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;

      #if vtkNumComponents > 2
        vec3 tColor2 = texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
        float pwfValue2 = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;

        #if vtkNumComponents > 3
          vec3 tColor3 = texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
          float pwfValue3 = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #endif
      #endif
    #endif

    #if !defined(vtkCustomComponentsColorMix)
      // default path for component color mix

      // compute the normal vectors as needed
      #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #endif

      // compute gradient opacity factors as needed
      vec4 goFactor = vec4(1.0, 1.0 ,1.0 ,1.0);
      #if defined(vtkGradientOpacityOn)
        #if !defined(vtkComponent0Proportional)
          goFactor.x =
            computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
        #endif
        #if vtkNumComponents > 1
          #if !defined(vtkComponent1Proportional)
            goFactor.y =
              computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          #endif
          #if vtkNumComponents > 2
            #if !defined(vtkComponent2Proportional)
              goFactor.z =
                computeGradientOpacityFactor(normalMat[2].a, goscale2, goshift2, gomin2, gomax2);
            #endif
            #if vtkNumComponents > 3
              #if !defined(vtkComponent3Proportional)
                goFactor.w =
                  computeGradientOpacityFactor(normalMat[3].a, goscale3, goshift3, gomin3, gomax3);
              #endif
            #endif
          #endif
        #endif
      #endif

      // process color and opacity for each component
      #if !defined(vtkComponent0Proportional)
        float alpha = goFactor.x*mix0*pwfValue0;
        #if vtkLightComplexity > 0
          applyLighting(tColor0, normalMat[0]);
        #endif
      #else
        tColor0 *= pwfValue0;
        float alpha = mix(pwfValue0, 1.0, (1.0 - mix0));
      #endif

      #if vtkNumComponents > 1
        #if !defined(vtkComponent1Proportional)
          alpha += goFactor.y*mix1*pwfValue1;
          #if vtkLightComplexity > 0
            applyLighting(tColor1, normalMat[1]);
          #endif
        #else
          tColor1 *= pwfValue1;
          alpha *= mix(pwfValue1, 1.0, (1.0 - mix1));
        #endif

        #if vtkNumComponents > 2
          #if !defined(vtkComponent2Proportional)
            alpha += goFactor.z*mix2*pwfValue2;
            #if vtkLightComplexity > 0
              applyLighting(tColor2, normalMat[2]);
            #endif
          #else
            tColor2 *= pwfValue2;
            alpha *= mix(pwfValue2, 1.0, (1.0 - mix2));
          #endif
        #endif

        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            alpha += goFactor.w*mix3*pwfValue3;
            #if vtkLightComplexity > 0
              applyLighting(tColor3, normalMat[3]);
            #endif
          #else
            tColor3 *= pwfValue3;
            alpha *= mix(pwfValue3, 1.0, (1.0 - mix3));
          #endif
        #endif
      #endif

      // perform final independent blend
      vec3 tColor = mix0 * tColor0;
      #if vtkNumComponents > 1
        tColor += mix1 * tColor1;
        #if vtkNumComponents > 2
          tColor += mix2 * tColor2;
          #if vtkNumComponents > 3
            tColor += mix3 * tColor3;
          #endif
        #endif
      #endif

      return vec4(tColor, alpha);
    #else
      /*
       * Mix the color information from all the independent components to get a single rgba output
       * Gradient opactity factors and normals are not computed
       *
       * You can compute these using:
       * - computeMat4Normal: always available, compute normal only for non proportional components, used by default independent component mix
       * - computeDensityNormal & computeNormalForDensity: available if ((LightComplexity > 0) || GradientOpacityOn) && ComputeNormalFromOpacity),
       *                                                   used by dependent component color mix, see code for Additive preset in OpenGl/VolumeMapper
       * - computeGradientOpacityFactor: always available, used in a lot of places
       *
       * Using applyAllLightning() is advised for shading but some features don't work well with it (volume shadows, LAO)
       * mix0, mix1, ... are defined for each component that is used and correspond to the componentWeight
       */
      //VTK::CustomComponentsColorMix::Impl
    #endif
  #else
    // dependent components

    // compute normal if needed
    #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
      // use component 3 of the opacity texture as getTextureValue() sets alpha to the opacity value
      #ifdef vtkComputeNormalFromOpacity
        vec3 scalarInterp[2];
        vec4 normal0 = computeNormalForDensity(posIS, tstep, scalarInterp, 3);
      #else
        vec4 normal0 = computeNormal(posIS, tstep);
      #endif
    #endif

    // compute gradient opacity factor enabled
    #if defined(vtkGradientOpacityOn)
      float gradientOpacity = computeGradientOpacityFactor(normal0.a, goscale0, goshift0, gomin0, gomax0);
    #else
      const float gradientOpacity = 1.0;
    #endif

    // get color and opacity
    #if vtkNumComponents == 1
      vec3 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5)).rgb;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      if (alpha < EPSILON){
        return vec4(0.0);
      }
    #endif
    #if vtkNumComponents == 2
      vec3 tColor = vec3(tValue.r * cscale0 + cshift0);
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    #endif
    #if vtkNumComponents == 3
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
    #endif
    #if vtkNumComponents == 4
      vec3 tColor;
      tColor.r = tValue.r * cscale0 + cshift0;
      tColor.g = tValue.g * cscale1 + cshift1;
      tColor.b = tValue.b * cscale2 + cshift2;
      float alpha = gradientOpacity*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
    #endif

    // lighting
    #if (vtkLightComplexity > 0)
      #ifdef vtkComputeNormalFromOpacity
        vec4 normalLight;
        if (!all(equal(normal0, vec4(0.0)))) {
          scalarInterp[0] = scalarInterp[0] * oscale0 + oshift0;
          scalarInterp[1] = scalarInterp[1] * oscale0 + oshift0;
          normalLight = computeDensityNormal(scalarInterp, 0.5, gradientOpacity);
          if (all(equal(normalLight, vec4(0.0)))) {
            normalLight = normal0;
          }
        }
      #else
        vec4 normalLight = normal0;
      #endif
      tColor = applyAllLightning(tColor, alpha, posIS, normalLight);
    #endif

    return vec4(tColor, alpha);
  #endif // dependent
#endif
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #else
    #ifdef UseIndependentComponents
      #if vtkNumComponents == 2
        if (val.r >= min.r && val.r <= max.r &&
            val.g >= min.g && val.g <= max.g) {
          withinRange = true;
        }
      #else
        if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
            all(lessThanEqual(val, ipScalarRangeMax))) {
          withinRange = true;
        }
      #endif
    #endif
  #endif
  return withinRange;
}

#if vtkBlendMode == 6 
bool checkOnEdgeForNeighbor(int i, int j, int s, vec3 stepIS) {
    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j), gl_FragCoord.z, gl_FragCoord.w);
    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);

    bool justSawIt = false;

    vec3 neighborPosIS = originalNeighborPosIS;

    float stepsTraveled = 0.0;


    // float neighborValue;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS += stepIS;
    }

    if (justSawIt){
      return false;
    }

   
    neighborPosIS = originalNeighborPosIS;
    for (int k = 0; k < //VTK::MaximumSamplesValue /2 ; ++k) {
        ivec3 texCoord = ivec3(neighborPosIS * vec3(volumeDimensions));
        vec4 texValue = texelFetch(texture1, texCoord, 0);

        if (int(texValue.g) == s) {
            justSawIt = true;
            break;
        }
        neighborPosIS -= stepIS;
    }


    if (!justSawIt) {
        // onedge
        vec3 tColorSegment = texture2D(ctexture, vec2(float(s) * cscale1 + cshift1, height1)).rgb;
        float pwfValueSegment = texture2D(otexture, vec2(float(s) * oscale1 + oshift1, height1)).r;
        gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);
        return true;
    }

    // not on edge
    return false;
}

#endif


//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // Initialize arrays to false
  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);
  
  #if vtkBlendMode == 6 
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);
    vec3 maxPosIS = posIS; // Store the position of the max value
    int segmentIndex = int(value.g);
    bool originalPosHasSeenNonZero = false;

    uint bitmask = 0u;

    if (segmentIndex != 0) {
      // Tried using the segment index in an boolean array but reading 
      // from the array by dynamic indexing was horrondously slow
      // so use bit masking instead and assign 1 to the bit corresponding to the segment index
      // and later check if the bit is set via bit operations
      setBit(segmentIndex);
    }
    
    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);
      segmentIndex = int(tValue.g);

      if (segmentIndex != 0) {
        originalPosHasSeenNonZero = true;
        setBit(segmentIndex);
      }

      if (tValue.r > value.r) {
        value =  tValue; // Update the max value
        maxPosIS = posIS; // Update the position where max occurred
      }

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);

    if (tValue.r > value.r) {
      value = tValue; // Update the max value
      maxPosIS = posIS; // Update the position where max occurred
    }  

    // If we have not seen any non-zero segments, we can return early
    // and grab color from the actual center value first component (image)
    if (!originalPosHasSeenNonZero) {
      gl_FragData[0] = getColorForValue(value, maxPosIS, tstep);
      return;
    }

    // probably we can make this configurable but for now we will use the same
    // sample distance as the original sample distance
    float neighborSampleDistanceIS = sampleDistanceIS;

    vec3 neighborRayStepsIS = stepIS;
    float neighborRaySteps = raySteps;
    bool shouldLookInAllNeighbors = false;

    float minVoxelSpacing = min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));
    vec4 base = vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);

    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);
    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z, gl_FragCoord.w);

    vec3 baseWorld = fragCoordToWorld(base);
    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);
    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);

    float XPlusDiff = length(baseXPlusWorld - baseWorld);
    float YPlusDiff = length(baseYPlusWorld - baseWorld);

    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);

    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {
      // bail out quickly if the segment index has not 
      // been seen by the center segment
      if (!isBitSet(s)) {
       continue;
      }

      // Use texture sampling for outlineThickness so that we can have 
      // per segment thickness
      float textureCoordinate = float(s - 1) / 1024.0;
      float textureValue = texture2D(ttexture, vec2(textureCoordinate, 0.5)).r;

      int actualThickness = int(textureValue * 255.0);

      // check the extreme points in the neighborhood since there is a better
      // chance of finding the edge there, so that we can bail out 
      // faster if we find the edge
      bool onEdge =
          checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(actualThickness, -actualThickness, s, stepIS) ||
          checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s, stepIS);

      if (onEdge) {
        return;
      }

      // since the next step is computationally expensive, we need to perform
      // some optimizations to avoid it if possible. One of the optimizations
      // is to check the whether the minimum of the voxel spacing is greater than 
      // the 2 * the thickness of the outline segment. If that is the case
      // then we can safely skip the next step since we can be sure that the
      // the previous 4 checks on the extreme points would caught the entirety 
      // of the all the fragments inside. i.e., this happens when we zoom out, 
      if (minVoxelSpacing > (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {
        continue;
      }
      
      // Loop through the rest, skipping the processed extremes and the center
      for (int i = -actualThickness; i <= actualThickness; i++) {
            for (int j = -actualThickness; j <= actualThickness; j++) {
                if (i == 0 && j == 0) continue; // Skip the center
                if (abs(i) == actualThickness && abs(j) == actualThickness) continue; // Skip corners
                if (checkOnEdgeForNeighbor(i, j, s, stepIS )) {
                    return;
                }
          }
      }
    }

    vec3 tColor0 = texture2D(ctexture, vec2(value.r * cscale0 + cshift0, height0)).rgb;
    float pwfValue0 = texture2D(otexture, vec2(value.r * oscale0 + oshift0, height0)).r;
    gl_FragData[0] = vec4(tColor0, pwfValue0);
  #endif
  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
  #if vtkBlendMode == 5 // RADON
    float normalizedRayIntensity = 1.0;

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tValue = getTextureValue(posIS);
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
      gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity, 0.5));
      return;
    }

    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar value
      tValue = getTextureValue(posIS);

      // Convert scalar value to normalizedRayIntensity coefficient and accumulate normalizedRayIntensity
      normalizedRayIntensity = normalizedRayIntensity - sampleDistance*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;

      posIS += stepIS;
      stepsTraveled++;
    }

    // map normalizedRayIntensity to color
    gl_FragData[0] = texture2D(ctexture, vec2(normalizedRayIntensity , 0.5));

  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
  #ifdef VolumeShadowOn
    sampleDistanceISVS = sampleDistanceIS * volumeShadowSamplingDistFactor;
  #endif
}

void main()
{

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  computeIndexSpaceValues(posIS, endIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, tdims);
}
`;
    const { vtkWarningMacro: pF, vtkErrorMacro: v5 } = da;
    function mF(t) {
        switch(t){
            case ch.CUSTOM:
                return "//VTK::CustomColorMix";
            case ch.ADDITIVE:
                return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);

          vec3 scalarInterp1[2];
          vec4 normalLight1 = computeNormalForDensity(posIS, tstep, scalarInterp1, 1);
          scalarInterp1[0] = scalarInterp1[0] * oscale1 + oshift1;
          scalarInterp1[1] = scalarInterp1[1] * oscale1 + oshift1;
          normalLight1 = computeDensityNormal(scalarInterp1, height1, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
          vec4 normalLight1 = normalMat[1];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        float opacity1 = pwfValue1;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
          float gof1 = computeGradientOpacityFactor(normalMat[1].a, goscale1, goshift1, gomin1, gomax1);
          opacity1 *= gof1;
        #endif
        float opacitySum = opacity0 + opacity1;
        if (opacitySum <= 0.0) {
          return vec4(0.0);
        }

        // mix the colors and opacities
        tColor0 = applyAllLightning(tColor0, opacity0, posIS, normalLight0);
        tColor1 = applyAllLightning(tColor1, opacity1, posIS, normalLight1);
        vec3 mixedColor = (opacity0 * tColor0 + opacity1 * tColor1) / opacitySum;
        return vec4(mixedColor, min(1.0, opacitySum));
`;
            case ch.COLORIZE:
                return `
        // compute normals
        mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
        #if (vtkLightComplexity > 0) && defined(vtkComputeNormalFromOpacity)
          vec3 scalarInterp0[2];
          vec4 normalLight0 = computeNormalForDensity(posIS, tstep, scalarInterp0, 0);
          scalarInterp0[0] = scalarInterp0[0] * oscale0 + oshift0;
          scalarInterp0[1] = scalarInterp0[1] * oscale0 + oshift0;
          normalLight0 = computeDensityNormal(scalarInterp0, height0, 1.0);
        #else
          vec4 normalLight0 = normalMat[0];
        #endif

        // compute opacities
        float opacity0 = pwfValue0;
        #ifdef vtkGradientOpacityOn
          float gof0 = computeGradientOpacityFactor(normalMat[0].a, goscale0, goshift0, gomin0, gomax0);
          opacity0 *= gof0;
        #endif

        // mix the colors and opacities
        vec3 color = tColor0 * mix(vec3(1.0), tColor1, pwfValue1);
        color = applyAllLightning(color, opacity0, posIS, normalLight0);
        return vec4(color, opacity0);
`;
            default:
                return null;
        }
    }
    function vF(t, e) {
        e.classHierarchy.push("vtkOpenGLVolumeMapper");
        function n(i) {
            [
                e._scalars,
                e._scalarOpacityFunc,
                e._colorTransferFunc,
                e._labelOutlineThicknessArray
            ].forEach((a)=>i.unregisterGraphicsResourceUser(a, t));
        }
        t.buildPass = ()=>{
            e.zBufferTexture = null;
        }, t.zBufferPass = (i, a)=>{
            if (i) {
                const o = a.getZBufferTexture();
                o !== e.zBufferTexture && (e.zBufferTexture = o);
            }
        }, t.opaqueZBufferPass = (i, a)=>t.zBufferPass(i, a), t.volumePass = (i, a)=>{
            if (i) {
                const o = e._openGLRenderWindow;
                e._openGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), o && !o.isDeleted() && o !== e._openGLRenderWindow && n(o), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow), e.jitterTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLVolume = t.getFirstAncestorOfType("vtkOpenGLVolume");
                const s = e.openGLVolume.getRenderable();
                e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer");
                const c = e._openGLRenderer.getRenderable();
                e.openGLCamera = e._openGLRenderer.getViewNodeFor(c.getActiveCamera()), t.renderPiece(c, s);
            }
        }, t.getShaderTemplate = (i, a, o)=>{
            i.Vertex = gF, i.Fragment = hF, i.Geometry = "";
        }, t.useIndependentComponents = (i)=>{
            const a = i.getIndependentComponents(), s = e.currentInput?.getPointData()?.getScalars()?.getNumberOfComponents(), c = i.getColorMixPreset();
            return a && s >= 2 || !!c;
        }, t.replaceShaderValues = (i, a, o)=>{
            const s = o.getProperty();
            let c = i.Fragment;
            s.getInterpolationType() === Lv.LINEAR && (c = Te.substitute(c, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result), t.isLabelmapOutlineRequired(o) === !0 && (c = Te.substitute(c, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result), e.renderable.getBlendMode() === H1.LABELMAP_EDGE_PROJECTION_BLEND && (c = Te.substitute(c, "//VTK::LabelEdgeProjectionOn", "#define vtkLabelEdgeProjectionOn").result);
            const g = e.scalarTexture.getComponents();
            c = Te.substitute(c, "//VTK::NumComponents", `#define vtkNumComponents ${g}`).result;
            const h = t.useIndependentComponents(s);
            h && (c = Te.substitute(c, "//VTK::IndependentComponentsOn", "#define UseIndependentComponents").result);
            const v = [], m = [];
            for(let M = 0; M < g; M++)s.getOpacityMode(M) === aS.PROPORTIONAL && v.push(`#define vtkComponent${M}Proportional`), s.getForceNearestInterpolation(M) && m.push(`#define vtkComponent${M}ForceNearest`);
            c = Te.substitute(c, "//VTK::vtkProportionalComponents", v.join(`
`)).result, c = Te.substitute(c, "//VTK::vtkForceNearestComponents", m.join(`
`)).result;
            const y = s.getColorMixPreset(), C = mF(y);
            C && (c = Te.substitute(c, "//VTK::CustomComponentsColorMixOn", "#define vtkCustomComponentsColorMix").result, c = Te.substitute(c, "//VTK::CustomComponentsColorMix::Impl", C).result);
            const T = e.currentInput.getSpatialExtent(), x = e.currentInput.getSpacing(), S = new Float64Array(3);
            Sn(S, (T[1] - T[0]) * x[0], (T[3] - T[2]) * x[1], (T[5] - T[4]) * x[2]);
            const D = Xa(S) / t.getCurrentSampleDistance(a);
            c = Te.substitute(c, "//VTK::MaximumSamplesValue", `${Math.ceil(D)}`).result, c = Te.substitute(c, "//VTK::LightComplexity", `#define vtkLightComplexity ${e.lightComplexity}`).result, e.lightComplexity > 0 && (e.renderable.getVolumetricScatteringBlending() > 0 && (c = Te.substitute(c, "//VTK::VolumeShadowOn", "#define VolumeShadowOn").result), e.renderable.getVolumetricScatteringBlending() < 1 && (c = Te.substitute(c, "//VTK::SurfaceShadowOn", "#define SurfaceShadowOn").result), e.renderable.getLocalAmbientOcclusion() && s.getAmbient() > 0 && (c = Te.substitute(c, "//VTK::localAmbientOcclusionOn", "#define localAmbientOcclusionOn").result));
            const _ = h ? g : 1;
            e.gopacity = !1;
            for(let M = 0; !e.gopacity && M < _; ++M)e.gopacity ||= s.getUseGradientOpacity(M);
            e.gopacity && (c = Te.substitute(c, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result), e.renderable.getComputeNormalFromOpacity() && (c = Te.substitute(c, "//VTK::vtkComputeNormalFromOpacity", "#define vtkComputeNormalFromOpacity").result), e.zBufferTexture !== null && (c = Te.substitute(c, "//VTK::ZBuffer::Dec", [
                "uniform sampler2D zBufferTexture;",
                "uniform float vpZWidth;",
                "uniform float vpZHeight;"
            ]).result, c = Te.substitute(c, "//VTK::ZBuffer::Impl", [
                "vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));",
                "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;",
                "zdepth = zdepth * 2.0 - 1.0;",
                "if (cameraParallel == 0) {",
                "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}",
                "else {",
                `zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}
`,
                "zdepth = -zdepth/rayDir.z;",
                "dists.y = min(zdepth,dists.y);"
            ]).result), c = Te.substitute(c, "//VTK::BlendMode", `${e.renderable.getBlendMode()}`).result, i.Fragment = c, t.replaceShaderLight(i, a, o), t.replaceShaderClippingPlane(i, a, o);
        }, t.replaceShaderLight = (i, a, o)=>{
            if (e.lightComplexity === 0) return;
            let s = i.Fragment, c = 0;
            a.getLights().forEach((l)=>{
                l.getSwitch() && (c += 1);
            }), s = Te.substitute(s, "//VTK::Light::Dec", [
                "uniform int lightNum;",
                "uniform bool twoSidedLighting;",
                `uniform vec3 lightColor[${c}];`,
                `uniform vec3 lightDirectionVC[${c}]; // normalized`,
                `uniform vec3 lightHalfAngleVC[${c}];`,
                "//VTK::Light::Dec"
            ], !1).result, e.lightComplexity === 3 && (s = Te.substitute(s, "//VTK::Light::Dec", [
                `uniform vec3 lightPositionVC[${c}];`,
                `uniform vec3 lightAttenuation[${c}];`,
                `uniform float lightConeAngle[${c}];`,
                `uniform float lightExponent[${c}];`,
                `uniform int lightPositional[${c}];`
            ], !1).result), e.renderable.getVolumetricScatteringBlending() > 0 && (s = Te.substitute(s, "//VTK::VolumeShadow::Dec", [
                "uniform float volumetricScatteringBlending;",
                "uniform float giReach;",
                "uniform float volumeShadowSamplingDistFactor;",
                "uniform float anisotropy;",
                "uniform float anisotropy2;"
            ], !1).result), e.renderable.getLocalAmbientOcclusion() && o.getProperty().getAmbient() > 0 && (s = Te.substitute(s, "//VTK::LAO::Dec", [
                "uniform int kernelRadius;",
                `uniform vec2 kernelSample[${e.renderable.getLAOKernelRadius()}];`,
                "uniform int kernelSize;"
            ], !1).result), i.Fragment = s;
        }, t.replaceShaderClippingPlane = (i, a, o)=>{
            let s = i.Fragment;
            if (e.renderable.getClippingPlanes().length > 0) {
                const c = e.renderable.getClippingPlanes().length;
                s = Te.substitute(s, "//VTK::ClipPlane::Dec", [
                    "uniform vec3 vClipPlaneNormals[6];",
                    "uniform float vClipPlaneDistances[6];",
                    "uniform vec3 vClipPlaneOrigins[6];",
                    "uniform int clip_numPlanes;",
                    "//VTK::ClipPlane::Dec",
                    "#define vtkClippingPlanesOn"
                ], !1).result, s = Te.substitute(s, "//VTK::ClipPlane::Impl", [
                    `for(int i = 0; i < ${c}; i++) {`,
                    "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);",
                    "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];",
                    "  if (rayDirRatio == 0.0)",
                    "  {",
                    "    if (equationResult < 0.0) dists.x = dists.y;",
                    "    continue;",
                    "  }",
                    "  float result = -1.0 * equationResult / rayDirRatio;",
                    "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);",
                    "  else dists.x = max(dists.x, result);",
                    "}",
                    "//VTK::ClipPlane::Impl"
                ], !1).result;
            }
            i.Fragment = s;
        };
        const r = (i, a)=>{
            let o = 0;
            i.getProperty().getShade() && e.renderable.getBlendMode() === H1.COMPOSITE_BLEND && (o = 0, e.numberOfLights = 0, a.forEach((s)=>{
                s.getSwitch() > 0 && (e.numberOfLights++, o === 0 && (o = 1)), o === 1 && (e.numberOfLights > 1 || s.getIntensity() !== 1 || !s.lightTypeIsHeadLight()) && (o = 2), o < 3 && s.getPositional() && (o = 3);
            })), o !== e.lightComplexity && (e.lightComplexity = o, t.modified());
        };
        t.getNeedToRebuildShaders = (i, a, o)=>{
            const s = o.getProperty();
            r(o, a.getLights());
            const c = e.scalarTexture.getComponents(), l = [], f = [];
            for(let C = 0; C < c; C++)l.push(s.getOpacityMode(C)), f.push(s.getForceNearestInterpolation(C));
            const u = e.currentInput.getSpatialExtent(), g = e.currentInput.getSpacing(), h = new Float64Array(3);
            Sn(h, (u[1] - u[0]) * g[0], (u[3] - u[2]) * g[1], (u[5] - u[4]) * g[2]);
            const v = Xa(h) / t.getCurrentSampleDistance(a), m = !!e.zBufferTexture, y = {
                iComps: s.getIndependentComponents(),
                colorMixPreset: s.getColorMixPreset(),
                interpolationType: s.getInterpolationType(),
                useLabelOutline: t.isLabelmapOutlineRequired(o),
                numComp: c,
                maxSamples: v,
                useGradientOpacity: s.getUseGradientOpacity(0),
                blendMode: e.renderable.getBlendMode(),
                hasZBufferTexture: m,
                opacityModes: l,
                forceNearestInterps: f
            };
            return i.getProgram()?.getHandle() === 0 || i.getShaderSourceTime().getMTime() < t.getMTime() || i.getShaderSourceTime().getMTime() < e.renderable.getMTime() || !e.previousState || !h3(e.previousState, y) ? (e.previousState = y, !0) : !1;
        }, t.updateShaders = (i, a, o)=>{
            if (t.getNeedToRebuildShaders(i, a, o)) {
                const s = {
                    Vertex: null,
                    Fragment: null,
                    Geometry: null
                };
                t.buildShaders(s, a, o);
                const c = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(s.Vertex, s.Fragment, s.Geometry);
                c !== i.getProgram() && (i.setProgram(c), i.getVAO().releaseGraphicsResources()), i.getShaderSourceTime().modified();
            } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(i.getProgram());
            i.getVAO().bind(), t.setMapperShaderParameters(i, a, o), t.setCameraShaderParameters(i, a, o), t.setPropertyShaderParameters(i, a, o), t.getClippingPlaneShaderParameters(i, a, o);
        }, t.setMapperShaderParameters = (i, a, o)=>{
            const s = i.getProgram();
            i.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > i.getAttributeUpdateTime().getMTime() || i.getShaderSourceTime().getMTime() > i.getAttributeUpdateTime().getMTime()) && (s.isAttributeUsed("vertexDC") && (i.getVAO().addAttributeArray(s, i.getCABO(), "vertexDC", i.getCABO().getVertexOffset(), i.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || v5("Error setting vertexDC in shader VAO.")), i.getAttributeUpdateTime().modified()), s.setUniformi("texture1", e.scalarTexture.getTextureUnit()), s.setUniformf("sampleDistance", t.getCurrentSampleDistance(a));
            const c = e.scalarTexture.getVolumeInfo(), l = e.renderable.getIpScalarRange();
            if (c?.dataComputedScale?.length) {
                const f = [], u = [];
                for(let g = 0; g < 4; g++)f[g] = l[0] * c.dataComputedScale[g] + c.dataComputedOffset[g], u[g] = l[1] * c.dataComputedScale[g] + c.dataComputedOffset[g], f[g] = (f[g] - c.offset[g]) / c.scale[g], u[g] = (u[g] - c.offset[g]) / c.scale[g];
                s.setUniform4f("ipScalarRangeMin", f[0], f[1], f[2], f[3]), s.setUniform4f("ipScalarRangeMax", u[0], u[1], u[2], u[3]);
            }
            if (e.zBufferTexture !== null) {
                s.setUniformi("zBufferTexture", e.zBufferTexture.getTextureUnit());
                const f = e._useSmallViewport ? [
                    e._smallViewportWidth,
                    e._smallViewportHeight
                ] : e._openGLRenderWindow.getFramebufferSize();
                s.setUniformf("vpZWidth", f[0]), s.setUniformf("vpZHeight", f[1]);
            }
        }, t.setCameraShaderParameters = (i, a, o)=>{
            const s = e.openGLCamera.getKeyMatrices(a), c = e.openGLVolume.getKeyMatrices();
            Qt(e.modelToView, s.wcvc, c.mcwc);
            const l = i.getProgram(), f = e.openGLCamera.getRenderable(), u = f.getClippingRange();
            l.setUniformf("camThick", u[1] - u[0]), l.setUniformf("camNear", u[0]), l.setUniformf("camFar", u[1]);
            const g = e.currentInput.getBounds(), h = e.currentInput.getDimensions(), v = new Float64Array(3), m = new Float64Array(3);
            let y = 1, C = -1, T = 1, x = -1;
            for(let ae = 0; ae < 8; ++ae){
                if (Sn(v, g[ae % 2], g[2 + Math.floor(ae / 2) % 2], g[4 + Math.floor(ae / 4)]), pn(v, v, e.modelToView), !f.getParallelProjection()) {
                    jn(m, v);
                    const ue = -u[0] / v[2];
                    Ys(v, m, ue);
                }
                pn(v, v, s.vcpc), y = Math.min(v[0], y), C = Math.max(v[0], C), T = Math.min(v[1], T), x = Math.max(v[1], x);
            }
            l.setUniformf("dcxmin", y), l.setUniformf("dcxmax", C), l.setUniformf("dcymin", T), l.setUniformf("dcymax", x), l.isUniformUsed("cameraParallel") && l.setUniformi("cameraParallel", f.getParallelProjection());
            const S = e.currentInput.getSpatialExtent(), D = e.currentInput.getSpacing(), _ = new Float64Array(3);
            Sn(_, (S[1] - S[0]) * D[0], (S[3] - S[2]) * D[1], (S[5] - S[4]) * D[2]), l.setUniform3f("vSpacing", D[0], D[1], D[2]), Sn(v, S[0], S[2], S[4]), e.currentInput.indexToWorldVec3(v, v), pn(v, v, e.modelToView), l.setUniform3f("vOriginVC", v[0], v[1], v[2]);
            const M = e.currentInput.getIndexToWorld();
            Qt(e.idxToView, e.modelToView, M), Xu(e.idxNormalMatrix, s.normalMatrix, c.normalMatrix), Xu(e.idxNormalMatrix, e.idxNormalMatrix, e.currentInput.getDirectionByReference());
            const P = Xa(_) / t.getCurrentSampleDistance(a);
            P > e.renderable.getMaximumSamplesPerRay() && pF(`The number of steps required ${Math.ceil(P)} is larger than the
        specified maximum number of steps ${e.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
            const F = new Float64Array(3);
            if (Sn(F, 1, 1, 1), $V(F, F, _), l.setUniform3f("vVCToIJK", F[0], F[1], F[2]), l.setUniform3i("volumeDimensions", h[0], h[1], h[2]), l.setUniform3f("volumeSpacings", D[0], D[1], D[2]), !e._openGLRenderWindow.getWebgl2()) {
                const ae = e.scalarTexture.getVolumeInfo();
                l.setUniformf("texWidth", e.scalarTexture.getWidth()), l.setUniformf("texHeight", e.scalarTexture.getHeight()), l.setUniformi("xreps", ae.xreps), l.setUniformi("xstride", ae.xstride), l.setUniformi("ystride", ae.ystride);
            }
            const N = new Float64Array(3), B = new Float64Array(3);
            for(let ae = 0; ae < 6; ++ae){
                switch(ae){
                    case 1:
                        Sn(N, -1, 0, 0), Sn(B, S[0], S[2], S[4]);
                        break;
                    case 2:
                        Sn(N, 0, 1, 0), Sn(B, S[1], S[3], S[5]);
                        break;
                    case 3:
                        Sn(N, 0, -1, 0), Sn(B, S[0], S[2], S[4]);
                        break;
                    case 4:
                        Sn(N, 0, 0, 1), Sn(B, S[1], S[3], S[5]);
                        break;
                    case 5:
                        Sn(N, 0, 0, -1), Sn(B, S[0], S[2], S[4]);
                        break;
                    case 0:
                    default:
                        Sn(N, 1, 0, 0), Sn(B, S[1], S[3], S[5]);
                        break;
                }
                ih(N, N, e.idxNormalMatrix), pn(B, B, e.idxToView);
                const ue = -1 * xt(B, N);
                l.setUniform3f(`vPlaneNormal${ae}`, N[0], N[1], N[2]), l.setUniformf(`vPlaneDistance${ae}`, ue);
            }
            if (t.isLabelmapOutlineRequired(o)) {
                const ue = e.currentInput.getWorldToIndex();
                l.setUniformMatrix("vWCtoIDX", ue);
                const le = a.getActiveCamera(), [oe, re] = le.getClippingRange(), X = le.getDistance();
                le.setClippingRange(X, X + .1);
                const ie = e.openGLCamera.getKeyMatrices(a);
                Xr(e.projectionToWorld, ie.wcpc), le.setClippingRange(oe, re), e.openGLCamera.getKeyMatrices(a), l.setUniformMatrix("PCWCMatrix", e.projectionToWorld);
                const he = t.getRenderTargetSize();
                l.setUniformf("vpWidth", he[0]), l.setUniformf("vpHeight", he[1]);
                const $e = t.getRenderTargetOffset();
                l.setUniformf("vpOffsetX", $e[0] / he[0]), l.setUniformf("vpOffsetY", $e[1] / he[1]);
            }
            if (Xr(e.projectionToView, s.vcpc), l.setUniformMatrix("PCVCMatrix", e.projectionToView), e.lightComplexity === 0) return;
            let G = 0;
            const Z = [], H = [], ne = [];
            if (a.getLights().forEach((ae)=>{
                if (ae.getSwitch() > 0) {
                    const le = ae.getColor(), oe = ae.getIntensity();
                    Z[0 + G * 3] = le[0] * oe, Z[1 + G * 3] = le[1] * oe, Z[2 + G * 3] = le[2] * oe;
                    const re = ae.getDirection();
                    Sn(N, re[0], re[1], re[2]), ih(N, N, s.normalMatrix), jn(N, N), H[0 + G * 3] = N[0], H[1 + G * 3] = N[1], H[2 + G * 3] = N[2], ne[0 + G * 3] = -.5 * N[0], ne[1 + G * 3] = -.5 * N[1], ne[2 + G * 3] = -.5 * (N[2] - 1), G++;
                }
            }), l.setUniformi("twoSidedLighting", a.getTwoSidedLighting()), l.setUniformi("lightNum", G), l.setUniform3fv("lightColor", Z), l.setUniform3fv("lightDirectionVC", H), l.setUniform3fv("lightHalfAngleVC", ne), e.lightComplexity === 3) {
                G = 0;
                const ae = [], ue = [], le = [], oe = [], re = [];
                a.getLights().forEach((X)=>{
                    if (X.getSwitch() > 0) {
                        const he = X.getAttenuationValues();
                        ue[0 + G * 3] = he[0], ue[1 + G * 3] = he[1], ue[2 + G * 3] = he[2], oe[G] = X.getExponent(), le[G] = X.getConeAngle(), re[G] = X.getPositional();
                        const $e = X.getTransformedPosition();
                        pn($e, $e, e.modelToView), ae[0 + G * 3] = $e[0], ae[1 + G * 3] = $e[1], ae[2 + G * 3] = $e[2], G += 1;
                    }
                }), l.setUniform3fv("lightPositionVC", ae), l.setUniform3fv("lightAttenuation", ue), l.setUniformfv("lightConeAngle", le), l.setUniformfv("lightExponent", oe), l.setUniformiv("lightPositional", re);
            }
            if (e.renderable.getVolumetricScatteringBlending() > 0 && (l.setUniformf("giReach", e.renderable.getGlobalIlluminationReach()), l.setUniformf("volumetricScatteringBlending", e.renderable.getVolumetricScatteringBlending()), l.setUniformf("volumeShadowSamplingDistFactor", e.renderable.getVolumeShadowSamplingDistFactor()), l.setUniformf("anisotropy", e.renderable.getAnisotropy()), l.setUniformf("anisotropy2", e.renderable.getAnisotropy() ** 2)), e.renderable.getLocalAmbientOcclusion() && o.getProperty().getAmbient() > 0) {
                const ae = e.renderable.getLAOKernelSize();
                l.setUniformi("kernelSize", ae);
                const ue = [];
                for(let le = 0; le < ae; le++)ue[le * 2] = Math.random() * .5, ue[le * 2 + 1] = Math.random() * .5;
                l.setUniform2fv("kernelSample", ue), l.setUniformi("kernelRadius", e.renderable.getLAOKernelRadius());
            }
        }, t.setPropertyShaderParameters = (i, a, o)=>{
            const s = i.getProgram();
            s.setUniformi("ctexture", e.colorTexture.getTextureUnit()), s.setUniformi("otexture", e.opacityTexture.getTextureUnit()), s.setUniformi("jtexture", e.jitterTexture.getTextureUnit()), s.setUniformi("ttexture", e.labelOutlineThicknessTexture.getTextureUnit());
            const c = e.scalarTexture.getVolumeInfo(), l = o.getProperty(), f = e.scalarTexture.getComponents(), u = t.useIndependentComponents(l);
            if (u) for(let h = 0; h < f; h++)s.setUniformf(`mix${h}`, o.getProperty().getComponentWeight(h));
            for(let h = 0; h < f; h++){
                const v = u ? h : 0, m = c.scale[h], C = l.getScalarOpacity(v).getRange(), T = m / (C[1] - C[0]), x = (c.offset[h] - C[0]) / (C[1] - C[0]);
                s.setUniformf(`oshift${h}`, x), s.setUniformf(`oscale${h}`, T);
                const D = l.getRGBTransferFunction(v).getRange(), _ = (c.offset[h] - D[0]) / (D[1] - D[0]), M = m / (D[1] - D[0]);
                s.setUniformf(`cshift${h}`, _), s.setUniformf(`cscale${h}`, M);
            }
            if (e.gopacity) if (u) for(let h = 0; h < f; ++h){
                const v = c.scale[h];
                if (l.getUseGradientOpacity(h)) {
                    const y = l.getGradientOpacityMinimumOpacity(h), C = l.getGradientOpacityMaximumOpacity(h);
                    s.setUniformf(`gomin${h}`, y), s.setUniformf(`gomax${h}`, C);
                    const T = [
                        l.getGradientOpacityMinimumValue(h),
                        l.getGradientOpacityMaximumValue(h)
                    ];
                    s.setUniformf(`goscale${h}`, v * (C - y) / (T[1] - T[0])), s.setUniformf(`goshift${h}`, -T[0] * (C - y) / (T[1] - T[0]) + y);
                } else s.setUniformf(`gomin${h}`, 1), s.setUniformf(`gomax${h}`, 1), s.setUniformf(`goscale${h}`, 0), s.setUniformf(`goshift${h}`, 1);
            }
            else {
                const h = c.scale[f - 1], v = l.getGradientOpacityMinimumOpacity(0), m = l.getGradientOpacityMaximumOpacity(0);
                s.setUniformf("gomin0", v), s.setUniformf("gomax0", m);
                const y = [
                    l.getGradientOpacityMinimumValue(0),
                    l.getGradientOpacityMaximumValue(0)
                ];
                s.setUniformf("goscale0", h * (m - v) / (y[1] - y[0])), s.setUniformf("goshift0", -y[0] * (m - v) / (y[1] - y[0]) + v);
            }
            if (t.isLabelmapOutlineRequired(o) === !0) {
                const h = o.getProperty().getLabelOutlineOpacity();
                s.setUniformf("outlineOpacity", h);
            }
            e.lightComplexity > 0 && (s.setUniformf("vAmbient", l.getAmbient()), s.setUniformf("vDiffuse", l.getDiffuse()), s.setUniformf("vSpecular", l.getSpecular()), s.setUniformf("vSpecularPower", l.getSpecularPower()));
        }, t.getClippingPlaneShaderParameters = (i, a, o)=>{
            if (e.renderable.getClippingPlanes().length > 0) {
                const s = e.openGLCamera.getKeyMatrices(a), c = [], l = [], f = [], u = e.renderable.getClippingPlanes(), g = u.length;
                for(let v = 0; v < g; ++v){
                    const m = u[v].getNormal(), y = u[v].getOrigin();
                    ih(m, m, s.normalMatrix), pn(y, y, s.wcvc);
                    const C = -1 * xt(y, m);
                    c.push(m[0]), c.push(m[1]), c.push(m[2]), l.push(C), f.push(y[0]), f.push(y[1]), f.push(y[2]);
                }
                const h = i.getProgram();
                h.setUniform3fv("vClipPlaneNormals", c), h.setUniformfv("vClipPlaneDistances", l), h.setUniform3fv("vClipPlaneOrigins", f), h.setUniformi("clip_numPlanes", g);
            }
        }, t.delete = jd(()=>{
            e._animationRateSubscription && (e._animationRateSubscription.unsubscribe(), e._animationRateSubscription = null);
        }, ()=>{
            e._openGLRenderWindow && n(e._openGLRenderWindow);
        }, t.delete), t.getRenderTargetSize = ()=>{
            if (e._useSmallViewport) return [
                e._smallViewportWidth,
                e._smallViewportHeight
            ];
            const { usize: i, vsize: a } = e._openGLRenderer.getTiledSizeAndOrigin();
            return [
                i,
                a
            ];
        }, t.getRenderTargetOffset = ()=>{
            const { lowerLeftU: i, lowerLeftV: a } = e._openGLRenderer.getTiledSizeAndOrigin();
            return [
                i,
                a
            ];
        }, t.getCurrentSampleDistance = (i)=>{
            const a = i.getVTKWindow().getInteractor(), o = e.renderable.getSampleDistance();
            if (a.isAnimating()) {
                const s = e.renderable.getInteractionSampleDistanceFactor();
                return o * s;
            }
            return o;
        }, t.renderPieceStart = (i, a)=>{
            const o = i.getVTKWindow().getInteractor();
            if (e._lastScale || (e._lastScale = e.renderable.getInitialInteractionScale()), e._useSmallViewport = !1, o.isAnimating() && e._lastScale > 1.5 && (e._useSmallViewport = !0), e._animationRateSubscription || (e._animationRateSubscription = o.onAnimationFrameRateUpdate(()=>{
                if (e.renderable.getAutoAdjustSampleDistances()) {
                    const c = o.getRecentAnimationFrameRate(), l = o.getDesiredUpdateRate() / c;
                    (l > 1.15 || l < .85) && (e._lastScale *= l), e._lastScale > 400 && (e._lastScale = 400), e._lastScale < 1.5 && (e._lastScale = 1.5);
                } else e._lastScale = e.renderable.getImageSampleDistance() * e.renderable.getImageSampleDistance();
            })), e._useSmallViewport) {
                const c = e._openGLRenderWindow.getFramebufferSize(), l = 1 / Math.sqrt(e._lastScale);
                if (e._smallViewportWidth = Math.ceil(l * c[0]), e._smallViewportHeight = Math.ceil(l * c[1]), e._smallViewportHeight > c[1] && (e._smallViewportHeight = c[1]), e._smallViewportWidth > c[0] && (e._smallViewportWidth = c[0]), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.getGLFramebuffer() === null) e.framebuffer.create(c[0], c[1]), e.framebuffer.populateFramebuffer();
                else {
                    const u = e.framebuffer.getSize();
                    (!u || u[0] !== c[0] || u[1] !== c[1]) && (e.framebuffer.create(c[0], c[1]), e.framebuffer.populateFramebuffer());
                }
                e.framebuffer.bind();
                const f = e.context;
                f.clearColor(0, 0, 0, 0), f.colorMask(!0, !0, !0, !0), f.clear(f.COLOR_BUFFER_BIT), f.viewport(0, 0, e._smallViewportWidth, e._smallViewportHeight), e.fvp = [
                    e._smallViewportWidth / c[0],
                    e._smallViewportHeight / c[1]
                ];
            }
            e.context.disable(e.context.DEPTH_TEST), t.updateBufferObjects(i, a), a.getProperty().getInterpolationType() === Lv.NEAREST ? (e.scalarTexture.setMinificationFilter(Tt.NEAREST), e.scalarTexture.setMagnificationFilter(Tt.NEAREST)) : (e.scalarTexture.setMinificationFilter(Tt.LINEAR), e.scalarTexture.setMagnificationFilter(Tt.LINEAR)), e.zBufferTexture !== null && e.zBufferTexture.activate();
        }, t.renderPieceDraw = (i, a)=>{
            const o = e.context;
            e.scalarTexture.activate(), e.opacityTexture.activate(), e.labelOutlineThicknessTexture.activate(), e.colorTexture.activate(), e.jitterTexture.activate(), t.updateShaders(e.tris, i, a), o.drawArrays(o.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.scalarTexture.deactivate(), e.colorTexture.deactivate(), e.opacityTexture.deactivate(), e.labelOutlineThicknessTexture.deactivate(), e.jitterTexture.deactivate();
        }, t.renderPieceFinish = (i, a)=>{
            if (e.zBufferTexture !== null && e.zBufferTexture.deactivate(), e._useSmallViewport) {
                if (e.framebuffer.restorePreviousBindingsAndBuffers(), e.copyShader === null) {
                    e.copyShader = e._openGLRenderWindow.getShaderCache().readyShaderProgramArray([
                        "//VTK::System::Dec",
                        "attribute vec4 vertexDC;",
                        "uniform vec2 tfactor;",
                        "varying vec2 tcoord;",
                        "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"
                    ].join(`
`), [
                        "//VTK::System::Dec",
                        "//VTK::Output::Dec",
                        "uniform sampler2D texture1;",
                        "varying vec2 tcoord;",
                        "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"
                    ].join(`
`), "");
                    const l = e.copyShader;
                    e.copyVAO = c4.newInstance(), e.copyVAO.setOpenGLRenderWindow(e._openGLRenderWindow), e.tris.getCABO().bind(), e.copyVAO.addAttributeArray(l, e.tris.getCABO(), "vertexDC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || v5("Error setting vertexDC in copy shader VAO.");
                } else e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.copyShader);
                const o = e._openGLRenderWindow.getFramebufferSize();
                e.context.viewport(0, 0, o[0], o[1]);
                const s = e.framebuffer.getColorTexture();
                s.activate(), e.copyShader.setUniformi("texture", s.getTextureUnit()), e.copyShader.setUniform2f("tfactor", e.fvp[0], e.fvp[1]);
                const c = e.context;
                c.blendFuncSeparate(c.ONE, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA), e.context.drawArrays(e.context.TRIANGLES, 0, e.tris.getCABO().getElementCount()), s.deactivate(), c.blendFuncSeparate(c.SRC_ALPHA, c.ONE_MINUS_SRC_ALPHA, c.ONE, c.ONE_MINUS_SRC_ALPHA);
            }
        }, t.renderPiece = (i, a)=>{
            if (t.invokeEvent({
                type: "StartEvent"
            }), e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.invokeEvent({
                type: "EndEvent"
            }), !e.currentInput) {
                v5("No input!");
                return;
            }
            t.renderPieceStart(i, a), t.renderPieceDraw(i, a), t.renderPieceFinish(i, a);
        }, t.computeBounds = (i, a)=>{
            if (!t.getInput()) {
                af(e.Bounds);
                return;
            }
            e.bounds = t.getInput().getBounds();
        }, t.updateBufferObjects = (i, a)=>{
            t.getNeedToRebuildBufferObjects(i, a) && t.buildBufferObjects(i, a);
        }, t.getNeedToRebuildBufferObjects = (i, a)=>e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < a.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < a.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime() || !e.scalarTexture?.getHandle() || !e.colorTexture?.getHandle() || !e.labelOutlineThicknessTexture?.getHandle(), t.buildBufferObjects = (i, a)=>{
            const o = e.currentInput;
            if (!o) return;
            const s = o.getPointData() && o.getPointData().getScalars();
            if (!s) return;
            const c = a.getProperty();
            if (!e.jitterTexture.getHandle()) {
                const M = new Uint8Array(1024);
                for(let P = 0; P < 32 * 32; ++P)M[P] = 255 * Math.random();
                e.jitterTexture.setMinificationFilter(Tt.LINEAR), e.jitterTexture.setMagnificationFilter(Tt.LINEAR), e.jitterTexture.create2DFromRaw(32, 32, 1, qt.UNSIGNED_CHAR, M);
            }
            const l = s.getNumberOfComponents(), f = t.useIndependentComponents(c), u = f ? l : 1, g = c.getScalarOpacity(), h = e._openGLRenderWindow.getGraphicsResourceForObject(g);
            let v = ic(g, f, u);
            if (!h?.oglObject || h.hash !== v) {
                e.opacityTexture = Qn.newInstance(), e.opacityTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const M = 1024, P = M * 2 * u, F = new Float32Array(P), N = new Float32Array(M);
                for(let B = 0; B < u; ++B){
                    const G = c.getScalarOpacity(B), Z = t.getCurrentSampleDistance(i) / c.getScalarOpacityUnitDistance(B), H = G.getRange();
                    G.getTable(H[0], H[1], M, N, 1);
                    for(let ne = 0; ne < M; ++ne)F[B * M * 2 + ne] = 1 - (1 - N[ne]) ** Z, F[B * M * 2 + ne + M] = F[B * M * 2 + ne];
                }
                if (e.opacityTexture.resetFormatAndType(), e.opacityTexture.setMinificationFilter(Tt.LINEAR), e.opacityTexture.setMagnificationFilter(Tt.LINEAR), e._openGLRenderWindow.getWebgl2() || e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) e.opacityTexture.create2DFromRaw(M, 2 * u, 1, qt.FLOAT, F);
                else {
                    const B = new Uint8ClampedArray(P);
                    for(let G = 0; G < P; ++G)B[G] = 255 * F[G];
                    e.opacityTexture.create2DFromRaw(M, 2 * u, 1, qt.UNSIGNED_CHAR, B);
                }
                g && (e._openGLRenderWindow.setGraphicsResourceForObject(g, e.opacityTexture, v), g !== e._scalarOpacityFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(g, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalarOpacityFunc, t)), e._scalarOpacityFunc = g);
            } else e.opacityTexture = h.oglObject;
            const y = c.getRGBTransferFunction();
            v = ic(y, f, u);
            const C = e._openGLRenderWindow.getGraphicsResourceForObject(y);
            if (!C?.oglObject?.getHandle() || C?.hash !== v) {
                e.colorTexture = Qn.newInstance(), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const M = 1024, P = M * 2 * u * 3, F = new Uint8ClampedArray(P), N = new Float32Array(M * 3);
                for(let B = 0; B < u; ++B){
                    const G = c.getRGBTransferFunction(B), Z = G.getRange();
                    G.getTable(Z[0], Z[1], M, N, 1);
                    for(let H = 0; H < M * 3; ++H)F[B * M * 6 + H] = 255 * N[H], F[B * M * 6 + H + M * 3] = 255 * N[H];
                }
                e.colorTexture.resetFormatAndType(), e.colorTexture.setMinificationFilter(Tt.LINEAR), e.colorTexture.setMagnificationFilter(Tt.LINEAR), e.colorTexture.create2DFromRaw(M, 2 * u, 3, qt.UNSIGNED_CHAR, F), y && (e._openGLRenderWindow.setGraphicsResourceForObject(y, e.colorTexture, v), y !== e._colorTransferFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(y, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc, t)), e._colorTransferFunc = y);
            } else e.colorTexture = C.oglObject;
            t.updateLabelOutlineThicknessTexture(a);
            const x = e._openGLRenderWindow.getGraphicsResourceForObject(s);
            v = u4(o, s);
            const S = !x?.oglObject?.getHandle() || x?.hash !== v, D = e.renderable.getUpdatedExtents(), _ = !!D.length;
            if (S && !_) {
                e.scalarTexture = Qn.newInstance(), e.scalarTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const M = o.getDimensions();
                e.scalarTexture.setOglNorm16Ext(e.context.getExtension("EXT_texture_norm16")), e.scalarTexture.resetFormatAndType(), e.scalarTexture.create3DFilterableFromDataArray(M[0], M[1], M[2], s), s && (e._openGLRenderWindow.setGraphicsResourceForObject(s, e.scalarTexture, v), s !== e._scalars && (e._openGLRenderWindow.registerGraphicsResourceUser(s, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalars, t)), e._scalars = s);
            } else e.scalarTexture = x.oglObject;
            if (_) {
                e.renderable.setUpdatedExtents([]);
                const M = o.getDimensions();
                e.scalarTexture.create3DFilterableFromDataArray(M[0], M[1], M[2], s, !1, D);
            }
            if (!e.tris.getCABO().getElementCount()) {
                const M = new Float32Array(12);
                for(let B = 0; B < 4; B++)M[B * 3] = B % 2 * 2 - 1, M[B * 3 + 1] = B > 1 ? 1 : -1, M[B * 3 + 2] = -1;
                const P = new Uint16Array(8);
                P[0] = 3, P[1] = 0, P[2] = 1, P[3] = 3, P[4] = 3, P[5] = 0, P[6] = 3, P[7] = 2;
                const F = Wt.newInstance({
                    numberOfComponents: 3,
                    values: M
                });
                F.setName("points");
                const N = Wt.newInstance({
                    numberOfComponents: 1,
                    values: P
                });
                e.tris.getCABO().createVBO(N, "polys", Yo.SURFACE, {
                    points: F,
                    cellOffset: 0
                });
            }
            e.VBOBuildTime.modified();
        }, t.updateLabelOutlineThicknessTexture = (i)=>{
            const a = i.getProperty().getLabelOutlineThickness(), o = e._openGLRenderWindow.getGraphicsResourceForObject(a), s = `${a.join("-")}`;
            if (!o?.oglObject?.getHandle() || o?.hash !== s) {
                e.labelOutlineThicknessTexture = Qn.newInstance(), e.labelOutlineThicknessTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const l = 1024, f = 1, u = l * f, g = new Uint8Array(u);
                for(let h = 0; h < l; ++h){
                    const v = typeof a[h] < "u" ? a[h] : a[0];
                    g[h] = v;
                }
                e.labelOutlineThicknessTexture.resetFormatAndType(), e.labelOutlineThicknessTexture.setMinificationFilter(Tt.NEAREST), e.labelOutlineThicknessTexture.setMagnificationFilter(Tt.NEAREST), e.labelOutlineThicknessTexture.create2DFromRaw(l, f, 1, qt.UNSIGNED_CHAR, g), a && (e._openGLRenderWindow.setGraphicsResourceForObject(a, e.labelOutlineThicknessTexture, s), a !== e._labelOutlineThicknessArray && (e._openGLRenderWindow.registerGraphicsResourceUser(a, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._labelOutlineThicknessArray, t)), e._labelOutlineThicknessArray = a);
            } else e.labelOutlineThicknessTexture = o.oglObject;
        }, t.isLabelmapOutlineRequired = (i)=>{
            const a = i.getProperty(), o = e.renderable;
            return a.getUseLabelOutline() || o.getBlendMode() === H1.LABELMAP_EDGE_PROJECTION_BLEND;
        };
    }
    const yF = {
        context: null,
        VBOBuildTime: null,
        scalarTexture: null,
        opacityTexture: null,
        opacityTextureString: null,
        colorTexture: null,
        colorTextureString: null,
        jitterTexture: null,
        labelOutlineThicknessTexture: null,
        labelOutlineThicknessTextureString: null,
        tris: null,
        framebuffer: null,
        copyShader: null,
        copyVAO: null,
        lastXYF: 1,
        targetXYF: 1,
        zBufferTexture: null,
        lastZBufferTexture: null,
        lightComplexity: 0,
        fullViewportTime: 1,
        idxToView: null,
        idxNormalMatrix: null,
        modelToView: null,
        projectionToView: null,
        avgWindowArea: 0,
        avgFrameTime: 0
    };
    function nE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, yF, n), Yr.extend(t, e, n), Wl.implementBuildShadersWithReplacements(t, e, n), e.VBOBuildTime = {}, tr(e.VBOBuildTime, {
            mtime: 0
        }), e.tris = Yl.newInstance(), e.jitterTexture = Qn.newInstance(), e.jitterTexture.setWrapS(bd.REPEAT), e.jitterTexture.setWrapT(bd.REPEAT), e.framebuffer = kp.newInstance(), e.idxToView = Ot(new Float64Array(16)), e.idxNormalMatrix = Ts(new Float64Array(9)), e.modelToView = Ot(new Float64Array(16)), e.projectionToView = Ot(new Float64Array(16)), e.projectionToWorld = Ot(new Float64Array(16)), si(t, e, [
            "context"
        ]), vF(t, e);
    }
    const rE = kn(nE, "vtkOpenGLVolumeMapper");
    var iE = {
        newInstance: rE,
        extend: nE
    };
    bi("vtkVolumeMapper", rE);
    const { vtkDebugMacro: CF } = da;
    function wF(t, e) {
        e.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"), t.opaquePass = (n, r)=>{
            e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
            const i = e._openGLRenderer.getAspectRatio(), a = e._openGLRenderer ? e._openGLRenderer.getRenderable().getActiveCamera() : null, o = e._openGLRenderer.getTiledSizeAndOrigin();
            let s = null;
            if (e.renderable.getUseZValues()) {
                const c = r.getZBufferTexture(), l = Math.floor(c.getWidth()), f = Math.floor(c.getHeight()), u = e._openGLRenderWindow.getContext();
                c.bind();
                const g = r.getFramebuffer();
                g ? g.saveCurrentBindingsAndBuffers() : CF("No framebuffer to save/restore");
                const h = u.createFramebuffer();
                u.bindFramebuffer(u.FRAMEBUFFER, h), u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, c.getHandle(), 0), u.checkFramebufferStatus(u.FRAMEBUFFER) === u.FRAMEBUFFER_COMPLETE && (s = new Uint8Array(l * f * 4), u.viewport(0, 0, l, f), u.readPixels(0, 0, l, f, u.RGBA, u.UNSIGNED_BYTE, s)), g && g.restorePreviousBindingsAndBuffers(), u.deleteFramebuffer(h);
            }
            e.renderable.invokeCallback(e.renderable.getInputData(), a, i, o, s);
        }, t.queryPass = (n, r)=>{
            n && e.renderable.getUseZValues() && r.requestDepth();
        };
    }
    const TF = {};
    function xF(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, TF, n), Yr.extend(t, e, n), wF(t, e);
    }
    const aE = kn(xF, "vtkOpenGLPixelSpaceCallbackMapper");
    var SF = {
        newInstance: aE
    };
    bi("vtkPixelSpaceCallbackMapper", aE);
    const oE = Object.create(null);
    sf = function(t, e) {
        oE[t] = e;
    };
    function EF(t, e) {
        e.classHierarchy.push("vtkWebGPUViewNodeFactory");
    }
    const DF = {};
    function _F(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, DF, n), e.overrides = oE, o4.extend(t, e, n), EF(t, e);
    }
    K.newInstance(_F, "vtkWebGPUViewNodeFactory");
    function RF(t, e) {
        e.classHierarchy.push("vtkWebGPUCamera"), t.getProjectionMatrix = (n, r, i, a)=>{
            if (Ot(n), e.renderable.getParallelProjection()) {
                const o = e.renderable.getParallelScale(), s = o * r, c = o, l = (a[0] - 1) * s, f = (a[0] + 1) * s, u = (a[1] - 1) * c, g = (a[1] + 1) * c, h = 1 / (f - l), v = 1 / (g - u);
                n[0] = 2 * h, n[5] = 2 * v, n[10] = 1 / (i[1] - i[0]), n[12] = (f + l) * h, n[13] = (g + u) * v, n[14] = i[1] / (i[1] - i[0]);
            } else {
                const o = Math.tan(Math.PI * e.renderable.getViewAngle() / 360);
                let s, c;
                e.renderable.getUseHorizontalViewAngle() === !0 ? (s = i[0] * o, c = i[0] * o / r) : (s = i[0] * o * r, c = i[0] * o);
                const l = (a[0] - 1) * s, f = (a[0] + 1) * s, u = (a[1] - 1) * c, g = (a[1] + 1) * c;
                n[0] = 2 * i[0] / (f - l), n[5] = 2 * i[0] / (g - u), n[12] = (l + f) / (f - l), n[13] = (u + g) / (g - u), n[10] = 0, n[14] = i[0], n[11] = -1, n[15] = 0;
            }
        }, t.convertToOpenGLDepth = (n)=>{
            if (e.renderable.getParallelProjection()) return 1 - n;
            const r = e.renderable.getClippingRangeByReference();
            let i = -r[0] / n;
            return i = (r[0] + r[1]) / (r[1] - r[0]) + 2 * r[0] * r[1] / (i * (r[1] - r[0])), .5 * i + .5;
        }, t.getKeyMatrices = (n)=>{
            const r = n.getRenderable(), i = n.getParent();
            if (Math.max(i.getMTime(), t.getMTime(), r.getMTime(), e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatrixTime.getMTime()) {
                const a = e.renderable.getViewMatrix();
                Ur(e.keyMatrices.normalMatrix, a), e.keyMatrices.normalMatrix[3] = 0, e.keyMatrices.normalMatrix[7] = 0, e.keyMatrices.normalMatrix[11] = 0, Xr(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), cn(e.keyMatrices.wcvc, a);
                const o = n.getStabilizedCenterByReference();
                qr(e.keyMatrices.scvc, e.keyMatrices.wcvc, o);
                const s = n.getAspectRatio(), c = e.renderable.getClippingRangeByReference();
                t.getProjectionMatrix(e.keyMatrices.vcpc, s, c, e.renderable.getWindowCenterByReference()), Qt(e.keyMatrices.scpc, e.keyMatrices.vcpc, e.keyMatrices.scvc), Xr(e.keyMatrices.pcsc, e.keyMatrices.scpc), e.keyMatrixTime.modified();
            }
            return e.keyMatrices;
        };
    }
    const OF = {
        keyMatrixTime: null,
        keyMatrices: null
    };
    function IF(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, OF, n), Yr.extend(t, e, n), e.keyMatrixTime = {}, K.obj(e.keyMatrixTime), e.keyMatrices = {
            normalMatrix: new Float64Array(16),
            vcpc: new Float64Array(16),
            pcsc: new Float64Array(16),
            wcvc: new Float64Array(16),
            scpc: new Float64Array(16),
            scvc: new Float64Array(16)
        }, K.setGet(t, e, [
            "keyMatrixTime"
        ]), RF(t, e);
    }
    const MF = K.newInstance(IF);
    sf("vtkCamera", MF);
    function bF(t, e) {
        e.classHierarchy.push("vtkWebGPUBindGroup"), t.setBindables = (n)=>{
            if (e.bindables.length === n.length) {
                let r = !0;
                for(let i = 0; i < e.bindables.length; i++)e.bindables[i] !== n[i] && (r = !1);
                if (r) return;
            }
            e.bindables = n, t.modified();
        }, t.getBindGroupLayout = (n)=>{
            const r = [];
            for(let i = 0; i < e.bindables.length; i++){
                const a = e.bindables[i].getBindGroupLayoutEntry();
                a.binding = i, r.push(a);
            }
            return n.getBindGroupLayout({
                entries: r
            });
        }, t.getBindGroup = (n)=>{
            let r = t.getMTime();
            for(let a = 0; a < e.bindables.length; a++){
                const o = e.bindables[a].getBindGroupTime().getMTime();
                r = o > r ? o : r;
            }
            if (r < e.bindGroupTime.getMTime()) return e.bindGroup;
            const i = [];
            for(let a = 0; a < e.bindables.length; a++){
                const o = e.bindables[a].getBindGroupEntry();
                o.binding = a, i.push(o);
            }
            return e.bindGroup = n.getHandle().createBindGroup({
                layout: t.getBindGroupLayout(n),
                entries: i,
                label: e.label
            }), e.bindGroupTime.modified(), e.bindGroup;
        }, t.getShaderCode = (n)=>{
            const r = [], i = n.getBindGroupLayoutCount(e.label);
            for(let a = 0; a < e.bindables.length; a++)r.push(e.bindables[a].getShaderCode(a, i));
            return r.join(`
`);
        };
    }
    const LF = {
        device: null,
        handle: null,
        label: null
    };
    function sE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, LF, n), K.obj(t, e), e.bindables = [], e.bindGroupTime = {}, K.obj(e.bindGroupTime, {
            mtime: 0
        }), K.get(t, e, [
            "bindGroupTime",
            "handle",
            "sizeInBytes",
            "usage"
        ]), K.setGet(t, e, [
            "label",
            "device",
            "arrayInformation"
        ]), bF(t, e);
    }
    const PF = K.newInstance(sE);
    var cE = {
        newInstance: PF,
        extend: sE
    };
    function VF(t, e) {
        e.classHierarchy.push("vtkWebGPUShaderModule"), t.initialize = (n, r)=>{
            e.device = n, e.handle = e.device.getHandle().createShaderModule({
                code: r.getCode()
            });
        };
    }
    const NF = {
        device: null,
        handle: null
    };
    function lE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, NF, n), K.obj(t, e), K.get(t, e, [
            "lastCameraMTime"
        ]), K.setGet(t, e, [
            "device",
            "handle"
        ]), VF(t, e);
    }
    const AF = K.newInstance(lE, "vtkWebGPUShaderModule");
    var kF = {
        newInstance: AF,
        extend: lE
    };
    function UF(t, e, n) {
        let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
        const i = Array.isArray(n) ? n.join(`
`) : n;
        let a = !1;
        t.search(e) !== -1 && (a = !0);
        let o = "";
        r && (o = "g");
        const s = new RegExp(e, o), c = t.replace(s, i);
        return {
            replace: a,
            result: c
        };
    }
    function FF(t, e) {
        e.classHierarchy.push("vtkWebGPUShaderCache"), t.getShaderModule = (n)=>{
            const r = n.getType(), i = n.getHash(), a = e._shaderModules.keys();
            for(let s = 0; s < a.length; s++){
                const c = a[s];
                if (c.getHash() === i && c.getType() === r) return e._shaderModules.get(c);
            }
            const o = kF.newInstance();
            return o.initialize(e.device, n), e._shaderModules.set(n, o), o;
        };
    }
    const BF = {
        shaderModules: null,
        device: null,
        window: null
    };
    function uE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, BF, n), e._shaderModules = new Map, K.obj(t, e), K.setGet(t, e, [
            "device",
            "window"
        ]), FF(t, e);
    }
    const GF = K.newInstance(uE, "vtkWebGPUShaderCache");
    wo = {
        newInstance: GF,
        extend: uE,
        substitute: UF
    };
    function WF(t, e) {
        e.classHierarchy.push("vtkWebGPUPipeline"), t.getShaderDescriptions = ()=>e.shaderDescriptions, t.initialize = (n, r)=>{
            e.pipelineDescription = e.renderEncoder.getPipelineSettings(), e.pipelineDescription.primitive.topology = e.topology, e.pipelineDescription.vertex = e.vertexState, e.pipelineDescription.label = r;
            const i = [];
            for(let a = 0; a < e.layouts.length; a++)i.push(e.layouts[a].layout);
            e.pipelineLayout = n.getHandle().createPipelineLayout({
                bindGroupLayouts: i
            }), e.pipelineDescription.layout = e.pipelineLayout;
            for(let a = 0; a < e.shaderDescriptions.length; a++){
                const o = e.shaderDescriptions[a], s = n.getShaderModule(o);
                o.getType() === "vertex" && (e.pipelineDescription.vertex.module = s.getHandle(), e.pipelineDescription.vertex.entryPoint = "main"), o.getType() === "fragment" && (e.pipelineDescription.fragment.module = s.getHandle(), e.pipelineDescription.fragment.entryPoint = "main");
            }
            e.handle = n.getHandle().createRenderPipeline(e.pipelineDescription);
        }, t.getShaderDescription = (n)=>{
            for(let r = 0; r < e.shaderDescriptions.length; r++)if (e.shaderDescriptions[r].getType() === n) return e.shaderDescriptions[r];
            return null;
        }, t.addBindGroupLayout = (n)=>{
            n && e.layouts.push({
                layout: n.getBindGroupLayout(e.device),
                label: n.getLabel()
            });
        }, t.getBindGroupLayout = (n)=>e.layouts[n].layout, t.getBindGroupLayoutCount = (n)=>{
            for(let r = 0; r < e.layouts.length; r++)if (e.layouts[r].label === n) return r;
            return 0;
        }, t.bindVertexInput = (n, r)=>{
            r.bindBuffers(n);
        };
    }
    const $F = {
        handle: null,
        layouts: null,
        renderEncoder: null,
        shaderDescriptions: null,
        vertexState: null,
        topology: null,
        pipelineDescription: null
    };
    function fE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, $F, n), tr(t, e), e.layouts = [], e.shaderDescriptions = [], La(t, e, [
            "handle",
            "pipelineDescription"
        ]), si(t, e, [
            "device",
            "renderEncoder",
            "topology",
            "vertexState"
        ]), WF(t, e);
    }
    const zF = kn(fE, "vtkWebGPUPipeline");
    var jF = {
        newInstance: zF,
        extend: fE
    };
    function HF(t, e) {
        e.classHierarchy.push("vtkWebGPUShaderDescription"), t.hasOutput = (n)=>e.outputNames.includes(n), t.addOutput = function(n, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
            e.outputTypes.push(n), e.outputNames.push(r), e.outputInterpolations.push(i);
        }, t.addBuiltinOutput = (n, r)=>{
            e.builtinOutputTypes.push(n), e.builtinOutputNames.push(r);
        }, t.addBuiltinInput = (n, r)=>{
            e.builtinInputTypes.push(n), e.builtinInputNames.push(r);
        }, t.replaceShaderCode = (n, r)=>{
            const i = [];
            let a = [];
            if (r && i.push(r.getShaderCode()), n || e.builtinInputNames.length) {
                const o = [];
                if (o.push(`struct ${e.type}Input
{`), n) {
                    const s = n.getOutputNamesByReference(), c = n.getOutputTypesByReference(), l = n.getOutputInterpolationsByReference();
                    for(let f = 0; f < s.length; f++)l[f] !== void 0 ? o.push(`  @location(${f}) @interpolate(${l[f]}) ${s[f]} : ${c[f]},`) : o.push(`  @location(${f}) ${s[f]} : ${c[f]},`);
                }
                for(let s = 0; s < e.builtinInputNames.length; s++)o.push(`  ${e.builtinInputNames[s]} : ${e.builtinInputTypes[s]},`);
                o.length > 1 && (o.push("};"), a = o, i[i.length - 1] += ",", i.push(`input: ${e.type}Input`));
            }
            if (i.length && (e.code = wo.substitute(e.code, "//VTK::IOStructs::Input", i).result), e.outputNames.length + e.builtinOutputNames.length) {
                const o = [
                    `struct ${e.type}Output
{`
                ];
                for(let s = 0; s < e.outputNames.length; s++)e.outputInterpolations[s] !== void 0 ? o.push(`  @location(${s}) @interpolate(${e.outputInterpolations[s]}) ${e.outputNames[s]} : ${e.outputTypes[s]},`) : o.push(`  @location(${s}) ${e.outputNames[s]} : ${e.outputTypes[s]},`);
                for(let s = 0; s < e.builtinOutputNames.length; s++)o.push(`  ${e.builtinOutputNames[s]} : ${e.builtinOutputTypes[s]},`);
                o.push("};"), a = a.concat(o), e.code = wo.substitute(e.code, "//VTK::IOStructs::Output", [
                    `-> ${e.type}Output`
                ]).result;
            }
            e.code = wo.substitute(e.code, "//VTK::IOStructs::Dec", a).result;
        };
    }
    const KF = {
        type: null,
        hash: null,
        code: null,
        outputNames: null,
        outputTypes: null
    };
    function dE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, KF, n), e.outputNames = [], e.outputTypes = [], e.outputInterpolations = [], e.builtinOutputNames = [], e.builtinOutputTypes = [], e.builtinInputNames = [], e.builtinInputTypes = [], K.obj(t, e), K.setGet(t, e, [
            "type",
            "hash",
            "code"
        ]), K.getArray(t, e, [
            "outputTypes",
            "outputNames",
            "outputInterpolations"
        ]), HF(t, e);
    }
    const qF = K.newInstance(dE, "vtkWebGPUShaderDescription");
    var j9 = {
        newInstance: qF,
        extend: dE
    };
    const H9 = {
        r8unorm: {
            numComponents: 1,
            nativeType: Uint8Array,
            stride: 1,
            elementSize: 1,
            sampleType: "float"
        },
        r8snorm: {
            numComponents: 1,
            nativeType: Int8Array,
            stride: 1,
            elementSize: 1,
            sampleType: "float"
        },
        r8uint: {
            numComponents: 1,
            nativeType: Uint8Array,
            stride: 1,
            elementSize: 1,
            sampleType: "uint"
        },
        r8sint: {
            numComponents: 1,
            nativeType: Int8Array,
            stride: 1,
            elementSize: 1,
            sampleType: "sint"
        },
        r16uint: {
            numComponents: 1,
            nativeType: Uint16Array,
            stride: 2,
            elementSize: 2,
            sampleType: "uint"
        },
        r16sint: {
            numComponents: 1,
            nativeType: Int16Array,
            stride: 2,
            elementSize: 2,
            sampleType: "sint"
        },
        r16float: {
            numComponents: 1,
            nativeType: Float32Array,
            stride: 2,
            elementSize: 2,
            sampleType: "float"
        },
        rg8unorm: {
            numComponents: 2,
            nativeType: Uint8Array,
            stride: 2,
            elementSize: 1,
            sampleType: "float"
        },
        rg8snorm: {
            numComponents: 2,
            nativeType: Int8Array,
            stride: 2,
            elementSize: 1,
            sampleType: "float"
        },
        rg8uint: {
            numComponents: 2,
            nativeType: Uint8Array,
            stride: 2,
            elementSize: 1,
            sampleType: "uint"
        },
        rg8sint: {
            numComponents: 2,
            nativeType: Int8Array,
            stride: 2,
            elementSize: 1,
            sampleType: "sint"
        },
        r32uint: {
            numComponents: 1,
            nativeType: Uint32Array,
            stride: 4,
            elementSize: 4,
            sampleType: "uint"
        },
        r32sint: {
            numComponents: 1,
            nativeType: Int32Array,
            stride: 4,
            elementSize: 4,
            sampleType: "sint"
        },
        r32float: {
            numComponents: 1,
            nativeType: Float32Array,
            stride: 4,
            elementSize: 4,
            sampleType: "unfilterable-float"
        },
        rg16uint: {
            numComponents: 2,
            nativeType: Uint16Array,
            stride: 4,
            elementSize: 2,
            sampleType: "uint"
        },
        rg16sint: {
            numComponents: 2,
            nativeType: Int16Array,
            stride: 4,
            elementSize: 2,
            sampleType: "sint"
        },
        rg16float: {
            numComponents: 2,
            nativeType: Float32Array,
            stride: 4,
            elementSize: 2,
            sampleType: "float"
        },
        rgba8unorm: {
            numComponents: 4,
            nativeType: Uint8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "float"
        },
        "rgba8unorm-srgb": {
            numComponents: 4,
            nativeType: Uint8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "float"
        },
        rgba8snorm: {
            numComponents: 4,
            nativeType: Int8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "float"
        },
        rgba8uint: {
            numComponents: 4,
            nativeType: Uint8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "uint"
        },
        rgba8sint: {
            numComponents: 4,
            nativeType: Int8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "sint"
        },
        bgra8unorm: {
            numComponents: 4,
            nativeType: Uint8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "float"
        },
        "bgra8unorm-srgb": {
            numComponents: 4,
            nativeType: Uint8Array,
            stride: 4,
            elementSize: 1,
            sampleType: "float"
        },
        rgb9e5ufloat: {
            numComponents: 4,
            nativeType: Uint32Array,
            stride: 4,
            sampleType: "float"
        },
        rgb10a2unorm: {
            numComponents: 4,
            nativeType: Uint32Array,
            stride: 4,
            sampleType: "float"
        },
        rg11b10ufloat: {
            numComponents: 4,
            nativeType: Float32Array,
            stride: 4,
            sampleType: "float"
        },
        rg32uint: {
            numComponents: 2,
            nativeType: Uint32Array,
            stride: 8,
            elementSize: 4,
            sampleType: "uint"
        },
        rg32sint: {
            numComponents: 2,
            nativeType: Int32Array,
            stride: 8,
            elementSize: 4,
            sampleType: "sint"
        },
        rg32float: {
            numComponents: 2,
            nativeType: Float32Array,
            stride: 8,
            elementSize: 4,
            sampleType: "unfilterable-float"
        },
        rgba16uint: {
            numComponents: 4,
            nativeType: Uint16Array,
            stride: 8,
            elementSize: 2,
            sampleType: "uint"
        },
        rgba16sint: {
            numComponents: 4,
            nativeType: Int16Array,
            stride: 8,
            elementSize: 2,
            sampleType: "sint"
        },
        rgba16float: {
            numComponents: 4,
            nativeType: Float32Array,
            stride: 8,
            elementSize: 2,
            sampleType: "float"
        },
        rgba32uint: {
            numComponents: 4,
            nativeType: Uint32Array,
            stride: 16,
            elementSize: 4,
            sampleType: "uint"
        },
        rgba32sint: {
            numComponents: 4,
            nativeType: Int32Array,
            stride: 16,
            elementSize: 4,
            sampleType: "sint"
        },
        rgba32float: {
            numComponents: 4,
            nativeType: Float32Array,
            stride: 16,
            elementSize: 4,
            sampleType: "unfilterable-float"
        },
        stencil8: {
            numComponents: 1,
            nativeType: Uint8Array,
            stride: 1,
            elementSize: 1,
            sampleType: "uint"
        },
        depth16unorm: {
            numComponents: 1,
            nativeType: Uint16Array,
            stride: 2,
            elementSize: 2,
            sampleType: "depth"
        },
        depth24plus: {
            numComponents: 1,
            nativeType: Uint32Array,
            stride: 4,
            elementSize: 3,
            sampleType: "depth"
        },
        "depth24plus-stencil8": {
            numComponents: 2,
            nativeType: Uint32Array,
            stride: 4,
            sampleType: "mixed"
        },
        depth32float: {
            numComponents: 1,
            nativeType: Float32Array,
            stride: 4,
            elementSize: 4,
            sampleType: "depth"
        }
    };
    function XF(t) {
        return !t || t.length < 6 ? 0 : t in H9 ? H9[t] : (Zt(`unknown format ${t}`), null);
    }
    function YF(t) {
        if (!t || t.length < 5) return 0;
        let e = 1;
        t[t.length - 2] === "x" && (e = Number(t[t.length - 1]));
        const n = e === 1 ? t.length - 1 : t.length - 3, r = Number(t[n]);
        if (Number.isNaN(r)) return Zt(`unknown format ${t}`), 0;
        const i = 5 - r / 2;
        return e * i;
    }
    function ZF(t) {
        if (!t || t.length < 5) return 0;
        let e = 1;
        return t[t.length - 2] === "x" && (e = Number(t[t.length - 1])), e;
    }
    function JF(t) {
        if (!t || t.length < 5) return 0;
        let e;
        if (t[0] === "f") e = "Float";
        else if (t[0] === "s") e = "Int";
        else if (t[0] === "u") e = "Uint";
        else {
            Zt(`unknown format ${t}`);
            return;
        }
        const n = t.split("x")[0], r = Number(n[n.length - 1]);
        if (Number.isNaN(r)) {
            Zt(`unknown format ${t}`);
            return;
        }
        return e += 8 * (5 - r / 2), e += "Array", e;
    }
    function QF(t) {
        let e;
        if (t[0] === "f" || t[1] === "n") e = "f32";
        else if (t[0] === "s" && t[1] === "i") e = "i32";
        else if (t[0] === "u" && t[1] === "i") e = "u32";
        else {
            Zt(`unknown format ${t}`);
            return;
        }
        let n = 1;
        return t[t.length - 2] === "x" && (n = Number(t[t.length - 1])), n === 4 ? `vec4<${e}>` : n === 3 ? `vec3<${e}>` : n === 2 ? `vec2<${e}>` : e;
    }
    function eB(t) {
        if (!t) return 0;
        let e = 1;
        return t.substring(0, 3) === "vec" ? e = Number(t[3]) : t.substring(0, 3) === "mat" && (e = t[3] * t[5]), e * 4;
    }
    function tB(t) {
        if (t) {
            if (t.includes("f32")) return "Float32Array";
            if (t.includes("i32")) return "Int32Array";
            if (t.includes("u32")) return "Uint32Array";
            Zt(`unknown format ${t}`);
        }
    }
    qs = {
        getDetailsFromTextureFormat: XF,
        getByteStrideFromBufferFormat: YF,
        getNumberOfComponentsFromBufferFormat: ZF,
        getNativeTypeFromBufferFormat: JF,
        getShaderTypeFromBufferFormat: QF,
        getByteStrideFromShaderFormat: eB,
        getNativeTypeFromShaderFormat: tB
    };
    function nB(t, e) {
        if (t === e) return !0;
        if (t == null || e == null || t.length !== e.length) return !1;
        for(let n = 0; n < t.length; ++n)if (!e.includes(t[n])) return !1;
        return !0;
    }
    function rB(t, e) {
        e.classHierarchy.push("vtkWebGPUVertexInput"), t.addBuffer = function(n, r) {
            let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex", a = r;
            Array.isArray(a) || (a = [
                a
            ]);
            for(let o = 0; o < e.inputs.length; o++)if (nB(e.inputs[o].names, a)) {
                if (e.inputs[o].buffer === n) return;
                e.inputs[o].buffer = n;
                return;
            }
            e.inputs.push({
                buffer: n,
                stepMode: i,
                names: a
            }), e.inputs = e.inputs.sort((o, s)=>o.names[0] < s.names[0] ? -1 : o.names[0] > s.names[0] ? 1 : 0);
        }, t.removeBufferIfPresent = (n)=>{
            for(let r = 0; r < e.inputs.length; r++)e.inputs[r].names.includes(n) && e.inputs.splice(r, 1);
        }, t.getBuffer = (n)=>{
            for(let r = 0; r < e.inputs.length; r++)if (e.inputs[r].names.includes(n)) return e.inputs[r].buffer;
            return null;
        }, t.hasAttribute = (n)=>{
            for(let r = 0; r < e.inputs.length; r++)if (e.inputs[r].names.includes(n)) return !0;
            return !1;
        }, t.getAttributeTime = (n)=>{
            for(let r = 0; r < e.inputs.length; r++)if (e.inputs[r].names.includes(n)) return e.inputs[r].buffer.getSourceTime();
            return 0;
        }, t.getShaderCode = ()=>{
            let n = "", r = 0;
            for(let i = 0; i < e.inputs.length; i++)for(let a = 0; a < e.inputs[i].names.length; a++){
                const o = e.inputs[i].buffer.getArrayInformation()[a], s = qs.getShaderTypeFromBufferFormat(o.format);
                r > 0 && (n += `,
`), n = `${n}  @location(${r}) ${e.inputs[i].names[a]} : ${s}`, r++;
            }
            return n;
        }, t.getVertexInputInformation = ()=>{
            const n = {};
            if (e.inputs.length) {
                const r = [];
                let i = 0;
                for(let a = 0; a < e.inputs.length; a++){
                    const o = e.inputs[a].buffer, s = {
                        arrayStride: o.getStrideInBytes(),
                        stepMode: e.inputs[a].stepMode,
                        attributes: []
                    }, c = o.getArrayInformation();
                    for(let l = 0; l < e.inputs[a].names.length; l++)s.attributes.push({
                        shaderLocation: i,
                        offset: c[l].offset,
                        format: c[l].format
                    }), i++;
                    r.push(s);
                }
                n.buffers = r;
            }
            return n;
        }, t.bindBuffers = (n)=>{
            for(let r = 0; r < e.inputs.length; r++)n.setVertexBuffer(r, e.inputs[r].buffer.getHandle());
            e.indexBuffer && n.setIndexBuffer(e.indexBuffer.getHandle(), e.indexBuffer.getArrayInformation()[0].format);
        }, t.getReady = ()=>{}, t.releaseGraphicsResources = ()=>{
            e.created && (e.inputs = [], e.bindingDescriptions = [], e.attributeDescriptions = []);
        };
    }
    const iB = {
        inputs: null,
        bindingDescriptions: !1,
        attributeDescriptions: null,
        indexBuffer: null
    };
    function gE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, iB, n), tr(t, e), e.bindingDescriptions = [], e.attributeDescriptions = [], e.inputs = [], si(t, e, [
            "created",
            "device",
            "handle",
            "indexBuffer"
        ]), rB(t, e);
    }
    const aB = kn(gE, "vtkWebGPUVertexInput");
    var oB = {
        newInstance: aB,
        extend: gE
    };
    const sB = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`, cB = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
    function lB(t, e) {
        e.classHierarchy.push("vtkWebGPUSimpleMapper"), t.generateShaderDescriptions = (n, r, i)=>{
            const a = j9.newInstance({
                type: "vertex",
                hash: n,
                code: e.vertexShaderTemplate
            }), o = j9.newInstance({
                type: "fragment",
                hash: n,
                code: e.fragmentShaderTemplate
            }), s = r.getShaderDescriptions();
            s.push(a), s.push(o);
            const c = e.vertexShaderTemplate + e.fragmentShaderTemplate, l = new RegExp("//VTK::[^:]*::", "g"), u = c.match(l).filter((g, h, v)=>v.indexOf(g) === h).map((g)=>`replaceShader${g.substring(7, g.length - 2)}`);
            for(let g = 0; g < u.length; g++){
                const h = u[g];
                h !== "replaceShaderIOStructs" && e.shaderReplacements.has(h) && e.shaderReplacements.get(h)(n, r, i);
            }
            t.replaceShaderIOStructs(n, r, i);
        }, t.replaceShaderIOStructs = (n, r, i)=>{
            const a = r.getShaderDescription("vertex");
            a.replaceShaderCode(null, i), r.getShaderDescription("fragment").replaceShaderCode(a);
        }, t.replaceShaderRenderEncoder = (n, r, i)=>{
            e.renderEncoder.replaceShaderCode(r);
        }, e.shaderReplacements.set("replaceShaderRenderEncoder", t.replaceShaderRenderEncoder), t.replaceShaderRenderer = (n, r, i)=>{
            if (!e.WebGPURenderer) return;
            const a = e.WebGPURenderer.getBindGroup().getShaderCode(r), o = r.getShaderDescription("vertex");
            let s = o.getCode();
            s = wo.substitute(s, "//VTK::Renderer::Dec", [
                a
            ]).result, o.setCode(s);
            const c = r.getShaderDescription("fragment");
            s = c.getCode(), s = wo.substitute(s, "//VTK::Renderer::Dec", [
                a
            ]).result, c.setCode(s);
        }, e.shaderReplacements.set("replaceShaderRenderer", t.replaceShaderRenderer), t.replaceShaderMapper = (n, r, i)=>{
            const a = e.bindGroup.getShaderCode(r), o = r.getShaderDescription("vertex");
            let s = o.getCode();
            s = wo.substitute(s, "//VTK::Mapper::Dec", [
                a
            ]).result, o.setCode(s);
            const c = r.getShaderDescription("fragment");
            c.addBuiltinInput("bool", "@builtin(front_facing) frontFacing"), s = c.getCode(), s = wo.substitute(s, "//VTK::Mapper::Dec", [
                a
            ]).result, c.setCode(s);
        }, e.shaderReplacements.set("replaceShaderMapper", t.replaceShaderMapper), t.replaceShaderPosition = (n, r, i)=>{
            const a = r.getShaderDescription("vertex");
            a.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
            let o = a.getCode();
            o = wo.substitute(o, "//VTK::Position::Impl", [
                "    output.Position = rendererUBO.SCPCMatrix*vertexBC;"
            ]).result, a.setCode(o);
        }, e.shaderReplacements.set("replaceShaderPosition", t.replaceShaderPosition), t.replaceShaderTCoord = (n, r, i)=>{
            r.getShaderDescription("vertex").addOutput("vec2<f32>", "tcoordVS");
        }, e.shaderReplacements.set("replaceShaderTCoord", t.replaceShaderTCoord), t.addTextureView = (n)=>{
            e.textureViews.includes(n) || e.textureViews.push(n);
        }, t.prepareToDraw = (n)=>{
            e.renderEncoder = n, t.updateInput(), t.updateBuffers(), t.updateBindings(), t.updatePipeline();
        }, t.updateInput = ()=>{}, t.updateBuffers = ()=>{}, t.updateBindings = ()=>{
            e.bindGroup.setBindables(t.getBindables());
        }, t.computePipelineHash = ()=>{}, t.registerDrawCallback = (n)=>{
            n.registerDrawCallback(e.pipeline, t.draw);
        }, t.prepareAndDraw = (n)=>{
            t.prepareToDraw(n), n.setPipeline(e.pipeline), t.draw(n);
        }, t.draw = (n)=>{
            const r = n.getBoundPipeline();
            n.activateBindGroup(e.bindGroup), e.WebGPURenderer && e.WebGPURenderer.bindUBO(n), r.bindVertexInput(n, e.vertexInput);
            const i = e.vertexInput.getIndexBuffer();
            i ? n.drawIndexed(i.getIndexCount(), e.numberOfInstances, 0, 0, 0) : n.draw(e.numberOfVertices, e.numberOfInstances, 0, 0);
        }, t.getBindables = ()=>{
            const n = [
                ...e.additionalBindables
            ];
            e.UBO && n.push(e.UBO), e.SSBO && n.push(e.SSBO);
            for(let r = 0; r < e.textureViews.length; r++){
                n.push(e.textureViews[r]);
                const i = e.textureViews[r].getSampler();
                i && n.push(i);
            }
            return n;
        }, t.updatePipeline = ()=>{
            t.computePipelineHash(), e.pipeline = e.device.getPipeline(e.pipelineHash), e.pipeline || (e.pipeline = jF.newInstance(), e.pipeline.setDevice(e.device), e.WebGPURenderer && e.pipeline.addBindGroupLayout(e.WebGPURenderer.getBindGroup()), e.pipeline.addBindGroupLayout(e.bindGroup), t.generateShaderDescriptions(e.pipelineHash, e.pipeline, e.vertexInput), e.pipeline.setTopology(e.topology), e.pipeline.setRenderEncoder(e.renderEncoder), e.pipeline.setVertexState(e.vertexInput.getVertexInputInformation()), e.device.createPipeline(e.pipelineHash, e.pipeline));
        };
    }
    const uB = {
        additionalBindables: void 0,
        bindGroup: null,
        device: null,
        fragmentShaderTemplate: null,
        numberOfInstances: 1,
        numberOfVertices: 0,
        pipelineHash: null,
        shaderReplacements: null,
        SSBO: null,
        textureViews: null,
        topology: "triangle-list",
        UBO: null,
        vertexShaderTemplate: null,
        WebGPURenderer: null
    };
    function hE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, uB, n), Yr.extend(t, e, n), e.textureViews = [], e.vertexInput = oB.newInstance(), e.bindGroup = cE.newInstance({
            label: "mapperBG"
        }), e.additionalBindables = [], e.fragmentShaderTemplate = e.fragmentShaderTemplate || cB, e.vertexShaderTemplate = e.vertexShaderTemplate || sB, e.shaderReplacements = new Map, K.get(t, e, [
            "pipeline",
            "vertexInput"
        ]), K.setGet(t, e, [
            "additionalBindables",
            "device",
            "fragmentShaderTemplate",
            "interpolate",
            "numberOfInstances",
            "numberOfVertices",
            "pipelineHash",
            "shaderReplacements",
            "SSBO",
            "textureViews",
            "topology",
            "UBO",
            "vertexShaderTemplate",
            "WebGPURenderer"
        ]), lB(t, e);
    }
    const fB = K.newInstance(hE, "vtkWebGPUSimpleMapper");
    dB = {
        newInstance: fB,
        extend: hE
    };
    function gB(t, e) {
        e.classHierarchy.push("vtkWebGPUFullScreenQuad"), t.replaceShaderPosition = (n, r, i)=>{
            const a = r.getShaderDescription("vertex");
            a.addBuiltinOutput("vec4<f32>", "@builtin(position) Position"), a.addOutput("vec4<f32>", "vertexVC");
            let o = a.getCode();
            o = wo.substitute(o, "//VTK::Position::Impl", [
                "output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);",
                "output.Position = vec4<f32>(vertexBC, 1.0);",
                "output.vertexVC = vec4<f32>(vertexBC, 1);"
            ]).result, a.setCode(o);
        }, e.shaderReplacements.set("replaceShaderPosition", t.replaceShaderPosition), t.updateBuffers = ()=>{
            const n = e.device.getBufferManager().getFullScreenQuadBuffer();
            e.vertexInput.addBuffer(n, [
                "vertexBC"
            ]), e.numberOfVertices = 6;
        };
    }
    const hB = {};
    function pE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, hB, n), dB.extend(t, e, n), gB(t, e);
    }
    const pB = K.newInstance(pE, "vtkWebGPUFullScreenQuad");
    var Uv = {
        newInstance: pB,
        extend: pE
    };
    const mB = {
        Verts: 0,
        Lines: 1,
        Triangles: 2,
        Strips: 3,
        LinesFromStrips: 4,
        LinesFromTriangles: 5,
        Points: 6,
        UniformArray: 7,
        PointArray: 8,
        NormalsFromPoints: 9,
        Texture: 10,
        RawVertex: 11,
        Storage: 12,
        Index: 13
    }, vB = {
        Start: 0,
        Points: 0,
        Lines: 1,
        Triangles: 2,
        TriangleStrips: 3,
        TriangleEdges: 4,
        TriangleStripEdges: 5,
        End: 6
    };
    var Qd = {
        BufferUsage: mB,
        PrimitiveTypes: vB
    };
    const y5 = [
        "getMappedRange",
        "mapAsync",
        "unmap"
    ];
    function yB(t, e, n, r) {
        const i = r.byteLength, a = t.createBuffer({
            size: i,
            usage: GPUBufferUsage.COPY_SRC,
            mappedAtCreation: !0
        }), o = a.getMappedRange(0, i);
        new Uint8Array(o).set(new Uint8Array(r)), a.unmap();
        const s = t.createCommandEncoder();
        s.copyBufferToBuffer(a, 0, e, n, i);
        const c = s.finish();
        t.queue.submit([
            c
        ]), a.destroy();
    }
    function CB(t, e) {
        e.classHierarchy.push("vtkWebGPUBuffer"), t.create = (n, r)=>{
            e.handle = e.device.getHandle().createBuffer({
                size: n,
                usage: r,
                label: e.label
            }), e.sizeInBytes = n, e.usage = r;
        }, t.write = (n)=>{
            yB(e.device.getHandle(), e.handle, 0, n.buffer);
        }, t.createAndWrite = (n, r)=>{
            e.handle = e.device.getHandle().createBuffer({
                size: n.byteLength,
                usage: r,
                mappedAtCreation: !0,
                label: e.label
            }), e.sizeInBytes = n.byteLength, e.usage = r, new Uint8Array(e.handle.getMappedRange()).set(new Uint8Array(n.buffer)), e.handle.unmap();
        };
        for(let n = 0; n < y5.length; n++)t[y5[n]] = function() {
            return e.handle[y5[n]](...arguments);
        };
    }
    const wB = {
        device: null,
        handle: null,
        sizeInBytes: 0,
        strideInBytes: 0,
        arrayInformation: null,
        usage: null,
        label: null,
        sourceTime: null
    };
    function mE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, wB, n), K.obj(t, e), K.get(t, e, [
            "handle",
            "sizeInBytes",
            "usage"
        ]), K.setGet(t, e, [
            "strideInBytes",
            "device",
            "arrayInformation",
            "label",
            "sourceTime"
        ]), CB(t, e);
    }
    const TB = K.newInstance(mE);
    var Fv = {
        newInstance: TB,
        extend: mE,
        ...Qd
    };
    const { Representation: od, Interpolation: sd } = AS;
    function K9(t) {
        return ()=>K.vtkErrorMacro(`vtkProperty::${t} - NOT IMPLEMENTED`);
    }
    function xB(t, e) {
        e.classHierarchy.push("vtkProperty"), t.setColor = (n, r, i)=>{
            Array.isArray(n) ? (e.color[0] !== n[0] || e.color[1] !== n[1] || e.color[2] !== n[2]) && (e.color[0] = n[0], e.color[1] = n[1], e.color[2] = n[2], t.modified()) : (e.color[0] !== n || e.color[1] !== r || e.color[2] !== i) && (e.color[0] = n, e.color[1] = r, e.color[2] = i, t.modified()), t.setDiffuseColor(e.color), t.setAmbientColor(e.color), t.setSpecularColor(e.color);
        }, t.computeCompositeColor = K9("ComputeCompositeColor"), t.getColor = ()=>{
            let n = 0;
            e.ambient + e.diffuse + e.specular > 0 && (n = 1 / (e.ambient + e.diffuse + e.specular));
            for(let r = 0; r < 3; r++)e.color[r] = n * (e.ambient * e.ambientColor[r] + e.diffuse * e.diffuseColor[r] + e.specular * e.specularColor[r]);
            return [].concat(e.color);
        }, t.setSpecularPower = (n)=>{
            const r = 1 / Math.max(1, n);
            (e.roughness !== r || e.specularPower !== n) && (e.specularPower = n, e.roughness = r, t.modified());
        }, t.addShaderVariable = K9("AddShaderVariable"), t.setInterpolationToFlat = ()=>t.setInterpolation(sd.FLAT), t.setInterpolationToGouraud = ()=>t.setInterpolation(sd.GOURAUD), t.setInterpolationToPhong = ()=>t.setInterpolation(sd.PHONG), t.getInterpolationAsString = ()=>K.enumToString(sd, e.interpolation), t.setRepresentationToWireframe = ()=>t.setRepresentation(od.WIREFRAME), t.setRepresentationToSurface = ()=>t.setRepresentation(od.SURFACE), t.setRepresentationToPoints = ()=>t.setRepresentation(od.POINTS), t.getRepresentationAsString = ()=>K.enumToString(od, e.representation);
    }
    const SB = {
        color: [
            1,
            1,
            1
        ],
        ambientColor: [
            1,
            1,
            1
        ],
        diffuseColor: [
            1,
            1,
            1
        ],
        specularColor: [
            1,
            1,
            1
        ],
        edgeColor: [
            0,
            0,
            0
        ],
        ambient: 0,
        diffuse: 1,
        metallic: 0,
        roughness: .6,
        normalStrength: 1,
        emission: 1,
        baseIOR: 1.45,
        specular: 0,
        specularPower: 1,
        opacity: 1,
        interpolation: sd.GOURAUD,
        representation: od.SURFACE,
        edgeVisibility: !1,
        backfaceCulling: !1,
        frontfaceCulling: !1,
        pointSize: 1,
        lineWidth: 1,
        lighting: !0,
        shading: !1,
        materialName: null
    };
    function vE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, SB, n), K.obj(t, e), K.setGet(t, e, [
            "lighting",
            "interpolation",
            "ambient",
            "diffuse",
            "metallic",
            "roughness",
            "normalStrength",
            "emission",
            "baseIOR",
            "specular",
            "specularPower",
            "opacity",
            "edgeVisibility",
            "lineWidth",
            "pointSize",
            "backfaceCulling",
            "frontfaceCulling",
            "representation",
            "diffuseTexture",
            "metallicTexture",
            "roughnessTexture",
            "normalTexture",
            "ambientOcclusionTexture",
            "emissionTexture"
        ]), K.setGetArray(t, e, [
            "ambientColor",
            "specularColor",
            "diffuseColor",
            "edgeColor"
        ], 3), xB(t, e);
    }
    const EB = K.newInstance(vE, "vtkProperty");
    eg = {
        newInstance: EB,
        extend: vE,
        ...AS
    };
    const { Representation: q9 } = eg, { PrimitiveTypes: Dl } = Qd;
    class DB {
        constructor(){
            this.keys = new Uint32Array(10), this.values = new Uint32Array(10), this.count = 0;
        }
        clear() {
            this.count = 0;
        }
        has(e) {
            for(let n = 0; n < this.count; n++)if (this.keys[n] === e) return !0;
        }
        get(e) {
            for(let n = 0; n < this.count; n++)if (this.keys[n] === e) return this.values[n];
        }
        set(e, n) {
            this.count < 9 && (this.keys[this.count] = e, this.values[this.count++] = n);
        }
    }
    function _B(t) {
        switch(t){
            case Dl.Points:
                return "points";
            case Dl.Lines:
                return "lines";
            case Dl.Triangles:
            case Dl.TriangleEdges:
                return "polys";
            case Dl.TriangleStripEdges:
            case Dl.TriangleStrips:
                return "strips";
            default:
                return "";
        }
    }
    function w1(t, e, n) {
        let r = t.pointIdToFlatId[e];
        return r < 0 && (r = t.flatId, t.pointIdToFlatId[e] = r, t.flatIdToPointId[t.flatId] = e, t.flatIdToCellId[t.flatId] = n, t.flatId++), r;
    }
    function RB(t, e, n) {
        const r = t.length;
        for(let o = 0; o < r; o++){
            let s = t[o];
            if (n.cellProvokedMap.has(s)) {
                n.ibo[n.iboId++] = n.cellProvokedMap.get(s);
                for(let c = o + 1; c < o + r; c++){
                    s = t[c % r];
                    const l = w1(n, s, e);
                    n.ibo[n.iboId++] = l;
                }
                return;
            }
        }
        for(let o = 0; o < r; o++){
            let s = t[o];
            if (!n.provokedPointIds[s]) {
                let c = w1(n, s, e);
                n.provokedPointIds[s] = 1, n.cellProvokedMap.set(s, c), n.flatIdToCellId[c] = e, n.ibo[n.iboId++] = c;
                for(let l = o + 1; l < o + r; l++)s = t[l % r], c = w1(n, s, e), n.ibo[n.iboId++] = c;
                return;
            }
        }
        let i = t[0], a = n.flatId;
        n.cellProvokedMap.set(i, a), n.flatIdToPointId[n.flatId] = i, n.flatIdToCellId[n.flatId] = e, n.flatId++, n.ibo[n.iboId++] = a;
        for(let o = 1; o < r; o++)i = t[o], a = w1(n, i, e), n.ibo[n.iboId++] = a;
    }
    function OB(t, e, n) {
        const r = t.length;
        n.iboSize += r;
        for(let i = 0; i < r; i++){
            const a = t[i];
            if (n.cellProvokedMap.has(a)) return;
        }
        for(let i = 0; i < r; i++){
            const a = t[i];
            if (!n.provokedPointIds[a]) {
                n.provokedPointIds[a] = 1, n.cellProvokedMap.set(a, 1);
                return;
            }
        }
        n.cellProvokedMap.set(t[0], 1), n.extraPoints++;
    }
    let Nc;
    const X9 = new Uint32Array(1), jo = new Uint32Array(2), yl = new Uint32Array(3), C5 = {
        anythingToPoints (t, e, n, r, i) {
            for(let a = 0; a < t; ++a)X9[0] = e[n + a], Nc(X9, r, i);
        },
        linesToWireframe (t, e, n, r, i) {
            for(let a = 0; a < t - 1; ++a)jo[0] = e[n + a], jo[1] = e[n + a + 1], Nc(jo, r, i);
        },
        polysToWireframe (t, e, n, r, i) {
            if (t > 2) for(let a = 0; a < t; ++a)jo[0] = e[n + a], jo[1] = e[n + (a + 1) % t], Nc(jo, r, i);
        },
        stripsToWireframe (t, e, n, r, i) {
            if (t > 2) {
                for(let a = 0; a < t - 1; ++a)jo[0] = e[n + a], jo[1] = e[n + a + 1], Nc(jo, r, i);
                for(let a = 0; a < t - 2; a++)jo[0] = e[n + a], jo[1] = e[n + a + 2], Nc(jo, r, i);
            }
        },
        polysToSurface (t, e, n, r, i) {
            for(let a = 0; a < t - 2; a++)yl[0] = e[n], yl[1] = e[n + a + 1], yl[2] = e[n + a + 2], Nc(yl, r, i);
        },
        stripsToSurface (t, e, n, r, i) {
            for(let a = 0; a < t - 2; a++)yl[0] = e[n + a], yl[1] = e[n + a + 1 + a % 2], yl[2] = e[n + a + 1 + (a + 1) % 2], Nc(yl, r, i);
        }
    };
    function IB(t, e) {
        e.classHierarchy.push("vtkWebGPUIndexBuffer"), t.buildIndexBuffer = (n)=>{
            const r = n.cells, i = n.primitiveType, a = n.representation, o = n.cellOffset, s = r.getData(), c = s.length, l = _B(i), f = n.numberOfPoints, u = {
                provokedPointIds: new Uint8Array(f),
                extraPoints: 0,
                iboSize: 0,
                flatId: 0,
                iboId: 0,
                cellProvokedMap: new DB
            };
            let g = null;
            a === q9.POINTS || i === Dl.Points ? g = C5.anythingToPoints : a === q9.WIREFRAME || i === Dl.Lines ? g = C5[`${l}ToWireframe`] : g = C5[`${l}ToSurface`], Nc = OB;
            let h = o || 0;
            for(let v = 0; v < c;)u.cellProvokedMap.clear(), g(s[v], s, v + 1, h, u), v += s[v] + 1, h++;
            f <= 65535 ? u.flatIdToPointId = new Uint16Array(f + u.extraPoints) : u.flatIdToPointId = new Uint32Array(f + u.extraPoints), f + u.extraPoints < 36863 ? u.pointIdToFlatId = new Int16Array(f) : u.pointIdToFlatId = new Int32Array(f), f + u.extraPoints <= 65535 ? (u.ibo = new Uint16Array(u.iboSize), n.format = "uint16") : (u.ibo = new Uint32Array(u.iboSize), n.format = "uint32"), h <= 65535 ? u.flatIdToCellId = new Uint16Array(f + u.extraPoints) : u.flatIdToCellId = new Uint32Array(f + u.extraPoints), u.pointIdToFlatId.fill(-1), u.provokedPointIds.fill(0), Nc = RB, h = o || 0;
            for(let v = 0; v < c;)u.cellProvokedMap.clear(), g(s[v], s, v + 1, h, u), v += s[v] + 1, h++;
            delete u.provokedPointIds, delete u.pointIdToFlatId, n.nativeArray = u.ibo, e.flatIdToPointId = u.flatIdToPointId, e.flatIdToCellId = u.flatIdToCellId, e.flatSize = u.flatId, e.indexCount = u.iboId;
        };
    }
    const MB = {
        flatIdToPointId: null,
        flatIdToCellId: null,
        flatSize: 0,
        indexCount: 0
    };
    function yE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, MB, n), Fv.extend(t, e, n), K.setGet(t, e, [
            "flatIdToPointId",
            "flatIdToCellId",
            "flatSize",
            "indexCount"
        ]), IB(t, e);
    }
    const bB = K.newInstance(yE);
    var LB = {
        newInstance: bB,
        extend: yE,
        ...Qd
    };
    const { BufferUsage: Cl } = Qd, { vtkErrorMacro: PB } = da, { VtkDataTypes: p0 } = Wt, VB = {};
    function NB(t) {
        let e;
        switch(t.getDataType()){
            case p0.UNSIGNED_CHAR:
                e = "uint8";
                break;
            case p0.FLOAT:
                e = "float32";
                break;
            case p0.UNSIGNED_INT:
                e = "uint32";
                break;
            case p0.INT:
                e = "sint32";
                break;
            case p0.DOUBLE:
                e = "float32";
                break;
            case p0.UNSIGNED_SHORT:
                e = "uint16";
                break;
            case p0.SHORT:
                e = "sin16";
                break;
            default:
                e = "float32";
                break;
        }
        switch(t.getNumberOfComponents()){
            case 2:
                e += "x2";
                break;
            case 3:
                e.includes("32") || PB(`unsupported x3 type for ${e}`), e += "x3";
                break;
            case 4:
                e += "x4";
                break;
        }
        return e;
    }
    function Y9(t, e, n, r, i) {
        const a = {}, o = t.getFlatSize();
        if (!o) return a;
        let s = [
            0,
            0,
            0,
            0
        ];
        i.shift && (i.shift.length ? s = i.shift : s.fill(i.shift));
        let c = [
            1,
            1,
            1,
            1
        ];
        i.scale && (i.scale.length ? c = i.scale : c.fill(i.scale));
        const l = Object.prototype.hasOwnProperty.call(i, "packExtra") ? i.packExtra : !1;
        let f, u = 0;
        const g = n + (l ? 1 : 0), h = nf(r, o * g);
        let v = t.getFlatIdToPointId();
        i.cellData && (v = t.getFlatIdToCellId()), n === 1 ? f = function(y) {
            h[u++] = c[0] * e[y] + s[0];
        } : n === 2 ? f = function(y) {
            h[u++] = c[0] * e[y] + s[0], h[u++] = c[1] * e[y + 1] + s[1];
        } : n === 3 && !l ? f = function(y) {
            h[u++] = c[0] * e[y] + s[0], h[u++] = c[1] * e[y + 1] + s[1], h[u++] = c[2] * e[y + 2] + s[2];
        } : n === 3 && l ? f = function(y) {
            h[u++] = c[0] * e[y] + s[0], h[u++] = c[1] * e[y + 1] + s[1], h[u++] = c[2] * e[y + 2] + s[2], h[u++] = c[3] * 1 + s[3];
        } : n === 4 && (f = function(y) {
            h[u++] = c[0] * e[y] + s[0], h[u++] = c[1] * e[y + 1] + s[1], h[u++] = c[2] * e[y + 2] + s[2], h[u++] = c[3] * e[y + 3] + s[3];
        });
        for(let m = 0; m < o; m++){
            const y = n * v[m];
            f(y);
        }
        return a.nativeArray = h, a;
    }
    function AB(t, e, n, r) {
        const i = [
            t[r * 3] - t[n * 3],
            t[r * 3 + 1] - t[n * 3 + 1],
            t[r * 3 + 2] - t[n * 3 + 2]
        ], a = [
            t[e * 3] - t[n * 3],
            t[e * 3 + 1] - t[n * 3 + 1],
            t[e * 3 + 2] - t[n * 3 + 2]
        ], o = [];
        return tc(i, a, o), F0(o), o;
    }
    function kB(t, e) {
        const n = e.getData(), r = t.getData();
        if (!r || !n) return null;
        const i = new Int8Array(t.getNumberOfCells() * 4), a = r.length;
        let o = 0;
        for(let s = 0; s < a;){
            const c = AB(n, r[s + 1], r[s + 2], r[s + 3]);
            i[o++] = 127 * c[0], i[o++] = 127 * c[1], i[o++] = 127 * c[2], i[o++] = 127, s += r[s] + 1;
        }
        return i;
    }
    function UB(t, e) {
        e.classHierarchy.push("vtkWebGPUBufferManager");
        function n(r) {
            r.dataArray && !r.nativeArray && (r.nativeArray = r.dataArray.getData());
            let i, a;
            if (r.usage === Cl.Index && (i = LB.newInstance({
                label: r.label
            }), i.setDevice(e.device), a = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST, i.buildIndexBuffer(r), i.createAndWrite(r.nativeArray, a), i.setArrayInformation([
                {
                    format: r.format
                }
            ])), i || (i = Fv.newInstance({
                label: r.label
            }), i.setDevice(e.device)), r.usage === Cl.UniformArray && (a = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, i.createAndWrite(r.nativeArray, a)), r.usage === Cl.Storage && (a = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST, i.createAndWrite(r.nativeArray, a)), r.usage === Cl.Texture && (a = GPUBufferUsage.COPY_SRC, i.createAndWrite(r.nativeArray, a)), r.usage === Cl.PointArray) {
                a = GPUBufferUsage.VERTEX;
                const o = qs.getNativeTypeFromBufferFormat(r.format), s = Y9(r.indexBuffer, r.dataArray.getData(), r.dataArray.getNumberOfComponents(), o, {
                    packExtra: r.packExtra,
                    shift: r.shift,
                    scale: r.scale,
                    cellData: r.cellData,
                    cellOffset: r.cellOffset
                });
                i.createAndWrite(s.nativeArray, a), i.setStrideInBytes(qs.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
                    {
                        offset: 0,
                        format: r.format,
                        interpolation: r.cellData ? "flat" : "perspective"
                    }
                ]);
            }
            if (r.usage === Cl.NormalsFromPoints) {
                a = GPUBufferUsage.VERTEX;
                const o = qs.getNativeTypeFromBufferFormat(r.format), s = kB(r.cells, r.dataArray), c = Y9(r.indexBuffer, s, 4, o, {
                    cellData: !0
                });
                i.createAndWrite(c.nativeArray, a), i.setStrideInBytes(qs.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
                    {
                        offset: 0,
                        format: r.format,
                        interpolation: "flat"
                    }
                ]);
            }
            return r.usage === Cl.RawVertex && (a = GPUBufferUsage.VERTEX, i.createAndWrite(r.nativeArray, a), i.setStrideInBytes(qs.getByteStrideFromBufferFormat(r.format)), i.setArrayInformation([
                {
                    offset: 0,
                    format: r.format
                }
            ])), i.setSourceTime(r.time), i;
        }
        t.hasBuffer = (r)=>e.device.hasCachedObject(r), t.getBuffer = (r)=>r.hash ? e.device.getCachedObject(r.hash, n, r) : n(r), t.getBufferForPointArray = (r, i)=>{
            const a = NB(r), o = {
                hash: `${r.getMTime()}I${i.getMTime()}${a}`,
                usage: Cl.PointArray,
                format: a,
                dataArray: r,
                indexBuffer: i
            };
            return t.getBuffer(o);
        }, t.getFullScreenQuadBuffer = ()=>{
            if (e.fullScreenQuadBuffer) return e.fullScreenQuadBuffer;
            e.fullScreenQuadBuffer = Fv.newInstance(), e.fullScreenQuadBuffer.setDevice(e.device);
            const r = new Float32Array([
                -1,
                -1,
                0,
                1,
                -1,
                0,
                1,
                1,
                0,
                -1,
                -1,
                0,
                1,
                1,
                0,
                -1,
                1,
                0
            ]);
            return e.fullScreenQuadBuffer.createAndWrite(r, GPUBufferUsage.VERTEX), e.fullScreenQuadBuffer.setStrideInBytes(12), e.fullScreenQuadBuffer.setArrayInformation([
                {
                    offset: 0,
                    format: "float32x3"
                }
            ]), e.fullScreenQuadBuffer;
        };
    }
    const FB = {
        device: null,
        fullScreenQuadBuffer: null
    };
    function BB(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, FB, n), tr(t, e), si(t, e, [
            "device"
        ]), UB(t, e);
    }
    kn(BB);
    CE = {
        ...VB,
        ...Qd
    };
    const { BufferUsage: GB } = CE, { vtkErrorMacro: pu } = K;
    function WB(t, e) {
        e.classHierarchy.push("vtkWebGPUStorageBuffer"), t.addEntry = (n, r)=>{
            if (e._bufferEntryNames.has(n)) {
                pu(`entry named ${n} already exists`);
                return;
            }
            e._bufferEntryNames.set(n, e.bufferEntries.length);
            const i = qs.getByteStrideFromShaderFormat(r);
            e.bufferEntries.push({
                name: n,
                type: r,
                sizeInBytes: i,
                offset: e.sizeInBytes,
                nativeType: qs.getNativeTypeFromShaderFormat(r)
            }), e.sizeInBytes += i;
        }, t.send = (n)=>{
            if (!e._buffer) {
                const r = {
                    nativeArray: e.Float32Array,
                    usage: GB.Storage,
                    label: e.label
                };
                e._buffer = n.getBufferManager().getBuffer(r), e.bindGroupTime.modified(), e._sendTime.modified();
                return;
            }
            n.getHandle().queue.writeBuffer(e._buffer.getHandle(), 0, e.arrayBuffer, 0, e.sizeInBytes * e.numberOfInstances), e._sendTime.modified();
        }, t.createView = (n)=>{
            n in e || (e.arrayBuffer || (e.arrayBuffer = new ArrayBuffer(e.sizeInBytes * e.numberOfInstances)), e[n] = K.newTypedArray(n, e.arrayBuffer));
        }, t.setValue = (n, r, i)=>{
            const a = e._bufferEntryNames.get(n);
            if (a === void 0) {
                pu(`entry named ${n} not found in UBO`);
                return;
            }
            const o = e.bufferEntries[a];
            t.createView(o.nativeType);
            const s = e[o.nativeType];
            s[(o.offset + r * e.sizeInBytes) / s.BYTES_PER_ELEMENT] = i;
        }, t.setArray = (n, r, i)=>{
            const a = e._bufferEntryNames.get(n);
            if (a === void 0) {
                pu(`entry named ${n} not found in UBO`);
                return;
            }
            const o = e.bufferEntries[a];
            t.createView(o.nativeType);
            const s = e[o.nativeType], c = (o.offset + r * e.sizeInBytes) / s.BYTES_PER_ELEMENT;
            for(let l = 0; l < i.length; l++)s[c + l] = i[l];
        }, t.setAllInstancesFromArray = (n, r)=>{
            const i = e._bufferEntryNames.get(n);
            if (i === void 0) {
                pu(`entry named ${n} not found in UBO`);
                return;
            }
            const a = e.bufferEntries[i];
            t.createView(a.nativeType);
            const o = e[a.nativeType], s = r.length / e.numberOfInstances;
            for(let c = 0; c < e.numberOfInstances; c++){
                const l = (a.offset + c * e.sizeInBytes) / o.BYTES_PER_ELEMENT;
                for(let f = 0; f < s; f++)o[l + f] = r[c * s + f];
            }
        }, t.setAllInstancesFromArrayColorToFloat = (n, r)=>{
            const i = e._bufferEntryNames.get(n);
            if (i === void 0) {
                pu(`entry named ${n} not found in UBO`);
                return;
            }
            const a = e.bufferEntries[i];
            t.createView(a.nativeType);
            const o = e[a.nativeType], s = r.length / e.numberOfInstances;
            for(let c = 0; c < e.numberOfInstances; c++){
                const l = (a.offset + c * e.sizeInBytes) / o.BYTES_PER_ELEMENT;
                for(let f = 0; f < s; f++)o[l + f] = r[c * s + f] / 255;
            }
        }, t.setAllInstancesFromArray3x3To4x4 = (n, r)=>{
            const i = e._bufferEntryNames.get(n);
            if (i === void 0) {
                pu(`entry named ${n} not found in UBO`);
                return;
            }
            const a = e.bufferEntries[i];
            t.createView(a.nativeType);
            const o = e[a.nativeType], s = 9;
            for(let c = 0; c < e.numberOfInstances; c++){
                const l = (a.offset + c * e.sizeInBytes) / o.BYTES_PER_ELEMENT;
                for(let f = 0; f < 3; f++)for(let u = 0; u < 3; u++)o[l + f * 4 + u] = r[c * s + f * 3 + u];
            }
        }, t.getSendTime = ()=>e._sendTime.getMTime(), t.getShaderCode = (n, r)=>{
            const i = [
                `struct ${e.label}StructEntry
{`
            ];
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                i.push(`  ${o.name}: ${o.type},`);
            }
            return i.push(`
};
struct ${e.label}Struct
{
  values: array<${e.label}StructEntry>,
};
@binding(${n}) @group(${r}) var<storage, read> ${e.label}: ${e.label}Struct;
`), i.join(`
`);
        }, t.getBindGroupEntry = ()=>({
                resource: {
                    buffer: e._buffer.getHandle()
                }
            }), t.clearData = ()=>{
            e.numberOfInstances = 0, e.sizeInBytes = 0, e.bufferEntries = [], e._bufferEntryNames = new Map, e._buffer = null, delete e.arrayBuffer, delete e.Float32Array;
        };
    }
    const $B = {
        bufferEntries: null,
        bufferEntryNames: null,
        sizeInBytes: 0,
        label: null,
        numberOfInstances: 1
    };
    function wE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, $B, n), K.obj(t, e), e._bufferEntryNames = new Map, e.bufferEntries = [], e._sendTime = {}, K.obj(e._sendTime, {
            mtime: 0
        }), e.bindGroupTime = {}, K.obj(e.bindGroupTime, {
            mtime: 0
        }), e.bindGroupLayoutEntry = e.bindGroupLayoutEntry || {
            buffer: {
                type: "read-only-storage"
            }
        }, K.get(t, e, [
            "bindGroupTime"
        ]), K.setGet(t, e, [
            "device",
            "bindGroupLayoutEntry",
            "label",
            "numberOfInstances",
            "sizeInBytes"
        ]), WB(t, e);
    }
    const zB = K.newInstance(wE, "vtkWebGPUStorageBuffer");
    var jB = {
        newInstance: zB,
        extend: wE
    };
    const { BufferUsage: HB } = CE, { vtkErrorMacro: w5 } = K;
    function KB(t, e) {
        e.classHierarchy.push("vtkWebGPUUniformBuffer"), t.addEntry = (n, r)=>{
            if (e._bufferEntryNames.has(n)) {
                w5(`entry named ${n} already exists`);
                return;
            }
            e.sortDirty = !0, e._bufferEntryNames.set(n, e.bufferEntries.length), e.bufferEntries.push({
                name: n,
                type: r,
                sizeInBytes: qs.getByteStrideFromShaderFormat(r),
                offset: -1,
                nativeType: qs.getNativeTypeFromShaderFormat(r),
                packed: !1
            });
        }, t.sortBufferEntries = ()=>{
            if (!e.sortDirty) return;
            let n = 0;
            const r = [];
            let i = 4;
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                o.sizeInBytes % 16 === 0 && (i = Math.max(16, i)), o.sizeInBytes % 8 === 0 && (i = Math.max(8, i));
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                o.packed === !1 && o.sizeInBytes % 16 === 0 && (o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes);
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                if (o.packed === !1 && o.sizeInBytes === 12) for(let s = 0; s < e.bufferEntries.length; s++){
                    const c = e.bufferEntries[s];
                    if (c.packed === !1 && c.sizeInBytes === 4) {
                        o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes, c.packed = !0, c.offset = n, r.push(c), n += c.sizeInBytes;
                        break;
                    }
                }
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                if (!o.packed && o.sizeInBytes % 8 === 0) for(let s = a + 1; s < e.bufferEntries.length; s++){
                    const c = e.bufferEntries[s];
                    if (!c.packed && c.sizeInBytes % 8 === 0) {
                        o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes, c.packed = !0, c.offset = n, r.push(c), n += c.sizeInBytes;
                        break;
                    }
                }
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                if (!o.packed && o.sizeInBytes % 8 === 0) {
                    let s = !1;
                    for(let c = 0; !s && c < e.bufferEntries.length; c++){
                        const l = e.bufferEntries[c];
                        if (!l.packed && l.sizeInBytes === 4) for(let f = c + 1; f < e.bufferEntries.length; f++){
                            const u = e.bufferEntries[f];
                            if (!u.packed && u.sizeInBytes === 4) {
                                o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes, l.packed = !0, l.offset = n, r.push(l), n += l.sizeInBytes, u.packed = !0, u.offset = n, r.push(u), n += u.sizeInBytes, s = !0;
                                break;
                            }
                        }
                    }
                }
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                !o.packed && o.sizeInBytes > 4 && (o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes);
            }
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                o.packed || (o.packed = !0, o.offset = n, r.push(o), n += o.sizeInBytes);
            }
            e.bufferEntries = r, e._bufferEntryNames.clear();
            for(let a = 0; a < e.bufferEntries.length; a++)e._bufferEntryNames.set(e.bufferEntries[a].name, a);
            e.sizeInBytes = n, e.sizeInBytes = i * Math.ceil(e.sizeInBytes / i), e.sortDirty = !1;
        }, t.sendIfNeeded = (n)=>{
            if (!e.UBO) {
                const r = {
                    nativeArray: e.Float32Array,
                    usage: HB.UniformArray,
                    label: e.label
                };
                e.UBO = n.getBufferManager().getBuffer(r), e.bindGroupTime.modified(), e.sendDirty = !1;
            }
            e.sendDirty && (n.getHandle().queue.writeBuffer(e.UBO.getHandle(), 0, e.arrayBuffer, 0, e.sizeInBytes), e.sendDirty = !1), e.sendTime.modified();
        }, t.createView = (n)=>{
            n in e || (e.arrayBuffer || (e.arrayBuffer = new ArrayBuffer(e.sizeInBytes)), e[n] = K.newTypedArray(n, e.arrayBuffer));
        }, t.setValue = (n, r)=>{
            t.sortBufferEntries();
            const i = e._bufferEntryNames.get(n);
            if (i === void 0) {
                w5(`entry named ${n} not found in UBO`);
                return;
            }
            const a = e.bufferEntries[i];
            t.createView(a.nativeType);
            const o = e[a.nativeType];
            a.lastValue !== r && (o[a.offset / o.BYTES_PER_ELEMENT] = r, e.sendDirty = !0), a.lastValue = r;
        }, t.setArray = (n, r)=>{
            t.sortBufferEntries();
            const i = e._bufferEntryNames.get(n);
            if (i === void 0) {
                w5(`entry named ${n} not found in UBO`);
                return;
            }
            const a = e.bufferEntries[i];
            t.createView(a.nativeType);
            const o = e[a.nativeType];
            let s = !1;
            for(let c = 0; c < r.length; c++)(!a.lastValue || a.lastValue[c] !== r[c]) && (o[a.offset / o.BYTES_PER_ELEMENT + c] = r[c], s = !0);
            s && (e.sendDirty = !0, a.lastValue = [
                ...r
            ]);
        }, t.getBindGroupEntry = ()=>({
                resource: {
                    buffer: e.UBO.getHandle()
                }
            }), t.getSendTime = ()=>e.sendTime.getMTime(), t.getShaderCode = (n, r)=>{
            t.sortBufferEntries();
            const i = [
                `struct ${e.label}Struct
{`
            ];
            for(let a = 0; a < e.bufferEntries.length; a++){
                const o = e.bufferEntries[a];
                i.push(`  ${o.name}: ${o.type},`);
            }
            return i.push(`};
@binding(${n}) @group(${r}) var<uniform> ${e.label}: ${e.label}Struct;`), i.join(`
`);
        };
    }
    const qB = {
        bufferEntries: null,
        bufferEntryNames: null,
        sizeInBytes: 0,
        label: null,
        bindGroupLayoutEntry: null,
        bindGroupEntry: null
    };
    function TE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, qB, n), K.obj(t, e), e._bufferEntryNames = new Map, e.bufferEntries = [], e.bindGroupLayoutEntry = e.bindGroupLayoutEntry || {
            buffer: {
                type: "uniform"
            }
        }, e.sendTime = {}, K.obj(e.sendTime, {
            mtime: 0
        }), e.bindGroupTime = {}, K.obj(e.bindGroupTime, {
            mtime: 0
        }), e.sendDirty = !0, e.sortDirty = !0, K.get(t, e, [
            "binding",
            "bindGroupTime"
        ]), K.setGet(t, e, [
            "bindGroupLayoutEntry",
            "device",
            "label",
            "sizeInBytes"
        ]), KB(t, e);
    }
    const XB = K.newInstance(TE, "vtkWebGPUUniformBuffer");
    vd = {
        newInstance: XB,
        extend: TE
    };
    const { vtkDebugMacro: YB } = da, Z9 = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`, ZB = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`, T1 = new Float64Array(16), J9 = new Float64Array(16);
    function JB(t) {
        return t.getPositional() ? t.getConeAngle() >= 90 ? 0 : 2 : 1;
    }
    function QB(t, e) {
        e.classHierarchy.push("vtkWebGPURenderer"), t.buildPass = (n)=>{
            if (n) {
                if (!e.renderable) return;
                e.camera = e.renderable.getActiveCamera(), t.updateLights(), t.prepareNodes(), t.addMissingNode(e.camera), t.addMissingNodes(e.renderable.getViewPropsWithNestedProps()), t.removeUnusedNodes(), e.webgpuCamera = t.getViewNodeFor(e.camera), t.updateStabilizedMatrix();
            }
        }, t.updateStabilizedMatrix = ()=>{
            const n = e.camera.getClippingRange(), r = e.camera.getPositionByReference(), i = e.camera.getDirectionOfProjectionByReference(), a = [], o = [];
            Ys(o, i, .5 * (n[0] + n[1])), Qc(a, r, o), In(o, a, e.stabilizedCenter), jh(o) / (n[1] - n[0]) > e.recenterThreshold && (e.stabilizedCenter = a, e.stabilizedTime.modified());
        }, t.updateLights = ()=>{
            let n = 0;
            const r = e.renderable.getLightsByReference();
            for(let i = 0; i < r.length; ++i)r[i].getSwitch() > 0 && n++;
            return n || (YB("No lights are on, creating one."), e.renderable.createLight()), n;
        }, t.updateUBO = ()=>{
            const n = e.UBO.getSendTime();
            if (e._parent.getMTime() > n || t.getMTime() > n || e.camera.getMTime() > n || e.renderable.getMTime() > n) {
                const r = e.webgpuCamera.getKeyMatrices(t);
                e.UBO.setArray("WCVCMatrix", r.wcvc), e.UBO.setArray("SCPCMatrix", r.scpc), e.UBO.setArray("PCSCMatrix", r.pcsc), e.UBO.setArray("SCVCMatrix", r.scvc), e.UBO.setArray("VCPCMatrix", r.vcpc), e.UBO.setArray("WCVCNormals", r.normalMatrix), e.UBO.setValue("LightCount", e.renderable.getLights().length), e.UBO.setValue("MaxEnvironmentMipLevel", e.renderable.getEnvironmentTexture()?.getMipLevel()), e.UBO.setValue("BackgroundDiffuseStrength", e.renderable.getEnvironmentTextureDiffuseStrength()), e.UBO.setValue("BackgroundSpecularStrength", e.renderable.getEnvironmentTextureSpecularStrength());
                const i = t.getYInvertedTiledSizeAndOrigin();
                e.UBO.setArray("viewportSize", [
                    i.usize,
                    i.vsize
                ]), e.UBO.setValue("cameraParallel", e.camera.getParallelProjection());
                const a = e._parent.getDevice();
                e.UBO.sendIfNeeded(a);
            }
        }, t.updateSSBO = ()=>{
            const n = e.renderable.getLights(), r = e.webgpuCamera.getKeyMatrices(t);
            let i = `${e.renderable.getMTime()}`;
            for(let a = 0; a < n.length; a++)i += n[a].getMTime();
            if (i !== e.lightTimeString) {
                const a = new Float32Array(n.length * 4), o = new Float32Array(n.length * 4), s = new Float32Array(n.length * 4), c = new Float32Array(n.length * 4);
                for(let f = 0; f < n.length; f++){
                    const u = f * 4, g = n[f].getPosition();
                    pn(g, g, r.wcvc), a[u] = g[0], a[u + 1] = g[1], a[u + 2] = g[2], a[u + 3] = 0, o[u] = -n[f].getDirection()[0], o[u + 1] = -n[f].getDirection()[1], o[u + 2] = -n[f].getDirection()[2], o[u + 3] = 0, s[u] = n[f].getColor()[0], s[u + 1] = n[f].getColor()[1], s[u + 2] = n[f].getColor()[2], s[u + 3] = n[f].getIntensity() * 5, c[u] = JB(n[f]), c[u + 1] = Math.cos(Sr(n[f].getConeAngle())), c[u + 2] = Math.cos(Sr(n[f].getConeAngle() + n[f].getConeFalloff())), c[u + 3] = 0;
                }
                e.SSBO.clearData(), e.SSBO.setNumberOfInstances(n.length), e.SSBO.addEntry("LightPos", "vec4<f32>"), e.SSBO.addEntry("LightDir", "vec4<f32>"), e.SSBO.addEntry("LightColor", "vec4<f32>"), e.SSBO.addEntry("LightData", "vec4<f32>"), e.SSBO.setAllInstancesFromArray("LightPos", a), e.SSBO.setAllInstancesFromArray("LightDir", o), e.SSBO.setAllInstancesFromArray("LightColor", s), e.SSBO.setAllInstancesFromArray("LightData", c);
                const l = e._parent.getDevice();
                e.SSBO.send(l);
            }
            e.lightTimeString = i;
        }, t.scissorAndViewport = (n)=>{
            const r = t.getYInvertedTiledSizeAndOrigin();
            n.getHandle().setViewport(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize, 0, 1), n.getHandle().setScissorRect(r.lowerLeftU, r.lowerLeftV, r.usize, r.vsize);
        }, t.bindUBO = (n)=>{
            n.activateBindGroup(e.bindGroup);
        }, t.opaquePass = (n)=>{
            n ? (e.renderEncoder.begin(e._parent.getCommandEncoder()), t.updateUBO(), t.updateSSBO()) : (t.scissorAndViewport(e.renderEncoder), t.clear(), e.renderEncoder.end());
        }, t.clear = ()=>{
            if (e.renderable.getTransparent() || e.suppressClear) return;
            const n = e._parent.getDevice();
            if (!e.clearFSQ) {
                e.clearFSQ = Uv.newInstance(), e.clearFSQ.setDevice(n), e.clearFSQ.setPipelineHash("clearfsq"), e.clearFSQ.setFragmentShaderTemplate(Z9);
                const a = vd.newInstance({
                    label: "mapperUBO"
                });
                a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a), e.backgroundTex = e.renderable.getEnvironmentTexture();
            }
            if (e.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && e.renderable.getUseEnvironmentTextureAsBackground() && e.backgroundTex?.getImageLoaded()) {
                e.clearFSQ.setFragmentShaderTemplate(ZB);
                const a = vd.newInstance({
                    label: "mapperUBO"
                });
                a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a);
                const o = n.getTextureManager().getTextureForVTKTexture(e.backgroundTex);
                if (o.getReady()) {
                    const s = o.createView("EnvironmentTexture");
                    e.clearFSQ.setTextureViews([
                        s
                    ]), e.backgroundTexLoaded = !0;
                    const c = e.backgroundTex.getInterpolate() ? "linear" : "nearest";
                    s.addSampler(n, {
                        addressModeU: "repeat",
                        addressModeV: "clamp-to-edge",
                        addressModeW: "repeat",
                        minFilter: c,
                        magFilter: c,
                        mipmapFilter: "linear"
                    });
                }
                e.clearFSQ.setPipelineHash("clearfsqwithtexture");
            } else if (e.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !e.renderable.getUseEnvironmentTextureAsBackground()) {
                e.clearFSQ = Uv.newInstance(), e.clearFSQ.setDevice(n), e.clearFSQ.setPipelineHash("clearfsq"), e.clearFSQ.setFragmentShaderTemplate(Z9);
                const a = vd.newInstance({
                    label: "mapperUBO"
                });
                a.addEntry("FSQMatrix", "mat4x4<f32>"), a.addEntry("BackgroundColor", "vec4<f32>"), e.clearFSQ.setUBO(a);
            }
            const r = e.webgpuCamera.getKeyMatrices(t), i = e.renderable.getBackgroundByReference();
            e.clearFSQ.getUBO().setArray("BackgroundColor", i), cn(J9, r.normalMatrix), $h(T1, r.scvc, r.pcsc), $h(T1, J9, T1), e.clearFSQ.getUBO().setArray("FSQMatrix", T1), e.clearFSQ.getUBO().sendIfNeeded(n), e.clearFSQ.prepareAndDraw(e.renderEncoder);
        }, t.translucentPass = (n)=>{
            n ? e.renderEncoder.begin(e._parent.getCommandEncoder()) : (t.scissorAndViewport(e.renderEncoder), e.renderEncoder.end());
        }, t.volumeDepthRangePass = (n)=>{
            n ? e.renderEncoder.begin(e._parent.getCommandEncoder()) : (t.scissorAndViewport(e.renderEncoder), e.renderEncoder.end());
        }, t.getAspectRatio = ()=>{
            const n = e._parent.getSizeByReference(), r = e.renderable.getViewportByReference();
            return n[0] * (r[2] - r[0]) / ((r[3] - r[1]) * n[1]);
        }, t.convertToOpenGLDepth = (n)=>e.webgpuCamera.convertToOpenGLDepth(n), t.getYInvertedTiledSizeAndOrigin = ()=>{
            const n = t.getTiledSizeAndOrigin(), r = e._parent.getSizeByReference();
            return n.lowerLeftV = r[1] - n.vsize - n.lowerLeftV, n;
        }, t.getTiledSizeAndOrigin = ()=>{
            const n = e.renderable.getViewportByReference(), r = [
                0,
                0,
                1,
                1
            ], i = n[0] - r[0], a = n[1] - r[1], o = e._parent.normalizedDisplayToDisplay(i, a), s = Math.round(o[0]), c = Math.round(o[1]), l = n[2] - r[0], f = n[3] - r[1], u = e._parent.normalizedDisplayToDisplay(l, f);
            let g = Math.round(u[0]) - s, h = Math.round(u[1]) - c;
            return g < 0 && (g = 0), h < 0 && (h = 0), {
                usize: g,
                vsize: h,
                lowerLeftU: s,
                lowerLeftV: c
            };
        }, t.getPropFromID = (n)=>{
            for(let r = 0; r < e.children.length; r++)if ((e.children[r].getPropID ? e.children[r].getPropID() : -1) === n) return e.children[r];
            return null;
        }, t.getStabilizedTime = ()=>e.stabilizedTime.getMTime(), t.releaseGraphicsResources = ()=>{
            e.selector !== null && e.selector.releaseGraphicsResources();
        };
    }
    const eG = {
        bindGroup: null,
        selector: null,
        renderEncoder: null,
        recenterThreshold: 20,
        suppressClear: !1,
        stabilizedCenter: [
            0,
            0,
            0
        ]
    };
    function tG(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, eG, n), Yr.extend(t, e, n), e.UBO = vd.newInstance({
            label: "rendererUBO"
        }), e.UBO.addEntry("WCVCMatrix", "mat4x4<f32>"), e.UBO.addEntry("SCPCMatrix", "mat4x4<f32>"), e.UBO.addEntry("PCSCMatrix", "mat4x4<f32>"), e.UBO.addEntry("SCVCMatrix", "mat4x4<f32>"), e.UBO.addEntry("VCPCMatrix", "mat4x4<f32>"), e.UBO.addEntry("WCVCNormals", "mat4x4<f32>"), e.UBO.addEntry("viewportSize", "vec2<f32>"), e.UBO.addEntry("LightCount", "i32"), e.UBO.addEntry("MaxEnvironmentMipLevel", "f32"), e.UBO.addEntry("BackgroundDiffuseStrength", "f32"), e.UBO.addEntry("BackgroundSpecularStrength", "f32"), e.UBO.addEntry("cameraParallel", "u32"), e.SSBO = jB.newInstance({
            label: "rendererLightSSBO"
        }), e.lightTimeString = "", e.bindGroup = cE.newInstance({
            label: "rendererBG"
        }), e.bindGroup.setBindables([
            e.UBO,
            e.SSBO
        ]), e.tmpMat4 = Ot(new Float64Array(16)), e.stabilizedTime = {}, tr(e.stabilizedTime, {
            mtime: 0
        }), La(t, e, [
            "bindGroup",
            "stabilizedTime"
        ]), rf(t, e, [
            "stabilizedCenter"
        ]), si(t, e, [
            "renderEncoder",
            "selector",
            "suppressClear",
            "UBO"
        ]), QB(t, e);
    }
    const nG = kn(tG, "vtkWebGPURenderer");
    sf("vtkRenderer", nG);
    function rG(t, e) {
        e.classHierarchy.push("vtkWebGPUSampler"), t.create = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            e.device = n, e.options.addressModeU = r.addressModeU ? r.addressModeU : "clamp-to-edge", e.options.addressModeV = r.addressModeV ? r.addressModeV : "clamp-to-edge", e.options.addressModeW = r.addressModeW ? r.addressModeW : "clamp-to-edge", e.options.magFilter = r.magFilter ? r.magFilter : "nearest", e.options.minFilter = r.minFilter ? r.minFilter : "nearest", e.options.mipmapFilter = r.mipmapFilter ? r.mipmapFilter : "nearest", e.options.label = e.label, e.handle = e.device.getHandle().createSampler(e.options), e.bindGroupTime.modified();
        }, t.getShaderCode = (n, r)=>`@binding(${n}) @group(${r}) var ${e.label}: sampler;`, t.getBindGroupEntry = ()=>({
                resource: e.handle
            });
    }
    const iG = {
        device: null,
        handle: null,
        label: null,
        options: null
    };
    function xE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, iG, n), K.obj(t, e), e.options = {}, e.bindGroupLayoutEntry = {
            visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
            sampler: {}
        }, e.bindGroupTime = {}, K.obj(e.bindGroupTime, {
            mtime: 0
        }), K.get(t, e, [
            "bindGroupTime",
            "handle",
            "options"
        ]), K.setGet(t, e, [
            "bindGroupLayoutEntry",
            "device",
            "label"
        ]), rG(t, e);
    }
    const aG = K.newInstance(xE);
    oG = {
        newInstance: aG,
        extend: xE
    };
    const { SlicingMode: Q9 } = Ap, sG = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::Image::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  //VTK::Image::Sample

  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);

//VTK::RenderEncoder::Impl

  return output;
}
`;
    function cG(t, e, n) {
        if (e.apply(t)) {
            const i = t.getIndependentComponents();
            return `${t.getMTime()}-${i}-${n}`;
        }
        return "0";
    }
    const po = new Float64Array(16), zs = new Float64Array(16), x1 = new Float64Array(16), bc = new Float64Array(4), ii = new Float64Array(4);
    function lG(t, e) {
        e.classHierarchy.push("vtkWebGPUImageMapper"), t.buildPass = (i)=>{
            if (i) {
                e.WebGPUImageSlice = t.getFirstAncestorOfType("vtkWebGPUImageSlice"), e.WebGPURenderer = e.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent(), e.device = e.WebGPURenderWindow.getDevice();
                const a = e.WebGPURenderer.getRenderable();
                e.renderable.getSliceAtFocalPoint() && e.renderable.setSliceFromCamera(a.getActiveCamera());
            }
        }, t.translucentPass = (i)=>{
            i && t.render();
        }, t.opaquePass = (i)=>{
            i && t.render();
        }, t.render = ()=>{
            e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.prepareToDraw(e.WebGPURenderer.getRenderEncoder()), e.renderEncoder.registerDrawCallback(e.pipeline, t.draw);
        }, t.computePipelineHash = ()=>{
            const i = e.currentInput.getExtent();
            i[0] === i[1] || i[2] === i[3] || i[4] === i[5] ? (e.dimensions = 2, e.pipelineHash = "img2") : (e.dimensions = 3, e.pipelineHash = "img3");
        }, t.updateUBO = ()=>{
            const i = e.UBO.getSendTime(), a = e.WebGPUImageSlice.getRenderable(), o = a.getMapper();
            if (t.getMTime() > i || e.renderable.getMTime() > i || a.getProperty().getMTime() > i) {
                const s = o.getInputData(), c = e.WebGPURenderer.getStabilizedCenterByReference();
                Ot(po), qr(po, po, c);
                const l = a.getMatrix();
                cn(zs, l), Xr(zs, zs), Qt(po, zs, po);
                const f = s.getWorldToIndex();
                Qt(po, f, po), Xr(x1, po), Yd(zs, [
                    .5,
                    .5,
                    .5
                ]), Qt(po, zs, po);
                const u = s.getDimensions();
                Ot(zs), nc(zs, zs, [
                    1 / u[0],
                    1 / u[1],
                    1 / u[2]
                ]), Qt(po, zs, po), e.UBO.setArray("SCTCMatrix", po);
                const g = e.currentInput.getExtent(), { ijkMode: h } = e.renderable.getClosestIJKAxis();
                let v = e.renderable.getSlice();
                h !== e.renderable.getSlicingMode() && (v = e.renderable.getSliceAtPosition(v));
                let m = 2, y = 0, C = 1;
                h === Q9.I ? (m = 0, y = 1, C = 2) : h === Q9.J && (m = 1, y = 2, C = 0), bc[m] = v, bc[y] = g[y * 2] - .5, bc[C] = g[C * 2] - .5, bc[3] = 1, Ll(bc, bc, x1), e.UBO.setArray("Origin", bc), ii[m] = v, ii[y] = g[y * 2 + 1] + .5, ii[C] = g[C * 2] - .5, ii[3] = 1, Ll(ii, ii, x1), R9(ii, ii, bc), ii[3] = 1, e.UBO.setArray("Axis1", ii), ii[m] = v, ii[y] = g[y * 2] - .5, ii[C] = g[C * 2 + 1] + .5, ii[3] = 1, Ll(ii, ii, x1), R9(ii, ii, bc), ii[3] = 1, e.UBO.setArray("Axis2", ii);
                const T = [
                    1,
                    1,
                    1,
                    1
                ], x = [
                    0,
                    0,
                    0,
                    0
                ], S = e.textureViews[0], D = S.getTexture().getScale(), _ = S.getTexture().getNumberOfComponents();
                for(let M = 0; M < _; M++){
                    let P = a.getProperty().getColorWindow(), F = a.getProperty().getColorLevel();
                    const B = a.getProperty().getRGBTransferFunction(0);
                    if (B) {
                        const G = B.getRange();
                        P = G[1] - G[0], F = .5 * (G[1] + G[0]);
                    }
                    T[M] = D / P, x[M] = -F / P + .5;
                }
                e.UBO.setArray("cScale", T), e.UBO.setArray("cShift", x), e.UBO.sendIfNeeded(e.device);
            }
        }, t.updateLUTImage = ()=>{
            const i = e.WebGPUImageSlice.getRenderable().getProperty();
            t.getTextureViews()[0].getTexture().getNumberOfComponents();
            const o = 1, s = cG(i, i.getRGBTransferFunction, o);
            if (e.colorTextureString !== s) {
                e.numRows = o;
                const c = new Uint8ClampedArray(e.numRows * 2 * e.rowLength * 4);
                let l = i.getRGBTransferFunction();
                if (l) {
                    const f = new Float32Array(e.rowLength * 3);
                    for(let u = 0; u < o; u++){
                        l = i.getRGBTransferFunction(u);
                        const g = l.getRange();
                        l.getTable(g[0], g[1], e.rowLength, f, 1);
                        for(let h = 0; h < e.rowLength; h++){
                            const v = u * e.rowLength * 8 + h * 4;
                            c[v] = 255 * f[h * 3], c[v + 1] = 255 * f[h * 3 + 1], c[v + 2] = 255 * f[h * 3 + 2], c[v + 3] = 255;
                            for(let m = 0; m < 4; m++)c[v + e.rowLength * 4 + m] = c[v + m];
                        }
                    }
                } else for(let f = 0; f < e.rowLength; ++f){
                    const u = 255 * f / (e.rowLength - 1);
                    c[f * 4] = u, c[f * 4 + 1] = u, c[f * 4 + 2] = u, c[f * 4 + 3] = 255;
                    for(let g = 0; g < 4; g++)c[f * 4 + e.rowLength * 4 + g] = c[f * 4 + g];
                }
                {
                    const f = {
                        nativeArray: c,
                        width: e.rowLength,
                        height: e.numRows * 2,
                        depth: 1,
                        format: "rgba8unorm"
                    }, g = e.device.getTextureManager().getTexture(f).createView("tfunTexture");
                    e.textureViews[1] = g;
                }
                e.colorTextureString = s;
            }
        };
        const n = t.updateBuffers;
        t.updateBuffers = ()=>{
            n();
            const i = e.device.getTextureManager().getTextureForImageData(e.currentInput), a = e.textureViews;
            if (!a[0] || a[0].getTexture() !== i) {
                const c = i.createView("imgTexture");
                a[0] = c;
            }
            t.updateLUTImage(), t.updateUBO();
            const s = e.WebGPUImageSlice.getRenderable().getProperty().getInterpolationType() === b0.NEAREST ? "nearest" : "linear";
            (!e.clampSampler || s !== e.clampSampler.getOptions().minFilter) && (e.clampSampler = oG.newInstance({
                label: "clampSampler"
            }), e.clampSampler.create(e.device, {
                minFilter: s,
                magFilter: s
            }), e.additionalBindables = [
                e.clampSampler
            ]);
        };
        const r = t.getShaderReplacements();
        t.replaceShaderPosition = (i, a, o)=>{
            const s = a.getShaderDescription("vertex");
            s.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
            let c = s.getCode();
            const l = [
                "var pos: vec4<f32> = mapperUBO.Origin +",
                "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;",
                "pos.w = 1.0;"
            ];
            e.dimensions === 2 ? l.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;") : l.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;"), l.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;"), c = wo.substitute(c, "//VTK::Position::Impl", l).result, s.setCode(c);
        }, r.set("replaceShaderPosition", t.replaceShaderPosition), t.replaceShaderTCoord = (i, a, o)=>{
            const s = a.getShaderDescription("vertex");
            e.dimensions === 2 ? s.addOutput("vec2<f32>", "tcoordVS") : s.addOutput("vec3<f32>", "tcoordVS");
        }, r.set("replaceShaderTCoord", t.replaceShaderTCoord), t.replaceShaderImage = (i, a, o)=>{
            const s = a.getShaderDescription("fragment");
            let c = s.getCode();
            e.dimensions === 3 ? c = wo.substitute(c, "//VTK::Image::Sample", [
                "    var computedColor: vec4<f32> =",
                "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);",
                "//VTK::Image::Sample"
            ]).result : c = wo.substitute(c, "//VTK::Image::Sample", [
                "    var computedColor: vec4<f32> =",
                "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);",
                "//VTK::Image::Sample"
            ]).result, c = wo.substitute(c, "//VTK::Image::Sample", [
                "    var coord: vec2<f32> =",
                "      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);",
                "    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);"
            ]).result, s.setCode(c);
        }, r.set("replaceShaderImage", t.replaceShaderImage);
    }
    const uG = {
        rowLength: 1024
    };
    function fG(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, uG, n), Uv.extend(t, e, n), t.setFragmentShaderTemplate(sG), e.UBO = vd.newInstance({
            label: "mapperUBO"
        }), e.UBO.addEntry("SCTCMatrix", "mat4x4<f32>"), e.UBO.addEntry("Origin", "vec4<f32>"), e.UBO.addEntry("Axis2", "vec4<f32>"), e.UBO.addEntry("Axis1", "vec4<f32>"), e.UBO.addEntry("cScale", "vec4<f32>"), e.UBO.addEntry("cShift", "vec4<f32>"), e.lutBuildTime = {}, tr(e.lutBuildTime, {
            mtime: 0
        }), e.imagemat = Ot(new Float64Array(16)), e.imagematinv = Ot(new Float64Array(16)), e.VBOBuildTime = {}, tr(e.VBOBuildTime), lG(t, e);
    }
    const dG = kn(fG, "vtkWebGPUImageMapper");
    sf("vtkImageMapper", dG);
    function gG(t, e) {
        e.classHierarchy.push("vtkWebGPUImageSlice"), t.buildPass = (n)=>{
            if (!(!e.renderable || !e.renderable.getVisibility()) && n) {
                if (!e.renderable) return;
                e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), t.prepareNodes(), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes();
            }
        }, t.traverseOpaquePass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children.forEach((r)=>{
                r.traverse(n);
            }), t.apply(n, !1));
        }, t.traverseTranslucentPass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e.WebGPURenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.children.forEach((r)=>{
                r.traverse(n);
            }), t.apply(n, !1));
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
            }
        }, t.getBufferShift = (n)=>(t.getKeyMatrices(n), e.bufferShift), t.getKeyMatrices = (n)=>{
            if (Math.max(e.renderable.getMTime(), n.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
                e.renderable.computeMatrix();
                const r = e.renderable.getMatrix(), i = n.getStabilizedCenterByReference();
                e.bufferShift[0] = r[3] - i[0], e.bufferShift[1] = r[7] - i[1], e.bufferShift[2] = r[11] - i[2], cn(e.keyMatrices.bcwc, r), e.renderable.getIsIdentity() ? Ot(e.keyMatrices.normalMatrix) : (Ur(e.keyMatrices.normalMatrix, e.keyMatrices.bcwc), e.keyMatrices.normalMatrix[3] = 0, e.keyMatrices.normalMatrix[7] = 0, e.keyMatrices.normalMatrix[11] = 0, Xr(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), cn(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix)), qr(e.keyMatrices.bcwc, e.keyMatrices.bcwc, [
                    -e.bufferShift[0],
                    -e.bufferShift[1],
                    -e.bufferShift[2]
                ]), qr(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
                    -i[0],
                    -i[1],
                    -i[2]
                ]), e.keyMatricesTime.modified();
            }
            return e.keyMatrices;
        };
    }
    const hG = {
        bufferShift: void 0,
        keyMatrixTime: null,
        keyMatrices: null,
        propID: void 0
    };
    function pG(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, hG, n), Yr.extend(t, e, n), e.keyMatricesTime = {}, tr(e.keyMatricesTime, {
            mtime: 0
        }), e.keyMatrices = {
            normalMatrix: new Float64Array(16),
            bcwc: new Float64Array(16),
            bcsc: new Float64Array(16)
        }, e.keyMatrixTime = {}, tr(e.keyMatrixTime, {
            mtime: 0
        }), e.keyMatrices = {
            mcwc: Ot(new Float64Array(16))
        }, e.bufferShift = [
            0,
            0,
            0,
            0
        ], La(t, e, [
            "propID",
            "keyMatricesTime"
        ]), gG(t, e);
    }
    const mG = kn(pG, "vtkWebGPUImageSlice");
    sf("vtkImageSlice", mG);
    function vG(t, e) {
        e.classHierarchy.push("vtkWebGPUVolume"), t.buildPass = (i)=>{
            !e.renderable || !e.renderable.getVisibility() || i && (e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow"), e.propID === void 0 && (e.propID = e.WebGPURenderWindow.getUniquePropID()), e.renderable.getMapper().update());
        }, t.queryPass = (i, a)=>{
            if (i) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                const o = e.renderable.getMapper().getBounds();
                if (!o || o.length !== 6 || o[0] > o[1]) return;
                a.addVolume(t);
            }
        };
        const n = new Float64Array(3), r = new Float64Array(3);
        t.getBoundingCubePoints = (i, a)=>{
            const o = e.renderable.getMapper().getInputData();
            if (!o) return;
            const s = o.getExtent(), c = e.renderable.getMatrix();
            let l = 0;
            for(let f = 4; f < 6; f++){
                n[2] = s[f];
                for(let u = 2; u < 4; u++){
                    n[1] = s[u];
                    for(let g = 0; g < 2; g++){
                        n[0] = s[g], o.indexToWorld(n, r);
                        let h = a + l * 3;
                        i[h++] = c[0] * r[0] + c[1] * r[1] + c[2] * r[2] + c[3], i[h++] = c[4] * r[0] + c[5] * r[1] + c[6] * r[2] + c[7], i[h++] = c[8] * r[0] + c[9] * r[1] + c[10] * r[2] + c[11], l++;
                    }
                }
            }
        }, t.getKeyMatrices = (i)=>{
            if (Math.max(e.renderable.getMTime(), i.getStabilizedTime()) > e.keyMatricesTime.getMTime()) {
                e.renderable.computeMatrix();
                const a = e.renderable.getMatrix(), o = i.getStabilizedCenterByReference();
                cn(e.keyMatrices.bcwc, a), qr(e.keyMatrices.bcsc, e.keyMatrices.bcwc, [
                    -o[0],
                    -o[1],
                    -o[2]
                ]), e.keyMatricesTime.modified();
            }
            return e.keyMatrices;
        };
    }
    const yG = {
        propID: void 0,
        keyMatricesTime: null
    };
    function CG(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, yG, n), Yr.extend(t, e, n), e.keyMatricesTime = {}, K.obj(e.keyMatricesTime, {
            mtime: 0
        }), e.keyMatrices = {
            bcwc: new Float64Array(16),
            bcsc: new Float64Array(16)
        }, K.get(t, e, [
            "propID",
            "keyMatricesTime"
        ]), vG(t, e);
    }
    const wG = K.newInstance(CG, "vtkWebGPUVolume");
    sf("vtkVolume", wG);
    function TG(t, e) {
        e.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper"), t.opaquePass = (n, r)=>{
            e.WebGPURenderer = t.getFirstAncestorOfType("vtkWebGPURenderer"), e.WebGPURenderWindow = e.WebGPURenderer.getParent();
            const i = e.WebGPURenderer.getAspectRatio(), a = e.WebGPURenderer ? e.WebGPURenderer.getRenderable().getActiveCamera() : null, o = e.WebGPURenderer.getTiledSizeAndOrigin(), s = null;
            e.renderable.getUseZValues(), e.renderable.invokeCallback(e.renderable.getInputData(), a, i, o, s);
        };
    }
    const xG = {};
    function SG(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, xG, n), Yr.extend(t, e, n), TG(t, e);
    }
    const EG = K.newInstance(SG, "vtkWebGPUPixelSpaceCallbackMapper");
    sf("vtkPixelSpaceCallbackMapper", EG);
    const ds = {
        UNCHANGED: 0,
        SINGLE_POINT: 1,
        X_LINE: 2,
        Y_LINE: 3,
        Z_LINE: 4,
        XY_PLANE: 5,
        YZ_PLANE: 6,
        XZ_PLANE: 7,
        XYZ_GRID: 8,
        EMPTY: 9
    };
    var SE = {
        StructuredType: ds
    };
    const { StructuredType: Lc } = SE;
    function DG(t) {
        let e = 0;
        for(let n = 0; n < 3; ++n)t[n * 2] < t[n * 2 + 1] && e++;
        return t[0] > t[1] || t[2] > t[3] || t[4] > t[5] ? Lc.EMPTY : e === 3 ? Lc.XYZ_GRID : e === 2 ? t[0] === t[1] ? Lc.YZ_PLANE : t[2] === t[3] ? Lc.XZ_PLANE : Lc.XY_PLANE : e === 1 ? t[0] < t[1] ? Lc.X_LINE : t[2] < t[3] ? Lc.Y_LINE : Lc.Z_LINE : Lc.SINGLE_POINT;
    }
    var _G = {
        getDataDescriptionFromExtent: DG,
        ...SE
    };
    const { vtkErrorMacro: m0 } = K;
    function RG(t, e) {
        e.classHierarchy.push("vtkImageData"), t.setExtent = function() {
            if (e.deleted) return m0("instance deleted - cannot call any method"), !1;
            for(var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i];
            const a = r.length === 1 ? r[0] : r;
            if (a.length !== 6) return !1;
            const o = e.extent.some((s, c)=>s !== a[c]);
            return o && (e.extent = a.slice(), e.dataDescription = _G.getDataDescriptionFromExtent(e.extent), t.modified()), o;
        }, t.setDimensions = function() {
            let n, r, i;
            if (e.deleted) {
                m0("instance deleted - cannot call any method");
                return;
            }
            if (arguments.length === 1) {
                const a = arguments.length <= 0 ? void 0 : arguments[0];
                n = a[0], r = a[1], i = a[2];
            } else if (arguments.length === 3) n = arguments.length <= 0 ? void 0 : arguments[0], r = arguments.length <= 1 ? void 0 : arguments[1], i = arguments.length <= 2 ? void 0 : arguments[2];
            else {
                m0("Bad dimension specification");
                return;
            }
            t.setExtent(0, n - 1, 0, r - 1, 0, i - 1);
        }, t.getDimensions = ()=>[
                e.extent[1] - e.extent[0] + 1,
                e.extent[3] - e.extent[2] + 1,
                e.extent[5] - e.extent[4] + 1
            ], t.getNumberOfCells = ()=>{
            const n = t.getDimensions();
            let r = 1;
            for(let i = 0; i < 3; i++){
                if (n[i] === 0) return 0;
                n[i] > 1 && (r *= n[i] - 1);
            }
            return r;
        }, t.getNumberOfPoints = ()=>{
            const n = t.getDimensions();
            return n[0] * n[1] * n[2];
        }, t.getPoint = (n)=>{
            const r = t.getDimensions();
            if (r[0] === 0 || r[1] === 0 || r[2] === 0) return m0("Requesting a point from an empty image."), null;
            const i = new Float64Array(3);
            switch(e.dataDescription){
                case ds.EMPTY:
                    return null;
                case ds.SINGLE_POINT:
                    break;
                case ds.X_LINE:
                    i[0] = n;
                    break;
                case ds.Y_LINE:
                    i[1] = n;
                    break;
                case ds.Z_LINE:
                    i[2] = n;
                    break;
                case ds.XY_PLANE:
                    i[0] = n % r[0], i[1] = n / r[0];
                    break;
                case ds.YZ_PLANE:
                    i[1] = n % r[1], i[2] = n / r[1];
                    break;
                case ds.XZ_PLANE:
                    i[0] = n % r[0], i[2] = n / r[0];
                    break;
                case ds.XYZ_GRID:
                    i[0] = n % r[0], i[1] = n / r[0] % r[1], i[2] = n / (r[0] * r[1]);
                    break;
                default:
                    m0("Invalid dataDescription");
                    break;
            }
            const a = [
                0,
                0,
                0
            ];
            return t.indexToWorld(i, a), a;
        }, t.getBounds = ()=>t.extentToBounds(t.getSpatialExtent()), t.extentToBounds = (n)=>zn.transformBounds(n, e.indexToWorld), t.getSpatialExtent = ()=>zn.inflate([
                ...e.extent
            ], .5), t.computeTransforms = ()=>{
            Yd(e.indexToWorld, e.origin), e.indexToWorld[0] = e.direction[0], e.indexToWorld[1] = e.direction[1], e.indexToWorld[2] = e.direction[2], e.indexToWorld[4] = e.direction[3], e.indexToWorld[5] = e.direction[4], e.indexToWorld[6] = e.direction[5], e.indexToWorld[8] = e.direction[6], e.indexToWorld[9] = e.direction[7], e.indexToWorld[10] = e.direction[8], nc(e.indexToWorld, e.indexToWorld, e.spacing), Xr(e.worldToIndex, e.indexToWorld);
        }, t.indexToWorld = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            return pn(r, n, e.indexToWorld), r;
        }, t.indexToWorldVec3 = t.indexToWorld, t.worldToIndex = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            return pn(r, n, e.worldToIndex), r;
        }, t.worldToIndexVec3 = t.worldToIndex, t.indexToWorldBounds = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            return zn.transformBounds(n, e.indexToWorld, r);
        }, t.worldToIndexBounds = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            return zn.transformBounds(n, e.worldToIndex, r);
        }, t.onModified(t.computeTransforms), t.computeTransforms(), t.getCenter = ()=>zn.getCenter(t.getBounds()), t.computeHistogram = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            const i = [
                0,
                0,
                0,
                0,
                0,
                0
            ];
            t.worldToIndexBounds(n, i);
            const a = [
                0,
                0,
                0
            ], o = [
                0,
                0,
                0
            ];
            zn.computeCornerPoints(i, a, o), wv(a, a), wv(o, o);
            const s = t.getDimensions();
            xv(a, [
                0,
                0,
                0
            ], [
                s[0] - 1,
                s[1] - 1,
                s[2] - 1
            ], a), xv(o, [
                0,
                0,
                0
            ], [
                s[0] - 1,
                s[1] - 1,
                s[2] - 1
            ], o);
            const c = s[0], l = s[0] * s[1], f = t.getPointData().getScalars().getData();
            let u = -1 / 0, g = 1 / 0, h = 0, v = 0, m = 0;
            for(let x = a[2]; x <= o[2]; x++)for(let S = a[1]; S <= o[1]; S++){
                let D = a[0] + S * c + x * l;
                for(let _ = a[0]; _ <= o[0]; _++){
                    if (!r || r([
                        _,
                        S,
                        x
                    ], i)) {
                        const M = f[D];
                        M > u && (u = M), M < g && (g = M), h += M * M, v += M, m += 1;
                    }
                    ++D;
                }
            }
            const y = m > 0 ? v / m : 0, C = m ? Math.abs(h / m - y * y) : 0, T = Math.sqrt(C);
            return {
                minimum: g,
                maximum: u,
                average: y,
                variance: C,
                sigma: T,
                count: m
            };
        }, t.computeIncrements = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            const i = [];
            let a = r;
            for(let o = 0; o < 3; ++o)i[o] = a, a *= n[o * 2 + 1] - n[o * 2] + 1;
            return i;
        }, t.computeOffsetIndex = (n)=>{
            let [r, i, a] = n;
            const o = t.getExtent(), s = t.getPointData().getScalars().getNumberOfComponents(), c = t.computeIncrements(o, s);
            return Math.floor((Math.round(r) - o[0]) * c[0] + (Math.round(i) - o[2]) * c[1] + (Math.round(a) - o[4]) * c[2]);
        }, t.getOffsetIndexFromWorld = (n)=>{
            const r = t.getExtent(), i = t.worldToIndex(n);
            for(let a = 0; a < 3; ++a)if (i[a] < r[a * 2] || i[a] > r[a * 2 + 1]) return m0(`GetScalarPointer: Pixel ${i} is not in memory. Current extent = ${r}`), NaN;
            return t.computeOffsetIndex(i);
        }, t.getScalarValueFromWorld = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const i = t.getPointData().getScalars().getNumberOfComponents();
            if (r < 0 || r >= i) return m0(`GetScalarPointer: Scalar Component ${r} is not within bounds. Current Scalar numberOfComponents: ${i}`), NaN;
            const a = t.getOffsetIndexFromWorld(n);
            return Number.isNaN(a) ? a : t.getPointData().getScalars().getComponent(a, r);
        };
    }
    const OG = {
        direction: null,
        indexToWorld: null,
        worldToIndex: null,
        spacing: [
            1,
            1,
            1
        ],
        origin: [
            0,
            0,
            0
        ],
        extent: [
            0,
            -1,
            0,
            -1,
            0,
            -1
        ],
        dataDescription: ds.EMPTY
    };
    function EE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, OG, n), of.extend(t, e, n), e.direction ? Array.isArray(e.direction) && (e.direction = new Float64Array(e.direction.slice(0, 9))) : e.direction = Ts(new Float64Array(9)), e.indexToWorld = new Float64Array(16), e.worldToIndex = new Float64Array(16), K.get(t, e, [
            "indexToWorld",
            "worldToIndex"
        ]), K.setGetArray(t, e, [
            "origin",
            "spacing"
        ], 3), K.setGetArray(t, e, [
            "direction"
        ], 9), K.getArray(t, e, [
            "extent"
        ], 6), RG(t, e);
    }
    const IG = K.newInstance(EE, "vtkImageData");
    var Up = {
        newInstance: IG,
        extend: EE
    };
    const eC = [
        [
            0,
            -1,
            0
        ],
        [
            0,
            1,
            0
        ],
        [
            0,
            0,
            -1
        ],
        [
            0,
            0,
            1
        ]
    ], tC = [
        [
            0,
            -1,
            0
        ],
        [
            0,
            1,
            0
        ]
    ], MG = [
        [
            0,
            -1,
            0
        ],
        [
            0,
            1,
            0
        ],
        [
            0,
            0,
            -1
        ]
    ], bG = [
        [
            0,
            -1,
            0
        ],
        [
            0,
            1,
            0
        ],
        [
            0,
            0,
            1
        ]
    ];
    class Ru {
        static copyMap(e, n) {
            for (const [r, i] of n.rows)e.rows.set(r, structuredClone(i));
        }
        constructor(e, n, r = 1){
            this.rows = new Map, this.height = 1, this.width = 1, this.depth = 1, this.jMultiple = 1, this.kMultiple = 1, this.numComps = 1, this.pixelDataConstructor = Uint8Array, this.updateScalarData = function(i) {
                i.fill(0);
                const a = (o, s, c)=>{
                    const { start: l, end: f, value: u } = s;
                    for(let g = l; g < f; g++)i[o + g] = u;
                };
                this.forEach(a);
            }, this.get = (i)=>{
                const a = i % this.jMultiple, o = (i - a) / this.jMultiple;
                return this.getRLE(a, o)?.value ?? this.defaultValue;
            }, this.getRun = (i, a)=>{
                const o = i + a * this.height;
                return this.rows.get(o);
            }, this.set = (i, a)=>{
                if (a === void 0) return;
                const o = i % this.width, s = (i - o) / this.width, c = this.rows.get(s);
                if (!c) {
                    this.rows.set(s, [
                        {
                            start: o,
                            end: o + 1,
                            value: a
                        }
                    ]);
                    return;
                }
                const l = this.findIndex(c, o), f = c[l], u = c[l - 1];
                if (!f) {
                    if (!u || u.value !== a || u.end !== o) {
                        c[l] = {
                            start: o,
                            end: o + 1,
                            value: a
                        };
                        return;
                    }
                    u.end++;
                    return;
                }
                const { start: g, end: h, value: v } = f;
                if (a === v && o >= g) return;
                const m = {
                    start: o,
                    end: o + 1,
                    value: a
                }, y = o > g, C = y ? l + 1 : l, T = y ? f : u;
                let x = y ? c[l + 1] : f;
                if (T?.value === a && T?.end === o) {
                    T.end++, x?.value === a && x.start === o + 1 ? (T.end = x.end, c.splice(l, 1)) : x?.start === o && (x.start++, x.start === x.end && (c.splice(l, 1), x = c[l], x?.start === o + 1 && x.value === a && (T.end = x.end, c.splice(l, 1))));
                    return;
                }
                if (x?.value === a && x.start === o + 1) {
                    x.start--, T?.end > o && (T.end = o, T.end === T.start && c.splice(l, 1));
                    return;
                }
                if (x?.start === o && x.end === o + 1) {
                    x.value = a;
                    const S = c[l + 1];
                    S?.start == o + 1 && S.value === a && (c.splice(l + 1, 1), x.end = S.end);
                    return;
                }
                o === x?.start && x.start++, y && h > o + 1 ? c.splice(C, 0, m, {
                    start: o + 1,
                    end: T.end,
                    value: T.value
                }) : c.splice(C, 0, m), T?.end > o && (T.end = o);
            }, this.width = e, this.height = n, this.depth = r, this.jMultiple = e, this.kMultiple = this.jMultiple * n;
        }
        static{
            this.getScalarData = function(e = Uint8ClampedArray) {
                const n = new e(this.frameSize);
                return this.map.updateScalarData(n), n;
            };
        }
        toIJK(e) {
            const n = e % this.jMultiple, r = (e - n) / this.jMultiple % this.height, i = Math.floor(e / this.kMultiple);
            return [
                n,
                r,
                i
            ];
        }
        toIndex([e, n, r]) {
            return e + r * this.kMultiple + n * this.jMultiple;
        }
        getRLE(e, n, r = 0) {
            const i = this.rows.get(n + r * this.height);
            if (!i) return;
            const a = this.findIndex(i, e), o = i[a];
            return e >= o?.start ? o : void 0;
        }
        has(e) {
            const n = e % this.jMultiple, r = (e - n) / this.jMultiple;
            return this.getRLE(n, r)?.value !== void 0;
        }
        delete(e) {
            const n = e % this.width, r = (e - n) / this.width, i = this.rows.get(r);
            if (!i) return;
            const a = this.findIndex(i, n), o = i[a];
            if (!o || o.start > n) return;
            if (o.end === n + 1) {
                o.end--, o.start >= o.end && (i.splice(a, 1), i.length || this.rows.delete(r));
                return;
            }
            if (o.start === n) {
                o.start++;
                return;
            }
            const s = {
                value: o.value,
                start: n + 1,
                end: o.end
            };
            o.end = n, i.splice(a + 1, 0, s);
        }
        findIndex(e, n) {
            for(let r = 0; r < e.length; r++){
                const { end: i } = e[r];
                if (n < i) return r;
            }
            return e.length;
        }
        forEach(e, n) {
            const r = n?.rowModified;
            for (const [i, a] of this.rows){
                const o = r ? [
                    ...a
                ] : a;
                for (const s of o)e(i * this.width, s, a);
            }
        }
        forEachRow(e) {
            for (const [n, r] of this.rows)e(n * this.width, r);
        }
        clear() {
            this.rows.clear();
        }
        keys() {
            return [
                ...this.rows.keys()
            ];
        }
        getPixelData(e = 0, n) {
            n ? n.fill(0) : n = new this.pixelDataConstructor(this.width * this.height * this.numComps);
            const { width: r, height: i, numComps: a } = this;
            for(let o = 0; o < i; o++){
                const s = this.getRun(o, e);
                if (s) if (a === 1) for (const c of s){
                    const l = o * r, { start: f, end: u, value: g } = c;
                    for(let h = f; h < u; h++)n[l + h] = g;
                }
                else for (const c of s){
                    const l = o * r * a, { start: f, end: u, value: g } = c;
                    for(let h = f; h < u; h += a)for(let v = 0; v < a; v++)n[l + h + v] = g[v];
                }
            }
            return n;
        }
        floodFill(e, n, r, i, a) {
            const o = this.getRLE(e, n, r);
            if (!o) throw new Error(`Initial point ${e},${n},${r} isn't in the RLE`);
            const s = [
                [
                    o,
                    n,
                    r
                ]
            ], c = o.value;
            if (c === i) throw new Error(`source (${c}) and destination (${i}) are identical`);
            return this.flood(s, c, i, a);
        }
        flood(e, n, r, i) {
            let a = 0;
            const { planar: o = !0, diagonals: s = !0, singlePlane: c = !1 } = i || {}, l = {
                planar: o,
                diagonals: s,
                singlePlane: c
            };
            for(; e.length;){
                const f = e.pop(), [u] = f;
                if (u.value !== n) continue;
                u.value = r, a += u.end - u.start;
                const g = this.findAdjacents(f, l).filter((h)=>h && h[0].value === n);
                e.push(...g);
            }
            return a;
        }
        fillFrom(e, n) {
            for(let r = n[2][0]; r <= n[2][1]; r++)for(let i = n[1][0]; i <= n[1][1]; i++){
                let a, o;
                for(let s = n[0][0]; s <= n[0][1]; s++){
                    const c = e(s, i, r);
                    if (c === void 0) {
                        a = void 0;
                        continue;
                    }
                    o || (o = [], this.rows.set(i + r * this.height, o)), a && a.value !== c && (a = void 0), a || (a = {
                        start: s,
                        end: s,
                        value: c
                    }, o.push(a)), a.end++;
                }
            }
        }
        findAdjacents(e, { diagonals: n = !0, planar: r = !0, singlePlane: i = !1 }) {
            const [a, o, s, c] = e, { start: l, end: f } = a, u = l > 0 && this.getRLE(l - 1, o, s), g = f < this.width && this.getRLE(f, o, s), h = n ? [
                l > 0 ? l - 1 : l,
                f < this.width ? f + 1 : f
            ] : [
                l,
                f
            ], v = [];
            u && v.push([
                u,
                o,
                s
            ]), g && v.push([
                g,
                o,
                s
            ]);
            for (const m of c || (i ? tC : eC)){
                const [, y, C] = m, T = y + o, x = C + s;
                if (T < 0 || T >= this.height || x < 0 || x >= this.depth) continue;
                const S = this.getRun(T, x);
                if (S) for (const D of S){
                    const _ = c || i && tC || r && C > 0 && bG || r && C < 0 && MG || eC;
                    D.end <= h[0] || D.start >= h[1] || v.push([
                        D,
                        T,
                        x,
                        _
                    ]);
                }
            }
            return v;
        }
    }
    let dh = class cd {
        constructor(e = {}){
            this._dimensions = 3, this._length = 0, this._byteSize = 4, this.growSize = 128;
            const { initialSize: n = 1024, dimensions: r = 3, growSize: i = 128 } = e, a = n * r;
            this.growSize = i, this.array = new ArrayBuffer(a * this._byteSize), this.data = new Float32Array(this.array), this._dimensions = r;
        }
        forEach(e) {
            for(let n = 0; n < this._length; n++)e(this.getPoint(n), n);
        }
        get length() {
            return this._length;
        }
        get dimensions() {
            return this._dimensions;
        }
        get dimensionLength() {
            return this._length * this._dimensions;
        }
        getPoint(e) {
            if (e < 0 && (e += this._length), e < 0 || e >= this._length) return;
            const n = this._dimensions * e;
            return this.data.subarray(n, n + this._dimensions);
        }
        getPointArray(e) {
            const n = [];
            if (e < 0 && (e += this._length), e < 0 || e >= this._length) return;
            const r = this._dimensions * e;
            for(let i = 0; i < this._dimensions; i++)n.push(this.data[i + r]);
            return n;
        }
        grow(e = 1, n = this.growSize) {
            if (this.dimensionLength + e * this._dimensions <= this.data.length) return;
            const r = this.data.length + n, i = new ArrayBuffer(r * this._dimensions * this._byteSize), a = new Float32Array(i);
            a.set(this.data), this.data = a, this.array = i;
        }
        reverse() {
            const e = Math.floor(this._length / 2);
            for(let n = 0; n < e; n++){
                const r = n * this._dimensions, i = (this._length - 1 - n) * this._dimensions;
                for(let a = 0; a < this._dimensions; a++){
                    const o = this.data[r + a];
                    this.data[r + a] = this.data[i + a], this.data[i + a] = o;
                }
            }
        }
        getTypedArray() {
            return this.data;
        }
        push(e) {
            this.grow(1);
            const n = this.length * this._dimensions;
            for(let r = 0; r < this._dimensions; r++)this.data[r + n] = e[r];
            this._length++;
        }
        map(e) {
            const n = [];
            for(let r = 0; r < this._length; r++)n.push(e(this.getPoint(r), r));
            return n;
        }
        get points() {
            return this.map((e)=>e);
        }
        toXYZ() {
            const e = {
                x: [],
                y: []
            };
            this._dimensions >= 3 && (e.z = []);
            const { x: n, y: r, z: i } = e;
            return this.forEach((a)=>{
                n.push(a[0]), r.push(a[1]), i && i.push(a[2]);
            }), e;
        }
        static fromXYZ({ x: e, y: n, z: r }) {
            const i = cd.create3(e.length);
            let a = 0;
            for(let o = 0; o < e.length; o++)i.data[a++] = e[o], i.data[a++] = n[o], i.data[a++] = r ? r[o] : 0;
            return i._length = e.length, i;
        }
        subselect(e = 10, n = 0) {
            const r = new cd({
                initialSize: e,
                dimensions: this._dimensions
            });
            for(let i = 0; i < e; i++){
                const a = (n + Math.floor(this.length * i / e)) % this.length;
                r.push(this.getPoint(a));
            }
            return r;
        }
        static create3(e = 128, n) {
            e = Math.max(e, n?.length || 0);
            const r = new cd({
                initialSize: e,
                dimensions: 3
            });
            return n && n.forEach((i)=>r.push(i)), r;
        }
        static create2(e = 128) {
            return new cd({
                initialSize: e,
                dimensions: 2
            });
        }
    };
    function DE(t) {
        const e = Xe(), n = t.getDimensions(), r = dh.create3(n[0]), i = dh.create3(n[1]), a = dh.create3(n[2]), o = t.getDirection(), s = o.slice(0, 3), c = o.slice(3, 6), l = o.slice(6, 9), f = t.getSpacing(), [u, g, h] = f, v = t.indexToWorld([
            0,
            0,
            0
        ]), m = en(s[0] * u, s[1] * u, s[2] * u), y = en(c[0] * g, c[1] * g, c[2] * g), C = en(l[0] * h, l[1] * h, l[2] * h), T = Xe();
        for(let _ = 0; _ < n[0]; _++)r.push(Qc(T, v, Ys(T, m, _)));
        for(let _ = 0; _ < n[1]; _++)i.push(Ys(T, y, _));
        for(let _ = 0; _ < n[2]; _++)a.push(Ys(T, C, _));
        const x = r.getTypedArray(), S = i.getTypedArray(), D = a.getTypedArray();
        return (_, M = e)=>{
            const [P, F, N] = _, B = P * 3, G = F * 3, Z = N * 3;
            return M[0] = x[B] + S[G] + D[Z], M[1] = x[B + 1] + S[G + 1] + D[Z + 1], M[2] = x[B + 2] + S[G + 2] + D[Z + 2], M;
        };
    }
    function _E(t, e) {
        const { pointInShapeFn: n, callback: r, boundsIJK: i, returnPoints: a = !1 } = e;
        let o;
        if (t.getScalarData) o = t.getScalarData();
        else {
            const u = t.getPointData().getScalars();
            if (u) o = u.getData();
            else {
                const { voxelManager: g } = t.get("voxelManager") || {};
                g && (o = g.getCompleteScalarDataArray());
            }
        }
        const s = t.getDimensions(), c = [
            [
                0,
                s[0]
            ],
            [
                0,
                s[1]
            ],
            [
                0,
                s[2]
            ]
        ], f = LG({
            imageData: t,
            bounds: i || c,
            scalarData: o,
            pointInShapeFn: n,
            callback: r
        });
        return a ? f : void 0;
    }
    function LG({ imageData: t, bounds: e, scalarData: n, pointInShapeFn: r, callback: i }) {
        const [[a, o], [s, c], [l, f]] = e, { numComps: u } = t, g = t.getDimensions(), h = DE(t), v = [
            0,
            0,
            0
        ], m = u || n.length / g[2] / g[1] / g[0], y = g[0] * m, C = g[1] * y, T = [];
        for(let x = l; x <= f; x++){
            v[2] = x;
            const S = x * C;
            for(let D = s; D <= c; D++){
                v[1] = D;
                const _ = S + D * y;
                for(let M = a; M <= o; M++){
                    v[0] = M;
                    const P = h(v);
                    if (r(P, v)) {
                        const F = _ + M * m;
                        let N;
                        m > 2 ? N = [
                            n[F],
                            n[F + 1],
                            n[F + 2]
                        ] : N = n[F], T.push({
                            value: N,
                            index: F,
                            pointIJK: v,
                            pointLPS: P.slice()
                        }), i({
                            value: N,
                            index: F,
                            pointIJK: v,
                            pointLPS: P
                        });
                    }
                }
            }
        }
        return T;
    }
    function PG({ voxelManager: t, bounds: e, imageData: n, pointInShapeFn: r, callback: i, returnPoints: a }) {
        const [[o, s], [c, l], [f, u]] = e, g = DE(n), h = [
            0,
            0,
            0
        ], v = [];
        for(let m = f; m <= u; m++){
            h[2] = m;
            for(let y = c; y <= l; y++){
                h[1] = y;
                for(let C = o; C <= s; C++){
                    h[0] = C;
                    const T = g(h);
                    if (r(T, h)) {
                        const x = t.toIndex(h), S = t.getAtIndex(x);
                        a && v.push({
                            value: S,
                            index: x,
                            pointIJK: [
                                ...h
                            ],
                            pointLPS: T.slice()
                        }), i?.({
                            value: S,
                            index: x,
                            pointIJK: h,
                            pointLPS: T
                        });
                    }
                }
            }
        }
        return v;
    }
    const VG = 5 * 1024;
    $n = class {
        get id() {
            return this._id;
        }
        constructor(e, n){
            this.modifiedSlices = new Set, this.boundsIJK = [
                [
                    1 / 0,
                    -1 / 0
                ],
                [
                    1 / 0,
                    -1 / 0
                ],
                [
                    1 / 0,
                    -1 / 0
                ]
            ], this.scalarData = null, this._sliceDataCache = null, this.getAtIJK = (r, i, a)=>{
                const o = this.toIndex([
                    r,
                    i,
                    a
                ]);
                return this._get(o);
            }, this.setAtIJK = (r, i, a, o)=>{
                const s = this.toIndex([
                    r,
                    i,
                    a
                ]), c = this._set(s, o);
                return c !== !1 && (this.modifiedSlices.add(a), $n.addBounds(this.boundsIJK, [
                    r,
                    i,
                    a
                ])), c;
            }, this.getAtIJKPoint = ([r, i, a])=>this.getAtIJK(r, i, a), this.setAtIJKPoint = ([r, i, a], o)=>{
                this.setAtIJK(r, i, a, o);
            }, this.getAtIndex = (r)=>this._get(r), this.setAtIndex = (r, i)=>{
                const a = this._set(r, i);
                if (a !== !1) {
                    const o = this.toIJK(r);
                    this.modifiedSlices.add(o[2]), $n.addBounds(this.boundsIJK, o);
                }
                return a;
            }, this.getMiddleSliceData = ()=>{
                const r = Math.floor(this.dimensions[2] / 2);
                return this.getSliceData({
                    sliceIndex: r,
                    slicePlane: 2
                });
            }, this.forEach = (r, i = {})=>{
                const a = i.boundsIJK || this.getBoundsIJK(), o = i.isInObject || this.isInObject || (()=>!0), s = i.returnPoints || !1, c = i.imageData, l = Math.min(a[0][0], a[0][1]), f = Math.max(a[0][0], a[0][1]), u = Math.min(a[1][0], a[1][1]), g = Math.max(a[1][0], a[1][1]), h = Math.min(a[2][0], a[2][1]), v = Math.max(a[2][0], a[2][1]), m = [];
                if (c) return PG({
                    voxelManager: this,
                    imageData: i.imageData,
                    bounds: [
                        [
                            l,
                            f
                        ],
                        [
                            u,
                            g
                        ],
                        [
                            h,
                            v
                        ]
                    ],
                    pointInShapeFn: o,
                    callback: r,
                    returnPoints: s
                });
                if (this.map) {
                    if (this.map instanceof Ru) return this.rleForEach(r, i);
                    for (const y of this.map.keys()){
                        const C = this.toIJK(y);
                        if (!o(null, C)) continue;
                        const T = this._get(y);
                        s && m.push({
                            value: T,
                            index: y,
                            pointIJK: C,
                            pointLPS: null
                        }), r({
                            value: T,
                            index: y,
                            pointIJK: C,
                            pointLPS: null
                        });
                    }
                    return m;
                } else {
                    for(let y = h; y <= v; y++){
                        const C = y * this.frameSize;
                        for(let T = u; T <= g; T++){
                            const x = C + T * this.width;
                            for(let S = l, D = x + S; S <= f; S++, D++){
                                const _ = this.getAtIndex(D), M = [
                                    S,
                                    T,
                                    y
                                ];
                                o(null, M) && (s && m.push({
                                    value: _,
                                    index: D,
                                    pointIJK: M,
                                    pointLPS: null
                                }), r({
                                    value: _,
                                    index: D,
                                    pointIJK: [
                                        S,
                                        T,
                                        y
                                    ],
                                    pointLPS: null
                                }));
                            }
                        }
                    }
                    return m;
                }
            }, this.getSliceData = ({ sliceIndex: r, slicePlane: i })=>{
                const [a, o, s] = this.dimensions, c = a * o, l = r * c;
                let f;
                const u = this.getConstructor();
                function g(v) {
                    return typeof v == "function";
                }
                if (!g(u)) return new Uint8Array(0);
                let h;
                switch(i){
                    case 0:
                        f = o * s, h = new u(f);
                        for(let v = 0; v < o; v++)for(let m = 0; m < s; m++){
                            const y = r + v * a + m * c;
                            this.setSliceDataValue(h, v * s + m, this._get(y));
                        }
                        break;
                    case 1:
                        f = a * s, h = new u(f);
                        for(let v = 0; v < a; v++)for(let m = 0; m < s; m++){
                            const y = v + r * a + m * c;
                            this.setSliceDataValue(h, v + m * a, this._get(y));
                        }
                        break;
                    case 2:
                        f = a * o, h = new u(f);
                        for(let v = 0; v < f; v++)this.setSliceDataValue(h, v, this._get(l + v));
                        break;
                    default:
                        throw new Error("Oblique plane - todo - implement as ortho normal vector");
                }
                return h;
            }, this.dimensions = e, this.width = e[0], this.frameSize = this.width * e[1], this._get = n._get, this._set = n._set, this._id = n._id || "", this._getConstructor = n._getConstructor, this.numberOfComponents = this.numberOfComponents || 1, this.scalarData = n.scalarData, this._getScalarData = n._getScalarData, this._updateScalarData = n._updateScalarData;
        }
        getMinMax() {
            let e, n;
            const r = ({ value: i })=>{
                const a = Array.isArray(i);
                if (e === void 0 && (e = a ? [
                    ...i
                ] : i, n = a ? [
                    ...i
                ] : i), a) for(let o = 0; o < i.length; o++)e[o] = Math.min(e[o], i[o]), n[o] = Math.max(n[o], i[o]);
                else e = Math.min(e, i), n = Math.max(n, i);
            };
            return this.forEach(r, {
                boundsIJK: this.getDefaultBounds()
            }), {
                min: e,
                max: n
            };
        }
        toIJK(e) {
            return [
                e % this.width,
                Math.floor(e % this.frameSize / this.width),
                Math.floor(e / this.frameSize)
            ];
        }
        toIndex(e) {
            return e[0] + e[1] * this.width + e[2] * this.frameSize;
        }
        getDefaultBounds() {
            return this.dimensions.map((e)=>[
                    0,
                    e - 1
                ]);
        }
        getBoundsIJK() {
            return this.boundsIJK[0][0] < this.dimensions[0] ? this.boundsIJK : this.getDefaultBounds();
        }
        rleForEach(e, n) {
            const r = n?.boundsIJK || this.getBoundsIJK(), { isWithinObject: i } = n || {}, a = this.map;
            if (!a) {
                console.warn("No map found, you need to use a map voxel manager to use rleForEach");
                return;
            }
            a.defaultValue = void 0;
            for(let o = r[2][0]; o <= r[2][1]; o++)for(let s = r[1][0]; s <= r[1][1]; s++){
                const c = a.getRun(s, o);
                if (c) for (const l of c){
                    const { start: f, end: u, value: g } = l, h = this.toIndex([
                        0,
                        s,
                        o
                    ]);
                    for(let v = f; v < u; v++){
                        const m = {
                            value: g,
                            index: h + v,
                            pointIJK: [
                                v,
                                s,
                                o
                            ]
                        };
                        i?.(m) !== !1 && e(m);
                    }
                }
            }
        }
        getScalarData(e = !1) {
            if (this.scalarData) return this._updateScalarData?.(this.scalarData), this.scalarData;
            if (this._getScalarData) {
                const n = this._getScalarData();
                return e && console.log("Not transient, should store value", n), n;
            }
            throw new Error("No scalar data available");
        }
        setScalarData(e) {
            this.scalarData = e;
        }
        getScalarDataLength() {
            if (this.scalarData) return this.scalarData.length;
            if (this._getScalarDataLength) return this._getScalarDataLength();
            throw new Error("No scalar data available");
        }
        get sizeInBytes() {
            return this.getScalarDataLength() * this.bytePerVoxel;
        }
        get bytePerVoxel() {
            return this.scalarData ? this.scalarData.BYTES_PER_ELEMENT : this._get(0).BYTES_PER_ELEMENT;
        }
        clearBounds() {
            this.boundsIJK.map((e)=>{
                e[0] = 1 / 0, e[1] = -1 / 0;
            });
        }
        clear() {
            this.map?.clear(), this.clearBounds(), this.modifiedSlices.clear(), this.points?.clear();
        }
        getConstructor() {
            return this.scalarData ? this.scalarData.constructor : this._getConstructor ? this._getConstructor() : (console.warn("No scalar data available or can be used to get the constructor"), Float32Array);
        }
        getArrayOfModifiedSlices() {
            return Array.from(this.modifiedSlices);
        }
        resetModifiedSlices() {
            this.modifiedSlices.clear();
        }
        setBounds(e) {
            this.boundsIJK = e;
        }
        static addBounds(e, n) {
            e || (e = [
                [
                    1 / 0,
                    -1 / 0
                ],
                [
                    1 / 0,
                    -1 / 0
                ],
                [
                    1 / 0,
                    -1 / 0
                ]
            ]), e[0][0] = Math.min(n[0], e[0][0]), e[0][1] = Math.max(n[0], e[0][1]), e[1][0] = Math.min(n[1], e[1][0]), e[1][1] = Math.max(n[1], e[1][1]), e[2][0] = Math.min(n[2], e[2][0]), e[2][1] = Math.max(n[2], e[2][1]);
        }
        addPoint(e) {
            const n = Array.isArray(e) ? e[0] + this.width * e[1] + this.frameSize * e[2] : e;
            this.points || (this.points = new Set), this.points.add(n);
        }
        getPoints() {
            return this.points ? [
                ...this.points
            ].map((e)=>this.toIJK(e)) : [];
        }
        setSliceDataValue(e, n, r) {
            if (Array.isArray(r)) for(let i = 0; i < r.length; i++)e[n * r.length + i] = this.toNumber(r[i]);
            else e[n] = this.toNumber(r);
        }
        toNumber(e) {
            return typeof e == "number" ? e : Array.isArray(e) && e[0] || 0;
        }
        static _createRGBScalarVolumeVoxelManager({ dimensions: e, scalarData: n, numberOfComponents: r = 3, id: i }) {
            const a = new $n(e, {
                _get: (o)=>(o *= r, [
                        n[o++],
                        n[o++],
                        n[o++]
                    ]),
                _id: i || "_createRGBScalarVolumeVoxelManager",
                _set: (o, s)=>{
                    o *= 3;
                    const c = !lr(n[o], s);
                    return n[o++] = s[0], n[o++] = s[1], n[o++] = s[2], c;
                },
                numberOfComponents: r,
                scalarData: n
            });
            return a.clear = ()=>{
                n.fill(0);
            }, a;
        }
        static createImageVolumeVoxelManager({ dimensions: e, imageIds: n, numberOfComponents: r = 1, id: i }) {
            const a = e[0] * e[1];
            function o(u) {
                const g = Math.floor(u / a);
                if (g < 0 || g >= e[2]) return {};
                const h = n[g];
                if (!h) return console.warn(`ImageId not found for sliceIndex: ${g}`), {
                    pixelData: null,
                    pixelIndex: null
                };
                const v = ot.getImage(h);
                if (!v) return console.warn(`Image not found for imageId: ${h}`), {
                    pixelData: null,
                    pixelIndex: null
                };
                const m = v.voxelManager, y = u % a;
                return {
                    voxelManager: m,
                    pixelIndex: y
                };
            }
            function s(u) {
                const { voxelManager: g, pixelIndex: h } = o(u);
                return !g || h === null ? null : g.getAtIndex(h);
            }
            function c(u, g) {
                const { voxelManager: h, pixelIndex: v } = o(u);
                if (!h || v === null) return !1;
                const m = h.getAtIndex(v), y = !lr(g, m);
                return y && (h.setAtIndex(v, g), !0);
            }
            const l = ()=>{
                const { voxelManager: u, pixelIndex: g } = o(0);
                return !u || g === null ? null : u.getConstructor();
            }, f = new $n(e, {
                _get: s,
                _set: c,
                numberOfComponents: r,
                _getConstructor: l,
                _id: i || "createImageVolumeVoxelManager"
            });
            return f.getMiddleSliceData = ()=>{
                const u = Math.floor(e[2] / 2);
                return f.getSliceData({
                    sliceIndex: u,
                    slicePlane: 2
                });
            }, f.clear = ()=>{
                for (const u of n)ot.getImage(u).voxelManager.clear();
            }, f.getRange = ()=>{
                let u = 1 / 0, g = -1 / 0;
                for (const h of n){
                    const v = ot.getImage(h);
                    v && (v.minPixelValue < u && (u = v.minPixelValue), v.maxPixelValue > g && (g = v.maxPixelValue));
                }
                return u === 1 / 0 && g === -1 / 0 ? [
                    0,
                    0
                ] : [
                    u,
                    g
                ];
            }, f._getScalarDataLength = ()=>{
                const { voxelManager: u, pixelIndex: g } = o(0);
                return !u || g === null ? 0 : u.getScalarDataLength() * e[2];
            }, f.getCompleteScalarDataArray = ()=>{
                const u = f._getConstructor();
                if (!u) return new Uint8Array(0);
                const g = f.getScalarDataLength(), h = new u(g), v = e[0] * e[1] * r;
                for(let m = 0; m < e[2]; m++){
                    const { voxelManager: y, pixelIndex: C } = o(m * v / r);
                    if (y && C !== null) {
                        const T = m * v, x = y.getScalarData();
                        if (r === 1) h.set(x, T);
                        else for(let S = 0; S < x.length; S += r)for(let D = 0; D < r; D++)h[T + S + D] = x[S + D];
                    }
                }
                return h;
            }, f.setCompleteScalarDataArray = (u)=>{
                const g = e[0] * e[1] * r, h = f._getConstructor();
                let v = 1 / 0, m = -1 / 0;
                for(let y = 0; y < e[2]; y++){
                    const { voxelManager: C } = o(y * g / r);
                    if (C && h) {
                        const T = y * g, x = T + g, S = new h(g);
                        if (S.set(u.subarray(T, x)), C.scalarData) C.scalarData.set(S), C.modifiedSlices.add(y);
                        else for(let M = 0; M < g; M++)C.setAtIndex(M, S[M]);
                        for(let M = 0; M < S.length; M++){
                            const P = S[M];
                            v = Math.min(v, P), m = Math.max(m, P);
                        }
                        const D = n[y], _ = ot.getImage(D);
                        _ && (_.minPixelValue = v, _.maxPixelValue = m);
                    }
                }
                for(let y = 0; y < e[2]; y++)f.modifiedSlices.add(y);
                f.boundsIJK = [
                    [
                        0,
                        e[0] - 1
                    ],
                    [
                        0,
                        e[1] - 1
                    ],
                    [
                        0,
                        e[2] - 1
                    ]
                ];
            }, f;
        }
        static createScalarVolumeVoxelManager({ dimensions: e, scalarData: n, numberOfComponents: r, id: i }) {
            if (e.length !== 3) throw new Error("Dimensions must be provided as [number, number, number] for [width, height, depth]");
            if (!r && (r = n.length / e[0] / e[1] / e[2], r > 4 || r < 1 || r === 2)) throw new Error(`Number of components ${r} must be 1, 3 or 4`);
            return r > 1 ? $n._createRGBScalarVolumeVoxelManager({
                dimensions: e,
                scalarData: n,
                numberOfComponents: r,
                id: i
            }) : $n._createNumberVolumeVoxelManager({
                dimensions: e,
                scalarData: n,
                id: i
            });
        }
        static createScalarDynamicVolumeVoxelManager({ imageIdGroups: e, dimensions: n, dimensionGroupNumber: r = 1, timePoint: i = 0, numberOfComponents: a = 1, id: o }) {
            let s = 0;
            if (r !== void 0 ? s = r - 1 : i !== void 0 && (console.warn("Warning: timePoint parameter is deprecated. Please use dimensionGroupNumber instead. timePoint is zero-based while dimensionGroupNumber starts at 1."), s = i), !a) {
                const f = ot.getImage(e[0][0]);
                if (!f) throw new Error("Unable to determine number of components: No image found");
                if (a = f.getPixelData().length / (n[0] * n[1]), a > 4 || a < 1 || a === 2) throw new Error(`Number of components ${a} must be 1, 3 or 4`);
            }
            const c = e.map((f)=>$n.createImageVolumeVoxelManager({
                    dimensions: n,
                    imageIds: f,
                    numberOfComponents: a,
                    id: o
                })), l = new $n(n, {
                _get: (f)=>c[s]._get(f),
                _set: (f, u)=>c[s]._set(f, u),
                numberOfComponents: a,
                _id: o || "createScalarDynamicVolumeVoxelManager"
            });
            return l.getScalarDataLength = ()=>c[s].getScalarDataLength(), l.getConstructor = ()=>c[s].getConstructor(), l.getRange = ()=>c[s].getRange(), l.getMiddleSliceData = ()=>c[s].getMiddleSliceData(), l.setTimePoint = (f)=>{
                console.warn("Warning: setTimePoint is deprecated. Please use setDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."), l.setDimensionGroupNumber(f + 1);
            }, l.setDimensionGroupNumber = (f)=>{
                s = f - 1, l._get = (u)=>c[s]._get(u), l._set = (u, g)=>c[s]._set(u, g);
            }, l.getAtIndexAndTimePoint = (f, u)=>(console.warn("Warning: getAtIndexAndTimePoint is deprecated. Please use getAtIndexAndDimensionGroup instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."), l.getAtIndexAndDimensionGroup(f, u + 1)), l.getAtIndexAndDimensionGroup = (f, u)=>c[u - 1]._get(f), l.getTimePointScalarData = (f)=>(console.warn("Warning: getTimePointScalarData is deprecated. Please use getDimensionGroupScalarData instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."), l.getDimensionGroupScalarData(f + 1)), l.getDimensionGroupScalarData = (f)=>c[f - 1].getCompleteScalarDataArray(), l.getCurrentTimePointScalarData = ()=>(console.warn("Warning: getCurrentTimePointScalarData is deprecated. Please use getCurrentDimensionGroupScalarData instead."), l.getCurrentDimensionGroupScalarData()), l.getCurrentDimensionGroupScalarData = ()=>c[s].getCompleteScalarDataArray(), l.getCurrentTimePoint = ()=>(console.warn("Warning: getCurrentTimePoint is deprecated. Please use getCurrentDimensionGroupNumber instead. Note that timePoint is zero-based while dimensionGroupNumber starts at 1."), s), l.getCurrentDimensionGroupNumber = ()=>s + 1, l;
        }
        static createImageVoxelManager({ width: e, height: n, scalarData: r, numberOfComponents: i = 1, id: a }) {
            const o = [
                e,
                n,
                1
            ];
            if (!i && (i = r.length / e / n, i > 4 || i < 1 || i === 2)) throw new Error(`Number of components ${i} must be 1, 3 or 4`);
            return i > 1 ? $n._createRGBScalarVolumeVoxelManager({
                dimensions: o,
                scalarData: r,
                numberOfComponents: i,
                id: a
            }) : $n._createNumberVolumeVoxelManager({
                dimensions: o,
                scalarData: r,
                id: a
            });
        }
        static _createNumberVolumeVoxelManager({ dimensions: e, scalarData: n, id: r }) {
            const i = new $n(e, {
                _get: (a)=>n[a],
                _set: (a, o)=>{
                    const s = n[a] !== o;
                    return n[a] = o, s;
                },
                _getConstructor: ()=>n.constructor,
                _id: r || "_createNumberVolumeVoxelManager"
            });
            return i.scalarData = n, i.clear = ()=>{
                i.scalarData.fill(0);
            }, i.getMiddleSliceData = ()=>{
                const a = Math.floor(e[2] / 2);
                return i.getSliceData({
                    sliceIndex: a,
                    slicePlane: 2
                });
            }, i;
        }
        static createMapVoxelManager({ dimension: e, id: n }) {
            const r = new Map, i = new $n(e, {
                _get: r.get.bind(r),
                _set: (a, o)=>r.set(a, o) && !0,
                _id: n || "createMapVoxelManager"
            });
            return i.map = r, i;
        }
        static createHistoryVoxelManager(e, n) {
            const r = new Map, { dimensions: i } = e, a = new $n(i, {
                _get: (o)=>r.get(o),
                _set: function(o, s) {
                    if (r.has(o)) s === r.get(o) && r.delete(o);
                    else {
                        const c = this.sourceVoxelManager.getAtIndex(o);
                        if (c === s) return !1;
                        r.set(o, c);
                    }
                    this.sourceVoxelManager.setAtIndex(o, s);
                },
                _id: n || "createHistoryVoxelManager"
            });
            return a.map = r, a.scalarData = e.scalarData, a.sourceVoxelManager = e, a;
        }
        static createRLEHistoryVoxelManager(e, n) {
            const { dimensions: r } = e, i = new Ru(r[0], r[1], r[2]), a = new $n(r, {
                _get: (o)=>i.get(o),
                _set: function(o, s) {
                    const c = i.get(o);
                    if (c === void 0) {
                        const l = this.sourceVoxelManager.getAtIndex(o);
                        if (l === s || l === void 0 && s === 0 || s === null) return !1;
                        i.set(o, l ?? 0);
                    } else (s === c || s === null) && (i.delete(o), s = c);
                    this.sourceVoxelManager.setAtIndex(o, s);
                },
                _getScalarData: Ru.getScalarData,
                _updateScalarData: (o)=>(i.updateScalarData(o), o),
                _id: n || "createRLEHistoryVoxelManager"
            });
            return a.map = i, a.sourceVoxelManager = e, a;
        }
        static createLazyVoxelManager({ dimensions: e, planeFactory: n, id: r }) {
            const i = new Map, [a, o] = e, s = a * o, c = new $n(e, {
                _get: (l)=>i.get(Math.floor(l / s))[l % s],
                _set: (l, f)=>{
                    const u = Math.floor(l / s);
                    let g = i.get(u);
                    return g || (g = n(a, o), i.set(u, g)), g[l % s] = f, !0;
                },
                _id: r || "createLazyVoxelManager"
            });
            return c.map = i, c;
        }
        static createRLEVolumeVoxelManager({ dimensions: e, id: n }) {
            const [r, i, a] = e, o = new Ru(r, i, a), s = new $n(e, {
                _get: (c)=>o.get(c),
                _set: (c, l)=>(o.set(c, l), !0),
                _getScalarData: Ru.getScalarData,
                _updateScalarData: (c)=>(o.updateScalarData(c), c),
                _id: n || "createRLEVolumeVoxelManager"
            });
            return s.map = o, s.getPixelData = o.getPixelData.bind(o), s;
        }
        static createRLEImageVoxelManager({ dimensions: e, id: n }) {
            const [r, i] = e;
            return $n.createRLEVolumeVoxelManager({
                dimensions: [
                    r,
                    i,
                    1
                ],
                id: n
            });
        }
        static addInstanceToImage(e) {
            const { width: n, height: r } = e, i = e.voxelManager.getScalarData();
            if (i.length >= n * r) {
                e.voxelManager = $n.createScalarVolumeVoxelManager({
                    dimensions: [
                        n,
                        r,
                        1
                    ],
                    scalarData: i
                });
                return;
            }
            e.voxelManager = $n.createRLEVolumeVoxelManager({
                dimensions: [
                    n,
                    r,
                    1
                ]
            }), e.getPixelData = e.voxelManager.getPixelData, e.sizeInBytes = VG;
        }
    };
    const NG = "WebGL", Qh = Object.create(null);
    function RE(t, e) {
        Qh[t] = e;
    }
    function AG() {
        return Object.keys(Qh);
    }
    function OE(t) {
        let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return Qh[t] && Qh[t](e);
    }
    function kG(t, e) {
        e.classHierarchy.push("vtkRenderWindow"), t.addRenderer = (n)=>{
            t.hasRenderer(n) || (n.setRenderWindow(t), e.renderers.push(n), t.modified());
        }, t.removeRenderer = (n)=>{
            e.renderers = e.renderers.filter((r)=>r !== n), t.modified();
        }, t.hasRenderer = (n)=>e.renderers.indexOf(n) !== -1, t.newAPISpecificView = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return OE(n || e.defaultViewAPI, r);
        }, t.addView = (n)=>{
            t.hasView(n) || (n.setRenderable(t), e._views.push(n), t.modified());
        }, t.removeView = (n)=>{
            e._views = e._views.filter((r)=>r !== n), t.modified();
        }, t.hasView = (n)=>e._views.indexOf(n) !== -1, t.preRender = ()=>{
            e.renderers.forEach((n)=>{
                n.isActiveCameraCreated() || n.resetCamera();
            });
        }, t.render = ()=>{
            t.preRender(), e.interactor ? e.interactor.render() : e._views.forEach((n)=>n.traverseAllPasses());
        }, t.getStatistics = ()=>{
            const n = {
                propCount: 0,
                invisiblePropCount: 0,
                gpuMemoryMB: 0
            };
            return e._views.forEach((r)=>{
                r.getGraphicsMemoryInfo && (n.gpuMemoryMB += r.getGraphicsMemoryInfo() / 1e6);
            }), e.renderers.forEach((r)=>{
                const i = r.getViewProps(), a = e._views[0].getViewNodeFor(r);
                i.forEach((o)=>{
                    if (o.getVisibility()) {
                        n.propCount += 1;
                        const s = o.getMapper && o.getMapper();
                        if (s && s.getPrimitiveCount) {
                            const c = a.getViewNodeFor(s);
                            if (c) {
                                c.getAllocatedGPUMemoryInBytes && (n.gpuMemoryMB += c.getAllocatedGPUMemoryInBytes() / 1e6);
                                const l = s.getPrimitiveCount();
                                Object.keys(l).forEach((f)=>{
                                    n[f] || (n[f] = 0), n[f] += l[f];
                                });
                            }
                        }
                    } else n.invisiblePropCount += 1;
                });
            }), n.str = Object.keys(n).map((r)=>`${r}: ${n[r]}`).join(`
`), n;
        }, t.captureImages = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png", r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return K.setImmediate(t.render), e._views.map((i)=>i.captureNextImage ? i.captureNextImage(n, r) : void 0).filter((i)=>!!i);
        }, t.addRenderWindow = (n)=>e.childRenderWindows.includes(n) ? !1 : (e.childRenderWindows.push(n), t.modified(), !0), t.removeRenderWindow = (n)=>{
            const r = e.childRenderWindows.findIndex((i)=>i === n);
            return r < 0 ? !1 : (e.childRenderWindows.splice(r, 1), t.modified(), !0);
        };
    }
    const UG = {
        defaultViewAPI: NG,
        renderers: [],
        views: [],
        interactor: null,
        neverRendered: !0,
        numberOfLayers: 1,
        childRenderWindows: []
    };
    function IE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, UG, n), K.obj(t, e), K.setGet(t, e, [
            "interactor",
            "numberOfLayers",
            "_views",
            "defaultViewAPI"
        ]), K.get(t, e, [
            "neverRendered"
        ]), K.getArray(t, e, [
            "renderers",
            "childRenderWindows"
        ]), K.moveToProtected(t, e, [
            "views"
        ]), K.event(t, e, "completion"), kG(t, e);
    }
    const FG = K.newInstance(IE, "vtkRenderWindow");
    var BG = {
        newInstance: FG,
        extend: IE,
        registerViewConstructor: RE,
        listViewAPIs: AG,
        newAPISpecificView: OE
    };
    function GG(t, e) {
        e.classHierarchy.push("vtkRenderPass"), t.getOperation = ()=>e.currentOperation, t.setCurrentOperation = (n)=>{
            e.currentOperation = n, e.currentTraverseOperation = `traverse${K.capitalize(e.currentOperation)}`;
        }, t.getTraverseOperation = ()=>e.currentTraverseOperation, t.traverse = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            e.deleted || (e._currentParent = r, e.preDelegateOperations.forEach((i)=>{
                t.setCurrentOperation(i), n.traverse(t);
            }), e.delegates.forEach((i)=>{
                i.traverse(n, t);
            }), e.postDelegateOperations.forEach((i)=>{
                t.setCurrentOperation(i), n.traverse(t);
            }));
        };
    }
    const WG = {
        delegates: [],
        currentOperation: null,
        preDelegateOperations: [],
        postDelegateOperations: [],
        currentParent: null
    };
    function ME(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, WG, n), K.obj(t, e), K.get(t, e, [
            "currentOperation"
        ]), K.setGet(t, e, [
            "delegates",
            "_currentParent",
            "preDelegateOperations",
            "postDelegateOperations"
        ]), K.moveToProtected(t, e, [
            "currentParent"
        ]), GG(t, e);
    }
    const $G = K.newInstance(ME, "vtkRenderPass");
    var g4 = {
        newInstance: $G,
        extend: ME
    };
    const { Representation: zG } = eg, { vtkErrorMacro: nC } = K;
    function jG(t) {
        const e = Te.substitute(t.Fragment, "//VTK::RenderPassFragmentShader::Impl", `
      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);
      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);
      gl_FragData[1].r = weight;
    `, !1);
        t.Fragment = e.result;
    }
    const HG = `//VTK::System::Dec

in vec2 tcoord;

uniform sampler2D translucentRTexture;
uniform sampler2D translucentRGBATexture;

// the output of this shader
//VTK::Output::Dec

void main()
{
  vec4 t1Color = texture(translucentRGBATexture, tcoord);
  float t2Color = texture(translucentRTexture, tcoord).r;
  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);
}
`;
    function KG(t, e) {
        e.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"), t.createVertexBuffer = ()=>{
            const n = new Float32Array([
                -1,
                -1,
                -1,
                1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                -1
            ]), r = new Float32Array([
                0,
                0,
                1,
                0,
                0,
                1,
                1,
                1
            ]), i = new Uint16Array([
                4,
                0,
                1,
                3,
                2
            ]), a = Wt.newInstance({
                numberOfComponents: 3,
                values: n
            });
            a.setName("points");
            const o = Wt.newInstance({
                numberOfComponents: 2,
                values: r
            });
            o.setName("tcoords");
            const s = Wt.newInstance({
                numberOfComponents: 1,
                values: i
            });
            e.tris.getCABO().createVBO(s, "polys", zG.SURFACE, {
                points: a,
                tcoords: o,
                cellOffset: 0
            }), e.VBOBuildTime.modified();
        }, t.createFramebuffer = (n)=>{
            const r = n.getSize(), i = n.getContext();
            e.framebuffer = kp.newInstance(), e.framebuffer.setOpenGLRenderWindow(n), e.framebuffer.create(...r), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.bind(), e.translucentRGBATexture = Qn.newInstance(), e.translucentRGBATexture.setInternalFormat(i.RGBA16F), e.translucentRGBATexture.setFormat(i.RGBA), e.translucentRGBATexture.setOpenGLDataType(i.HALF_FLOAT), e.translucentRGBATexture.setOpenGLRenderWindow(n), e.translucentRGBATexture.create2DFromRaw(r[0], r[1], 4, "Float32Array", null), e.translucentRTexture = Qn.newInstance(), e.translucentRTexture.setInternalFormat(i.R16F), e.translucentRTexture.setFormat(i.RED), e.translucentRTexture.setOpenGLDataType(i.HALF_FLOAT), e.translucentRTexture.setOpenGLRenderWindow(n), e.translucentRTexture.create2DFromRaw(r[0], r[1], 1, "Float32Array", null), e.translucentZTexture = Qn.newInstance(), e.translucentZTexture.setOpenGLRenderWindow(n), e.translucentZTexture.createDepthFromRaw(r[0], r[1], "Float32Array", null), e.framebuffer.setColorBuffer(e.translucentRGBATexture, 0), e.framebuffer.setColorBuffer(e.translucentRTexture, 1), e.framebuffer.setDepthBuffer(e.translucentZTexture);
        }, t.createCopyShader = (n)=>{
            e.copyShader = n.getShaderCache().readyShaderProgramArray([
                "//VTK::System::Dec",
                "attribute vec4 vertexDC;",
                "attribute vec2 tcoordTC;",
                "varying vec2 tcoord;",
                "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"
            ].join(`
`), HG, "");
        }, t.createVBO = (n)=>{
            const r = n.getContext();
            e.tris.setOpenGLRenderWindow(n), t.createVertexBuffer();
            const i = e.copyShader;
            e.tris.getCABO().bind(), e.copyVAO.addAttributeArray(i, e.tris.getCABO(), "vertexDC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), r.FLOAT, 3, r.FALSE) || nC("Error setting vertexDC in copy shader VAO."), e.copyVAO.addAttributeArray(i, e.tris.getCABO(), "tcoordTC", e.tris.getCABO().getTCoordOffset(), e.tris.getCABO().getStride(), r.FLOAT, 2, r.FALSE) || nC("Error setting vertexDC in copy shader VAO.");
        }, t.traverse = (n, r, i)=>{
            if (e.deleted) return;
            const a = n.getSize(), o = n.getContext();
            if (e._supported = !1, r.getSelector() || !o || !n.getWebgl2() || !o.getExtension("EXT_color_buffer_half_float") && !o.getExtension("EXT_color_buffer_float")) {
                t.setCurrentOperation("translucentPass"), r.traverse(t);
                return;
            }
            if (e._supported = !0, e.framebuffer === null) t.createFramebuffer(n);
            else {
                const c = e.framebuffer.getSize();
                c === null || c[0] !== a[0] || c[1] !== a[1] ? (e.framebuffer.releaseGraphicsResources(), e.translucentRGBATexture.releaseGraphicsResources(n), e.translucentRTexture.releaseGraphicsResources(n), e.translucentZTexture.releaseGraphicsResources(n), t.createFramebuffer(n)) : (e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.bind());
            }
            o.drawBuffers([
                o.COLOR_ATTACHMENT0
            ]), o.clearBufferfv(o.COLOR, 0, [
                0,
                0,
                0,
                0
            ]), o.clearBufferfv(o.DEPTH, 0, [
                1
            ]), o.colorMask(!1, !1, !1, !1), i.getOpaqueActorCount() > 0 && (i.setCurrentOperation("opaqueZBufferPass"), r.traverse(i)), o.colorMask(!0, !0, !0, !0), o.drawBuffers([
                o.COLOR_ATTACHMENT0,
                o.COLOR_ATTACHMENT1
            ]), o.viewport(0, 0, a[0], a[1]), o.scissor(0, 0, a[0], a[1]), o.clearBufferfv(o.COLOR, 0, [
                0,
                0,
                0,
                1
            ]), o.clearBufferfv(o.COLOR, 1, [
                0,
                0,
                0,
                0
            ]), o.enable(o.DEPTH_TEST), o.enable(o.BLEND), o.blendFuncSeparate(o.ONE, o.ONE, o.ZERO, o.ONE_MINUS_SRC_ALPHA), t.setCurrentOperation("translucentPass"), r.traverse(t), o.drawBuffers([
                o.NONE
            ]), e.framebuffer.restorePreviousBindingsAndBuffers(), e.copyShader === null ? t.createCopyShader(n) : n.getShaderCache().readyShaderProgram(e.copyShader), e.copyVAO || (e.copyVAO = c4.newInstance(), e.copyVAO.setOpenGLRenderWindow(n)), e.copyVAO.bind(), e.VBOBuildTime.getMTime() < t.getMTime() && t.createVBO(n), o.blendFuncSeparate(o.SRC_ALPHA, o.ONE_MINUS_SRC_ALPHA, o.ONE, o.ONE_MINUS_SRC_ALPHA), o.depthMask(!1), o.depthFunc(o.ALWAYS), o.viewport(0, 0, a[0], a[1]), o.scissor(0, 0, a[0], a[1]), e.translucentRGBATexture.activate(), e.copyShader.setUniformi("translucentRGBATexture", e.translucentRGBATexture.getTextureUnit()), e.translucentRTexture.activate(), e.copyShader.setUniformi("translucentRTexture", e.translucentRTexture.getTextureUnit()), o.drawArrays(o.TRIANGLES, 0, e.tris.getCABO().getElementCount()), o.depthMask(!0), o.depthFunc(o.LEQUAL), e.translucentRGBATexture.deactivate(), e.translucentRTexture.deactivate();
            const s = r.getTiledSizeAndOrigin();
            o.scissor(s.lowerLeftU, s.lowerLeftV, s.usize, s.vsize), o.viewport(s.lowerLeftU, s.lowerLeftV, s.usize, s.vsize);
        }, t.getShaderReplacement = ()=>e._supported ? jG : null, t.releaseGraphicsResources = (n)=>{
            e.framebuffer && (e.framebuffer.releaseGraphicsResources(n), e.framebuffer = null), e.translucentRGBATexture && (e.translucentRGBATexture.releaseGraphicsResources(n), e.translucentRGBATexture = null), e.translucentRTexture && (e.translucentRTexture.releaseGraphicsResources(n), e.translucentRTexture = null), e.translucentZTexture && (e.translucentZTexture.releaseGraphicsResources(n), e.translucentZTexture = null), e.copyVAO && (e.copyVAO.releaseGraphicsResources(n), e.copyVAO = null), e.copyShader && (e.copyShader.releaseGraphicsResources(n), e.copyShader = null), e.tris && (e.tris.releaseGraphicsResources(n), e.tris = null), t.modified();
        };
    }
    const qG = {
        framebuffer: null,
        copyShader: null,
        tris: null
    };
    function bE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, qG, n), g4.extend(t, e, n), e.VBOBuildTime = {}, K.obj(e.VBOBuildTime, {
            mtime: 0
        }), e.tris = Yl.newInstance(), K.get(t, e, [
            "framebuffer"
        ]), KG(t, e);
    }
    const XG = K.newInstance(bE, "vtkOpenGLOrderIndependentTranslucentPass");
    var YG = {
        newInstance: XG,
        extend: bE
    };
    function ZG(t, e) {
        e.classHierarchy.push("vtkForwardPass"), t.traverse = function(n) {
            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (e.deleted) return;
            e._currentParent = r, t.setCurrentOperation("buildPass"), n.traverse(t);
            const i = n.getRenderable().getNumberOfLayers(), a = n.getRenderable().getRenderersByReference();
            for(let o = 0; o < i; o++)for(let s = 0; s < a.length; s++){
                const c = a[s], l = n.getViewNodeFor(c);
                if (c.getDraw() && c.getLayer() === o) {
                    if (e.opaqueActorCount = 0, e.translucentActorCount = 0, e.volumeCount = 0, e.overlayActorCount = 0, t.setCurrentOperation("queryPass"), l.traverse(t), (e.opaqueActorCount > 0 || e.translucentActorCount > 0) && e.volumeCount > 0 || e.depthRequested) {
                        const f = n.getFramebufferSize();
                        e.framebuffer === null && (e.framebuffer = kp.newInstance()), e.framebuffer.setOpenGLRenderWindow(n), e.framebuffer.saveCurrentBindingsAndBuffers();
                        const u = e.framebuffer.getSize();
                        (u === null || u[0] !== f[0] || u[1] !== f[1]) && (e.framebuffer.create(f[0], f[1]), e.framebuffer.populateFramebuffer()), e.framebuffer.bind(), t.setCurrentOperation("zBufferPass"), l.traverse(t), e.framebuffer.restorePreviousBindingsAndBuffers(), e.depthRequested = !1;
                    }
                    t.setCurrentOperation("cameraPass"), l.traverse(t), e.opaqueActorCount > 0 && (t.setCurrentOperation("opaquePass"), l.traverse(t)), e.translucentActorCount > 0 && (e.translucentPass || (e.translucentPass = YG.newInstance()), e.translucentPass.traverse(n, l, t)), e.volumeCount > 0 && (t.setCurrentOperation("volumePass"), l.traverse(t)), e.overlayActorCount > 0 && (t.setCurrentOperation("overlayPass"), l.traverse(t));
                }
            }
        }, t.getZBufferTexture = ()=>e.framebuffer ? e.framebuffer.getColorTexture() : null, t.requestDepth = ()=>{
            e.depthRequested = !0;
        }, t.incrementOpaqueActorCount = ()=>e.opaqueActorCount++, t.incrementTranslucentActorCount = ()=>e.translucentActorCount++, t.incrementVolumeCount = ()=>e.volumeCount++, t.incrementOverlayActorCount = ()=>e.overlayActorCount++;
    }
    const JG = {
        opaqueActorCount: 0,
        translucentActorCount: 0,
        volumeCount: 0,
        overlayActorCount: 0,
        framebuffer: null,
        depthRequested: !1
    };
    function LE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, JG, n), g4.extend(t, e, n), K.get(t, e, [
            "framebuffer",
            "opaqueActorCount",
            "translucentActorCount",
            "volumeCount"
        ]), ZG(t, e);
    }
    const QG = K.newInstance(LE, "vtkForwardPass");
    var eW = {
        newInstance: QG,
        extend: LE
    };
    const _a = {
        MIN_KNOWN_PASS: 0,
        ACTOR_PASS: 0,
        COMPOSITE_INDEX_PASS: 1,
        ID_LOW24: 2,
        ID_HIGH24: 3,
        MAX_KNOWN_PASS: 3
    };
    var PE = {
        PassTypes: _a
    };
    const { FieldAssociations: tW } = of;
    function nW(t, e) {
        e.classHierarchy.push("vtkHardwareSelector"), t.getSourceDataAsync = async (n, r, i, a, o)=>{}, t.selectAsync = async (n, r, i, a, o)=>{
            const s = await t.getSourceDataAsync(n, r, i, a, o);
            return s ? s.generateSelection(r, i, a, o) : [];
        };
    }
    const rW = {
        fieldAssociation: tW.FIELD_ASSOCIATION_CELLS,
        captureZValues: !1
    };
    function VE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, rW, n), K.obj(t, e), K.setGet(t, e, [
            "fieldAssociation",
            "captureZValues"
        ]), nW(t, e);
    }
    const iW = K.newInstance(VE, "vtkHardwareSelector");
    var aW = {
        newInstance: iW,
        extend: VE
    };
    const oW = {
        GLOBALIDS: 0,
        PEDIGREEIDS: 1,
        VALUES: 2,
        INDICES: 3,
        FRUSTUM: 4,
        LOCATIONS: 5,
        THRESHOLDS: 6,
        BLOCKS: 7,
        QUERY: 8
    }, sW = {
        CELL: 0,
        POINT: 1,
        FIELD: 2,
        VERTEX: 3,
        EDGE: 4,
        ROW: 5
    };
    var cW = {
        SelectionContent: oW,
        SelectionField: sW
    };
    function lW(t, e) {
        e.classHierarchy.push("vtkSelectionNode"), t.getBounds = ()=>e.points.getBounds();
    }
    const uW = {
        contentType: -1,
        fieldType: -1,
        properties: null,
        selectionList: []
    };
    function NE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, uW, n), K.obj(t, e), e.properties = {}, K.setGet(t, e, [
            "contentType",
            "fieldType",
            "properties",
            "selectionList"
        ]), lW(t, e);
    }
    const fW = K.newInstance(NE, "vtkSelectionNode");
    var AE = {
        newInstance: fW,
        extend: NE,
        ...cW
    };
    const { PassTypes: Hr } = PE, { SelectionContent: dW, SelectionField: rC } = AE, { FieldAssociations: yd } = of, { vtkErrorMacro: kE } = K, _l = 1;
    function UE(t) {
        return `${t.propID} ${t.compositeID}`;
    }
    function FE(t, e, n, r) {
        if (!n) return 0;
        const i = (e * (r[2] - r[0] + 1) + t) * 4;
        return n[i + 3];
    }
    function Bc(t, e, n, r) {
        if (!n) return 0;
        const i = (e * (r[2] - r[0] + 1) + t) * 4, a = n[i], o = n[i + 1];
        return (n[i + 2] * 256 + o) * 256 + a;
    }
    function BE(t, e) {
        let n = e;
        return n <<= 24, n |= t, n;
    }
    function gW(t, e, n, r) {
        {
            if (r[0] = e[0], r[1] = e[1], e[0] < t.area[0] || e[0] > t.area[2] || e[1] < t.area[1] || e[1] > t.area[3]) return null;
            const i = [
                e[0] - t.area[0],
                e[1] - t.area[1]
            ], a = Bc(i[0], i[1], t.pixBuffer[Hr.ACTOR_PASS], t.area);
            if (a <= 0 || a - _l >= t.props.length) return null;
            const o = {};
            o.valid = !0, o.propID = a - _l, o.prop = t.props[o.propID];
            let s = Bc(i[0], i[1], t.pixBuffer[Hr.COMPOSITE_INDEX_PASS], t.area);
            if ((s < 0 || s > 16777215) && (s = 0), o.compositeID = s - _l, t.captureZValues) {
                const f = (i[1] * (t.area[2] - t.area[0] + 1) + i[0]) * 4;
                o.zValue = (256 * t.zBuffer[f] + t.zBuffer[f + 1]) / 65535, o.displayPosition = e;
            }
            if (t.pixBuffer[Hr.ID_LOW24] && FE(i[0], i[1], t.pixBuffer[Hr.ID_LOW24], t.area) === 0) return o;
            const c = Bc(i[0], i[1], t.pixBuffer[Hr.ID_LOW24], t.area), l = Bc(i[0], i[1], t.pixBuffer[Hr.ID_HIGH24], t.area);
            return o.attributeID = BE(c, l), o;
        }
    }
    function GE(t, e, n, r, i) {
        const a = [];
        let o = 0;
        return e.forEach((s, c)=>{
            const l = AE.newInstance();
            switch(l.setContentType(dW.INDICES), t){
                case yd.FIELD_ASSOCIATION_CELLS:
                    l.setFieldType(rC.CELL);
                    break;
                case yd.FIELD_ASSOCIATION_POINTS:
                    l.setFieldType(rC.POINT);
                    break;
                default:
                    kE("Unknown field association");
            }
            l.getProperties().propID = s.info.propID, l.getProperties().prop = s.info.prop, l.getProperties().compositeID = s.info.compositeID, l.getProperties().attributeID = s.info.attributeID, l.getProperties().pixelCount = s.pixelCount, n && (l.getProperties().displayPosition = [
                s.info.displayPosition[0],
                s.info.displayPosition[1],
                s.info.zValue
            ], l.getProperties().worldPosition = i.displayToWorld(s.info.displayPosition[0], s.info.displayPosition[1], s.info.zValue, r)), l.setSelectionList(s.attributeIDs), a[o] = l, o++;
        }), a;
    }
    function hW(t, e, n, r, i) {
        const a = Math.floor(e), o = Math.floor(n), s = Math.floor(r), c = Math.floor(i), l = new Map, f = [
            0,
            0
        ];
        for(let u = o; u <= c; u++)for(let g = a; g <= s; g++){
            const v = gW(t, [
                g,
                u
            ], 0, f);
            if (v && v.valid) {
                const m = UE(v);
                if (!l.has(m)) l.set(m, {
                    info: v,
                    pixelCount: 1,
                    attributeIDs: [
                        v.attributeID
                    ]
                });
                else {
                    const y = l.get(m);
                    y.pixelCount++, t.captureZValues && v.zValue < y.info.zValue && (y.info = v), y.attributeIDs.indexOf(v.attributeID) === -1 && y.attributeIDs.push(v.attributeID);
                }
            }
        }
        return GE(t.fieldAssociation, l, t.captureZValues, t.renderer, t.openGLRenderWindow);
    }
    function pW(t, e) {
        e.classHierarchy.push("vtkOpenGLHardwareSelector"), t.releasePixBuffers = ()=>{
            e.rawPixBuffer = [], e.pixBuffer = [], e.zBuffer = null;
        }, t.beginSelection = ()=>{
            e._openGLRenderer = e._openGLRenderWindow.getViewNodeFor(e._renderer), e.maxAttributeId = 0;
            const r = e._openGLRenderWindow.getSize();
            if (!e.framebuffer) e.framebuffer = kp.newInstance(), e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.saveCurrentBindingsAndBuffers(), e.framebuffer.create(r[0], r[1]), e.framebuffer.populateFramebuffer();
            else {
                e.framebuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.framebuffer.saveCurrentBindingsAndBuffers();
                const i = e.framebuffer.getSize();
                !i || i[0] !== r[0] || i[1] !== r[1] ? (e.framebuffer.create(r[0], r[1]), e.framebuffer.populateFramebuffer()) : e.framebuffer.bind();
            }
            if (e._openGLRenderer.clear(), e._openGLRenderer.setSelector(t), e.hitProps = {}, e.propPixels = {}, e.props = [], t.releasePixBuffers(), e.fieldAssociation === yd.FIELD_ASSOCIATION_POINTS) {
                const i = e._openGLRenderWindow.getContext(), a = i.isEnabled(i.BLEND);
                i.disable(i.BLEND), e._openGLRenderWindow.traverseAllPasses(), a && i.enable(i.BLEND);
            }
        }, t.endSelection = ()=>{
            e.hitProps = {}, e._openGLRenderer.setSelector(null), e.framebuffer.restorePreviousBindingsAndBuffers();
        }, t.preCapturePass = ()=>{
            const r = e._openGLRenderWindow.getContext();
            e.originalBlending = r.isEnabled(r.BLEND), r.disable(r.BLEND);
        }, t.postCapturePass = ()=>{
            const r = e._openGLRenderWindow.getContext();
            e.originalBlending && r.enable(r.BLEND);
        }, t.select = ()=>{
            let r = null;
            return t.captureBuffers() && (r = t.generateSelection(e.area[0], e.area[1], e.area[2], e.area[3]), t.releasePixBuffers()), r;
        }, t.getSourceDataAsync = async (r, i, a, o, s)=>{
            if (e._renderer = r, i === void 0) {
                const l = e._openGLRenderWindow.getSize();
                t.setArea(0, 0, l[0] - 1, l[1] - 1);
            } else t.setArea(i, a, o, s);
            if (!t.captureBuffers()) return !1;
            const c = {
                area: [
                    ...e.area
                ],
                pixBuffer: [
                    ...e.pixBuffer
                ],
                captureZValues: e.captureZValues,
                zBuffer: e.zBuffer,
                props: [
                    ...e.props
                ],
                fieldAssociation: e.fieldAssociation,
                renderer: r,
                openGLRenderWindow: e._openGLRenderWindow
            };
            return c.generateSelection = function() {
                for(var l = arguments.length, f = new Array(l), u = 0; u < l; u++)f[u] = arguments[u];
                return hW(c, ...f);
            }, c;
        }, t.captureBuffers = ()=>{
            if (!e._renderer || !e._openGLRenderWindow) return kE("Renderer and view must be set before calling Select."), !1;
            e._openGLRenderer = e._openGLRenderWindow.getViewNodeFor(e._renderer), e._openGLRenderWindow.getRenderable().preRender(), t.invokeEvent({
                type: "StartEvent"
            }), e.originalBackground = e._renderer.getBackgroundByReference(), e._renderer.setBackground(0, 0, 0, 0);
            const r = e._openGLRenderWindow.getRenderPasses();
            t.beginSelection();
            const i = [];
            for(e.currentPass = Hr.MIN_KNOWN_PASS; e.currentPass <= Hr.MAX_KNOWN_PASS; e.currentPass++)t.passRequired(e.currentPass) && (t.preCapturePass(e.currentPass), e.captureZValues && e.currentPass === Hr.ACTOR_PASS && typeof r[0].requestDepth == "function" && typeof r[0].getFramebuffer == "function" && r[0].requestDepth(), e._openGLRenderWindow.traverseAllPasses(), t.postCapturePass(e.currentPass), t.savePixelBuffer(e.currentPass), i.push(e.currentPass));
            return i.forEach((a)=>{
                e.currentPass = a, t.processPixelBuffers();
            }), e.currentPass = Hr.MAX_KNOWN_PASS, t.endSelection(), e._renderer.setBackground(e.originalBackground), t.invokeEvent({
                type: "EndEvent"
            }), !0;
        }, t.processPixelBuffers = ()=>{
            e.props.forEach((r, i)=>{
                t.isPropHit(i) && r.processSelectorPixelBuffers(t, e.propPixels[i]);
            });
        }, t.passRequired = (r)=>{
            if (r === Hr.ID_HIGH24) {
                if (e.fieldAssociation === yd.FIELD_ASSOCIATION_POINTS) return e.maximumPointId > 16777215;
                if (e.fieldAssociation === yd.FIELD_ASSOCIATION_CELLS) return e.maximumCellId > 16777215;
            }
            return !0;
        }, t.savePixelBuffer = (r)=>{
            if (e.pixBuffer[r] = e._openGLRenderWindow.getPixelData(e.area[0], e.area[1], e.area[2], e.area[3]), !e.rawPixBuffer[r]) {
                const i = (e.area[2] - e.area[0] + 1) * (e.area[3] - e.area[1] + 1) * 4;
                e.rawPixBuffer[r] = new Uint8Array(i), e.rawPixBuffer[r].set(e.pixBuffer[r]);
            }
            if (r === Hr.ACTOR_PASS) {
                if (e.captureZValues) {
                    const i = e._openGLRenderWindow.getRenderPasses();
                    if (typeof i[0].requestDepth == "function" && typeof i[0].getFramebuffer == "function") {
                        const a = i[0].getFramebuffer();
                        a.saveCurrentBindingsAndBuffers(), a.bind(), e.zBuffer = e._openGLRenderWindow.getPixelData(e.area[0], e.area[1], e.area[2], e.area[3]), a.restorePreviousBindingsAndBuffers();
                    }
                }
                t.buildPropHitList(e.rawPixBuffer[r]);
            }
        }, t.buildPropHitList = (r)=>{
            let i = 0;
            for(let a = 0; a <= e.area[3] - e.area[1]; a++)for(let o = 0; o <= e.area[2] - e.area[0]; o++){
                let s = Bc(o, a, r, e.area);
                s > 0 && (s--, s in e.hitProps || (e.hitProps[s] = !0, e.propPixels[s] = []), e.propPixels[s].push(i * 4)), ++i;
            }
        }, t.renderProp = (r)=>{
            e.currentPass === Hr.ACTOR_PASS && (t.setPropColorValueFromInt(e.props.length + _l), e.props.push(r));
        }, t.renderCompositeIndex = (r)=>{
            e.currentPass === Hr.COMPOSITE_INDEX_PASS && t.setPropColorValueFromInt(r + _l);
        }, t.renderAttributeId = (r)=>{
            r < 0 || (e.maxAttributeId = r > e.maxAttributeId ? r : e.maxAttributeId);
        }, t.passTypeToString = (r)=>K.enumToString(Hr, r), t.isPropHit = (r)=>!!e.hitProps[r], t.setPropColorValueFromInt = (r)=>{
            e.propColorValue[0] = r % 256 / 255, e.propColorValue[1] = Math.floor(r / 256) % 256 / 255, e.propColorValue[2] = Math.floor(r / 65536) % 256 / 255;
        }, t.getPixelInformation = (r, i, a)=>{
            const o = i < 0 ? 0 : i;
            if (o === 0) {
                if (a[0] = r[0], a[1] = r[1], r[0] < e.area[0] || r[0] > e.area[2] || r[1] < e.area[1] || r[1] > e.area[3]) return null;
                const f = [
                    r[0] - e.area[0],
                    r[1] - e.area[1]
                ], u = Bc(f[0], f[1], e.pixBuffer[Hr.ACTOR_PASS], e.area);
                if (u <= 0 || u - _l >= e.props.length) return null;
                const g = {};
                g.valid = !0, g.propID = u - _l, g.prop = e.props[g.propID];
                let h = Bc(f[0], f[1], e.pixBuffer[Hr.COMPOSITE_INDEX_PASS], e.area);
                if ((h < 0 || h > 16777215) && (h = 0), g.compositeID = h - _l, e.captureZValues) {
                    const y = (f[1] * (e.area[2] - e.area[0] + 1) + f[0]) * 4;
                    g.zValue = (256 * e.zBuffer[y] + e.zBuffer[y + 1]) / 65535, g.displayPosition = r;
                }
                if (e.pixBuffer[Hr.ID_LOW24] && FE(f[0], f[1], e.pixBuffer[Hr.ID_LOW24], e.area) === 0) return g;
                const v = Bc(f[0], f[1], e.pixBuffer[Hr.ID_LOW24], e.area), m = Bc(f[0], f[1], e.pixBuffer[Hr.ID_HIGH24], e.area);
                return g.attributeID = BE(v, m), g;
            }
            const s = [
                r[0],
                r[1]
            ], c = [
                0,
                0
            ];
            let l = t.getPixelInformation(r, 0, a);
            if (l && l.valid) return l;
            for(let f = 1; f < o; ++f){
                for(let u = s[1] > f ? s[1] - f : 0; u <= s[1] + f; ++u)if (c[1] = u, s[0] >= f && (c[0] = s[0] - f, l = t.getPixelInformation(c, 0, a), l && l.valid) || (c[0] = s[0] + f, l = t.getPixelInformation(c, 0, a), l && l.valid)) return l;
                for(let u = s[0] >= f ? s[0] - (f - 1) : 0; u <= s[0] + (f - 1); ++u)if (c[0] = u, s[1] >= f && (c[1] = s[1] - f, l = t.getPixelInformation(c, 0, a), l && l.valid) || (c[1] = s[1] + f, l = t.getPixelInformation(c, 0, a), l && l.valid)) return l;
            }
            return a[0] = r[0], a[1] = r[1], null;
        }, t.generateSelection = (r, i, a, o)=>{
            const s = Math.floor(r), c = Math.floor(i), l = Math.floor(a), f = Math.floor(o), u = new Map, g = [
                0,
                0
            ];
            for(let h = c; h <= f; h++)for(let v = s; v <= l; v++){
                const m = [
                    v,
                    h
                ], y = t.getPixelInformation(m, 0, g);
                if (y && y.valid) {
                    const C = UE(y);
                    if (!u.has(C)) u.set(C, {
                        info: y,
                        pixelCount: 1,
                        attributeIDs: [
                            y.attributeID
                        ]
                    });
                    else {
                        const T = u.get(C);
                        T.pixelCount++, e.captureZValues && y.zValue < T.info.zValue && (T.info = y), T.attributeIDs.indexOf(y.attributeID) === -1 && T.attributeIDs.push(y.attributeID);
                    }
                }
            }
            return GE(e.fieldAssociation, u, e.captureZValues, e._renderer, e._openGLRenderWindow);
        }, t.getRawPixelBuffer = (r)=>e.rawPixBuffer[r], t.getPixelBuffer = (r)=>e.pixBuffer[r], t.attach = (r, i)=>{
            e._openGLRenderWindow = r, e._renderer = i;
        };
        const n = t.setArea;
        t.setArea = function() {
            return n(...arguments) ? (e.area[0] = Math.floor(e.area[0]), e.area[1] = Math.floor(e.area[1]), e.area[2] = Math.floor(e.area[2]), e.area[3] = Math.floor(e.area[3]), !0) : !1;
        };
    }
    const mW = {
        area: void 0,
        currentPass: -1,
        propColorValue: null,
        props: null,
        maximumPointId: 0,
        maximumCellId: 0,
        idOffset: 1
    };
    function WE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, mW, n), aW.extend(t, e, n), e.propColorValue = [
            0,
            0,
            0
        ], e.props = [], e.area || (e.area = [
            0,
            0,
            0,
            0
        ]), K.setGetArray(t, e, [
            "area"
        ], 4), K.setGet(t, e, [
            "_renderer",
            "currentPass",
            "_openGLRenderWindow",
            "maximumPointId",
            "maximumCellId"
        ]), K.setGetArray(t, e, [
            "propColorValue"
        ], 3), K.moveToProtected(t, e, [
            "renderer",
            "openGLRenderWindow"
        ]), K.event(t, e, "event"), pW(t, e);
    }
    const vW = K.newInstance(WE, "vtkOpenGLHardwareSelector");
    var h4 = {
        newInstance: vW,
        extend: WE,
        ...PE
    }, T5 = {
        exports: {}
    }, iC;
    function yW() {
        return iC || (iC = 1, function(t, e) {
            (function(n) {
                t.exports = n();
            })(function(n) {
                var r = [
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f"
                ];
                function i(C, T) {
                    var x = C[0], S = C[1], D = C[2], _ = C[3];
                    x += (S & D | ~S & _) + T[0] - 680876936 | 0, x = (x << 7 | x >>> 25) + S | 0, _ += (x & S | ~x & D) + T[1] - 389564586 | 0, _ = (_ << 12 | _ >>> 20) + x | 0, D += (_ & x | ~_ & S) + T[2] + 606105819 | 0, D = (D << 17 | D >>> 15) + _ | 0, S += (D & _ | ~D & x) + T[3] - 1044525330 | 0, S = (S << 22 | S >>> 10) + D | 0, x += (S & D | ~S & _) + T[4] - 176418897 | 0, x = (x << 7 | x >>> 25) + S | 0, _ += (x & S | ~x & D) + T[5] + 1200080426 | 0, _ = (_ << 12 | _ >>> 20) + x | 0, D += (_ & x | ~_ & S) + T[6] - 1473231341 | 0, D = (D << 17 | D >>> 15) + _ | 0, S += (D & _ | ~D & x) + T[7] - 45705983 | 0, S = (S << 22 | S >>> 10) + D | 0, x += (S & D | ~S & _) + T[8] + 1770035416 | 0, x = (x << 7 | x >>> 25) + S | 0, _ += (x & S | ~x & D) + T[9] - 1958414417 | 0, _ = (_ << 12 | _ >>> 20) + x | 0, D += (_ & x | ~_ & S) + T[10] - 42063 | 0, D = (D << 17 | D >>> 15) + _ | 0, S += (D & _ | ~D & x) + T[11] - 1990404162 | 0, S = (S << 22 | S >>> 10) + D | 0, x += (S & D | ~S & _) + T[12] + 1804603682 | 0, x = (x << 7 | x >>> 25) + S | 0, _ += (x & S | ~x & D) + T[13] - 40341101 | 0, _ = (_ << 12 | _ >>> 20) + x | 0, D += (_ & x | ~_ & S) + T[14] - 1502002290 | 0, D = (D << 17 | D >>> 15) + _ | 0, S += (D & _ | ~D & x) + T[15] + 1236535329 | 0, S = (S << 22 | S >>> 10) + D | 0, x += (S & _ | D & ~_) + T[1] - 165796510 | 0, x = (x << 5 | x >>> 27) + S | 0, _ += (x & D | S & ~D) + T[6] - 1069501632 | 0, _ = (_ << 9 | _ >>> 23) + x | 0, D += (_ & S | x & ~S) + T[11] + 643717713 | 0, D = (D << 14 | D >>> 18) + _ | 0, S += (D & x | _ & ~x) + T[0] - 373897302 | 0, S = (S << 20 | S >>> 12) + D | 0, x += (S & _ | D & ~_) + T[5] - 701558691 | 0, x = (x << 5 | x >>> 27) + S | 0, _ += (x & D | S & ~D) + T[10] + 38016083 | 0, _ = (_ << 9 | _ >>> 23) + x | 0, D += (_ & S | x & ~S) + T[15] - 660478335 | 0, D = (D << 14 | D >>> 18) + _ | 0, S += (D & x | _ & ~x) + T[4] - 405537848 | 0, S = (S << 20 | S >>> 12) + D | 0, x += (S & _ | D & ~_) + T[9] + 568446438 | 0, x = (x << 5 | x >>> 27) + S | 0, _ += (x & D | S & ~D) + T[14] - 1019803690 | 0, _ = (_ << 9 | _ >>> 23) + x | 0, D += (_ & S | x & ~S) + T[3] - 187363961 | 0, D = (D << 14 | D >>> 18) + _ | 0, S += (D & x | _ & ~x) + T[8] + 1163531501 | 0, S = (S << 20 | S >>> 12) + D | 0, x += (S & _ | D & ~_) + T[13] - 1444681467 | 0, x = (x << 5 | x >>> 27) + S | 0, _ += (x & D | S & ~D) + T[2] - 51403784 | 0, _ = (_ << 9 | _ >>> 23) + x | 0, D += (_ & S | x & ~S) + T[7] + 1735328473 | 0, D = (D << 14 | D >>> 18) + _ | 0, S += (D & x | _ & ~x) + T[12] - 1926607734 | 0, S = (S << 20 | S >>> 12) + D | 0, x += (S ^ D ^ _) + T[5] - 378558 | 0, x = (x << 4 | x >>> 28) + S | 0, _ += (x ^ S ^ D) + T[8] - 2022574463 | 0, _ = (_ << 11 | _ >>> 21) + x | 0, D += (_ ^ x ^ S) + T[11] + 1839030562 | 0, D = (D << 16 | D >>> 16) + _ | 0, S += (D ^ _ ^ x) + T[14] - 35309556 | 0, S = (S << 23 | S >>> 9) + D | 0, x += (S ^ D ^ _) + T[1] - 1530992060 | 0, x = (x << 4 | x >>> 28) + S | 0, _ += (x ^ S ^ D) + T[4] + 1272893353 | 0, _ = (_ << 11 | _ >>> 21) + x | 0, D += (_ ^ x ^ S) + T[7] - 155497632 | 0, D = (D << 16 | D >>> 16) + _ | 0, S += (D ^ _ ^ x) + T[10] - 1094730640 | 0, S = (S << 23 | S >>> 9) + D | 0, x += (S ^ D ^ _) + T[13] + 681279174 | 0, x = (x << 4 | x >>> 28) + S | 0, _ += (x ^ S ^ D) + T[0] - 358537222 | 0, _ = (_ << 11 | _ >>> 21) + x | 0, D += (_ ^ x ^ S) + T[3] - 722521979 | 0, D = (D << 16 | D >>> 16) + _ | 0, S += (D ^ _ ^ x) + T[6] + 76029189 | 0, S = (S << 23 | S >>> 9) + D | 0, x += (S ^ D ^ _) + T[9] - 640364487 | 0, x = (x << 4 | x >>> 28) + S | 0, _ += (x ^ S ^ D) + T[12] - 421815835 | 0, _ = (_ << 11 | _ >>> 21) + x | 0, D += (_ ^ x ^ S) + T[15] + 530742520 | 0, D = (D << 16 | D >>> 16) + _ | 0, S += (D ^ _ ^ x) + T[2] - 995338651 | 0, S = (S << 23 | S >>> 9) + D | 0, x += (D ^ (S | ~_)) + T[0] - 198630844 | 0, x = (x << 6 | x >>> 26) + S | 0, _ += (S ^ (x | ~D)) + T[7] + 1126891415 | 0, _ = (_ << 10 | _ >>> 22) + x | 0, D += (x ^ (_ | ~S)) + T[14] - 1416354905 | 0, D = (D << 15 | D >>> 17) + _ | 0, S += (_ ^ (D | ~x)) + T[5] - 57434055 | 0, S = (S << 21 | S >>> 11) + D | 0, x += (D ^ (S | ~_)) + T[12] + 1700485571 | 0, x = (x << 6 | x >>> 26) + S | 0, _ += (S ^ (x | ~D)) + T[3] - 1894986606 | 0, _ = (_ << 10 | _ >>> 22) + x | 0, D += (x ^ (_ | ~S)) + T[10] - 1051523 | 0, D = (D << 15 | D >>> 17) + _ | 0, S += (_ ^ (D | ~x)) + T[1] - 2054922799 | 0, S = (S << 21 | S >>> 11) + D | 0, x += (D ^ (S | ~_)) + T[8] + 1873313359 | 0, x = (x << 6 | x >>> 26) + S | 0, _ += (S ^ (x | ~D)) + T[15] - 30611744 | 0, _ = (_ << 10 | _ >>> 22) + x | 0, D += (x ^ (_ | ~S)) + T[6] - 1560198380 | 0, D = (D << 15 | D >>> 17) + _ | 0, S += (_ ^ (D | ~x)) + T[13] + 1309151649 | 0, S = (S << 21 | S >>> 11) + D | 0, x += (D ^ (S | ~_)) + T[4] - 145523070 | 0, x = (x << 6 | x >>> 26) + S | 0, _ += (S ^ (x | ~D)) + T[11] - 1120210379 | 0, _ = (_ << 10 | _ >>> 22) + x | 0, D += (x ^ (_ | ~S)) + T[2] + 718787259 | 0, D = (D << 15 | D >>> 17) + _ | 0, S += (_ ^ (D | ~x)) + T[9] - 343485551 | 0, S = (S << 21 | S >>> 11) + D | 0, C[0] = x + C[0] | 0, C[1] = S + C[1] | 0, C[2] = D + C[2] | 0, C[3] = _ + C[3] | 0;
                }
                function a(C) {
                    var T = [], x;
                    for(x = 0; x < 64; x += 4)T[x >> 2] = C.charCodeAt(x) + (C.charCodeAt(x + 1) << 8) + (C.charCodeAt(x + 2) << 16) + (C.charCodeAt(x + 3) << 24);
                    return T;
                }
                function o(C) {
                    var T = [], x;
                    for(x = 0; x < 64; x += 4)T[x >> 2] = C[x] + (C[x + 1] << 8) + (C[x + 2] << 16) + (C[x + 3] << 24);
                    return T;
                }
                function s(C) {
                    var T = C.length, x = [
                        1732584193,
                        -271733879,
                        -1732584194,
                        271733878
                    ], S, D, _, M, P, F;
                    for(S = 64; S <= T; S += 64)i(x, a(C.substring(S - 64, S)));
                    for(C = C.substring(S - 64), D = C.length, _ = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], S = 0; S < D; S += 1)_[S >> 2] |= C.charCodeAt(S) << (S % 4 << 3);
                    if (_[S >> 2] |= 128 << (S % 4 << 3), S > 55) for(i(x, _), S = 0; S < 16; S += 1)_[S] = 0;
                    return M = T * 8, M = M.toString(16).match(/(.*?)(.{0,8})$/), P = parseInt(M[2], 16), F = parseInt(M[1], 16) || 0, _[14] = P, _[15] = F, i(x, _), x;
                }
                function c(C) {
                    var T = C.length, x = [
                        1732584193,
                        -271733879,
                        -1732584194,
                        271733878
                    ], S, D, _, M, P, F;
                    for(S = 64; S <= T; S += 64)i(x, o(C.subarray(S - 64, S)));
                    for(C = S - 64 < T ? C.subarray(S - 64) : new Uint8Array(0), D = C.length, _ = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], S = 0; S < D; S += 1)_[S >> 2] |= C[S] << (S % 4 << 3);
                    if (_[S >> 2] |= 128 << (S % 4 << 3), S > 55) for(i(x, _), S = 0; S < 16; S += 1)_[S] = 0;
                    return M = T * 8, M = M.toString(16).match(/(.*?)(.{0,8})$/), P = parseInt(M[2], 16), F = parseInt(M[1], 16) || 0, _[14] = P, _[15] = F, i(x, _), x;
                }
                function l(C) {
                    var T = "", x;
                    for(x = 0; x < 4; x += 1)T += r[C >> x * 8 + 4 & 15] + r[C >> x * 8 & 15];
                    return T;
                }
                function f(C) {
                    var T;
                    for(T = 0; T < C.length; T += 1)C[T] = l(C[T]);
                    return C.join("");
                }
                f(s("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
                    function C(T, x) {
                        return T = T | 0 || 0, T < 0 ? Math.max(T + x, 0) : Math.min(T, x);
                    }
                    ArrayBuffer.prototype.slice = function(T, x) {
                        var S = this.byteLength, D = C(T, S), _ = S, M, P, F, N;
                        return x !== n && (_ = C(x, S)), D > _ ? new ArrayBuffer(0) : (M = _ - D, P = new ArrayBuffer(M), F = new Uint8Array(P), N = new Uint8Array(this, D, M), F.set(N), P);
                    };
                }();
                function u(C) {
                    return /[\u0080-\uFFFF]/.test(C) && (C = unescape(encodeURIComponent(C))), C;
                }
                function g(C, T) {
                    var x = C.length, S = new ArrayBuffer(x), D = new Uint8Array(S), _;
                    for(_ = 0; _ < x; _ += 1)D[_] = C.charCodeAt(_);
                    return T ? D : S;
                }
                function h(C) {
                    return String.fromCharCode.apply(null, new Uint8Array(C));
                }
                function v(C, T, x) {
                    var S = new Uint8Array(C.byteLength + T.byteLength);
                    return S.set(new Uint8Array(C)), S.set(new Uint8Array(T), C.byteLength), S;
                }
                function m(C) {
                    var T = [], x = C.length, S;
                    for(S = 0; S < x - 1; S += 2)T.push(parseInt(C.substr(S, 2), 16));
                    return String.fromCharCode.apply(String, T);
                }
                function y() {
                    this.reset();
                }
                return y.prototype.append = function(C) {
                    return this.appendBinary(u(C)), this;
                }, y.prototype.appendBinary = function(C) {
                    this._buff += C, this._length += C.length;
                    var T = this._buff.length, x;
                    for(x = 64; x <= T; x += 64)i(this._hash, a(this._buff.substring(x - 64, x)));
                    return this._buff = this._buff.substring(x - 64), this;
                }, y.prototype.end = function(C) {
                    var T = this._buff, x = T.length, S, D = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], _;
                    for(S = 0; S < x; S += 1)D[S >> 2] |= T.charCodeAt(S) << (S % 4 << 3);
                    return this._finish(D, x), _ = f(this._hash), C && (_ = m(_)), this.reset(), _;
                }, y.prototype.reset = function() {
                    return this._buff = "", this._length = 0, this._hash = [
                        1732584193,
                        -271733879,
                        -1732584194,
                        271733878
                    ], this;
                }, y.prototype.getState = function() {
                    return {
                        buff: this._buff,
                        length: this._length,
                        hash: this._hash.slice()
                    };
                }, y.prototype.setState = function(C) {
                    return this._buff = C.buff, this._length = C.length, this._hash = C.hash, this;
                }, y.prototype.destroy = function() {
                    delete this._hash, delete this._buff, delete this._length;
                }, y.prototype._finish = function(C, T) {
                    var x = T, S, D, _;
                    if (C[x >> 2] |= 128 << (x % 4 << 3), x > 55) for(i(this._hash, C), x = 0; x < 16; x += 1)C[x] = 0;
                    S = this._length * 8, S = S.toString(16).match(/(.*?)(.{0,8})$/), D = parseInt(S[2], 16), _ = parseInt(S[1], 16) || 0, C[14] = D, C[15] = _, i(this._hash, C);
                }, y.hash = function(C, T) {
                    return y.hashBinary(u(C), T);
                }, y.hashBinary = function(C, T) {
                    var x = s(C), S = f(x);
                    return T ? m(S) : S;
                }, y.ArrayBuffer = function() {
                    this.reset();
                }, y.ArrayBuffer.prototype.append = function(C) {
                    var T = v(this._buff.buffer, C), x = T.length, S;
                    for(this._length += C.byteLength, S = 64; S <= x; S += 64)i(this._hash, o(T.subarray(S - 64, S)));
                    return this._buff = S - 64 < x ? new Uint8Array(T.buffer.slice(S - 64)) : new Uint8Array(0), this;
                }, y.ArrayBuffer.prototype.end = function(C) {
                    var T = this._buff, x = T.length, S = [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ], D, _;
                    for(D = 0; D < x; D += 1)S[D >> 2] |= T[D] << (D % 4 << 3);
                    return this._finish(S, x), _ = f(this._hash), C && (_ = m(_)), this.reset(), _;
                }, y.ArrayBuffer.prototype.reset = function() {
                    return this._buff = new Uint8Array(0), this._length = 0, this._hash = [
                        1732584193,
                        -271733879,
                        -1732584194,
                        271733878
                    ], this;
                }, y.ArrayBuffer.prototype.getState = function() {
                    var C = y.prototype.getState.call(this);
                    return C.buff = h(C.buff), C;
                }, y.ArrayBuffer.prototype.setState = function(C) {
                    return C.buff = g(C.buff, !0), y.prototype.setState.call(this, C);
                }, y.ArrayBuffer.prototype.destroy = y.prototype.destroy, y.ArrayBuffer.prototype._finish = y.prototype._finish, y.ArrayBuffer.hash = function(C, T) {
                    var x = c(new Uint8Array(C)), S = f(x);
                    return T ? m(S) : S;
                }, y;
            });
        }(T5)), T5.exports;
    }
    var CW = yW();
    const wW = Qa(CW), TW = [
        "lastShaderProgramBound",
        "context",
        "_openGLRenderWindow"
    ];
    function xW(t, e) {
        e.classHierarchy.push("vtkShaderCache"), t.replaceShaderValues = (n, r, i)=>{
            let a = r;
            i.length > 0 && (a = Te.substitute(a, "VSOut", "GSOut").result);
            const o = e._openGLRenderWindow.getWebgl2();
            let s = `
`, c = `#version 100
`;
            o ? c = `#version 300 es
#define attribute in
#define textureCube texture
#define texture2D texture
#define textureCubeLod textureLod
#define texture2DLod textureLod
` : (e.context.getExtension("OES_standard_derivatives"), e.context.getExtension("EXT_frag_depth") && (s = `#extension GL_EXT_frag_depth : enable
`), e.context.getExtension("EXT_shader_texture_lod") && (s += `#extension GL_EXT_shader_texture_lod : enable
#define textureCubeLod textureCubeLodEXT
#define texture2DLod texture2DLodEXT`)), a = Te.substitute(a, "//VTK::System::Dec", [
                `${c}
`,
                o ? "" : `#extension GL_OES_standard_derivatives : enable
`,
                s,
                "#ifdef GL_FRAGMENT_PRECISION_HIGH",
                "precision highp float;",
                "precision highp int;",
                "#else",
                "precision mediump float;",
                "precision mediump int;",
                "#endif"
            ]).result;
            let l = Te.substitute(n, "//VTK::System::Dec", [
                `${c}
`,
                "#ifdef GL_FRAGMENT_PRECISION_HIGH",
                "precision highp float;",
                "precision highp int;",
                "#else",
                "precision mediump float;",
                "precision mediump int;",
                "#endif"
            ]).result;
            if (o) {
                l = Te.substitute(l, "varying", "out").result, a = Te.substitute(a, "varying", "in").result;
                let u = "", g = 0;
                for(; a.includes(`gl_FragData[${g}]`);)a = Te.substitute(a, `gl_FragData\\[${g}\\]`, `fragOutput${g}`).result, u += `layout(location = ${g}) out vec4 fragOutput${g};
`, g++;
                a = Te.substitute(a, "//VTK::Output::Dec", u).result;
            }
            const f = Te.substitute(i, "//VTK::System::Dec", c).result;
            return {
                VSSource: l,
                FSSource: a,
                GSSource: f
            };
        }, t.readyShaderProgramArray = (n, r, i)=>{
            const a = t.replaceShaderValues(n, r, i), o = t.getShaderProgram(a.VSSource, a.FSSource, a.GSSource);
            return t.readyShaderProgram(o);
        }, t.readyShaderProgram = (n)=>!n || !n.getCompiled() && !n.compileShader() || !t.bindShaderProgram(n) ? null : n, t.getShaderProgram = (n, r, i)=>{
            const a = `${n}${r}${i}`, o = wW.hash(a);
            if (!(o in e.shaderPrograms)) {
                const s = Te.newInstance();
                return s.setContext(e.context), s.getVertexShader().setSource(n), s.getFragmentShader().setSource(r), i && s.getGeometryShader().setSource(i), s.setMd5Hash(o), e.shaderPrograms[o] = s, s;
            }
            return e.shaderPrograms[o];
        }, t.releaseGraphicsResources = (n)=>{
            t.releaseCurrentShaderProgram(), Object.keys(e.shaderPrograms).map((r)=>e.shaderPrograms[r]).forEach((r)=>r.cleanup()), e.shaderPrograms = {};
        }, t.releaseCurrentShaderProgram = ()=>{
            e.lastShaderProgramBound && (e.lastShaderProgramBound.cleanup(), e.lastShaderProgramBound = null);
        }, t.bindShaderProgram = (n)=>(e.lastShaderProgramBound === n || (e.lastShaderProgramBound && e.lastShaderProgramBound.release(), n.bind(), e.lastShaderProgramBound = n), 1);
    }
    const SW = {
        lastShaderProgramBound: null,
        shaderPrograms: null,
        context: null
    };
    function $E(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, SW, n), e.shaderPrograms = {}, K.obj(t, e), K.setGet(t, e, TW), K.moveToProtected(t, e, [
            "openGLRenderWindow"
        ]), xW(t, e);
    }
    const EW = K.newInstance($E, "vtkShaderCache");
    var DW = {
        newInstance: EW,
        extend: $E
    };
    const { vtkErrorMacro: _W } = K;
    function RW(t, e) {
        e.classHierarchy.push("vtkOpenGLTextureUnitManager"), t.deleteTable = ()=>{
            for(let n = 0; n < e.numberOfTextureUnits; ++n)e.textureUnits[n] === !0 && _W("some texture units  were not properly released");
            e.textureUnits = [], e.numberOfTextureUnits = 0;
        }, t.setContext = (n)=>{
            if (e.context !== n) {
                if (e.context !== 0 && t.deleteTable(), e.context = n, e.context) {
                    e.numberOfTextureUnits = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);
                    for(let r = 0; r < e.numberOfTextureUnits; ++r)e.textureUnits[r] = !1;
                }
                t.modified();
            }
        }, t.allocate = ()=>{
            for(let n = 0; n < e.numberOfTextureUnits; n++)if (!t.isAllocated(n)) return e.textureUnits[n] = !0, n;
            return -1;
        }, t.allocateUnit = (n)=>t.isAllocated(n) ? -1 : (e.textureUnits[n] = !0, n), t.isAllocated = (n)=>e.textureUnits[n], t.free = (n)=>{
            e.textureUnits[n] = !1;
        }, t.freeAll = ()=>{
            for(let n = 0; n < e.numberOfTextureUnits; ++n)e.textureUnits[n] = !1;
        };
    }
    const OW = {
        context: null,
        numberOfTextureUnits: 0,
        textureUnits: 0
    };
    function zE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, OW, n), K.obj(t, e), e.textureUnits = [], K.get(t, e, [
            "numberOfTextureUnits"
        ]), K.setGet(t, e, [
            "context"
        ]), RW(t, e);
    }
    const IW = K.newInstance(zE, "vtkOpenGLTextureUnitManager");
    var MW = {
        newInstance: IW,
        extend: zE
    };
    function bW(t, e) {
        e.classHierarchy.push("vtkRenderWindowViewNode"), t.getViewNodeFactory = ()=>null, t.getAspectRatio = ()=>e.size[0] / e.size[1], t.getAspectRatioForRenderer = (n)=>{
            const r = n.getViewportByReference();
            return e.size[0] * (r[2] - r[0]) / ((r[3] - r[1]) * e.size[1]);
        }, t.isInViewport = (n, r, i)=>{
            const a = i.getViewportByReference(), o = t.getFramebufferSize();
            return a[0] * o[0] <= n && a[2] * o[0] >= n && a[1] * o[1] <= r && a[3] * o[1] >= r;
        }, t.getViewportSize = (n)=>{
            const r = n.getViewportByReference(), i = t.getFramebufferSize();
            return [
                (r[2] - r[0]) * i[0],
                (r[3] - r[1]) * i[1]
            ];
        }, t.getViewportCenter = (n)=>{
            const r = t.getViewportSize(n);
            return [
                r[0] * .5,
                r[1] * .5
            ];
        }, t.displayToNormalizedDisplay = (n, r, i)=>{
            const a = t.getFramebufferSize();
            return [
                n / a[0],
                r / a[1],
                i
            ];
        }, t.normalizedDisplayToDisplay = (n, r, i)=>{
            const a = t.getFramebufferSize();
            return [
                n * a[0],
                r * a[1],
                i
            ];
        }, t.worldToView = (n, r, i, a)=>a.worldToView(n, r, i), t.viewToWorld = (n, r, i, a)=>a.viewToWorld(n, r, i), t.worldToDisplay = (n, r, i, a)=>{
            const o = a.worldToView(n, r, i), s = t.getViewportSize(a), c = a.viewToProjection(o[0], o[1], o[2], s[0] / s[1]), l = a.projectionToNormalizedDisplay(c[0], c[1], c[2]);
            return t.normalizedDisplayToDisplay(l[0], l[1], l[2]);
        }, t.displayToWorld = (n, r, i, a)=>{
            const o = t.displayToNormalizedDisplay(n, r, i), s = a.normalizedDisplayToProjection(o[0], o[1], o[2]), c = t.getViewportSize(a), l = a.projectionToView(s[0], s[1], s[2], c[0] / c[1]);
            return a.viewToWorld(l[0], l[1], l[2]);
        }, t.normalizedDisplayToViewport = (n, r, i, a)=>{
            let o = a.getViewportByReference();
            o = t.normalizedDisplayToDisplay(o[0], o[1], 0);
            const s = t.normalizedDisplayToDisplay(n, r, i);
            return [
                s[0] - o[0] - .5,
                s[1] - o[1] - .5,
                i
            ];
        }, t.viewportToNormalizedViewport = (n, r, i, a)=>{
            const o = t.getViewportSize(a);
            return o && o[0] !== 0 && o[1] !== 0 ? [
                n / (o[0] - 1),
                r / (o[1] - 1),
                i
            ] : [
                n,
                r,
                i
            ];
        }, t.normalizedViewportToViewport = (n, r, i, a)=>{
            const o = t.getViewportSize(a);
            return [
                n * (o[0] - 1),
                r * (o[1] - 1),
                i
            ];
        }, t.displayToLocalDisplay = (n, r, i)=>{
            const a = t.getFramebufferSize();
            return [
                n,
                a[1] - r - 1,
                i
            ];
        }, t.viewportToNormalizedDisplay = (n, r, i, a)=>{
            let o = a.getViewportByReference();
            o = t.normalizedDisplayToDisplay(o[0], o[1], 0);
            const s = n + o[0] + .5, c = r + o[1] + .5;
            return t.displayToNormalizedDisplay(s, c, i);
        }, t.getComputedDevicePixelRatio = ()=>e.size[0] / t.getContainerSize()[0], t.getContainerSize = ()=>{
            K.vtkErrorMacro("not implemented");
        }, t.getPixelData = (n, r, i, a)=>{
            K.vtkErrorMacro("not implemented");
        }, t.createSelector = ()=>{
            K.vtkErrorMacro("not implemented");
        };
    }
    const LW = {
        size: void 0,
        selector: void 0
    };
    function jE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, LW, n), e.size || (e.size = [
            300,
            300
        ]), K.getArray(t, e, [
            "size"
        ], 2), K.get(t, e, [
            "selector"
        ]), Yr.extend(t, e, n), bW(t, e);
    }
    const PW = K.newInstance(jE, "vtkRenderWindowViewNode");
    var VW = {
        newInstance: PW,
        extend: jE
    };
    const NW = "__getUnderlyingContext";
    function AW() {
        const t = new Map, e = {
            apply (i, a, o) {
                return t.has(o[0]) ? t.get(o[0]) : i.apply(a, o);
            }
        };
        function n(i) {
            return {
                apply (a, o, s) {
                    return t.set(i, s[0]), a.apply(o, s);
                }
            };
        }
        const r = Object.create(null);
        return r.getParameter = (i, a, o, s)=>new Proxy(s.bind(i), e), r.depthMask = (i, a, o, s)=>new Proxy(s.bind(i), n(i.DEPTH_WRITEMASK)), {
            get (i, a, o) {
                if (a === NW) return ()=>i;
                let s = Reflect.get(i, a, i);
                s instanceof Function && (s = s.bind(i));
                const c = r[a];
                return c ? c(i, a, o, s) : s;
            }
        };
    }
    const { vtkDebugMacro: aC, vtkErrorMacro: oC } = K, kW = {
        position: "absolute",
        top: 0,
        left: 0,
        width: "100%",
        height: "100%"
    }, UW = [
        "activateTexture",
        "deactivateTexture",
        "disableCullFace",
        "enableCullFace",
        "get3DContext",
        "getActiveFramebuffer",
        "getContext",
        "getDefaultTextureByteSize",
        "getDefaultTextureInternalFormat",
        "getDefaultToWebgl2",
        "getGLInformations",
        "getGraphicsMemoryInfo",
        "getGraphicsResourceForObject",
        "getHardwareMaximumLineWidth",
        "getPixelData",
        "getShaderCache",
        "getTextureUnitForTexture",
        "getTextureUnitManager",
        "getWebgl2",
        "makeCurrent",
        "releaseGraphicsResources",
        "registerGraphicsResourceUser",
        "unregisterGraphicsResourceUser",
        "restoreContext",
        "setActiveFramebuffer",
        "setContext",
        "setDefaultToWebgl2",
        "setGraphicsResourceForObject"
    ];
    function Da(t, e, n) {
        const r = t.createFramebuffer(), i = t.createTexture();
        t.bindTexture(t.TEXTURE_2D, i), t.texImage2D(t.TEXTURE_2D, 0, e, 2, 2, 0, e, n, null), t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, i, 0);
        const a = t.checkFramebufferStatus(t.FRAMEBUFFER);
        return t.bindFramebuffer(t.FRAMEBUFFER, null), t.bindTexture(t.TEXTURE_2D, null), a === t.FRAMEBUFFER_COMPLETE;
    }
    let ep = 0;
    const Fp = [];
    function FW() {
        ep++, Fp.forEach((t)=>t(ep));
    }
    function BW() {
        ep--, Fp.forEach((t)=>t(ep));
    }
    function GW(t) {
        Fp.push(t);
    }
    function WW(t) {
        return Fp.pop();
    }
    function sC(t) {
        t.preventDefault();
    }
    function $W(t, e) {
        e.classHierarchy.push("vtkOpenGLRenderWindow");
        let n;
        function r() {
            return n || (n = AW()), n;
        }
        t.getViewNodeFactory = ()=>e.myFactory, e.canvas.addEventListener("webglcontextlost", sC, !1), e.canvas.addEventListener("webglcontextrestored", t.restoreContext, !1);
        const i = [
            0,
            0
        ];
        function a() {
            e.renderable && (e.size[0] !== i[0] || e.size[1] !== i[1]) && (i[0] = e.size[0], i[1] = e.size[1], e.canvas.setAttribute("width", e.size[0]), e.canvas.setAttribute("height", e.size[1])), e.viewStream && e.viewStream.setSize(e.size[0], e.size[1]), e.canvas.style.display = e.useOffScreen ? "none" : "block", e.el && (e.el.style.cursor = e.cursorVisibility ? e.cursor : "none"), e.containerSize = null;
        }
        t.onModified(a), t.buildPass = (u)=>{
            if (u) {
                if (!e.renderable) return;
                t.prepareNodes(), t.addMissingNodes(e.renderable.getRenderersByReference()), t.addMissingNodes(e.renderable.getChildRenderWindowsByReference()), t.removeUnusedNodes(), t.initialize(), e.children.forEach((g)=>{
                    g.setOpenGLRenderWindow?.(t);
                });
            }
        }, t.initialize = ()=>{
            if (!e.initialized) {
                if (e.rootOpenGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e.rootOpenGLRenderWindow) e.context2D = t.get2DContext();
                else {
                    e.context = t.get3DContext(), t.resizeFromChildRenderWindows(), e.context && FW(), e.textureUnitManager = MW.newInstance(), e.textureUnitManager.setContext(e.context), e.shaderCache.setContext(e.context);
                    const u = e.context;
                    u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA), u.depthFunc(u.LEQUAL), u.enable(u.BLEND);
                }
                e.initialized = !0;
            }
        }, t.makeCurrent = ()=>{
            e.context.makeCurrent();
        }, t.setContainer = (u)=>{
            e.el && e.el !== u && (e.canvas.parentNode !== e.el && oC("Error: canvas parent node does not match container"), e.el.removeChild(e.canvas), e.el.contains(e.bgImage) && e.el.removeChild(e.bgImage)), e.el !== u && (e.el = u, e.el && (e.el.appendChild(e.canvas), e.useBackgroundImage && e.el.appendChild(e.bgImage)), t.modified());
        }, t.getContainer = ()=>e.el, t.getContainerSize = ()=>{
            if (!e.containerSize && e.el) {
                const { width: u, height: g } = e.el.getBoundingClientRect();
                e.containerSize = [
                    u,
                    g
                ];
            }
            return e.containerSize || e.size;
        }, t.getFramebufferSize = ()=>e.activeFramebuffer?.getSize() || e.size, t.getPixelData = (u, g, h, v)=>{
            const m = new Uint8Array((h - u + 1) * (v - g + 1) * 4);
            return e.context.readPixels(u, g, h - u + 1, v - g + 1, e.context.RGBA, e.context.UNSIGNED_BYTE, m), m;
        }, t.get3DContext = function() {
            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                preserveDrawingBuffer: !1,
                depth: !0,
                alpha: !0,
                powerPreference: "high-performance"
            }, g = null;
            const h = typeof WebGL2RenderingContext < "u";
            return e.webgl2 = !1, e.defaultToWebgl2 && h && (g = e.canvas.getContext("webgl2", u), g && (e.webgl2 = !0, aC("using webgl2"))), g || (aC("using webgl1"), g = e.canvas.getContext("webgl", u) || e.canvas.getContext("experimental-webgl", u)), new Proxy(g, r());
        }, t.get2DContext = function() {
            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return e.canvas.getContext("2d", u);
        }, t.restoreContext = ()=>{
            const u = g4.newInstance();
            u.setCurrentOperation("Release"), u.traverse(t, null);
        }, t.activateTexture = (u)=>{
            const g = e._textureResourceIds.get(u);
            if (g !== void 0) {
                e.context.activeTexture(e.context.TEXTURE0 + g);
                return;
            }
            const h = t.getTextureUnitManager().allocate();
            if (h < 0) {
                oC("Hardware does not support the number of textures defined.");
                return;
            }
            e._textureResourceIds.set(u, h), e.context.activeTexture(e.context.TEXTURE0 + h);
        }, t.deactivateTexture = (u)=>{
            const g = e._textureResourceIds.get(u);
            g !== void 0 && (t.getTextureUnitManager().free(g), e._textureResourceIds.delete(u));
        }, t.getTextureUnitForTexture = (u)=>{
            const g = e._textureResourceIds.get(u);
            return g !== void 0 ? g : -1;
        }, t.getDefaultTextureByteSize = function(u) {
            let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            if (e.webgl2) switch(u){
                case qt.CHAR:
                case qt.SIGNED_CHAR:
                case qt.UNSIGNED_CHAR:
                    return 1;
                case g:
                case h:
                case qt.UNSIGNED_SHORT:
                case qt.SHORT:
                case qt.VOID:
                    return 2;
                default:
                    return 4;
            }
            return 1;
        }, t.getDefaultTextureInternalFormat = function(u, g) {
            let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
            if (e.webgl2) switch(u){
                case qt.UNSIGNED_CHAR:
                    switch(g){
                        case 1:
                            return e.context.R8;
                        case 2:
                            return e.context.RG8;
                        case 3:
                            return e.context.RGB8;
                        case 4:
                        default:
                            return e.context.RGBA8;
                    }
                case (h && !v && qt.UNSIGNED_SHORT):
                    switch(g){
                        case 1:
                            return h.R16_EXT;
                        case 2:
                            return h.RG16_EXT;
                        case 3:
                            return h.RGB16_EXT;
                        case 4:
                        default:
                            return h.RGBA16_EXT;
                    }
                case (h && !v && qt.SHORT):
                    switch(g){
                        case 1:
                            return h.R16_SNORM_EXT;
                        case 2:
                            return h.RG16_SNORM_EXT;
                        case 3:
                            return h.RGB16_SNORM_EXT;
                        case 4:
                        default:
                            return h.RGBA16_SNORM_EXT;
                    }
                case qt.UNSIGNED_SHORT:
                case qt.SHORT:
                case qt.FLOAT:
                default:
                    switch(g){
                        case 1:
                            return v ? e.context.R16F : e.context.R32F;
                        case 2:
                            return v ? e.context.RG16F : e.context.RG32F;
                        case 3:
                            return v ? e.context.RGB16F : e.context.RGB32F;
                        case 4:
                        default:
                            return v ? e.context.RGBA16F : e.context.RGBA32F;
                    }
            }
            switch(g){
                case 1:
                    return e.context.LUMINANCE;
                case 2:
                    return e.context.LUMINANCE_ALPHA;
                case 3:
                    return e.context.RGB;
                case 4:
                default:
                    return e.context.RGBA;
            }
        }, t.setBackgroundImage = (u)=>{
            e.bgImage.src = u.src;
        }, t.setUseBackgroundImage = (u)=>{
            e.useBackgroundImage = u, e.useBackgroundImage && !e.el.contains(e.bgImage) ? e.el.appendChild(e.bgImage) : !e.useBackgroundImage && e.el.contains(e.bgImage) && e.el.removeChild(e.bgImage);
        };
        function o() {
            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.imageFormat;
            const g = document.createElement("canvas"), h = g.getContext("2d");
            g.width = e.canvas.width, g.height = e.canvas.height, h.drawImage(e.canvas, 0, 0);
            const v = e.canvas.getBoundingClientRect();
            e.renderable.getRenderers().forEach((T)=>{
                T.getViewProps().forEach((S)=>{
                    if (S.getContainer) {
                        const _ = S.getContainer().getElementsByTagName("canvas");
                        for(let M = 0; M < _.length; M++){
                            const P = _[M], F = P.getBoundingClientRect(), N = F.x - v.x, B = F.y - v.y;
                            h.drawImage(P, N, B);
                        }
                    }
                });
            });
            const C = g.toDataURL(u);
            g.remove(), t.invokeImageReady(C);
        }
        t.captureNextImage = function() {
            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png", { resetCamera: g = !1, size: h = null, scale: v = 1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (e.deleted) return null;
            e.imageFormat = u;
            const m = e.notifyStartCaptureImage;
            return e.notifyStartCaptureImage = !0, e._screenshot = {
                size: h || v !== 1 ? h || e.size.map((y)=>y * v) : null
            }, new Promise((y, C)=>{
                const T = t.onImageReady((x)=>{
                    if (e._screenshot.size === null) e.notifyStartCaptureImage = m, T.unsubscribe(), e._screenshot.placeHolder && (e.size = e._screenshot.originalSize, t.modified(), e._screenshot.cameras && e._screenshot.cameras.forEach((S)=>{
                        let { restoreParamsFn: D, arg: _ } = S;
                        return D(_);
                    }), t.traverseAllPasses(), e.el.removeChild(e._screenshot.placeHolder), e._screenshot.placeHolder.remove(), e._screenshot = null), y(x);
                    else {
                        const S = document.createElement("img");
                        if (S.style = kW, S.src = x, e._screenshot.placeHolder = e.el.appendChild(S), e.canvas.style.display = "none", e._screenshot.originalSize = e.size, e.size = e._screenshot.size, e.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(), e._screenshot.size = null, t.modified(), g) {
                            const D = g !== !0;
                            e._screenshot.cameras = e.renderable.getRenderers().map((_)=>{
                                const M = _.getActiveCamera(), P = M.get("focalPoint", "position", "parallelScale");
                                return {
                                    resetCameraArgs: D ? {
                                        renderer: _
                                    } : void 0,
                                    resetCameraFn: D ? g : _.resetCamera,
                                    restoreParamsFn: M.set,
                                    arg: JSON.parse(JSON.stringify(P))
                                };
                            }), e._screenshot.cameras.forEach((_)=>{
                                let { resetCameraFn: M, resetCameraArgs: P } = _;
                                return M(P);
                            });
                        }
                        t.traverseAllPasses();
                    }
                });
            });
        };
        let s;
        t.getHardwareMaximumLineWidth = ()=>{
            if (s != null) return s;
            const u = t.get3DContext(), g = u.getParameter(u.ALIASED_LINE_WIDTH_RANGE);
            return s = g[1], g[1];
        }, t.getGLInformations = ()=>{
            if (e._glInformation) return e._glInformation;
            const u = t.get3DContext(), g = u.getExtension("OES_texture_float"), h = u.getExtension("OES_texture_half_float"), v = u.getExtension("WEBGL_debug_renderer_info"), m = u.getExtension("WEBGL_draw_buffers"), y = u.getExtension("EXT_texture_filter_anisotropic") || u.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), C = [
                [
                    "Max Vertex Attributes",
                    "MAX_VERTEX_ATTRIBS",
                    u.getParameter(u.MAX_VERTEX_ATTRIBS)
                ],
                [
                    "Max Varying Vectors",
                    "MAX_VARYING_VECTORS",
                    u.getParameter(u.MAX_VARYING_VECTORS)
                ],
                [
                    "Max Vertex Uniform Vectors",
                    "MAX_VERTEX_UNIFORM_VECTORS",
                    u.getParameter(u.MAX_VERTEX_UNIFORM_VECTORS)
                ],
                [
                    "Max Fragment Uniform Vectors",
                    "MAX_FRAGMENT_UNIFORM_VECTORS",
                    u.getParameter(u.MAX_FRAGMENT_UNIFORM_VECTORS)
                ],
                [
                    "Max Fragment Texture Image Units",
                    "MAX_TEXTURE_IMAGE_UNITS",
                    u.getParameter(u.MAX_TEXTURE_IMAGE_UNITS)
                ],
                [
                    "Max Vertex Texture Image Units",
                    "MAX_VERTEX_TEXTURE_IMAGE_UNITS",
                    u.getParameter(u.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
                ],
                [
                    "Max Combined Texture Image Units",
                    "MAX_COMBINED_TEXTURE_IMAGE_UNITS",
                    u.getParameter(u.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
                ],
                [
                    "Max 2D Texture Size",
                    "MAX_TEXTURE_SIZE",
                    u.getParameter(u.MAX_TEXTURE_SIZE)
                ],
                [
                    "Max Cube Texture Size",
                    "MAX_CUBE_MAP_TEXTURE_SIZE",
                    u.getParameter(u.MAX_CUBE_MAP_TEXTURE_SIZE)
                ],
                [
                    "Max Texture Anisotropy",
                    "MAX_TEXTURE_MAX_ANISOTROPY_EXT",
                    y && u.getParameter(y.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                ],
                [
                    "Point Size Range",
                    "ALIASED_POINT_SIZE_RANGE",
                    u.getParameter(u.ALIASED_POINT_SIZE_RANGE).join(" - ")
                ],
                [
                    "Line Width Range",
                    "ALIASED_LINE_WIDTH_RANGE",
                    u.getParameter(u.ALIASED_LINE_WIDTH_RANGE).join(" - ")
                ],
                [
                    "Max Viewport Dimensions",
                    "MAX_VIEWPORT_DIMS",
                    u.getParameter(u.MAX_VIEWPORT_DIMS).join(" - ")
                ],
                [
                    "Max Renderbuffer Size",
                    "MAX_RENDERBUFFER_SIZE",
                    u.getParameter(u.MAX_RENDERBUFFER_SIZE)
                ],
                [
                    "Framebuffer Red Bits",
                    "RED_BITS",
                    u.getParameter(u.RED_BITS)
                ],
                [
                    "Framebuffer Green Bits",
                    "GREEN_BITS",
                    u.getParameter(u.GREEN_BITS)
                ],
                [
                    "Framebuffer Blue Bits",
                    "BLUE_BITS",
                    u.getParameter(u.BLUE_BITS)
                ],
                [
                    "Framebuffer Alpha Bits",
                    "ALPHA_BITS",
                    u.getParameter(u.ALPHA_BITS)
                ],
                [
                    "Framebuffer Depth Bits",
                    "DEPTH_BITS",
                    u.getParameter(u.DEPTH_BITS)
                ],
                [
                    "Framebuffer Stencil Bits",
                    "STENCIL_BITS",
                    u.getParameter(u.STENCIL_BITS)
                ],
                [
                    "Framebuffer Subpixel Bits",
                    "SUBPIXEL_BITS",
                    u.getParameter(u.SUBPIXEL_BITS)
                ],
                [
                    "MSAA Samples",
                    "SAMPLES",
                    u.getParameter(u.SAMPLES)
                ],
                [
                    "MSAA Sample Buffers",
                    "SAMPLE_BUFFERS",
                    u.getParameter(u.SAMPLE_BUFFERS)
                ],
                [
                    "Supported Formats for UByte Render Targets     ",
                    "UNSIGNED_BYTE RENDER TARGET FORMATS",
                    [
                        g && Da(u, u.RGBA, u.UNSIGNED_BYTE) ? "RGBA" : "",
                        g && Da(u, u.RGB, u.UNSIGNED_BYTE) ? "RGB" : "",
                        g && Da(u, u.LUMINANCE, u.UNSIGNED_BYTE) ? "LUMINANCE" : "",
                        g && Da(u, u.ALPHA, u.UNSIGNED_BYTE) ? "ALPHA" : "",
                        g && Da(u, u.LUMINANCE_ALPHA, u.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""
                    ].join(" ")
                ],
                [
                    "Supported Formats for Half Float Render Targets",
                    "HALF FLOAT RENDER TARGET FORMATS",
                    [
                        h && Da(u, u.RGBA, h.HALF_FLOAT_OES) ? "RGBA" : "",
                        h && Da(u, u.RGB, h.HALF_FLOAT_OES) ? "RGB" : "",
                        h && Da(u, u.LUMINANCE, h.HALF_FLOAT_OES) ? "LUMINANCE" : "",
                        h && Da(u, u.ALPHA, h.HALF_FLOAT_OES) ? "ALPHA" : "",
                        h && Da(u, u.LUMINANCE_ALPHA, h.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""
                    ].join(" ")
                ],
                [
                    "Supported Formats for Full Float Render Targets",
                    "FLOAT RENDER TARGET FORMATS",
                    [
                        g && Da(u, u.RGBA, u.FLOAT) ? "RGBA" : "",
                        g && Da(u, u.RGB, u.FLOAT) ? "RGB" : "",
                        g && Da(u, u.LUMINANCE, u.FLOAT) ? "LUMINANCE" : "",
                        g && Da(u, u.ALPHA, u.FLOAT) ? "ALPHA" : "",
                        g && Da(u, u.LUMINANCE_ALPHA, u.FLOAT) ? "LUMINANCE_ALPHA" : ""
                    ].join(" ")
                ],
                [
                    "Max Multiple Render Targets Buffers",
                    "MAX_DRAW_BUFFERS_WEBGL",
                    m ? u.getParameter(m.MAX_DRAW_BUFFERS_WEBGL) : 0
                ],
                [
                    "High Float Precision in Vertex Shader",
                    "HIGH_FLOAT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Medium Float Precision in Vertex Shader",
                    "MEDIUM_FLOAT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Low Float Precision in Vertex Shader",
                    "LOW_FLOAT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "High Float Precision in Fragment Shader",
                    "HIGH_FLOAT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Medium Float Precision in Fragment Shader",
                    "MEDIUM_FLOAT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Low Float Precision in Fragment Shader",
                    "LOW_FLOAT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_FLOAT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "High Int Precision in Vertex Shader",
                    "HIGH_INT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.HIGH_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Medium Int Precision in Vertex Shader",
                    "MEDIUM_INT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.MEDIUM_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Low Int Precision in Vertex Shader",
                    "LOW_INT VERTEX_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.VERTEX_SHADER, u.LOW_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "High Int Precision in Fragment Shader",
                    "HIGH_INT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.HIGH_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Medium Int Precision in Fragment Shader",
                    "MEDIUM_INT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.MEDIUM_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Low Int Precision in Fragment Shader",
                    "LOW_INT FRAGMENT_SHADER",
                    [
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).precision,
                        " (-2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).rangeMin,
                        "</sup> - 2<sup>",
                        u.getShaderPrecisionFormat(u.FRAGMENT_SHADER, u.LOW_INT).rangeMax,
                        "</sup>)"
                    ].join("")
                ],
                [
                    "Supported Extensions",
                    "EXTENSIONS",
                    u.getSupportedExtensions().join("<br/>					    ")
                ],
                [
                    "WebGL Renderer",
                    "RENDERER",
                    u.getParameter(u.RENDERER)
                ],
                [
                    "WebGL Vendor",
                    "VENDOR",
                    u.getParameter(u.VENDOR)
                ],
                [
                    "WebGL Version",
                    "VERSION",
                    u.getParameter(u.VERSION)
                ],
                [
                    "Shading Language Version",
                    "SHADING_LANGUAGE_VERSION",
                    u.getParameter(u.SHADING_LANGUAGE_VERSION)
                ],
                [
                    "Unmasked Renderer",
                    "UNMASKED_RENDERER",
                    v && u.getParameter(v.UNMASKED_RENDERER_WEBGL)
                ],
                [
                    "Unmasked Vendor",
                    "UNMASKED_VENDOR",
                    v && u.getParameter(v.UNMASKED_VENDOR_WEBGL)
                ],
                [
                    "WebGL Version",
                    "WEBGL_VERSION",
                    e.webgl2 ? 2 : 1
                ]
            ], T = {};
            for(; C.length;){
                const [x, S, D] = C.pop();
                S && (T[S] = {
                    label: x,
                    value: D
                });
            }
            return e._glInformation = T, T;
        }, t.traverseAllPasses = ()=>{
            if (e.renderPasses) for(let g = 0; g < e.renderPasses.length; ++g)e.renderPasses[g].traverse(t, null);
            t.copyParentContent(), e.notifyStartCaptureImage && o();
            const u = e.renderable.getChildRenderWindowsByReference();
            for(let g = 0; g < u.length; ++g)t.getViewNodeFor(u[g])?.traverseAllPasses();
        }, t.copyParentContent = ()=>{
            const u = e.rootOpenGLRenderWindow;
            if (!u || !e.context2D || e.children.some((v)=>!!v.getSelector?.())) return;
            const g = u.getCanvas(), h = e.canvas;
            e.context2D.drawImage(g, 0, g.height - h.height, h.width, h.height, 0, 0, h.width, h.height);
        }, t.resizeFromChildRenderWindows = ()=>{
            const u = e.renderable.getChildRenderWindowsByReference();
            if (u.length > 0) {
                const g = [
                    0,
                    0
                ];
                for(let h = 0; h < u.length; ++h){
                    const v = t.getViewNodeFor(u[h])?.getSize();
                    v && (g[0] = v[0] > g[0] ? v[0] : g[0], g[1] = v[1] > g[1] ? v[1] : g[1]);
                }
                t.setSize(...g);
            }
        }, t.disableCullFace = ()=>{
            e.cullFaceEnabled && (e.context.disable(e.context.CULL_FACE), e.cullFaceEnabled = !1);
        }, t.enableCullFace = ()=>{
            e.cullFaceEnabled || (e.context.enable(e.context.CULL_FACE), e.cullFaceEnabled = !0);
        }, t.setViewStream = (u)=>{
            if (e.viewStream === u) return !1;
            if (e.subscription && (e.subscription.unsubscribe(), e.subscription = null), e.viewStream = u, e.viewStream) {
                const g = e.renderable.getRenderers()[0];
                g.getBackgroundByReference()[3] = 0, t.setUseBackgroundImage(!0), e.subscription = e.viewStream.onImageReady((h)=>t.setBackgroundImage(h.image)), e.viewStream.setSize(e.size[0], e.size[1]), e.viewStream.invalidateCache(), e.viewStream.render(), t.modified();
            }
            return !0;
        }, t.createSelector = ()=>{
            const u = h4.newInstance();
            return u.setOpenGLRenderWindow(t), u;
        };
        function c() {
            e.canvas.removeEventListener("webglcontextlost", sC), e.canvas.removeEventListener("webglcontextrestored", t.restoreContext);
        }
        t.delete = K.chain(()=>{
            e.context && BW(), t.setContainer(), t.setViewStream();
        }, c, t.delete), t.setActiveFramebuffer = (u)=>{
            e.activeFramebuffer = u;
        };
        const l = t.setSize;
        t.setSize = (u, g)=>{
            const h = l(u, g);
            return h && t.invokeWindowResizeEvent({
                width: u,
                height: g
            }), h;
        }, t.registerGraphicsResourceUser = (u, g)=>{
            e._graphicsResources.has(u) || t.setGraphicsResourceForObject(u, null, null), e._graphicsResources.get(u)?.users.add(g);
        }, t.unregisterGraphicsResourceUser = (u, g)=>{
            const h = e._graphicsResources.get(u);
            h && (h.users.delete(g), h.users.size || (h.oglObject?.releaseGraphicsResources(t), e._graphicsResources.delete(u)));
        }, t.getGraphicsResourceForObject = (u)=>e._graphicsResources.get(u), t.setGraphicsResourceForObject = (u, g, h)=>{
            if (!u) return;
            const v = e._graphicsResources.get(u);
            v?.oglObject?.releaseGraphicsResources(t), e._graphicsResources.set(u, {
                coreObject: u,
                oglObject: g,
                hash: h,
                users: v?.users ?? new Set
            });
        }, t.getGraphicsMemoryInfo = ()=>{
            let u = 0;
            return e._graphicsResources.forEach((g)=>{
                let { oglObject: h } = g;
                u += h.getAllocatedGPUMemoryInBytes();
            }), u;
        }, t.releaseGraphicsResources = ()=>{
            e.shaderCache !== null && e.shaderCache.releaseGraphicsResources(t), e._graphicsResources.forEach((u)=>{
                let { oglObject: g } = u;
                g.releaseGraphicsResources(t);
            }), e._graphicsResources.clear(), e.textureUnitManager !== null && e.textureUnitManager.freeAll(), e.renderable.getRenderersByReference().forEach((u)=>{
                t.getViewNodeFor(u)?.releaseGraphicsResources();
            });
        };
        const f = {
            ...t
        };
        UW.forEach((u)=>{
            t[u] = function() {
                return e.rootOpenGLRenderWindow ? e.rootOpenGLRenderWindow[u](...arguments) : f[u](...arguments);
            };
        });
    }
    const zW = {
        cullFaceEnabled: !1,
        shaderCache: null,
        initialized: !1,
        context: null,
        context2D: null,
        canvas: null,
        cursorVisibility: !0,
        cursor: "pointer",
        textureUnitManager: null,
        textureResourceIds: null,
        containerSize: null,
        renderPasses: [],
        notifyStartCaptureImage: !1,
        webgl2: !1,
        defaultToWebgl2: !0,
        activeFramebuffer: null,
        imageFormat: "image/png",
        useOffScreen: !1,
        useBackgroundImage: !1
    };
    function HE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, zW, n), VW.extend(t, e, n), e.canvas || (e.canvas = document.createElement("canvas"), e.canvas.style.width = "100%"), e.selector || (e.selector = h4.newInstance(), e.selector.setOpenGLRenderWindow(t)), e.bgImage = new Image, e.bgImage.style.position = "absolute", e.bgImage.style.left = "0", e.bgImage.style.top = "0", e.bgImage.style.width = "100%", e.bgImage.style.height = "100%", e.bgImage.style.zIndex = "-1", e._textureResourceIds = new Map, e._graphicsResources = new Map, e._glInformation = null, e.myFactory = ZN.newInstance(), e.shaderCache = DW.newInstance(), e.shaderCache.setOpenGLRenderWindow(t), e.renderPasses[0] = eW.newInstance(), K.get(t, e, [
            "shaderCache",
            "textureUnitManager",
            "webgl2",
            "useBackgroundImage",
            "activeFramebuffer",
            "rootOpenGLRenderWindow"
        ]), K.setGet(t, e, [
            "initialized",
            "context",
            "context2D",
            "canvas",
            "renderPasses",
            "notifyStartCaptureImage",
            "defaultToWebgl2",
            "cursor",
            "useOffScreen"
        ]), K.setGetArray(t, e, [
            "size"
        ], 2), K.event(t, e, "imageReady"), K.event(t, e, "windowResizeEvent"), $W(t, e);
    }
    const p4 = K.newInstance(HE, "vtkOpenGLRenderWindow");
    RE("WebGL", p4);
    var jW = {
        newInstance: p4,
        extend: HE,
        pushMonitorGLContextCount: GW,
        popMonitorGLContextCount: WW
    };
    bi("vtkRenderWindow", p4);
    function HW(t, e) {
        e.classHierarchy.push("vtkOpenGLActor"), t.buildPass = (n)=>{
            if (n) {
                e._openGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNodes(e.renderable.getTextures()), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes(), e.ogltextures = null, e.activeTextures = null;
                for(let r = 0; r < e.children.length; r++){
                    const i = e.children[r];
                    i.isA("vtkOpenGLTexture") ? (e.ogltextures || (e.ogltextures = []), e.ogltextures.push(i)) : e.oglmapper = i;
                }
            }
        }, t.traverseZBufferPass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.traverseOpaqueZBufferPass = (n)=>t.traverseOpaquePass(n), t.traverseOpaquePass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.traverseTranslucentPass = (n)=>{
            !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.activateTextures = ()=>{
            if (e.ogltextures) {
                e.activeTextures = [];
                for(let n = 0; n < e.ogltextures.length; n++){
                    const r = e.ogltextures[n];
                    r.render(), r.getHandle() && e.activeTextures.push(r);
                }
            }
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                e.renderable.getIsOpaque() ? r.incrementOpaqueActorCount() : r.incrementTranslucentActorCount();
            }
        }, t.zBufferPass = (n, r)=>t.opaquePass(n, r), t.opaqueZBufferPass = (n, r)=>t.opaquePass(n, r), t.opaquePass = (n, r)=>{
            if (n) e.context.depthMask(!0), t.activateTextures();
            else if (e.activeTextures) for(let i = 0; i < e.activeTextures.length; i++)e.activeTextures[i].deactivate();
        }, t.translucentPass = (n, r)=>{
            if (n) e.context.depthMask(e._openGLRenderer.getSelector() && e.renderable.getNestedPickable()), t.activateTextures();
            else if (e.activeTextures) for(let i = 0; i < e.activeTextures.length; i++)e.activeTextures[i].deactivate();
        }, t.getKeyMatrices = ()=>(e.renderable.getMTime() > e.keyMatrixTime.getMTime() && (e.renderable.computeMatrix(), Ur(e.keyMatrices.mcwc, e.renderable.getMatrix()), cn(e.keyMatrices.mcwc, e.keyMatrices.mcwc), e.renderable.getIsIdentity() ? Ts(e.keyMatrices.normalMatrix) : (Mp(e.keyMatrices.normalMatrix, e.keyMatrices.mcwc), Xd(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix), V3(e.keyMatrices.normalMatrix, e.keyMatrices.normalMatrix)), e.keyMatrixTime.modified()), e.keyMatrices);
    }
    const KW = {
        context: null,
        keyMatrixTime: null,
        keyMatrices: null,
        activeTextures: null
    };
    function qW(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, KW, n), Yr.extend(t, e, n), e.keyMatrixTime = {}, tr(e.keyMatrixTime, {
            mtime: 0
        }), e.keyMatrices = {
            normalMatrix: Ts(new Float64Array(9)),
            mcwc: Ot(new Float64Array(16))
        }, si(t, e, [
            "context"
        ]), La(t, e, [
            "activeTextures"
        ]), HW(t, e);
    }
    const KE = kn(qW);
    var XW = {
        newInstance: KE
    };
    bi("vtkActor", KE);
    function YW(t, e) {
        e.classHierarchy.push("vtkOpenGLActor2D"), t.buildPass = (n)=>{
            if (n) {
                if (!e.renderable) return;
                e._openGLRenderWindow = t.getLastAncestorOfType("vtkOpenGLRenderWindow"), e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e.context = e._openGLRenderWindow.getContext(), t.prepareNodes(), t.addMissingNodes(e.renderable.getTextures()), t.addMissingNode(e.renderable.getMapper()), t.removeUnusedNodes(), e.ogltextures = null, e.activeTextures = null;
                for(let r = 0; r < e.children.length; r++){
                    const i = e.children[r];
                    i.isA("vtkOpenGLTexture") ? (e.ogltextures || (e.ogltextures = []), e.ogltextures.push(i)) : e.oglmapper = i;
                }
            }
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                r.incrementOverlayActorCount();
            }
        }, t.traverseOpaquePass = (n)=>{
            !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || !e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.traverseTranslucentPass = (n)=>{
            !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || e.renderable.getIsOpaque() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable() || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.traverseOverlayPass = (n)=>{
            !e.oglmapper || !e.renderable || !e.renderable.getNestedVisibility() || e._openGLRenderer.getSelector() && !e.renderable.getNestedPickable || (t.apply(n, !0), e.oglmapper.traverse(n), t.apply(n, !1));
        }, t.activateTextures = ()=>{
            if (e.ogltextures) {
                e.activeTextures = [];
                for(let n = 0; n < e.ogltextures.length; n++){
                    const r = e.ogltextures[n];
                    r.render(), r.getHandle() && e.activeTextures.push(r);
                }
            }
        }, t.opaquePass = (n, r)=>{
            if (n) e.context.depthMask(!0), t.activateTextures();
            else if (e.activeTextures) for(let i = 0; i < e.activeTextures.length; i++)e.activeTextures[i].deactivate();
        }, t.translucentPass = (n, r)=>{
            if (n) e.context.depthMask(!1), t.activateTextures();
            else if (e.activeTextures) for(let i = 0; i < e.activeTextures.length; i++)e.activeTextures[i].deactivate();
        }, t.overlayPass = (n, r)=>{
            if (n) e.context.depthMask(!0), t.activateTextures();
            else if (e.activeTextures) for(let i = 0; i < e.activeTextures.length; i++)e.activeTextures[i].deactivate();
        };
    }
    const ZW = {
        context: null,
        activeTextures: null
    };
    function JW(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, ZW, n), Yr.extend(t, e, n), si(t, e, [
            "context"
        ]), La(t, e, [
            "activeTextures"
        ]), YW(t, e);
    }
    const qE = kn(JW);
    var QW = {
        newInstance: qE
    };
    bi("vtkActor2D", qE);
    function e$(t, e) {
        e.classHierarchy.push("vtkAbstractMapper"), t.update = ()=>{
            t.getInputData();
        }, t.addClippingPlane = (n)=>n.isA("vtkPlane") ? e.clippingPlanes.includes(n) ? !1 : (e.clippingPlanes.push(n), t.modified(), !0) : !1, t.getNumberOfClippingPlanes = ()=>e.clippingPlanes.length, t.removeAllClippingPlanes = ()=>e.clippingPlanes.length === 0 ? !1 : (e.clippingPlanes.length = 0, t.modified(), !0), t.removeClippingPlane = (n)=>{
            const r = e.clippingPlanes.indexOf(n);
            return r === -1 ? !1 : (e.clippingPlanes.splice(r, 1), t.modified(), !0);
        }, t.getClippingPlanes = ()=>e.clippingPlanes, t.setClippingPlanes = (n)=>{
            if (n) if (!Array.isArray(n)) t.addClippingPlane(n);
            else {
                const r = n.length;
                for(let i = 0; i < r && i < 6; i++)t.addClippingPlane(n[i]);
            }
        }, t.getClippingPlaneInDataCoords = (n, r, i)=>{
            const a = e.clippingPlanes, o = n;
            if (a) {
                const s = a.length;
                if (r >= 0 && r < s) {
                    const c = a[r], l = c.getNormal(), f = c.getOrigin(), u = l[0], g = l[1], h = l[2], v = -(u * f[0] + g * f[1] + h * f[2]);
                    i[0] = u * o[0] + g * o[4] + h * o[8] + v * o[12], i[1] = u * o[1] + g * o[5] + h * o[9] + v * o[13], i[2] = u * o[2] + g * o[6] + h * o[10] + v * o[14], i[3] = u * o[3] + g * o[7] + h * o[11] + v * o[15];
                    return;
                }
            }
            K.vtkErrorMacro(`Clipping plane index ${r} is out of range.`);
        };
    }
    const t$ = {
        clippingPlanes: []
    };
    function n$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, t$, n), K.obj(t, e), K.algo(t, e, 1, 0), e.clippingPlanes || (e.clippingPlanes = []), e$(t, e);
    }
    r$ = {
        extend: n$
    };
    function i$(t, e) {
        t.getBounds = ()=>(K.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"), Gl()), t.getCenter = ()=>{
            const n = t.getBounds();
            return e.center = zn.isValid(n) ? zn.getCenter(n) : null, e.center?.slice();
        }, t.getLength = ()=>{
            const n = t.getBounds();
            return zn.getDiagonalLength(n);
        };
    }
    const a$ = (t)=>({
            bounds: [
                ...zn.INIT_BOUNDS
            ],
            center: [
                0,
                0,
                0
            ],
            viewSpecificProperties: {},
            ...t
        });
    function o$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, a$(n)), r$.extend(t, e, n), K.setGet(t, e, [
            "viewSpecificProperties"
        ]), i$(t, e);
    }
    var m4 = {
        extend: o$
    };
    const { vtkErrorMacro: cC } = K, lC = 0, uC = 1, x5 = 2;
    function s$(t, e) {
        e.classHierarchy.push("vtkLookupTable"), t.isOpaque = ()=>{
            if (e.opaqueFlagBuildTime.getMTime() < t.getMTime()) {
                let n = !0;
                e.nanColor[3] < 1 && (n = 0), e.useBelowRangeColor && e.belowRangeColor[3] < 1 && (n = 0), e.useAboveRangeColor && e.aboveRangeColor[3] < 1 && (n = 0);
                for(let r = 3; r < e.table.length && n; r += 4)e.table[r] < 255 && (n = !1);
                e.opaqueFlag = n, e.opaqueFlagBuildTime.modified();
            }
            return e.opaqueFlag;
        }, t.usingLogScale = ()=>!1, t.getNumberOfAvailableColors = ()=>e.table.length / 4 - 3, t.linearIndexLookup = (n, r)=>{
            let i = 0;
            const a = Number(n);
            return a < r.range[0] ? i = r.maxIndex + lC + 1.5 : a > r.range[1] ? i = r.maxIndex + uC + 1.5 : (i = (a + r.shift) * r.scale, i = i < r.maxIndex ? i : r.maxIndex), Math.floor(i);
        }, t.linearLookup = (n, r, i)=>{
            let a = 0;
            Bh(n) ? a = Math.floor(i.maxIndex + 1.5 + x5) : a = t.linearIndexLookup(n, i);
            const o = 4 * a;
            return r.slice(o, o + 4);
        }, t.indexedLookupFunction = (n, r, i)=>{
            let a = t.getAnnotatedValueIndexInternal(n);
            a === -1 && (a = e.numberOfColors + x5);
            const o = 4 * a;
            return [
                r[o],
                r[o + 1],
                r[o + 2],
                r[o + 3]
            ];
        }, t.lookupShiftAndScale = (n, r)=>{
            r.shift = -n[0], r.scale = Number.MAX_VALUE, n[1] > n[0] && (r.scale = (r.maxIndex + 1) / (n[1] - n[0]));
        }, t.mapScalarsThroughTable = (n, r, i, a)=>{
            let o = t.linearLookup;
            e.indexedLookup && (o = t.indexedLookupFunction);
            const s = t.getMappingRange(), c = {
                maxIndex: t.getNumberOfColors() - 1,
                range: s,
                shift: 0,
                scale: 0
            };
            t.lookupShiftAndScale(s, c);
            const l = t.getAlpha(), f = n.getNumberOfTuples(), u = n.getNumberOfComponents(), g = r.getData(), h = n.getData();
            if (l >= 1) {
                if (i === Dv.RGBA) for(let v = 0; v < f; v++){
                    const m = o(h[v * u + a], e.table, c);
                    g[v * 4] = m[0], g[v * 4 + 1] = m[1], g[v * 4 + 2] = m[2], g[v * 4 + 3] = m[3];
                }
            } else if (i === Dv.RGBA) for(let v = 0; v < f; v++){
                const m = o(h[v * u + a], e.table, c);
                g[v * 4] = m[0], g[v * 4 + 1] = m[1], g[v * 4 + 2] = m[2], g[v * 4 + 3] = Math.floor(m[3] * l + .5);
            }
        }, t.forceBuild = ()=>{
            let n = 0, r = 0, i = 0, a = 0;
            const o = e.numberOfColors - 1;
            o && (n = (e.hueRange[1] - e.hueRange[0]) / o, r = (e.saturationRange[1] - e.saturationRange[0]) / o, i = (e.valueRange[1] - e.valueRange[0]) / o, a = (e.alphaRange[1] - e.alphaRange[0]) / o), e.table.length = 4 * o + 16;
            const s = [], c = [];
            for(let l = 0; l <= o; l++)s[0] = e.hueRange[0] + l * n, s[1] = e.saturationRange[0] + l * r, s[2] = e.valueRange[0] + l * i, R0(s, c), c[3] = e.alphaRange[0] + l * a, e.table[l * 4] = c[0] * 255 + .5, e.table[l * 4 + 1] = c[1] * 255 + .5, e.table[l * 4 + 2] = c[2] * 255 + .5, e.table[l * 4 + 3] = c[3] * 255 + .5;
            t.buildSpecialColors(), e.buildTime.modified();
        }, t.setTable = (n)=>{
            if (Array.isArray(n)) {
                const i = n[0].length;
                e.numberOfColors = n.length;
                const a = 4 - i;
                let o = 0;
                for(let s = 0; s < e.numberOfColors; s++)e.table[s * 4] = 255, e.table[s * 4 + 1] = 255, e.table[s * 4 + 2] = 255, e.table[s * 4 + 3] = 255;
                for(let s = 0; s < n.length; s++){
                    const c = n[s];
                    for(let l = 0; l < i; l++)e.table[o++] = c[l];
                    o += a;
                }
                return t.buildSpecialColors(), e.insertTime.modified(), t.modified(), !0;
            }
            if (n.getNumberOfComponents() !== 4) return cC("Expected 4 components for RGBA colors"), !1;
            if (n.getDataType() !== qt.UNSIGNED_CHAR) return cC("Expected unsigned char values for RGBA colors"), !1;
            e.numberOfColors = n.getNumberOfTuples();
            const r = n.getData();
            e.table.length = r.length;
            for(let i = 0; i < r.length; i++)e.table[i] = r[i];
            return t.buildSpecialColors(), e.insertTime.modified(), t.modified(), !0;
        }, t.buildSpecialColors = ()=>{
            const { numberOfColors: n } = e, r = e.table;
            let i = (n + lC) * 4;
            e.useBelowRangeColor || n === 0 ? (r[i] = e.belowRangeColor[0] * 255 + .5, r[i + 1] = e.belowRangeColor[1] * 255 + .5, r[i + 2] = e.belowRangeColor[2] * 255 + .5, r[i + 3] = e.belowRangeColor[3] * 255 + .5) : (r[i] = r[0], r[i + 1] = r[1], r[i + 2] = r[2], r[i + 3] = r[3]), i = (n + uC) * 4, e.useAboveRangeColor || n === 0 ? (r[i] = e.aboveRangeColor[0] * 255 + .5, r[i + 1] = e.aboveRangeColor[1] * 255 + .5, r[i + 2] = e.aboveRangeColor[2] * 255 + .5, r[i + 3] = e.aboveRangeColor[3] * 255 + .5) : (r[i] = r[4 * (n - 1) + 0], r[i + 1] = r[4 * (n - 1) + 1], r[i + 2] = r[4 * (n - 1) + 2], r[i + 3] = r[4 * (n - 1) + 3]), i = (n + x5) * 4, r[i] = e.nanColor[0] * 255 + .5, r[i + 1] = e.nanColor[1] * 255 + .5, r[i + 2] = e.nanColor[2] * 255 + .5, r[i + 3] = e.nanColor[3] * 255 + .5;
        }, t.build = ()=>{
            (e.table.length < 1 || t.getMTime() > e.buildTime.getMTime() && e.insertTime.getMTime() <= e.buildTime.getMTime()) && t.forceBuild();
        }, e.table.length > 0 && (t.buildSpecialColors(), e.insertTime.modified());
    }
    const c$ = {
        numberOfColors: 256,
        hueRange: [
            0,
            .66667
        ],
        saturationRange: [
            1,
            1
        ],
        valueRange: [
            1,
            1
        ],
        alphaRange: [
            1,
            1
        ],
        nanColor: [
            .5,
            0,
            0,
            1
        ],
        belowRangeColor: [
            0,
            0,
            0,
            1
        ],
        aboveRangeColor: [
            1,
            1,
            1,
            1
        ],
        useAboveRangeColor: !1,
        useBelowRangeColor: !1,
        alpha: 1
    };
    function XE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, c$, n), b3.extend(t, e, n), e.table || (e.table = []), e.buildTime = {}, K.obj(e.buildTime), e.opaqueFlagBuildTime = {}, K.obj(e.opaqueFlagBuildTime, {
            mtime: 0
        }), e.insertTime = {}, K.obj(e.insertTime, {
            mtime: 0
        }), K.get(t, e, [
            "buildTime"
        ]), K.setGet(t, e, [
            "numberOfColors",
            "useAboveRangeColor",
            "useBelowRangeColor"
        ]), K.setArray(t, e, [
            "alphaRange",
            "hueRange",
            "saturationRange",
            "valueRange"
        ], 2), K.setArray(t, e, [
            "nanColor",
            "belowRangeColor",
            "aboveRangeColor"
        ], 4), K.getArray(t, e, [
            "hueRange",
            "saturationRange",
            "valueRange",
            "alphaRange",
            "nanColor",
            "belowRangeColor",
            "aboveRangeColor"
        ]), s$(t, e);
    }
    const l$ = K.newInstance(XE, "vtkLookupTable");
    Bv = {
        newInstance: l$,
        extend: XE
    };
    const { FieldAssociations: fC } = of, { staticOffsetAPI: u$, otherStaticMethods: f$ } = Np, { ColorMode: S1, ScalarMode: v0, GetArray: S5 } = M3, { VectorMode: d$ } = I3, { VtkDataTypes: g$ } = Wt;
    function Gf(t) {
        return ()=>K.vtkErrorMacro(`vtkMapper::${t} - NOT IMPLEMENTED`);
    }
    function h$(t, e) {
        const n = t[1] % 2 === 0 ? 1 : -1;
        if (t[0] += n, t[0] >= e[0] || t[0] < 0) {
            const r = t[2] % 2 === 0 ? 1 : -1;
            t[0] -= n, t[1] += r, (t[1] >= e[1] || t[1] < 0) && (t[1] -= r, t[2]++);
        }
    }
    function p$(t, e) {
        return t[0] + e[0] * (t[1] + e[1] * t[2]);
    }
    function dC(t, e, n) {
        const r = Math.floor(e), i = r % (2 * n[0]);
        let a, o;
        i < n[0] ? (t[0] = i, a = 1, o = t[0] === n[0] - 1) : (t[0] = 2 * n[0] - 1 - i, a = -1, o = t[0] === 0);
        const s = Math.floor(r / n[0]), c = s % (2 * n[1]);
        let l, f;
        c < n[1] ? (t[1] = c, l = 1, f = t[1] === n[1] - 1) : (t[1] = 2 * n[1] - 1 - c, l = -1, f = t[1] === 0), t[2] = Math.floor(s / n[1]);
        const u = e - r;
        o ? f ? t[2] += u : t[1] += l * u : t[0] += a * u, t[0] = (t[0] + .5) / n[0], t[1] = (t[1] + .5) / n[1], t[2] = (t[2] + .5) / n[2];
    }
    const gC = new WeakMap;
    function m$(t, e, n, r, i, a, o) {
        const s = new Array(arguments.length);
        for(let G = 0; G < arguments.length; ++G){
            const Z = arguments[G];
            s[G] = Z.getMTime?.() ?? Z;
        }
        const c = s.join("/"), l = gC.get(t);
        if (l && l.stringHash === c) return l.textureCoordinates;
        const f = (n[1] - n[0]) / (r - 1), [u, g] = [
            n[0] - f,
            n[1] + f
        ], h = u - .5 * f, v = 1 / (g - u + f), m = u, y = (r + 1) / (g - u), C = t.getData(), T = t.getNumberOfTuples(), x = t.getNumberOfComponents(), S = e < 0 || e >= x, D = i[2] <= 1 ? 2 : 3, _ = Wt.newInstance({
            numberOfComponents: D,
            values: new Float32Array(T * D)
        }), M = _.getData(), P = [
            0,
            0,
            0
        ];
        dC(P, r + 2, i);
        let F = 0, N = 0;
        const B = [
            .5,
            .5,
            .5
        ];
        for(let G = 0; G < T; ++G){
            let Z;
            if (S) {
                let H = 0;
                for(let ne = 0; ne < x; ++ne){
                    const ae = C[F + ne];
                    H += ae * ae;
                }
                Z = Math.sqrt(H);
            } else Z = C[F + e];
            if (F += x, a && (Z = Bv.applyLogScale(Z, n, n)), Bh(Z)) B[0] = P[0], B[1] = P[1], B[2] = P[2];
            else if (o) {
                let H = (Z - m) * y;
                H < 1 ? H = 0 : H > r && (H = r + 1), dC(B, H, i);
            } else {
                B[1] = .49;
                const H = (Z - h) * v;
                H > 1e3 ? B[0] = 1e3 : H < -1e3 ? B[0] = -1e3 : B[0] = H;
            }
            for(let H = 0; H < D; ++H)M[N++] = B[H];
        }
        return gC.set(t, {
            stringHash: c,
            textureCoordinates: _
        }), _;
    }
    function v$(t, e) {
        e.classHierarchy.push("vtkMapper"), t.getBounds = ()=>{
            const n = t.getInputData();
            return n ? (e.static || t.update(), e.bounds = n.getBounds()) : e.bounds = Gl(), e.bounds;
        }, t.setForceCompileOnly = (n)=>{
            e.forceCompileOnly = n;
        }, t.setSelectionWebGLIdsToVTKIds = (n)=>{
            e.selectionWebGLIdsToVTKIds = n;
        }, t.createDefaultLookupTable = ()=>{
            e.lookupTable = Bv.newInstance();
        }, t.getColorModeAsString = ()=>K.enumToString(S1, e.colorMode), t.setColorModeToDefault = ()=>t.setColorMode(0), t.setColorModeToMapScalars = ()=>t.setColorMode(1), t.setColorModeToDirectScalars = ()=>t.setColorMode(2), t.getScalarModeAsString = ()=>K.enumToString(v0, e.scalarMode), t.setScalarModeToDefault = ()=>t.setScalarMode(0), t.setScalarModeToUsePointData = ()=>t.setScalarMode(1), t.setScalarModeToUseCellData = ()=>t.setScalarMode(2), t.setScalarModeToUsePointFieldData = ()=>t.setScalarMode(3), t.setScalarModeToUseCellFieldData = ()=>t.setScalarMode(4), t.setScalarModeToUseFieldData = ()=>t.setScalarMode(5), t.getAbstractScalars = (n, r, i, a, o)=>{
            if (!n || !e.scalarVisibility) return {
                scalars: null,
                cellFlag: !1
            };
            let s = null, c = !1;
            if (r === v0.DEFAULT) s = n.getPointData().getScalars(), s || (s = n.getCellData().getScalars(), c = !0);
            else if (r === v0.USE_POINT_DATA) s = n.getPointData().getScalars();
            else if (r === v0.USE_CELL_DATA) s = n.getCellData().getScalars(), c = !0;
            else if (r === v0.USE_POINT_FIELD_DATA) {
                const l = n.getPointData();
                i === S5.BY_ID ? s = l.getArrayByIndex(a) : s = l.getArrayByName(o);
            } else if (r === v0.USE_CELL_FIELD_DATA) {
                const l = n.getCellData();
                c = !0, i === S5.BY_ID ? s = l.getArrayByIndex(a) : s = l.getArrayByName(o);
            } else if (r === v0.USE_FIELD_DATA) {
                const l = n.getFieldData();
                i === S5.BY_ID ? s = l.getArrayByIndex(a) : s = l.getArrayByName(o);
            }
            return {
                scalars: s,
                cellFlag: c
            };
        }, t.mapScalars = (n, r)=>{
            const { scalars: i, cellFlag: a } = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName);
            if (e.areScalarsMappedFromCells = a, !i) {
                e.colorCoordinates = null, e.colorTextureMap = null, e.colorMapColors = null;
                return;
            }
            const o = `${t.getMTime()}${i.getMTime()}${r}`;
            if (e.colorBuildString !== o) {
                if (e.useLookupTableScalarRange || t.getLookupTable().setRange(e.scalarRange[0], e.scalarRange[1]), t.canUseTextureMapForColoring(i, a)) e.mapScalarsToTexture(i, a, r);
                else {
                    e.colorCoordinates = null, e.colorTextureMap = null;
                    const s = t.getLookupTable();
                    s && (s.build(), e.colorMapColors = s.mapScalars(i, e.colorMode, e.fieldDataTupleId));
                }
                e.colorBuildString = `${t.getMTime()}${i.getMTime()}${r}`;
            }
        }, e.mapScalarsToTexture = (n, r, i)=>{
            const a = e.lookupTable.getRange(), o = e.lookupTable.usingLogScale();
            o && Bv.getLogRange(a, a);
            const s = e.lookupTable.getAlpha();
            if (e.colorMapColors = null, e.colorTextureMap == null || t.getMTime() > e.colorTextureMap.getMTime() || e.lookupTable.getMTime() > e.colorTextureMap.getMTime() || e.lookupTable.getAlpha() !== i) {
                e.lookupTable.setAlpha(i), e.colorTextureMap = null, e.lookupTable.build();
                const l = e.lookupTable.getNumberOfAvailableColors(), f = 2048, u = f ** 3 - 3, h = 4096 - 2, v = 2, m = r ? u : h;
                e.numberOfColorsInRange = Math.min(Math.max(l, v), m);
                const y = e.numberOfColorsInRange + 3, C = e.numberOfColorsInRange + 2, T = r ? [
                    Math.min(Math.ceil(y / f ** 0), f),
                    Math.min(Math.ceil(y / f ** 1), f),
                    Math.min(Math.ceil(y / f ** 2), f)
                ] : [
                    C,
                    2,
                    1
                ], x = T[0] * T[1] * T[2], S = new Float64Array(x);
                S.fill(NaN);
                const D = e.numberOfColorsInRange, _ = D + 2, M = [
                    0,
                    0,
                    0
                ], P = a[0], F = a[1] - a[0];
                for(let G = 0; G < _; ++G){
                    const Z = p$(M, T), H = P + F * (G - 1) / (D - 1);
                    S[Z] = o ? 10 ** H : H, h$(M, T);
                }
                const N = Wt.newInstance({
                    numberOfComponents: 1,
                    values: S
                }), B = e.lookupTable.mapScalars(N, e.colorMode, 0);
                e.colorTextureMap = Up.newInstance(), e.colorTextureMap.setDimensions(T), e.colorTextureMap.getPointData().setScalars(B), e.lookupTable.setAlpha(s);
            }
            const c = e.lookupTable.getVectorMode() === d$.MAGNITUDE && n.getNumberOfComponents() > 1 ? -1 : e.lookupTable.getVectorComponent();
            e.colorCoordinates = m$(n, c, a, e.numberOfColorsInRange, e.colorTextureMap.getDimensions(), o, r);
        }, t.getIsOpaque = ()=>{
            const n = t.getInputData(), i = t.getAbstractScalars(n, e.scalarMode, e.arrayAccessMode, e.arrayId, e.colorByArrayName).scalars;
            if (!e.scalarVisibility || i == null) return !0;
            const a = t.getLookupTable();
            return a ? (a.build(), a.areScalarsOpaque(i, e.colorMode, -1)) : !0;
        }, t.canUseTextureMapForColoring = (n, r)=>r && e.colorMode !== S1.DIRECT_SCALARS ? !0 : !(!e.interpolateScalarsBeforeMapping || e.lookupTable && e.lookupTable.getIndexedLookup() || !n || e.colorMode === S1.DEFAULT && n.getDataType() === g$.UNSIGNED_CHAR || e.colorMode === S1.DIRECT_SCALARS), t.clearColorArrays = ()=>{
            e.colorMapColors = null, e.colorCoordinates = null, e.colorTextureMap = null;
        }, t.getLookupTable = ()=>(e.lookupTable || t.createDefaultLookupTable(), e.lookupTable), t.getMTime = ()=>{
            let n = e.mtime;
            if (e.lookupTable !== null) {
                const r = e.lookupTable.getMTime();
                n = r > n ? r : n;
            }
            return n;
        }, t.getPrimitiveCount = ()=>{
            const n = t.getInputData();
            return {
                points: n.getPoints().getNumberOfValues() / 3,
                verts: n.getVerts().getNumberOfValues() - n.getVerts().getNumberOfCells(),
                lines: n.getLines().getNumberOfValues() - 2 * n.getLines().getNumberOfCells(),
                triangles: n.getPolys().getNumberOfValues() - 3 * n.getPolys().getNumberOfCells()
            };
        }, t.acquireInvertibleLookupTable = Gf("AcquireInvertibleLookupTable"), t.valueToColor = Gf("ValueToColor"), t.colorToValue = Gf("ColorToValue"), t.useInvertibleColorFor = Gf("UseInvertibleColorFor"), t.clearInvertibleColor = Gf("ClearInvertibleColor"), t.processSelectorPixelBuffers = (n, r)=>{
            if (!n || !e.selectionWebGLIdsToVTKIds || !e.populateSelectionSettings) return;
            const i = n.getRawPixelBuffer(_a.ID_LOW24), a = n.getRawPixelBuffer(_a.ID_HIGH24), o = n.getCurrentPass(), s = n.getFieldAssociation();
            let c = null;
            s === fC.FIELD_ASSOCIATION_POINTS ? c = e.selectionWebGLIdsToVTKIds.points : s === fC.FIELD_ASSOCIATION_CELLS && (c = e.selectionWebGLIdsToVTKIds.cells), c && r.forEach((l)=>{
                if (o === _a.ID_LOW24) {
                    let f = 0;
                    a && (f += a[l], f *= 256), f += i[l + 2], f *= 256, f += i[l + 1], f *= 256, f += i[l];
                    const u = c[f], g = n.getPixelBuffer(_a.ID_LOW24);
                    g[l] = u & 255, g[l + 1] = (u & 65280) >> 8, g[l + 2] = (u & 16711680) >> 16;
                } else if (o === _a.ID_HIGH24 && a) {
                    let f = 0;
                    f += a[l], f *= 256, f += i[l + 2], f *= 256, f += i[l + 1], f *= 256, f += i[l];
                    const u = c[f], g = n.getPixelBuffer(_a.ID_HIGH24);
                    g[l] = (u & 4278190080) >> 24;
                }
            });
        };
    }
    const y$ = {
        colorMapColors: null,
        areScalarsMappedFromCells: !1,
        static: !1,
        lookupTable: null,
        scalarVisibility: !0,
        scalarRange: [
            0,
            1
        ],
        useLookupTableScalarRange: !1,
        colorMode: 0,
        scalarMode: 0,
        arrayAccessMode: 1,
        renderTime: 0,
        colorByArrayName: null,
        fieldDataTupleId: -1,
        populateSelectionSettings: !0,
        selectionWebGLIdsToVTKIds: null,
        interpolateScalarsBeforeMapping: !1,
        colorCoordinates: null,
        colorTextureMap: null,
        numberOfColorsInRange: 0,
        forceCompileOnly: 0,
        useInvertibleColors: !1,
        invertibleScalars: null,
        customShaderAttributes: []
    };
    function YE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, y$, n), m4.extend(t, e, n), K.get(t, e, [
            "areScalarsMappedFromCells",
            "colorCoordinates",
            "colorMapColors",
            "colorTextureMap",
            "numberOfColorsInRange",
            "selectionWebGLIdsToVTKIds"
        ]), K.setGet(t, e, [
            "colorByArrayName",
            "arrayAccessMode",
            "colorMode",
            "fieldDataTupleId",
            "interpolateScalarsBeforeMapping",
            "lookupTable",
            "populateSelectionSettings",
            "renderTime",
            "scalarMode",
            "scalarVisibility",
            "static",
            "useLookupTableScalarRange",
            "customShaderAttributes"
        ]), K.setGetArray(t, e, [
            "scalarRange"
        ], 2), Np.implementCoincidentTopologyMethods(t, e), v$(t, e);
    }
    const C$ = K.newInstance(YE, "vtkMapper");
    ZE = {
        newInstance: C$,
        extend: YE,
        ...u$,
        ...f$,
        ...M3
    };
    const { FieldAssociations: E5 } = of, { primTypes: vi } = Yl, { Representation: mu, Shading: hC } = eg, { ScalarMode: E1 } = ZE, { Filter: pC, Wrap: mC } = Qn, { vtkErrorMacro: y0 } = da, w$ = {
        type: "StartEvent"
    }, T$ = {
        type: "EndEvent"
    }, { CoordinateSystem: x$ } = rS;
    function S$(t) {
        const e = t.getSelector();
        return e ? e.getCurrentPass() : _a.MIN_KNOWN_PASS - 1;
    }
    function E$(t, e) {
        e.classHierarchy.push("vtkOpenGLPolyDataMapper"), t.buildPass = (r)=>{
            r && (e.currentRenderPass = null, e.openGLActor = t.getFirstAncestorOfType("vtkOpenGLActor"), e._openGLRenderer = e.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"), e.openGLCamera = e._openGLRenderer.getViewNodeFor(e._openGLRenderer.getRenderable().getActiveCamera()));
        }, t.translucentPass = (r, i)=>{
            r && (e.currentRenderPass = i, t.render());
        }, t.zBufferPass = (r)=>{
            r && (e.haveSeenDepthRequest = !0, e.renderDepth = !0, t.render(), e.renderDepth = !1);
        }, t.opaqueZBufferPass = (r)=>t.zBufferPass(r), t.opaquePass = (r)=>{
            r && t.render();
        }, t.render = ()=>{
            const r = e._openGLRenderWindow.getContext();
            if (e.context !== r) {
                e.context = r;
                for(let o = vi.Start; o < vi.End; o++)e.primitives[o].setOpenGLRenderWindow(e._openGLRenderWindow);
            }
            const i = e.openGLActor.getRenderable(), a = e._openGLRenderer.getRenderable();
            t.renderPiece(a, i);
        }, t.getShaderTemplate = (r, i, a)=>{
            r.Vertex = d4, r.Fragment = Jd, r.Geometry = "";
        }, t.replaceShaderColor = (r, i, a)=>{
            let o = r.Vertex, s = r.Geometry, c = r.Fragment;
            const l = e.lastBoundBO.getReferenceByName("lastLightComplexity");
            let f = [
                "uniform float ambient;",
                "uniform float diffuse;",
                "uniform float specular;",
                "uniform float opacityUniform; // the fragment opacity",
                "uniform vec3 ambientColorUniform;",
                "uniform vec3 diffuseColorUniform;"
            ];
            l && (f = f.concat([
                "uniform vec3 specularColorUniform;",
                "uniform float specularPowerUniform;"
            ]));
            let u = [
                "vec3 ambientColor;",
                "  vec3 diffuseColor;",
                "  float opacity;"
            ];
            l && (u = u.concat([
                "  vec3 specularColor;",
                "  float specularPower;"
            ])), u = u.concat([
                "  ambientColor = ambientColorUniform;",
                "  diffuseColor = diffuseColorUniform;",
                "  opacity = opacityUniform;"
            ]), l && (u = u.concat([
                "  specularColor = specularColorUniform;",
                "  specularPower = specularPowerUniform;"
            ])), e.lastBoundBO.getCABO().getColorComponents() !== 0 && !e.drawingEdges && (f = f.concat([
                "varying vec4 vertexColorVSOutput;"
            ]), o = Te.substitute(o, "//VTK::Color::Dec", [
                "attribute vec4 scalarColor;",
                "varying vec4 vertexColorVSOutput;"
            ]).result, o = Te.substitute(o, "//VTK::Color::Impl", [
                "vertexColorVSOutput =  scalarColor;"
            ]).result, s = Te.substitute(s, "//VTK::Color::Dec", [
                "in vec4 vertexColorVSOutput[];",
                "out vec4 vertexColorGSOutput;"
            ]).result, s = Te.substitute(s, "//VTK::Color::Impl", [
                "vertexColorGSOutput = vertexColorVSOutput[i];"
            ]).result), e.lastBoundBO.getCABO().getColorComponents() !== 0 && !e.drawingEdges ? c = Te.substitute(c, "//VTK::Color::Impl", u.concat([
                "  diffuseColor = vertexColorVSOutput.rgb;",
                "  ambientColor = vertexColorVSOutput.rgb;",
                "  opacity = opacity*vertexColorVSOutput.a;"
            ])).result : (e.renderable.getAreScalarsMappedFromCells() || e.renderable.getInterpolateScalarsBeforeMapping()) && e.renderable.getColorCoordinates() && !e.drawingEdges ? c = Te.substitute(c, "//VTK::Color::Impl", u.concat([
                "  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);",
                "  diffuseColor = texColor.rgb;",
                "  ambientColor = texColor.rgb;",
                "  opacity = opacity*texColor.a;"
            ])).result : (a.getBackfaceProperty() && !e.drawingEdges && (f = f.concat([
                "uniform float opacityUniformBF; // the fragment opacity",
                "uniform float ambientIntensityBF; // the material ambient",
                "uniform float diffuseIntensityBF; // the material diffuse",
                "uniform vec3 ambientColorUniformBF; // ambient material color",
                "uniform vec3 diffuseColorUniformBF; // diffuse material color"
            ]), l ? (f = f.concat([
                "uniform float specularIntensityBF; // the material specular intensity",
                "uniform vec3 specularColorUniformBF; // intensity weighted color",
                "uniform float specularPowerUniformBF;"
            ]), u = u.concat([
                "if (gl_FrontFacing == false) {",
                "  ambientColor = ambientIntensityBF * ambientColorUniformBF;",
                "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;",
                "  specularColor = specularIntensityBF * specularColorUniformBF;",
                "  specularPower = specularPowerUniformBF;",
                "  opacity = opacityUniformBF; }"
            ])) : u = u.concat([
                "if (gl_FrontFacing == false) {",
                "  ambientColor = ambientIntensityBF * ambientColorUniformBF;",
                "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;",
                "  opacity = opacityUniformBF; }"
            ])), e.haveCellScalars && !e.drawingEdges && (f = f.concat([
                "uniform samplerBuffer texture1;"
            ])), c = Te.substitute(c, "//VTK::Color::Impl", u).result), c = Te.substitute(c, "//VTK::Color::Dec", f).result, r.Vertex = o, r.Geometry = s, r.Fragment = c;
        }, t.replaceShaderLight = (r, i, a)=>{
            let o = r.Fragment;
            const s = "", c = e.lastBoundBO.getReferenceByName("lastLightComplexity"), l = e.lastBoundBO.getReferenceByName("lastLightCount");
            let f = [];
            switch(c){
                case 0:
                    o = Te.substitute(o, "//VTK::Light::Impl", [
                        "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);",
                        "  //VTK::Light::Impl"
                    ], !1).result;
                    break;
                case 1:
                    o = Te.substitute(o, "//VTK::Light::Impl", [
                        "  float df = max(0.0, normalVCVSOutput.z);",
                        "  float sf = pow(df, specularPower);",
                        "  vec3 diffuseL = df * diffuseColor;",
                        "  vec3 specularL = sf * specularColor;",
                        "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
                        "  //VTK::Light::Impl"
                    ], !1).result;
                    break;
                case 2:
                    for(let u = 0; u < l; ++u)f = f.concat([
                        `uniform vec3 lightColor${u};`,
                        `uniform vec3 lightDirectionVC${u}; // normalized`,
                        `uniform vec3 lightHalfAngleVC${u}; // normalized`
                    ]);
                    o = Te.substitute(o, "//VTK::Light::Dec", f).result, f = [
                        "vec3 diffuseL = vec3(0,0,0);",
                        "  vec3 specularL = vec3(0,0,0);",
                        "  float df;"
                    ];
                    for(let u = 0; u < l; ++u)f = f.concat([
                        `  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${u}));`,
                        `  diffuseL += ((df${s}) * lightColor${u});`,
                        `  if (dot(normalVCVSOutput, lightDirectionVC${u}) < 0.0)`,
                        "    {",
                        `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${u},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`,
                        `    specularL += (sf${s} * lightColor${u});`,
                        "    }"
                    ]);
                    f = f.concat([
                        "  diffuseL = diffuseL * diffuseColor;",
                        "  specularL = specularL * specularColor;",
                        "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
                        "  //VTK::Light::Impl"
                    ]), o = Te.substitute(o, "//VTK::Light::Impl", f, !1).result;
                    break;
                case 3:
                    for(let u = 0; u < l; ++u)f = f.concat([
                        `uniform vec3 lightColor${u};`,
                        `uniform vec3 lightDirectionVC${u}; // normalized`,
                        `uniform vec3 lightHalfAngleVC${u}; // normalized`,
                        `uniform vec3 lightPositionVC${u};`,
                        `uniform vec3 lightAttenuation${u};`,
                        `uniform float lightConeAngle${u};`,
                        `uniform float lightExponent${u};`,
                        `uniform int lightPositional${u};`
                    ]);
                    o = Te.substitute(o, "//VTK::Light::Dec", f).result, f = [
                        "vec3 diffuseL = vec3(0,0,0);",
                        "  vec3 specularL = vec3(0,0,0);",
                        "  vec3 vertLightDirectionVC;",
                        "  float attenuation;",
                        "  float df;"
                    ];
                    for(let u = 0; u < l; ++u)f = f.concat([
                        "  attenuation = 1.0;",
                        `  if (lightPositional${u} == 0)`,
                        "    {",
                        `      vertLightDirectionVC = lightDirectionVC${u};`,
                        "    }",
                        "  else",
                        "    {",
                        `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${u};`,
                        "    float distanceVC = length(vertLightDirectionVC);",
                        "    vertLightDirectionVC = normalize(vertLightDirectionVC);",
                        "    attenuation = 1.0 /",
                        `      (lightAttenuation${u}.x`,
                        `       + lightAttenuation${u}.y * distanceVC`,
                        `       + lightAttenuation${u}.z * distanceVC * distanceVC);`,
                        "    // per OpenGL standard cone angle is 90 or less for a spot light",
                        `    if (lightConeAngle${u} <= 90.0)`,
                        "      {",
                        `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${u});`,
                        "      // if inside the cone",
                        `      if (coneDot >= cos(radians(lightConeAngle${u})))`,
                        "        {",
                        `        attenuation = attenuation * pow(coneDot, lightExponent${u});`,
                        "        }",
                        "      else",
                        "        {",
                        "        attenuation = 0.0;",
                        "        }",
                        "      }",
                        "    }",
                        "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",
                        `    diffuseL += ((df${s}) * lightColor${u});`,
                        "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)",
                        "      {",
                        `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${u},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`,
                        `    specularL += ((sf${s}) * lightColor${u});`,
                        "    }"
                    ]);
                    f = f.concat([
                        "  diffuseL = diffuseL * diffuseColor;",
                        "  specularL = specularL * specularColor;",
                        "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);",
                        "  //VTK::Light::Impl"
                    ]), o = Te.substitute(o, "//VTK::Light::Impl", f, !1).result;
                    break;
                default:
                    y0("bad light complexity");
            }
            r.Fragment = o;
        }, t.replaceShaderNormal = (r, i, a)=>{
            if (e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0) {
                let s = r.Vertex, c = r.Geometry, l = r.Fragment;
                e.lastBoundBO.getCABO().getNormalOffset() ? (s = Te.substitute(s, "//VTK::Normal::Dec", [
                    "attribute vec3 normalMC;",
                    "uniform mat3 normalMatrix;",
                    "varying vec3 normalVCVSOutput;"
                ]).result, s = Te.substitute(s, "//VTK::Normal::Impl", [
                    "normalVCVSOutput = normalMatrix * normalMC;"
                ]).result, c = Te.substitute(c, "//VTK::Normal::Dec", [
                    "in vec3 normalVCVSOutput[];",
                    "out vec3 normalVCGSOutput;"
                ]).result, c = Te.substitute(c, "//VTK::Normal::Impl", [
                    "normalVCGSOutput = normalVCVSOutput[i];"
                ]).result, l = Te.substitute(l, "//VTK::Normal::Dec", [
                    "varying vec3 normalVCVSOutput;"
                ]).result, l = Te.substitute(l, "//VTK::Normal::Impl", [
                    "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
                    "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
                ]).result) : e.haveCellNormals ? (l = Te.substitute(l, "//VTK::Normal::Dec", [
                    "uniform mat3 normalMatrix;",
                    "uniform samplerBuffer textureN;"
                ]).result, l = Te.substitute(l, "//VTK::Normal::Impl", [
                    "vec3 normalVCVSOutput = normalize(normalMatrix *",
                    "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);",
                    "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
                ]).result) : e.lastBoundBO.getOpenGLMode(a.getProperty().getRepresentation()) === e.context.LINES ? (l = Te.substitute(l, "//VTK::UniformFlow::Impl", [
                    "  vec3 fdx = dFdx(vertexVC.xyz);",
                    "  vec3 fdy = dFdy(vertexVC.xyz);",
                    "  //VTK::UniformFlow::Impl"
                ]).result, l = Te.substitute(l, "//VTK::Normal::Impl", [
                    "vec3 normalVCVSOutput;",
                    "  if (abs(fdx.x) > 0.0)",
                    "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }",
                    "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"
                ]).result) : (l = Te.substitute(l, "//VTK::Normal::Dec", [
                    "uniform int cameraParallel;"
                ]).result, l = Te.substitute(l, "//VTK::UniformFlow::Impl", [
                    "  vec3 fdx = dFdx(vertexVC.xyz);",
                    "  vec3 fdy = dFdy(vertexVC.xyz);",
                    "  //VTK::UniformFlow::Impl"
                ]).result, l = Te.substitute(l, "//VTK::Normal::Impl", [
                    "  fdx = normalize(fdx);",
                    "  fdy = normalize(fdy);",
                    "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
                    "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
                    "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
                ]).result), r.Vertex = s, r.Geometry = c, r.Fragment = l;
            }
        }, t.replaceShaderPositionVC = (r, i, a)=>{
            e.lastBoundBO.replaceShaderPositionVC(r, i, a);
            let o = r.Vertex, s = r.Geometry, c = r.Fragment;
            e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0 ? (o = Te.substitute(o, "//VTK::PositionVC::Dec", [
                "varying vec4 vertexVCVSOutput;"
            ]).result, o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                "vertexVCVSOutput = MCVCMatrix * vertexMC;",
                "  gl_Position = MCPCMatrix * vertexMC;"
            ]).result, o = Te.substitute(o, "//VTK::Camera::Dec", [
                "uniform mat4 MCPCMatrix;",
                "uniform mat4 MCVCMatrix;"
            ]).result, s = Te.substitute(s, "//VTK::PositionVC::Dec", [
                "in vec4 vertexVCVSOutput[];",
                "out vec4 vertexVCGSOutput;"
            ]).result, s = Te.substitute(s, "//VTK::PositionVC::Impl", [
                "vertexVCGSOutput = vertexVCVSOutput[i];"
            ]).result, c = Te.substitute(c, "//VTK::PositionVC::Dec", [
                "varying vec4 vertexVCVSOutput;"
            ]).result, c = Te.substitute(c, "//VTK::PositionVC::Impl", [
                "vec4 vertexVC = vertexVCVSOutput;"
            ]).result) : (o = Te.substitute(o, "//VTK::Camera::Dec", [
                "uniform mat4 MCPCMatrix;"
            ]).result, o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                "  gl_Position = MCPCMatrix * vertexMC;"
            ]).result), r.Vertex = o, r.Geometry = s, r.Fragment = c;
        }, t.replaceShaderTCoord = (r, i, a)=>{
            if (e.lastBoundBO.getCABO().getTCoordOffset()) {
                let o = r.Vertex, s = r.Geometry, c = r.Fragment;
                if (e.drawingEdges) return;
                o = Te.substitute(o, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
                const l = e.openGLActor.getActiveTextures();
                let f = 2, u = 2;
                if (l && l.length > 0 && (f = l[0].getComponents(), l[0].getTarget() === e.context.TEXTURE_CUBE_MAP && (u = 3)), e.renderable.getColorTextureMap() && (f = e.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(), u = 2), u === 2) {
                    if (o = Te.substitute(o, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result, s = Te.substitute(s, "//VTK::TCoord::Dec", [
                        "in vec2 tcoordVCVSOutput[];",
                        "out vec2 tcoordVCGSOutput;"
                    ]).result, s = Te.substitute(s, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result, c = Te.substitute(c, "//VTK::TCoord::Dec", [
                        "varying vec2 tcoordVCVSOutput;",
                        "uniform sampler2D texture1;"
                    ]).result, l && l.length >= 1) switch(f){
                        case 1:
                            c = Te.substitute(c, "//VTK::TCoord::Impl", [
                                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                                "  ambientColor = ambientColor*tcolor.r;",
                                "  diffuseColor = diffuseColor*tcolor.r;"
                            ]).result;
                            break;
                        case 2:
                            c = Te.substitute(c, "//VTK::TCoord::Impl", [
                                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                                "  ambientColor = ambientColor*tcolor.r;",
                                "  diffuseColor = diffuseColor*tcolor.r;",
                                "  opacity = opacity * tcolor.g;"
                            ]).result;
                            break;
                        default:
                            c = Te.substitute(c, "//VTK::TCoord::Impl", [
                                "  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);",
                                "  ambientColor = ambientColor*tcolor.rgb;",
                                "  diffuseColor = diffuseColor*tcolor.rgb;",
                                "  opacity = opacity * tcolor.a;"
                            ]).result;
                    }
                } else switch(o = Te.substitute(o, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result, s = Te.substitute(s, "//VTK::TCoord::Dec", [
                    "in vec3 tcoordVCVSOutput[];",
                    "out vec3 tcoordVCGSOutput;"
                ]).result, s = Te.substitute(s, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result, c = Te.substitute(c, "//VTK::TCoord::Dec", [
                    "varying vec3 tcoordVCVSOutput;",
                    "uniform samplerCube texture1;"
                ]).result, f){
                    case 1:
                        c = Te.substitute(c, "//VTK::TCoord::Impl", [
                            "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
                            "  ambientColor = ambientColor*tcolor.r;",
                            "  diffuseColor = diffuseColor*tcolor.r;"
                        ]).result;
                        break;
                    case 2:
                        c = Te.substitute(c, "//VTK::TCoord::Impl", [
                            "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
                            "  ambientColor = ambientColor*tcolor.r;",
                            "  diffuseColor = diffuseColor*tcolor.r;",
                            "  opacity = opacity * tcolor.g;"
                        ]).result;
                        break;
                    default:
                        c = Te.substitute(c, "//VTK::TCoord::Impl", [
                            "  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);",
                            "  ambientColor = ambientColor*tcolor.rgb;",
                            "  diffuseColor = diffuseColor*tcolor.rgb;",
                            "  opacity = opacity * tcolor.a;"
                        ]).result;
                }
                r.Vertex = o, r.Geometry = s, r.Fragment = c;
            }
        }, t.replaceShaderClip = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            if (e.renderable.getNumberOfClippingPlanes()) {
                const c = e.renderable.getNumberOfClippingPlanes();
                o = Te.substitute(o, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    `uniform vec4 clipPlanes[${c}];`,
                    `varying float clipDistancesVSOutput[${c}];`
                ]).result, o = Te.substitute(o, "//VTK::Clip::Impl", [
                    `for (int planeNum = 0; planeNum < ${c}; planeNum++)`,
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);",
                    "    }"
                ]).result, s = Te.substitute(s, "//VTK::Clip::Dec", [
                    "uniform int numClipPlanes;",
                    `varying float clipDistancesVSOutput[${c}];`
                ]).result, s = Te.substitute(s, "//VTK::Clip::Impl", [
                    `for (int planeNum = 0; planeNum < ${c}; planeNum++)`,
                    "    {",
                    "    if (planeNum >= numClipPlanes)",
                    "        {",
                    "        break;",
                    "        }",
                    "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;",
                    "    }"
                ]).result;
            }
            r.Vertex = o, r.Fragment = s;
        }, t.getCoincidentParameters = (r, i)=>{
            let a = {
                factor: 0,
                offset: 0
            };
            const o = i.getProperty();
            if (e.renderable.getResolveCoincidentTopology() == Ds.PolygonOffset || o.getEdgeVisibility() && o.getRepresentation() === mu.SURFACE) {
                const c = e.lastBoundBO.getPrimitiveType();
                c === vi.Points || o.getRepresentation() === mu.POINTS ? a = e.renderable.getCoincidentTopologyPointOffsetParameter() : c === vi.Lines || o.getRepresentation() === mu.WIREFRAME ? a = e.renderable.getCoincidentTopologyLineOffsetParameters() : (c === vi.Tris || c === vi.TriStrips) && (a = e.renderable.getCoincidentTopologyPolygonOffsetParameters()), (c === vi.TrisEdges || c === vi.TriStripsEdges) && (a = e.renderable.getCoincidentTopologyPolygonOffsetParameters(), a.factor /= 2, a.offset /= 2);
            }
            const s = e._openGLRenderer.getSelector();
            return s && s.getFieldAssociation() === E5.FIELD_ASSOCIATION_POINTS && (a.offset -= 2), a;
        }, t.replaceShaderPicking = (r, i, a)=>{
            let o = r.Fragment, s = r.Vertex;
            if (o = Te.substitute(o, "//VTK::Picking::Dec", [
                "uniform int picking;",
                "//VTK::Picking::Dec"
            ]).result, !!e._openGLRenderer.getSelector()) {
                switch((e.lastSelectionState === _a.ID_LOW24 || e.lastSelectionState === _a.ID_HIGH24) && (s = Te.substitute(s, "//VTK::Picking::Dec", [
                    `flat out int vertexIDVSOutput;
`,
                    `uniform int VertexIDOffset;
`
                ]).result, s = Te.substitute(s, "//VTK::Picking::Impl", `  vertexIDVSOutput = gl_VertexID + VertexIDOffset;
`).result, o = Te.substitute(o, "//VTK::Picking::Dec", `flat in int vertexIDVSOutput;
`).result, o = Te.substitute(o, "//VTK::Picking::Impl", [
                    "  int idx = vertexIDVSOutput;",
                    "//VTK::Picking::Impl"
                ]).result), e.lastSelectionState){
                    case _a.ID_LOW24:
                        o = Te.substitute(o, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
                        break;
                    case _a.ID_HIGH24:
                        o = Te.substitute(o, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;
                        break;
                    default:
                        o = Te.substitute(o, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result, o = Te.substitute(o, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
                }
                r.Fragment = o, r.Vertex = s;
            }
        }, t.replaceShaderValues = (r, i, a)=>{
            if (t.replaceShaderColor(r, i, a), t.replaceShaderNormal(r, i, a), t.replaceShaderLight(r, i, a), t.replaceShaderTCoord(r, i, a), t.replaceShaderPicking(r, i, a), t.replaceShaderClip(r, i, a), t.replaceShaderCoincidentOffset(r, i, a), t.replaceShaderPositionVC(r, i, a), e.haveSeenDepthRequest) {
                let o = r.Fragment;
                o = Te.substitute(o, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result, o = Te.substitute(o, "//VTK::ZBuffer::Impl", [
                    "if (depthRequest == 1) {",
                    "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);",
                    "float rf = floor(iz/256.0)/255.0;",
                    "float gf = mod(iz,256.0)/255.0;",
                    "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
                ]).result, r.Fragment = o;
            }
        }, t.getNeedToRebuildShaders = (r, i, a)=>{
            let o = 0, s = 0;
            const c = r.getPrimitiveType(), l = e.currentInput;
            let f = !1;
            const u = l.getPointData().getNormals(), g = l.getCellData().getNormals(), h = a.getProperty().getInterpolation() === hC.FLAT, v = a.getProperty().getRepresentation(), m = r.getOpenGLMode(v, c);
            if ((m === e.context.TRIANGLES || g && !u || !h && u || !h && m === e.context.LINES) && (f = !0), a.getProperty().getLighting() && f) {
                o = 0;
                const x = i.getLightsByReference();
                for(let S = 0; S < x.length; ++S){
                    const D = x[S];
                    D.getSwitch() > 0 && (s++, o === 0 && (o = 1)), o === 1 && (s > 1 || D.getIntensity() !== 1 || !D.lightTypeIsHeadLight()) && (o = 2), o < 3 && D.getPositional() && (o = 3);
                }
            }
            let y = !1;
            const C = e.lastBoundBO.getReferenceByName("lastLightComplexity"), T = e.lastBoundBO.getReferenceByName("lastLightCount");
            return (C !== o || T !== s) && (e.lastBoundBO.set({
                lastLightComplexity: o
            }, !0), e.lastBoundBO.set({
                lastLightCount: s
            }, !0), y = !0), (!e.currentRenderPass && e.lastRenderPassShaderReplacement || e.currentRenderPass && e.currentRenderPass.getShaderReplacement() !== e.lastRenderPassShaderReplacement) && (y = !0), e.lastHaveSeenDepthRequest !== e.haveSeenDepthRequest || r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || r.getShaderSourceTime().getMTime() < e.currentInput.getMTime() || r.getShaderSourceTime().getMTime() < e.selectionStateChanged.getMTime() || y ? (e.lastHaveSeenDepthRequest = e.haveSeenDepthRequest, !0) : !1;
        }, t.invokeShaderCallbacks = (r, i, a)=>{
            const o = e.renderable.getViewSpecificProperties().ShadersCallbacks;
            o && o.forEach((s)=>{
                s.callback(s.userData, r, i, a);
            });
        }, t.setMapperShaderParameters = (r, i, a)=>{
            if (r.getProgram().isUniformUsed("PrimitiveIDOffset") && r.getProgram().setUniformi("PrimitiveIDOffset", e.primitiveIDOffset), r.getProgram().isUniformUsed("VertexIDOffset") && r.getProgram().setUniformi("VertexIDOffset", e.vertexIDOffset), r.getCABO().getElementCount() && (e.VBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
                const c = e.lastBoundBO.getReferenceByName("lastLightComplexity");
                r.getProgram().isAttributeUsed("vertexMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "vertexMC", r.getCABO().getVertexOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, !1) || y0("Error setting vertexMC in shader VAO.")), r.getProgram().isAttributeUsed("normalMC") && r.getCABO().getNormalOffset() && c > 0 ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "normalMC", r.getCABO().getNormalOffset(), r.getCABO().getStride(), e.context.FLOAT, 3, !1) || y0("Error setting normalMC in shader VAO.") : r.getVAO().removeAttributeArray("normalMC"), e.renderable.getCustomShaderAttributes().forEach((l, f)=>{
                    r.getProgram().isAttributeUsed(`${l}MC`) && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), `${l}MC`, r.getCABO().getCustomData()[f].offset, r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getCustomData()[f].components, !1) || y0(`Error setting ${l}MC in shader VAO.`));
                }), r.getProgram().isAttributeUsed("tcoordMC") && r.getCABO().getTCoordOffset() ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "tcoordMC", r.getCABO().getTCoordOffset(), r.getCABO().getStride(), e.context.FLOAT, r.getCABO().getTCoordComponents(), !1) || y0("Error setting tcoordMC in shader VAO.") : r.getVAO().removeAttributeArray("tcoordMC"), r.getProgram().isAttributeUsed("scalarColor") && r.getCABO().getColorComponents() ? r.getVAO().addAttributeArray(r.getProgram(), r.getCABO().getColorBO(), "scalarColor", r.getCABO().getColorOffset(), r.getCABO().getColorBOStride(), e.context.UNSIGNED_BYTE, 4, !0) || y0("Error setting scalarColor in shader VAO.") : r.getVAO().removeAttributeArray("scalarColor"), r.getAttributeUpdateTime().modified();
            }
            if (e.renderable.getNumberOfClippingPlanes()) {
                const c = e.renderable.getNumberOfClippingPlanes(), l = [], u = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, g = u ? Ur(e.tmpMat4, a.getMatrix()) : a.getMatrix();
                u && (cn(g, g), Qt(g, g, u), cn(g, g));
                for(let h = 0; h < c; h++){
                    const v = [];
                    e.renderable.getClippingPlaneInDataCoords(g, h, v);
                    for(let m = 0; m < 4; m++)l.push(v[m]);
                }
                r.getProgram().setUniformi("numClipPlanes", c), r.getProgram().setUniform4fv("clipPlanes", l);
            }
            e.internalColorTexture && r.getProgram().isUniformUsed("texture1") && r.getProgram().setUniformi("texture1", e.internalColorTexture.getTextureUnit());
            const o = e.openGLActor.getActiveTextures();
            if (o) for(let c = 0; c < o.length; ++c){
                const f = o[c].getTextureUnit(), u = `texture${f + 1}`;
                r.getProgram().isUniformUsed(u) && r.getProgram().setUniformi(u, f);
            }
            if (e.haveSeenDepthRequest && r.getProgram().setUniformi("depthRequest", e.renderDepth ? 1 : 0), r.getProgram().isUniformUsed("coffset")) {
                const c = t.getCoincidentParameters(i, a);
                r.getProgram().setUniformf("coffset", c.offset), r.getProgram().isUniformUsed("cfactor") && r.getProgram().setUniformf("cfactor", c.factor);
            }
            r.setMapperShaderParameters(i, a, e._openGLRenderer.getTiledSizeAndOrigin());
            const s = e._openGLRenderer.getSelector();
            r.getProgram().setUniform3fArray("mapperIndex", s ? s.getPropColorValue() : [
                0,
                0,
                0
            ]), r.getProgram().setUniformi("picking", s ? s.getCurrentPass() + 1 : 0);
        }, t.setLightingShaderParameters = (r, i, a)=>{
            const o = e.lastBoundBO.getReferenceByName("lastLightComplexity");
            if (o < 2) return;
            const s = r.getProgram();
            let c = 0;
            const l = i.getLightsByReference();
            for(let g = 0; g < l.length; ++g){
                const h = l[g];
                if (h.getSwitch() > 0) {
                    const m = h.getColorByReference(), y = h.getIntensity();
                    e.lightColor[0] = m[0] * y, e.lightColor[1] = m[1] * y, e.lightColor[2] = m[2] * y;
                    const C = h.getDirection(), T = i.getActiveCamera().getViewMatrix(), x = [
                        ...C
                    ];
                    h.lightTypeIsSceneLight() && (x[0] = T[0] * C[0] + T[1] * C[1] + T[2] * C[2], x[1] = T[4] * C[0] + T[5] * C[1] + T[6] * C[2], x[2] = T[8] * C[0] + T[9] * C[1] + T[10] * C[2], F0(x)), e.lightDirection[0] = x[0], e.lightDirection[1] = x[1], e.lightDirection[2] = x[2], F0(e.lightDirection), s.setUniform3fArray(`lightColor${c}`, e.lightColor), s.setUniform3fArray(`lightDirectionVC${c}`, e.lightDirection), c++;
                }
            }
            if (o < 3) return;
            const u = i.getActiveCamera().getViewMatrix();
            cn(u, u), c = 0;
            for(let g = 0; g < l.length; ++g){
                const h = l[g];
                if (h.getSwitch() > 0) {
                    const m = h.getTransformedPosition(), y = new Float64Array(3);
                    pn(y, m, u), s.setUniform3fArray(`lightAttenuation${c}`, h.getAttenuationValuesByReference()), s.setUniformi(`lightPositional${c}`, h.getPositional()), s.setUniformf(`lightExponent${c}`, h.getExponent()), s.setUniformf(`lightConeAngle${c}`, h.getConeAngle()), s.setUniform3fArray(`lightPositionVC${c}`, [
                        y[0],
                        y[1],
                        y[2]
                    ]), c++;
                }
            }
        };
        function n(r, i, a) {
            return i.identity(a), r.reduce((o, s, c)=>c === 0 ? s ? i.copy(o, s) : i.identity(o) : s ? i.multiply(o, o, s) : o, a);
        }
        t.setCameraShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = e.openGLCamera.getKeyMatrices(i), c = i.getActiveCamera(), l = e.openGLCamera.getKeyMatrixTime().getMTime(), f = o.getLastCameraMTime(), g = r.getCABO().getCoordShiftAndScaleEnabled() ? r.getCABO().getInverseShiftAndScaleMatrix() : null, h = a.getIsIdentity(), v = h ? {
                mcwc: null,
                normalMatrix: null
            } : e.openGLActor.getKeyMatrices();
            if (a.getCoordinateSystem() === x$.DISPLAY) {
                const m = e._openGLRenderer.getTiledSizeAndOrigin();
                Ot(e.tmpMat4), e.tmpMat4[0] = 2 / m.usize, e.tmpMat4[12] = -1, e.tmpMat4[5] = 2 / m.vsize, e.tmpMat4[13] = -1, Qt(e.tmpMat4, e.tmpMat4, g), o.setUniformMatrix("MCPCMatrix", e.tmpMat4);
            } else o.setUniformMatrix("MCPCMatrix", n([
                s.wcpc,
                v.mcwc,
                g
            ], zh, e.tmpMat4));
            o.isUniformUsed("MCVCMatrix") && o.setUniformMatrix("MCVCMatrix", n([
                s.wcvc,
                v.mcwc,
                g
            ], zh, e.tmpMat4)), o.isUniformUsed("normalMatrix") && o.setUniformMatrix3x3("normalMatrix", n([
                s.normalMatrix,
                v.normalMatrix
            ], vV, e.tmpMat3)), f !== l && (o.isUniformUsed("cameraParallel") && o.setUniformi("cameraParallel", c.getParallelProjection()), o.setLastCameraMTime(l)), h || o.setLastCameraMTime(0);
        }, t.setPropertyShaderParameters = (r, i, a)=>{
            const o = r.getProgram();
            let s = a.getProperty(), c = s.getOpacity(), l = e.drawingEdges ? s.getEdgeColorByReference() : s.getAmbientColorByReference(), f = e.drawingEdges ? s.getEdgeColorByReference() : s.getDiffuseColorByReference(), u = e.drawingEdges ? 1 : s.getAmbient(), g = e.drawingEdges ? 0 : s.getDiffuse(), h = e.drawingEdges ? 0 : s.getSpecular();
            const v = s.getSpecularPower();
            o.setUniformf("opacityUniform", c), o.setUniform3fArray("ambientColorUniform", l), o.setUniform3fArray("diffuseColorUniform", f), o.setUniformf("ambient", u), o.setUniformf("diffuse", g);
            const m = e.lastBoundBO.getReferenceByName("lastLightComplexity");
            if (m < 1) return;
            let y = s.getSpecularColorByReference();
            if (o.setUniform3fArray("specularColorUniform", y), o.setUniformf("specularPowerUniform", v), o.setUniformf("specular", h), o.isUniformUsed("ambientIntensityBF")) {
                if (s = a.getBackfaceProperty(), c = s.getOpacity(), l = s.getAmbientColor(), u = s.getAmbient(), f = s.getDiffuseColor(), g = s.getDiffuse(), y = s.getSpecularColor(), h = s.getSpecular(), o.setUniformf("ambientIntensityBF", u), o.setUniformf("diffuseIntensityBF", g), o.setUniformf("opacityUniformBF", c), o.setUniform3fArray("ambientColorUniformBF", l), o.setUniform3fArray("diffuseColorUniformBF", f), m < 1) return;
                o.setUniformf("specularIntensityBF", h), o.setUniform3fArray("specularColorUniformBF", y), o.setUniformf("specularPowerUniformBF", v);
            }
        }, t.updateMaximumPointCellIds = (r, i)=>{
            const a = e._openGLRenderer.getSelector();
            if (!a) return;
            if (e.selectionWebGLIdsToVTKIds?.points?.length) {
                const s = e.selectionWebGLIdsToVTKIds.points.length;
                a.setMaximumPointId(s - 1);
            }
            if (e.selectionWebGLIdsToVTKIds?.cells?.length) {
                const s = e.selectionWebGLIdsToVTKIds.cells.length;
                a.setMaximumCellId(s - 1);
            }
            a.getFieldAssociation() === E5.FIELD_ASSOCIATION_POINTS && (e.pointPicking = !0);
        }, t.renderPieceStart = (r, i)=>{
            e.primitiveIDOffset = 0, e.vertexIDOffset = 0;
            const a = S$(e._openGLRenderer);
            e.lastSelectionState !== a && (e.selectionStateChanged.modified(), e.lastSelectionState = a), e._openGLRenderer.getSelector() && e._openGLRenderer.getSelector().renderProp(i), t.updateBufferObjects(r, i), e.renderable.getColorTextureMap() && e.internalColorTexture.activate(), e.lastBoundBO = null;
        }, t.renderPieceDraw = (r, i)=>{
            const a = i.getProperty().getRepresentation(), o = i.getProperty().getEdgeVisibility() && a === mu.SURFACE, s = e._openGLRenderer.getSelector(), c = s && s.getFieldAssociation() === E5.FIELD_ASSOCIATION_POINTS && (e.lastSelectionState === _a.ID_LOW24 || e.lastSelectionState === _a.ID_HIGH24);
            for(let l = vi.Start; l < vi.End; l++)e.primitives[l].setPointPicking(c), e.primitives[l].getCABO().getElementCount() && (e.drawingEdges = o && (l === vi.TrisEdges || l === vi.TriStripsEdges), (!e.drawingEdges || !(e.renderDepth || e.lastSelectionState >= 0)) && (e.lastBoundBO = e.primitives[l], e.primitiveIDOffset += e.primitives[l].drawArrays(r, i, a, t), e.vertexIDOffset += e.primitives[l].getCABO().getElementCount()));
        }, t.renderPieceFinish = (r, i)=>{
            e.LastBoundBO && e.LastBoundBO.getVAO().release(), e.renderable.getColorTextureMap() && e.internalColorTexture.deactivate();
        }, t.renderPiece = (r, i)=>{
            if (t.invokeEvent(w$), e.renderable.getStatic() || e.renderable.update(), e.currentInput = e.renderable.getInputData(), t.invokeEvent(T$), !e.currentInput) {
                y0("No input!");
                return;
            }
            if (!e.currentInput.getPoints || !e.currentInput.getPoints().getNumberOfValues()) return;
            const a = e.context, o = i.getProperty().getBackfaceCulling(), s = i.getProperty().getFrontfaceCulling();
            !o && !s ? e._openGLRenderWindow.disableCullFace() : s ? (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.FRONT)) : (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.BACK)), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
        }, t.computeBounds = (r, i)=>{
            if (!t.getInput()) {
                af(e.bounds);
                return;
            }
            e.bounds = t.getInput().getBounds();
        }, t.updateBufferObjects = (r, i)=>{
            t.getNeedToRebuildBufferObjects(r, i) && t.buildBufferObjects(r, i), t.updateMaximumPointCellIds();
        }, t.getNeedToRebuildBufferObjects = (r, i)=>{
            const a = e.VBOBuildTime.getMTime();
            return a < t.getMTime() || a < e.renderable.getMTime() || a < i.getMTime() || a < e.currentInput.getMTime();
        }, t.buildBufferObjects = (r, i)=>{
            const a = e.currentInput;
            if (a === null) return;
            e.renderable.mapScalars(a, 1);
            const o = e.renderable.getColorMapColors();
            e.haveCellScalars = !1;
            const s = e.renderable.getScalarMode();
            e.renderable.getScalarVisibility() && (s === E1.USE_CELL_DATA || s === E1.USE_CELL_FIELD_DATA || s === E1.USE_FIELD_DATA || !a.getPointData().getScalars()) && s !== E1.USE_POINT_FIELD_DATA && o && (e.haveCellScalars = !0);
            let c = i.getProperty().getInterpolation() !== hC.FLAT ? a.getPointData().getNormals() : null;
            c === null && a.getCellData().getNormals() && (e.haveCellNormals = !0, c = a.getCellData().getNormals());
            const l = i.getProperty().getRepresentation();
            let f = a.getPointData().getTCoords();
            e.openGLActor.getActiveTextures() || (f = null);
            let u = !1;
            if (e.renderable.getColorCoordinates()) {
                f = e.renderable.getColorCoordinates(), u = e.renderable.getAreScalarsMappedFromCells(), e.internalColorTexture || (e.internalColorTexture = Qn.newInstance({
                    resizable: !0
                }));
                const h = e.internalColorTexture;
                h.setMinificationFilter(pC.NEAREST), h.setMagnificationFilter(pC.NEAREST), h.setWrapS(mC.CLAMP_TO_EDGE), h.setWrapT(mC.CLAMP_TO_EDGE), h.setOpenGLRenderWindow(e._openGLRenderWindow);
                const v = e.renderable.getColorTextureMap(), m = v.getExtent(), y = v.getPointData().getScalars();
                h.create2DFromRaw(m[1] - m[0] + 1, m[3] - m[2] + 1, y.getNumberOfComponents(), y.getDataType(), y.getData()), h.activate(), h.sendParameters(), h.deactivate();
            }
            const g = `${a.getMTime()}A${l}B${a.getMTime()}C${c ? c.getMTime() : 1}D${o ? o.getMTime() : 1}E${i.getProperty().getEdgeVisibility()}F${f ? f.getMTime() : 1}`;
            if (e.VBOBuildString !== g) {
                const v = {
                    points: a.getPoints(),
                    normals: c,
                    tcoords: f,
                    colors: o,
                    cellOffset: 0,
                    vertexOffset: 0,
                    useTCoordsPerCell: u,
                    haveCellScalars: e.haveCellScalars,
                    haveCellNormals: e.haveCellNormals,
                    customAttributes: e.renderable.getCustomShaderAttributes().map((C)=>a.getPointData().getArrayByName(C))
                };
                e.renderable.getPopulateSelectionSettings() && (e.selectionWebGLIdsToVTKIds = {
                    points: null,
                    cells: null
                });
                const m = [
                    {
                        inRep: "verts",
                        cells: a.getVerts()
                    },
                    {
                        inRep: "lines",
                        cells: a.getLines()
                    },
                    {
                        inRep: "polys",
                        cells: a.getPolys()
                    },
                    {
                        inRep: "strips",
                        cells: a.getStrips()
                    },
                    {
                        inRep: "polys",
                        cells: a.getPolys()
                    },
                    {
                        inRep: "strips",
                        cells: a.getStrips()
                    }
                ], y = i.getProperty().getEdgeVisibility() && l === mu.SURFACE;
                for(let C = vi.Start; C < vi.End; C++)C !== vi.TrisEdges && C !== vi.TriStripsEdges ? (v.cellOffset += e.primitives[C].getCABO().createVBO(m[C].cells, m[C].inRep, l, v, e.selectionWebGLIdsToVTKIds), v.vertexOffset += e.primitives[C].getCABO().getElementCount()) : y ? e.primitives[C].getCABO().createVBO(m[C].cells, m[C].inRep, mu.WIREFRAME, {
                    ...v,
                    tcoords: null,
                    colors: null,
                    haveCellScalars: !1,
                    haveCellNormals: !1
                }) : e.primitives[C].releaseGraphicsResources();
                e.renderable.getPopulateSelectionSettings() && e.renderable.setSelectionWebGLIdsToVTKIds(e.selectionWebGLIdsToVTKIds), e.VBOBuildString = g;
            }
            e.VBOBuildTime.modified();
        }, t.getAllocatedGPUMemoryInBytes = ()=>{
            let r = 0;
            return e.primitives.forEach((i)=>{
                r += i.getAllocatedGPUMemoryInBytes();
            }), r;
        };
    }
    const D$ = {
        context: null,
        VBOBuildTime: 0,
        VBOBuildString: null,
        primitives: null,
        primTypes: null,
        shaderRebuildString: null,
        tmpMat4: null,
        ambientColor: [],
        diffuseColor: [],
        specularColor: [],
        lightColor: [],
        lightDirection: [],
        lastHaveSeenDepthRequest: !1,
        haveSeenDepthRequest: !1,
        lastSelectionState: _a.MIN_KNOWN_PASS - 1,
        selectionStateChanged: null,
        selectionWebGLIdsToVTKIds: null,
        pointPicking: !1
    };
    function JE(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, D$, n), Yr.extend(t, e, n), Wl.implementReplaceShaderCoincidentOffset(t, e, n), Wl.implementBuildShadersWithReplacements(t, e, n), e.primitives = [], e.primTypes = vi, e.tmpMat3 = Ts(new Float64Array(9)), e.tmpMat4 = Ot(new Float64Array(16));
        for(let r = vi.Start; r < vi.End; r++)e.primitives[r] = Yl.newInstance(), e.primitives[r].setPrimitiveType(r), e.primitives[r].set({
            lastLightComplexity: 0,
            lastLightCount: 0,
            lastSelectionPass: !1
        }, !0);
        si(t, e, [
            "context"
        ]), e.VBOBuildTime = {}, tr(e.VBOBuildTime, {
            mtime: 0
        }), e.selectionStateChanged = {}, tr(e.selectionStateChanged, {
            mtime: 0
        }), E$(t, e);
    }
    const QE = kn(JE, "vtkOpenGLPolyDataMapper");
    var Bp = {
        newInstance: QE,
        extend: JE
    };
    bi("vtkMapper", QE);
    const { vtkErrorMacro: Wf } = da, { Representation: _$ } = eg, { ObjectType: D1 } = $c, { PassTypes: R$ } = h4, O$ = {
        type: "StartEvent"
    }, I$ = {
        type: "EndEvent"
    };
    function M$(t, e) {
        e.classHierarchy.push("vtkOpenGLGlyph3DMapper");
        const n = {
            ...t
        };
        t.renderPiece = (r, i)=>{
            if (t.invokeEvent(O$), e.renderable.getStatic() || e.renderable.update(), e.currentInput = e.renderable.getInputData(1), t.invokeEvent(I$), !e.currentInput) {
                Wf("No input!");
                return;
            }
            if (!e.currentInput.getPoints || !e.currentInput.getPoints().getNumberOfValues()) return;
            const a = e.context;
            e._openGLRenderWindow.getWebgl2() ? (e.hardwareSupport = !0, e.extension = null) : e.extension || (e.extension = e.context.getExtension("ANGLE_instanced_arrays"), e.hardwareSupport = !!e.extension);
            const o = i.getProperty().getBackfaceCulling(), s = i.getProperty().getFrontfaceCulling();
            !o && !s ? e._openGLRenderWindow.disableCullFace() : s ? (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.FRONT)) : (e._openGLRenderWindow.enableCullFace(), a.cullFace(a.BACK)), t.renderPieceStart(r, i), t.renderPieceDraw(r, i), t.renderPieceFinish(r, i);
        }, t.multiply4x4WithOffset = (r, i, a, o)=>{
            const s = i[0], c = i[1], l = i[2], f = i[3], u = i[4], g = i[5], h = i[6], v = i[7], m = i[8], y = i[9], C = i[10], T = i[11], x = i[12], S = i[13], D = i[14], _ = i[15];
            let M = a[o], P = a[o + 1], F = a[o + 2], N = a[o + 3];
            r[0] = M * s + P * u + F * m + N * x, r[1] = M * c + P * g + F * y + N * S, r[2] = M * l + P * h + F * C + N * D, r[3] = M * f + P * v + F * T + N * _, M = a[o + 4], P = a[o + 5], F = a[o + 6], N = a[o + 7], r[4] = M * s + P * u + F * m + N * x, r[5] = M * c + P * g + F * y + N * S, r[6] = M * l + P * h + F * C + N * D, r[7] = M * f + P * v + F * T + N * _, M = a[o + 8], P = a[o + 9], F = a[o + 10], N = a[o + 11], r[8] = M * s + P * u + F * m + N * x, r[9] = M * c + P * g + F * y + N * S, r[10] = M * l + P * h + F * C + N * D, r[11] = M * f + P * v + F * T + N * _, M = a[o + 12], P = a[o + 13], F = a[o + 14], N = a[o + 15], r[12] = M * s + P * u + F * m + N * x, r[13] = M * c + P * g + F * y + N * S, r[14] = M * l + P * h + F * C + N * D, r[15] = M * f + P * v + F * T + N * _;
        }, t.replaceShaderNormal = (r, i, a)=>{
            if (e.hardwareSupport && e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0) {
                let s = r.Vertex;
                e.lastBoundBO.getCABO().getNormalOffset() && (s = Te.substitute(s, "//VTK::Normal::Dec", [
                    "attribute vec3 normalMC;",
                    "attribute mat3 gNormal;",
                    "uniform mat3 normalMatrix;",
                    "varying vec3 normalVCVSOutput;"
                ]).result, s = Te.substitute(s, "//VTK::Normal::Impl", [
                    "normalVCVSOutput = normalMatrix * gNormal * normalMC;"
                ]).result), r.Vertex = s;
            }
            n.replaceShaderNormal(r, i, a);
        }, t.replaceShaderColor = (r, i, a)=>{
            if (e.hardwareSupport && e.renderable.getColorArray()) {
                let o = r.Vertex, s = r.Geometry, c = r.Fragment;
                const l = e.lastBoundBO.getReferenceByName("lastLightComplexity");
                let f = [
                    "uniform float ambient;",
                    "uniform float diffuse;",
                    "uniform float specular;",
                    "uniform float opacityUniform; // the fragment opacity"
                ];
                l && (f = f.concat([
                    "uniform vec3 specularColorUniform;",
                    "uniform float specularPowerUniform;"
                ]));
                let u = [
                    "vec3 ambientColor;",
                    "  vec3 diffuseColor;",
                    "  float opacity;"
                ];
                l && (u = u.concat([
                    "  vec3 specularColor;",
                    "  float specularPower;"
                ])), u = u.concat([
                    "  opacity = opacityUniform;"
                ]), l && (u = u.concat([
                    "  specularColor = specularColorUniform;",
                    "  specularPower = specularPowerUniform;"
                ])), e.drawingEdges || (f = f.concat([
                    "varying vec4 vertexColorVSOutput;"
                ]), o = Te.substitute(o, "//VTK::Color::Dec", [
                    "attribute vec4 gColor;",
                    "varying vec4 vertexColorVSOutput;"
                ]).result, o = Te.substitute(o, "//VTK::Color::Impl", [
                    "vertexColorVSOutput = gColor;"
                ]).result, s = Te.substitute(s, "//VTK::Color::Dec", [
                    "in vec4 vertexColorVSOutput[];",
                    "out vec4 vertexColorGSOutput;"
                ]).result, s = Te.substitute(s, "//VTK::Color::Impl", [
                    "vertexColorGSOutput = vertexColorVSOutput[i];"
                ]).result, u = u.concat([
                    "  diffuseColor = vertexColorVSOutput.rgb;",
                    "  ambientColor = vertexColorVSOutput.rgb;",
                    "  opacity = opacity*vertexColorVSOutput.a;"
                ])), c = Te.substitute(c, "//VTK::Color::Impl", u).result, c = Te.substitute(c, "//VTK::Color::Dec", f).result, r.Vertex = o, r.Geometry = s, r.Fragment = c;
            }
            n.replaceShaderColor(r, i, a);
        }, t.replaceShaderPositionVC = (r, i, a)=>{
            if (e.hardwareSupport) {
                let o = r.Vertex;
                e.lastBoundBO.getReferenceByName("lastLightComplexity") > 0 ? (o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                    "vec4 gVertexMC = gMatrix * vertexMC;",
                    "vertexVCVSOutput = MCVCMatrix * gVertexMC;",
                    "  gl_Position = MCPCMatrix * gVertexMC;"
                ]).result, o = Te.substitute(o, "//VTK::Camera::Dec", [
                    "attribute mat4 gMatrix;",
                    "uniform mat4 MCPCMatrix;",
                    "uniform mat4 MCVCMatrix;"
                ]).result) : (o = Te.substitute(o, "//VTK::Camera::Dec", [
                    "attribute mat4 gMatrix;",
                    "uniform mat4 MCPCMatrix;"
                ]).result, o = Te.substitute(o, "//VTK::PositionVC::Impl", [
                    "vec4 gVertexMC = gMatrix * vertexMC;",
                    "  gl_Position = MCPCMatrix * gVertexMC;"
                ]).result), r.Vertex = o;
            }
            n.replaceShaderPositionVC(r, i, a);
        }, t.replaceShaderPicking = (r, i, a)=>{
            if (e.hardwareSupport) {
                let o = r.Fragment, s = r.Vertex;
                s = Te.substitute(s, "//VTK::Picking::Dec", [
                    "attribute vec3 mapperIndexVS;",
                    "varying vec3 mapperIndexVSOutput;"
                ]).result, s = Te.substitute(s, "//VTK::Picking::Impl", "  mapperIndexVSOutput = mapperIndexVS;").result, r.Vertex = s, o = Te.substitute(o, "//VTK::Picking::Dec", [
                    "varying vec3 mapperIndexVSOutput;",
                    "uniform vec3 mapperIndex;",
                    "uniform int picking;"
                ]).result, o = Te.substitute(o, "//VTK::Picking::Impl", [
                    "  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);",
                    "  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"
                ]).result, r.Fragment = o;
            } else n.replaceShaderPicking(r, i, a);
        }, t.updateGlyphShaderParameters = (r, i, a, o, s, c, l, f)=>{
            const u = a.getProgram();
            if (r) {
                const g = e.normalMatrix, h = c, v = l * 9, m = e.tmpMat3, y = g[0], C = g[1], T = g[2], x = g[3], S = g[4], D = g[5], _ = g[6], M = g[7], P = g[8], F = h[v], N = h[v + 1], B = h[v + 2], G = h[v + 3], Z = h[v + 4], H = h[v + 5], ne = h[v + 6], ae = h[v + 7], ue = h[v + 8];
                m[0] = F * y + N * x + B * _, m[1] = F * C + N * S + B * M, m[2] = F * T + N * D + B * P, m[3] = G * y + Z * x + H * _, m[4] = G * C + Z * S + H * M, m[5] = G * T + Z * D + H * P, m[6] = ne * y + ae * x + ue * _, m[7] = ne * C + ae * S + ue * M, m[8] = ne * T + ae * D + ue * P, u.setUniformMatrix3x3("normalMatrix", e.tmpMat3);
            }
            if (t.multiply4x4WithOffset(e.tmpMat4, e.mcpcMatrix, s, l * 16), u.setUniformMatrix("MCPCMatrix", e.tmpMat4), i && (t.multiply4x4WithOffset(e.tmpMat4, e.mcvcMatrix, s, l * 16), u.setUniformMatrix("MCVCMatrix", e.tmpMat4)), o) {
                const g = o.getData();
                e.tmpColor[0] = g[l * 4] / 255, e.tmpColor[1] = g[l * 4 + 1] / 255, e.tmpColor[2] = g[l * 4 + 2] / 255, u.setUniform3fArray("ambientColorUniform", e.tmpColor), u.setUniform3fArray("diffuseColorUniform", e.tmpColor);
            }
            f && u.setUniform3fArray("mapperIndex", f.getPropColorValue());
        }, t.renderPieceDraw = (r, i)=>{
            const a = i.getProperty().getRepresentation(), o = e.context, s = i.getProperty().getEdgeVisibility() && a === _$.SURFACE, c = e.openGLCamera.getKeyMatrices(r), l = e.openGLActor.getKeyMatrices();
            Xu(e.normalMatrix, c.normalMatrix, l.normalMatrix), Qt(e.mcpcMatrix, c.wcpc, l.mcwc), Qt(e.mcvcMatrix, c.wcvc, l.mcwc);
            const f = e.renderable.getMatrixArray(), u = e.renderable.getNormalArray(), g = e.renderable.getColorArray(), h = f.length / 16;
            let v = !1;
            e._openGLRenderer.getSelector() && e._openGLRenderer.getSelector().getCurrentPass() === R$.COMPOSITE_INDEX_PASS && (v = !0);
            for(let m = e.primTypes.Start; m < e.primTypes.End; m++){
                const y = e.primitives[m].getCABO();
                if (y.getElementCount()) {
                    e.drawingEdges = s && (m === e.primTypes.TrisEdges || m === e.primTypes.TriStripsEdges), e.lastBoundBO = e.primitives[m], e.primitives[m].updateShaders(r, i, t);
                    const C = e.primitives[m].getProgram(), T = e.primitives[m].getOpenGLMode(a), x = C.isUniformUsed("normalMatrix"), S = C.isUniformUsed("MCVCMatrix");
                    if (e.hardwareSupport) e.extension ? e.extension.drawArraysInstancedANGLE(T, 0, y.getElementCount(), h) : o.drawArraysInstanced(T, 0, y.getElementCount(), h);
                    else for(let D = 0; D < h; ++D)v && e._openGLRenderer.getSelector().renderCompositeIndex(D), t.updateGlyphShaderParameters(x, S, e.primitives[m], g, f, u, D, v ? e._openGLRenderer.getSelector() : null), o.drawArrays(T, 0, y.getElementCount());
                }
            }
        }, t.setMapperShaderParameters = (r, i, a)=>{
            if (r.getCABO().getElementCount() && (e.glyphBOBuildTime.getMTime() > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime())) {
                r.getProgram().isAttributeUsed("gMatrix") ? r.getVAO().addAttributeMatrixWithDivisor(r.getProgram(), e.matrixBuffer, "gMatrix", 0, 64, e.context.FLOAT, 4, !1, 1) || Wf("Error setting gMatrix in shader VAO.") : r.getVAO().removeAttributeArray("gMatrix"), r.getProgram().isAttributeUsed("gNormal") ? r.getVAO().addAttributeMatrixWithDivisor(r.getProgram(), e.normalBuffer, "gNormal", 0, 36, e.context.FLOAT, 3, !1, 1) || Wf("Error setting gNormal in shader VAO.") : r.getVAO().removeAttributeArray("gNormal"), r.getProgram().isAttributeUsed("gColor") ? r.getVAO().addAttributeArrayWithDivisor(r.getProgram(), e.colorBuffer, "gColor", 0, 4, e.context.UNSIGNED_BYTE, 4, !0, 1, !1) || Wf("Error setting gColor in shader VAO.") : r.getVAO().removeAttributeArray("gColor"), r.getProgram().isAttributeUsed("mapperIndexVS") ? r.getVAO().addAttributeArrayWithDivisor(r.getProgram(), e.pickBuffer, "mapperIndexVS", 0, 4, e.context.UNSIGNED_BYTE, 4, !0, 1, !1) || Wf("Error setting mapperIndexVS in shader VAO.") : r.getVAO().removeAttributeArray("mapperIndexVS"), n.setMapperShaderParameters(r, i, a), r.getAttributeUpdateTime().modified();
                return;
            }
            n.setMapperShaderParameters(r, i, a);
        }, t.getNeedToRebuildBufferObjects = (r, i)=>(e.renderable.buildArrays(), e.VBOBuildTime.getMTime() < e.renderable.getBuildTime().getMTime() ? !0 : n.getNeedToRebuildBufferObjects(r, i)), t.getNeedToRebuildShaders = (r, i, a)=>!!(n.getNeedToRebuildShaders(r, i, a) || r.getShaderSourceTime().getMTime() < e.renderable.getMTime() || r.getShaderSourceTime().getMTime() < e.currentInput.getMTime()), t.buildBufferObjects = (r, i)=>{
            if (e.hardwareSupport) {
                const a = e.renderable.getMatrixArray(), o = e.renderable.getNormalArray(), s = e.renderable.getColorArray();
                if (e.matrixBuffer || (e.matrixBuffer = $c.newInstance(), e.matrixBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.normalBuffer = $c.newInstance(), e.normalBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.colorBuffer = $c.newInstance(), e.colorBuffer.setOpenGLRenderWindow(e._openGLRenderWindow), e.pickBuffer = $c.newInstance(), e.pickBuffer.setOpenGLRenderWindow(e._openGLRenderWindow)), e.renderable.getBuildTime().getMTime() > e.glyphBOBuildTime.getMTime()) {
                    e.matrixBuffer.upload(a, D1.ARRAY_BUFFER), e.normalBuffer.upload(o, D1.ARRAY_BUFFER), s ? e.colorBuffer.upload(s.getData(), D1.ARRAY_BUFFER) : e.colorBuffer.releaseGraphicsResources();
                    const c = a.length / 16, l = new Uint8Array(4 * c);
                    for(let f = 0; f < c; ++f){
                        let u = f + 1;
                        const g = f * 4;
                        l[g] = u % 256, u -= l[g], u /= 256, l[g + 1] = u % 256, u -= l[g + 1], u /= 256, l[g + 2] = u % 256, l[g + 3] = 255;
                    }
                    e.pickBuffer.upload(l, D1.ARRAY_BUFFER), e.glyphBOBuildTime.modified();
                }
            }
            return n.buildBufferObjects(r, i);
        };
    }
    const b$ = {
        normalMatrix: null,
        mcpcMatrix: null,
        mcwcMatrix: null
    };
    function L$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, b$, n), Bp.extend(t, e, n), e.tmpMat3 = Ts(new Float64Array(9)), e.normalMatrix = Ts(new Float64Array(9)), e.mcpcMatrix = Ot(new Float64Array(16)), e.mcvcMatrix = Ot(new Float64Array(16)), e.tmpColor = [], e.glyphBOBuildTime = {}, tr(e.glyphBOBuildTime, {
            mtime: 0
        }), M$(t, e);
    }
    const eD = kn(L$, "vtkOpenGLGlyph3DMapper");
    var P$ = {
        newInstance: eD
    };
    bi("vtkGlyph3DMapper", eD);
    const { vtkErrorMacro: vC } = da;
    function V$(t, e) {
        e.classHierarchy.push("vtkOpenGLSkybox"), t.buildPass = (n)=>{
            if (n) {
                e._openGLRenderer = t.getFirstAncestorOfType("vtkOpenGLRenderer"), e._openGLRenderWindow = e._openGLRenderer.getParent(), e.context = e._openGLRenderWindow.getContext(), e.tris.setOpenGLRenderWindow(e._openGLRenderWindow), e.openGLTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const r = e._openGLRenderer.getRenderable();
                e.openGLCamera = e._openGLRenderer.getViewNodeFor(r.getActiveCamera());
            }
        }, t.queryPass = (n, r)=>{
            if (n) {
                if (!e.renderable || !e.renderable.getVisibility()) return;
                r.incrementOpaqueActorCount();
            }
        }, t.opaquePass = (n, r)=>{
            if (n && !e._openGLRenderer.getSelector()) {
                t.updateBufferObjects(), e.context.depthMask(!0), e._openGLRenderWindow.getShaderCache().readyShaderProgram(e.tris.getProgram()), e.openGLTexture.render(e._openGLRenderWindow);
                const i = e.openGLTexture.getTextureUnit();
                e.tris.getProgram().setUniformi("sbtexture", i);
                const a = e._openGLRenderer.getRenderable(), o = e.openGLCamera.getKeyMatrices(a), s = new Float64Array(16);
                if (Xr(s, o.wcpc), e.tris.getProgram().setUniformMatrix("IMCPCMatrix", s), e.lastFormat === "box") {
                    const c = a.getActiveCamera().getPosition();
                    e.tris.getProgram().setUniform3f("camPos", c[0], c[1], c[2]);
                }
                e.tris.getVAO().bind(), e.context.drawArrays(e.context.TRIANGLES, 0, e.tris.getCABO().getElementCount()), e.tris.getVAO().release(), e.openGLTexture.deactivate();
            }
        }, t.updateBufferObjects = ()=>{
            if (!e.tris.getCABO().getElementCount()) {
                const r = new Float32Array(12);
                for(let s = 0; s < 4; s++)r[s * 3] = s % 2 * 2 - 1, r[s * 3 + 1] = s > 1 ? 1 : -1, r[s * 3 + 2] = 1;
                const i = Wt.newInstance({
                    numberOfComponents: 3,
                    values: r
                });
                i.setName("points");
                const a = new Uint16Array(8);
                a[0] = 3, a[1] = 0, a[2] = 1, a[3] = 3, a[4] = 3, a[5] = 0, a[6] = 3, a[7] = 2;
                const o = Wt.newInstance({
                    numberOfComponents: 1,
                    values: a
                });
                e.tris.getCABO().createVBO(o, "polys", Yo.SURFACE, {
                    points: i,
                    cellOffset: 0
                });
            }
            e.renderable.getFormat() !== e.lastFormat && (e.lastFormat = e.renderable.getFormat(), e.lastFormat === "box" && e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, "")), e.lastFormat === "background" && e.tris.setProgram(e._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, "")), e.tris.getShaderSourceTime().modified(), e.tris.getVAO().bind(), e.tris.getVAO().addAttributeArray(e.tris.getProgram(), e.tris.getCABO(), "vertexMC", e.tris.getCABO().getVertexOffset(), e.tris.getCABO().getStride(), e.context.FLOAT, 3, e.context.FALSE) || vC("Error setting vertexMC in shader VAO."));
            const n = e.renderable.getTextures();
            n.length || vC("vtkSkybox requires a texture map"), e.openGLTexture.getRenderable() !== n[0] && (e.openGLTexture.releaseGraphicsResources(e._openGLRenderWindow), e.openGLTexture.setRenderable(n[0]));
        };
    }
    const N$ = {
        context: null
    };
    function A$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, N$, n), Yr.extend(t, e, n), e.openGLTexture = Qn.newInstance(), e.tris = Yl.newInstance(), e.keyMatrixTime = {}, tr(e.keyMatrixTime, {
            mtime: 0
        }), e.keyMatrices = {
            normalMatrix: Ts(new Float64Array(9)),
            mcwc: Ot(new Float64Array(16))
        }, si(t, e, [
            "context"
        ]), La(t, e, [
            "activeTextures"
        ]), V$(t, e);
    }
    const tD = kn(A$);
    var k$ = {
        newInstance: tD
    };
    bi("vtkSkybox", tD);
    var U$ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkSphereMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Spheres

attribute vec4 vertexMC;
attribute vec2 offsetMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying vec3 centerVCVSOutput;

uniform int cameraParallel;
uniform float scaleFactor;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  // compute the projected vertex position
  vec2 scaledOffsetMC = scaleFactor * offsetMC;
  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = length(scaledOffsetMC)*0.5;

  // make the triangle face the camera
  if (cameraParallel == 0)
    {
    vec3 dir = normalize(-vertexVCVSOutput.xyz);
    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));
    vec3 base1 = cross(base2,dir);
    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;
    }
  else
    {
    // add in the offset
    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;
    }

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;
    const { vtkErrorMacro: F$ } = da;
    function B$(t, e) {
        e.classHierarchy.push("vtkOpenGLSphereMapper");
        const n = {
            ...t
        };
        t.getShaderTemplate = (r, i, a)=>{
            r.Vertex = U$, r.Fragment = Jd, r.Geometry = "";
        }, t.replaceShaderValues = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            o = Te.substitute(o, "//VTK::Camera::Dec", [
                `uniform mat4 VCPCMatrix;
`,
                "uniform mat4 MCVCMatrix;"
            ]).result, s = Te.substitute(s, "//VTK::PositionVC::Dec", [
                "varying vec4 vertexVCVSOutput;"
            ]).result, s = Te.substitute(s, "//VTK::PositionVC::Impl", [
                `vec4 vertexVC = vertexVCVSOutput;
`
            ]).result;
            const c = [
                `uniform float invertedDepth;
`,
                `uniform int cameraParallel;
`,
                `varying float radiusVCVSOutput;
`,
                `varying vec3 centerVCVSOutput;
`,
                `uniform mat4 VCPCMatrix;
`
            ];
            s = Te.substitute(s, "//VTK::Normal::Dec", c).result;
            let l = "";
            e.context.getExtension("EXT_frag_depth") && (l = `gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`), e._openGLRenderWindow.getWebgl2() && (l = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`), s = Te.substitute(s, "//VTK::Depth::Impl", [
                `  vec3 EyePos;
`,
                `  vec3 EyeDir;
`,
                `  if (cameraParallel != 0) {
`,
                `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
                `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
                `  else {
`,
                `    EyeDir = vertexVC.xyz;
`,
                `    EyePos = vec3(0.0,0.0,0.0);
`,
                `    float lengthED = length(EyeDir);
`,
                `    EyeDir = normalize(EyeDir);
`,
                `    if (lengthED > radiusVCVSOutput*3.0) {
`,
                `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
                `    }
`,
                `  EyePos = EyePos - centerVCVSOutput;
`,
                `  EyePos = EyePos/radiusVCVSOutput;
`,
                `  float b = 2.0*dot(EyePos,EyeDir);
`,
                `  float c = dot(EyePos,EyePos) - 1.0;
`,
                `  float d = b*b - 4.0*c;
`,
                `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
                `  if (d < 0.0) { discard; }
`,
                `  else {
`,
                `    float t = (-b - invertedDepth*sqrt(d))*0.5;
`,
                `    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);
`,
                `    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;
`,
                `    }
`,
                `  vec4 pos = VCPCMatrix * vertexVC;
`,
                l
            ]).result, s = Te.substitute(s, "//VTK::Normal::Impl", "").result, e.haveSeenDepthRequest && (s = Te.substitute(s, "//VTK::ZBuffer::Impl", [
                "if (depthRequest == 1) {",
                "float computedZ = (pos.z / pos.w + 1.0) / 2.0;",
                "float iz = floor(computedZ * 65535.0 + 0.1);",
                "float rf = floor(iz/256.0)/255.0;",
                "float gf = mod(iz,256.0)/255.0;",
                "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
            ]).result), r.Vertex = o, r.Fragment = s, n.replaceShaderValues(r, i, a);
        }, t.setMapperShaderParameters = (r, i, a)=>{
            if (r.getCABO().getElementCount() && (e.VBOBuildTime > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && r.getProgram().isAttributeUsed("offsetMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "offsetMC", 12, r.getCABO().getStride(), e.context.FLOAT, 2, !1) || F$("Error setting 'offsetMC' in shader VAO.")), r.getProgram().isUniformUsed("invertedDepth") && r.getProgram().setUniformf("invertedDepth", e.invert ? -1 : 1), r.getProgram().isUniformUsed("scaleFactor")) {
                const s = e.currentInput.getPointData();
                e.renderable.getScaleArray() != null && s.hasArray(e.renderable.getScaleArray()) ? r.getProgram().setUniformf("scaleFactor", e.renderable.getScaleFactor()) : r.getProgram().setUniformf("scaleFactor", 1);
            }
            n.setMapperShaderParameters(r, i, a);
        }, t.setCameraShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = i.getActiveCamera(), c = e.openGLCamera.getKeyMatrices(i);
            if (o.isUniformUsed("VCPCMatrix") && o.setUniformMatrix("VCPCMatrix", c.vcpc), o.isUniformUsed("MCVCMatrix")) if (a.getIsIdentity()) o.setUniformMatrix("MCVCMatrix", c.wcvc);
            else {
                const l = e.openGLActor.getKeyMatrices(), f = new Float64Array(16);
                Qt(f, c.wcvc, l.mcwc), o.setUniformMatrix("MCVCMatrix", f);
            }
            o.isUniformUsed("cameraParallel") && r.getProgram().setUniformi("cameraParallel", s.getParallelProjection());
        }, t.getOpenGLMode = (r, i)=>e.context.TRIANGLES, t.buildBufferObjects = (r, i)=>{
            const a = e.currentInput;
            if (a === null) return;
            e.renderable.mapScalars(a, 1);
            const o = e.renderable.getColorMapColors(), s = e.primitives[e.primTypes.Tris].getCABO(), c = a.getPointData(), l = a.getPoints(), f = l.getNumberOfPoints(), u = l.getData(), g = 5;
            let h = null;
            e.renderable.getScaleArray() != null && c.hasArray(e.renderable.getScaleArray()) && (h = c.getArray(e.renderable.getScaleArray()).getData());
            let v = null, m = 0, y = null;
            o ? (m = o.getNumberOfComponents(), s.setColorOffset(0), s.setColorBOStride(4), v = o.getData(), y = new Uint8Array(3 * f * 4), s.getColorBO() || s.setColorBO($c.newInstance()), s.getColorBO().setOpenGLRenderWindow(e._openGLRenderWindow)) : s.getColorBO() && s.setColorBO(null), s.setColorComponents(m);
            const C = new Float32Array(g * f * 3);
            s.setStride(g * 4);
            const T = Math.cos(Sr(30));
            let x = 0, S = 0, D = 0, _ = 0;
            for(let M = 0; M < f; ++M){
                let P = e.renderable.getRadius();
                h && (P = h[M]), x = M * 3, C[D++] = u[x++], C[D++] = u[x++], C[D++] = u[x++], C[D++] = -2 * P * T, C[D++] = -P, v && (S = M * m, y[_++] = v[S], y[_++] = v[S + 1], y[_++] = v[S + 2], y[_++] = v[S + 3]), x = M * 3, C[D++] = u[x++], C[D++] = u[x++], C[D++] = u[x++], C[D++] = 2 * P * T, C[D++] = -P, v && (y[_++] = v[S], y[_++] = v[S + 1], y[_++] = v[S + 2], y[_++] = v[S + 3]), x = M * 3, C[D++] = u[x++], C[D++] = u[x++], C[D++] = u[x++], C[D++] = 0, C[D++] = 2 * P, v && (y[_++] = v[S], y[_++] = v[S + 1], y[_++] = v[S + 2], y[_++] = v[S + 3]);
            }
            s.setElementCount(D / g), s.upload(C, Kc.ARRAY_BUFFER), o && s.getColorBO().upload(y, Kc.ARRAY_BUFFER), e.VBOBuildTime.modified();
        };
    }
    const G$ = {};
    function W$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, G$, n), Bp.extend(t, e, n), B$(t, e);
    }
    const nD = kn(W$, "vtkOpenGLSphereMapper");
    var $$ = {
        newInstance: nD
    };
    bi("vtkSphereMapper", nD);
    var z$ = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkStickMapperVS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// this shader implements imposters in OpenGL for Sticks

attribute vec4 vertexMC;
attribute vec3 orientMC;
attribute vec4 offsetMC;
attribute float radiusMC;

// optional normal declaration
//VTK::Normal::Dec

//VTK::Picking::Dec

// Texture coordinates
//VTK::TCoord::Dec

uniform mat3 normalMatrix; // transform model coordinate directions to view coordinates

// material property values
//VTK::Color::Dec

// clipping plane vars
//VTK::Clip::Dec

// camera and actor matrix values
//VTK::Camera::Dec

varying vec4 vertexVCVSOutput;
varying float radiusVCVSOutput;
varying float lengthVCVSOutput;
varying vec3 centerVCVSOutput;
varying vec3 orientVCVSOutput;

uniform int cameraParallel;

void main()
{
  //VTK::Picking::Impl

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Clip::Impl

  vertexVCVSOutput = MCVCMatrix * vertexMC;
  centerVCVSOutput = vertexVCVSOutput.xyz;
  radiusVCVSOutput = radiusMC;
  lengthVCVSOutput = length(orientMC);
  orientVCVSOutput = normalMatrix * normalize(orientMC);

  // make sure it is pointing out of the screen
  if (orientVCVSOutput.z < 0.0)
    {
    orientVCVSOutput = -orientVCVSOutput;
    }

  // make the basis
  vec3 xbase;
  vec3 ybase;
  vec3 dir = vec3(0.0,0.0,1.0);
  if (cameraParallel == 0)
    {
    dir = normalize(-vertexVCVSOutput.xyz);
    }
  if (abs(dot(dir,orientVCVSOutput)) == 1.0)
    {
    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));
    ybase = cross(xbase,orientVCVSOutput);
    }
  else
    {
    xbase = normalize(cross(orientVCVSOutput,dir));
    ybase = cross(orientVCVSOutput,xbase);
    }

  vec3 offsets = offsetMC.xyz*2.0-1.0;
  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +
    radiusVCVSOutput*offsets.x*xbase +
    radiusVCVSOutput*offsets.y*ybase +
    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;

  gl_Position = VCPCMatrix * vertexVCVSOutput;
}
`;
    const { vtkErrorMacro: _1 } = da;
    function j$(t, e) {
        e.classHierarchy.push("vtkOpenGLStickMapper");
        const n = {
            ...t
        };
        t.getShaderTemplate = (r, i, a)=>{
            r.Vertex = z$, r.Fragment = Jd, r.Geometry = "";
        }, t.replaceShaderValues = (r, i, a)=>{
            let o = r.Vertex, s = r.Fragment;
            o = Te.substitute(o, "//VTK::Camera::Dec", [
                `uniform mat4 VCPCMatrix;
`,
                "uniform mat4 MCVCMatrix;"
            ]).result, s = Te.substitute(s, "//VTK::PositionVC::Dec", "varying vec4 vertexVCVSOutput;").result, s = Te.substitute(s, "//VTK::PositionVC::Impl", `  vec4 vertexVC = vertexVCVSOutput;
`).result;
            const c = [
                `uniform int cameraParallel;
`,
                `varying float radiusVCVSOutput;
`,
                `varying vec3 orientVCVSOutput;
`,
                `varying float lengthVCVSOutput;
`,
                `varying vec3 centerVCVSOutput;
`,
                `uniform mat4 VCPCMatrix;
`
            ];
            s = Te.substitute(s, "//VTK::Normal::Dec", c).result;
            let l = "";
            e.context.getExtension("EXT_frag_depth") && (l = `  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;
`), e._openGLRenderWindow.getWebgl2() && (l = `gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;
`), s = Te.substitute(s, "//VTK::Depth::Impl", [
                `  vec3 EyePos;
`,
                `  vec3 EyeDir;
`,
                `  if (cameraParallel != 0) {
`,
                `    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);
`,
                `    EyeDir = vec3(0.0,0.0,-1.0); }
`,
                `  else {
`,
                `    EyeDir = vertexVC.xyz;
`,
                `    EyePos = vec3(0.0,0.0,0.0);
`,
                `    float lengthED = length(EyeDir);
`,
                `    EyeDir = normalize(EyeDir);
`,
                `    if (lengthED > radiusVCVSOutput*3.0) {
`,
                `      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }
`,
                `    }
`,
                `  EyePos = EyePos - centerVCVSOutput;
`,
                `  vec3 base1;
`,
                `  if (abs(orientVCVSOutput.z) < 0.99) {
`,
                `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }
`,
                `  else {
`,
                `    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }
`,
                `  vec3 base2 = cross(orientVCVSOutput,base1);
`,
                `  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));
`,
                `  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));
`,
                `  EyePos = EyePos/radiusVCVSOutput;
`,
                `  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;
`,
                `  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);
`,
                `  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;
`,
                `  float d = b*b - 4.0*a*c;
`,
                `  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);
`,
                `  if (d < 0.0) { discard; }
`,
                `  else {
`,
                `    float t =  (-b - sqrt(d))/(2.0*a);
`,
                `    float tz = EyePos.z + t*EyeDir.z;
`,
                `    vec3 iPoint = EyePos + t*EyeDir;
`,
                `    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {
`,
                `      float t2 = (-b + sqrt(d))/(2.0*a);
`,
                `      float tz2 = EyePos.z + t2*EyeDir.z;
`,
                `      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }
`,
                `      else {
`,
                `        normalVCVSOutput = orientVCVSOutput;
`,
                `        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;
`,
                `        iPoint = EyePos + t3*EyeDir;
`,
                `        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
                `        }
`,
                `      }
`,
                `    else {
`,
                `      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;
`,
                `      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;
`,
                `      }
`,
                `    }
`,
                `  vec4 pos = VCPCMatrix * vertexVC;
`,
                l
            ]).result, s = Te.substitute(s, "//VTK::Normal::Impl", "").result, e.haveSeenDepthRequest && (s = Te.substitute(s, "//VTK::ZBuffer::Impl", [
                "if (depthRequest == 1) {",
                "float computedZ = (pos.z / pos.w + 1.0) / 2.0;",
                "float iz = floor(computedZ * 65535.0 + 0.1);",
                "float rf = floor(iz/256.0)/255.0;",
                "float gf = mod(iz,256.0)/255.0;",
                "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"
            ]).result), r.Vertex = o, r.Fragment = s, n.replaceShaderValues(r, i, a);
        }, t.setMapperShaderParameters = (r, i, a)=>{
            r.getCABO().getElementCount() && (e.VBOBuildTime > r.getAttributeUpdateTime().getMTime() || r.getShaderSourceTime().getMTime() > r.getAttributeUpdateTime().getMTime()) && (r.getProgram().isAttributeUsed("orientMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "orientMC", 12, r.getCABO().getStride(), e.context.FLOAT, 3, !1) || _1("Error setting 'orientMC' in shader VAO.")), r.getProgram().isAttributeUsed("offsetMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO().getColorBO(), "offsetMC", 0, r.getCABO().getColorBOStride(), e.context.UNSIGNED_BYTE, 3, !0) || _1("Error setting 'offsetMC' in shader VAO.")), r.getProgram().isAttributeUsed("radiusMC") && (r.getVAO().addAttributeArray(r.getProgram(), r.getCABO(), "radiusMC", 24, r.getCABO().getStride(), e.context.FLOAT, 1, !1) || _1("Error setting 'radiusMC' in shader VAO."))), n.setMapperShaderParameters(r, i, a);
        }, t.setCameraShaderParameters = (r, i, a)=>{
            const o = r.getProgram(), s = i.getActiveCamera(), c = e.openGLCamera.getKeyMatrices(i);
            if (o.isUniformUsed("VCPCMatrix") && o.setUniformMatrix("VCPCMatrix", c.vcpc), a.getIsIdentity()) o.isUniformUsed("MCVCMatrix") && o.setUniformMatrix("MCVCMatrix", c.wcvc), o.isUniformUsed("normalMatrix") && o.setUniformMatrix3x3("normalMatrix", c.normalMatrix);
            else {
                const l = e.openGLActor.getKeyMatrices();
                if (o.isUniformUsed("MCVCMatrix")) {
                    const f = new Float64Array(16);
                    Qt(f, c.wcvc, l.mcwc), o.setUniformMatrix("MCVCMatrix", f);
                }
                if (o.isUniformUsed("normalMatrix")) {
                    const f = new Float64Array(9);
                    Xu(f, c.normalMatrix, l.normalMatrix), o.setUniformMatrix3x3("normalMatrix", f);
                }
            }
            o.isUniformUsed("cameraParallel") && r.getProgram().setUniformi("cameraParallel", s.getParallelProjection());
        }, t.getOpenGLMode = (r, i)=>e.context.TRIANGLES, t.buildBufferObjects = (r, i)=>{
            const a = e.currentInput;
            if (a === null) return;
            e.renderable.mapScalars(a, 1);
            const o = e.renderable.getColorMapColors(), s = e.primitives[e.primTypes.Tris].getCABO(), c = a.getPointData(), l = a.getPoints(), f = l.getNumberOfPoints(), u = l.getData();
            let g = 3;
            g += 4;
            let h = null, v = 0;
            s.setColorBOStride(4), s.getColorBO() || s.setColorBO($c.newInstance()), s.getColorBO().setOpenGLRenderWindow(e._openGLRenderWindow), o && (v = o.getNumberOfComponents(), s.setColorOffset(4), h = o.getData(), s.setColorBOStride(8)), s.setColorComponents(v), s.setStride(g * 4);
            const m = new Float32Array(g * f * 12), y = new Uint8Array(12 * f * (h ? 8 : 4));
            let C = null, T = null;
            e.renderable.getScaleArray() != null && c.hasArray(e.renderable.getScaleArray()) && (C = c.getArray(e.renderable.getScaleArray()).getData()), e.renderable.getOrientationArray() != null && c.hasArray(e.renderable.getOrientationArray()) ? T = c.getArray(e.renderable.getOrientationArray()).getData() : _1([
                `Error setting orientationArray.
`,
                "You have to specify the stick orientation"
            ]);
            const x = [
                0,
                1,
                3,
                0,
                3,
                2,
                2,
                3,
                5,
                2,
                5,
                4
            ];
            let S = 0, D = 0, _ = 0, M = 0;
            for(let P = 0; P < f; ++P){
                let F = e.renderable.getLength(), N = e.renderable.getRadius();
                C && (F = C[P * 2], N = C[P * 2 + 1]);
                for(let B = 0; B < x.length; ++B)S = P * 3, m[_++] = u[S++], m[_++] = u[S++], m[_++] = u[S++], S = P * 3, m[_++] = T[S++] * F, m[_++] = T[S++] * F, m[_++] = T[S++] * F, m[_++] = N, y[M++] = 255 * (x[B] % 2), y[M++] = x[B] >= 4 ? 255 : 0, y[M++] = x[B] >= 2 ? 255 : 0, y[M++] = 255, D = P * v, h && (y[M++] = h[D], y[M++] = h[D + 1], y[M++] = h[D + 2], y[M++] = h[D + 3]);
            }
            s.setElementCount(_ / g), s.upload(m, Kc.ARRAY_BUFFER), s.getColorBO().upload(y, Kc.ARRAY_BUFFER), e.VBOBuildTime.modified();
        };
    }
    const H$ = {};
    function K$(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, H$, n), Bp.extend(t, e, n), j$(t, e);
    }
    const rD = kn(K$, "vtkOpenGLStickMapper");
    var q$ = {
        newInstance: rD
    };
    bi("vtkStickMapper", rD);
    function v4(t, e) {
        switch(t){
            case "Float32Array":
                return Float32Array;
            case "Uint8Array":
                return Uint8Array;
            case "Uint32Array":
                return Uint32Array;
            case "Uint16Array":
            case "Int16Array":
                return e ? (console.debug(`${t} is not supported for volume rendering, switching back to Float32Array`), Float32Array) : t === "Uint16Array" ? Uint16Array : Int16Array;
            default:
                if (t) throw new Error("TargetBuffer should be Float32Array, Uint8Array, Uint16Array, Int16Array, or Uint32Array");
                return Float32Array;
        }
    }
    function y4(t, e, n = {}) {
        const { isVolumeBuffer: r = !1 } = n, i = v4(t, r), a = i.BYTES_PER_ELEMENT;
        return {
            numBytes: e * a,
            TypedArrayConstructor: i
        };
    }
    function X$(t, e) {
        e.classHierarchy.push("vtkStreamingOpenGLVolumeMapper"), t.buildBufferObjects = (n, r)=>{
            const i = e.currentInput;
            if (!i) return;
            const a = r.getProperty();
            if (!e.jitterTexture.getHandle()) {
                const m = new Uint8Array(1024);
                for(let y = 0; y < 32 * 32; ++y)m[y] = 255 * Math.random();
                e.jitterTexture.setMinificationFilter(Tt.LINEAR), e.jitterTexture.setMagnificationFilter(Tt.LINEAR), e.jitterTexture.create2DFromRaw(32, 32, 1, qt.UNSIGNED_CHAR, m);
            }
            const { numberOfComponents: o } = i.get("numberOfComponents"), s = t.useIndependentComponents(a), c = a.getScalarOpacity(), l = e._openGLRenderWindow.getGraphicsResourceForObject(c);
            let f = ic(c, s, o);
            if (!l?.oglObject || l.hash !== f) {
                e.opacityTexture = Qn.newInstance(), e.opacityTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const m = 1024, y = m * 2 * o, C = new Float32Array(y), T = new Float32Array(m);
                for(let x = 0; x < o; ++x){
                    const S = a.getScalarOpacity(x), D = t.getCurrentSampleDistance(n) / a.getScalarOpacityUnitDistance(x), _ = S.getRange();
                    S.getTable(_[0], _[1], m, T, 1);
                    for(let M = 0; M < m; ++M)C[x * m * 2 + M] = 1 - (1 - T[M]) ** D, C[x * m * 2 + M + m] = C[x * m * 2 + M];
                }
                if (e.opacityTexture.resetFormatAndType(), e.opacityTexture.setMinificationFilter(Tt.LINEAR), e.opacityTexture.setMagnificationFilter(Tt.LINEAR), e._openGLRenderWindow.getWebgl2() && e.context.getExtension("OES_texture_float") && e.context.getExtension("OES_texture_float_linear")) e.opacityTexture.create2DFromRaw(m, 2 * o, 1, qt.FLOAT, C);
                else {
                    const x = new Uint8ClampedArray(y);
                    for(let S = 0; S < y; ++S)x[S] = 255 * C[S];
                    e.opacityTexture.create2DFromRaw(m, 2 * o, 1, qt.UNSIGNED_CHAR, x);
                }
                c && (e._openGLRenderWindow.setGraphicsResourceForObject(c, e.opacityTexture, f), c !== e._scalarOpacityFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(c, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._scalarOpacityFunc, t)), e._scalarOpacityFunc = c);
            } else e.opacityTexture = l.oglObject;
            const g = a.getRGBTransferFunction();
            f = ic(g, s, o);
            const h = e._openGLRenderWindow.getGraphicsResourceForObject(g);
            if (!h?.oglObject?.getHandle() || h?.hash !== f) {
                e.colorTexture = Qn.newInstance(), e.colorTexture.setOpenGLRenderWindow(e._openGLRenderWindow);
                const m = 1024, y = m * 2 * o * 3, C = new Uint8ClampedArray(y), T = new Float32Array(m * 3);
                for(let x = 0; x < o; ++x){
                    const S = a.getRGBTransferFunction(x), D = S.getRange();
                    S.getTable(D[0], D[1], m, T, 1);
                    for(let _ = 0; _ < m * 3; ++_)C[x * m * 6 + _] = 255 * T[_], C[x * m * 6 + _ + m * 3] = 255 * T[_];
                }
                e.colorTexture.resetFormatAndType(), e.colorTexture.setMinificationFilter(Tt.LINEAR), e.colorTexture.setMagnificationFilter(Tt.LINEAR), e.colorTexture.create2DFromRaw(m, 2 * o, 3, qt.UNSIGNED_CHAR, C), g && (e._openGLRenderWindow.setGraphicsResourceForObject(g, e.colorTexture, f), g !== e._colorTransferFunc && (e._openGLRenderWindow.registerGraphicsResourceUser(g, t), e._openGLRenderWindow.unregisterGraphicsResourceUser(e._colorTransferFunc, t)), e._colorTransferFunc = g);
            } else e.colorTexture = h.oglObject;
            if (t.updateLabelOutlineThicknessTexture(r), f = `${i.getMTime()}-${e.scalarTexture.getMTime()}`, e.scalarTextureString !== f) {
                const m = i.getDimensions();
                e.scalarTexture.setOpenGLRenderWindow(e._openGLRenderWindow), e.scalarTexture.enableUseHalfFloat(!1);
                const y = e.scalarTexture.getTextureParameters(), C = i.get("dataType").dataType;
                let T = !0;
                if (y?.dataType === C && y?.width === m[0] && y?.height === m[1] && y?.depth === m[2] && (T = !1), T) {
                    const x = e.context.getExtension("EXT_texture_norm16");
                    e.scalarTexture.setOglNorm16Ext(wb() ? x : null), e.scalarTexture.resetFormatAndType(), e.scalarTexture.setTextureParameters({
                        width: m[0],
                        height: m[1],
                        depth: m[2],
                        numberOfComponents: o,
                        dataType: C
                    }), e.scalarTexture.create3DFromRaw(m[0], m[1], m[2], o, C, null), e.scalarTexture.update3DFromRaw();
                } else e.scalarTexture.deactivate(), e.scalarTexture.update3DFromRaw();
                e.scalarTextureString = f;
            }
            if (!e.tris.getCABO().getElementCount()) {
                const m = new Float32Array(12);
                for(let x = 0; x < 4; x++)m[x * 3] = x % 2 * 2 - 1, m[x * 3 + 1] = x > 1 ? 1 : -1, m[x * 3 + 2] = -1;
                const y = new Uint16Array(8);
                y[0] = 3, y[1] = 0, y[2] = 1, y[3] = 3, y[4] = 3, y[5] = 0, y[6] = 3, y[7] = 2;
                const C = Wt.newInstance({
                    numberOfComponents: 3,
                    values: m
                });
                C.setName("points");
                const T = Wt.newInstance({
                    numberOfComponents: 1,
                    values: y
                });
                e.tris.getCABO().createVBO(T, "polys", Yo.SURFACE, {
                    points: C,
                    cellOffset: 0
                });
            }
            e.VBOBuildTime.modified();
        }, t.getNeedToRebuildBufferObjects = (n, r)=>e.VBOBuildTime.getMTime() < t.getMTime() || e.VBOBuildTime.getMTime() < r.getMTime() || e.VBOBuildTime.getMTime() < e.renderable.getMTime() || e.VBOBuildTime.getMTime() < r.getProperty().getMTime() || e.VBOBuildTime.getMTime() < e.currentInput.getMTime() || e.VBOBuildTime.getMTime() < e.scalarTexture?.getMTime() || e.VBOBuildTime.getMTime() < e.colorTexture?.getMTime() || e.VBOBuildTime.getMTime() < e.labelOutlineThicknessTexture?.getMTime() || !e.scalarTexture?.getHandle() || !e.colorTexture?.getHandle() || !e.labelOutlineThicknessTexture?.getHandle();
    }
    const Y$ = {};
    function Z$(t, e, n = {}) {
        Object.assign(e, Y$, n), iE.extend(t, e, n), e.scalarTexture = n.scalarTexture, e.previousState = {}, X$(t, e);
    }
    const J$ = K.newInstance(Z$, "vtkStreamingOpenGLVolumeMapper"), Q$ = {
        newInstance: J$
    }, iD = Object.create(null);
    function Ii(t, e) {
        iD[t] = e;
    }
    function ez(t, e) {
        e.classHierarchy.push("vtkStreamingOpenGLViewNodeFactory"), t.createNode = (n)=>{
            if (n.isDeleted()) return null;
            let r = 0, i = n.getClassName(r++), a = !1;
            const o = Object.keys(e.overrides);
            for(; i && !a;)o.includes(i) ? a = !0 : i = n.getClassName(r++);
            if (!a) return null;
            const s = e.getModelInitialValues(n), c = e.overrides[i](s);
            return c.setMyFactory(t), c;
        }, e.overrides = iD, e.getModelInitialValues = (n)=>{
            const r = {};
            return n.getClassName() === "vtkSharedVolumeMapper" && (r.scalarTexture = n.getScalarTexture()), r;
        };
    }
    const tz = {};
    function aD(t, e, n = {}) {
        Object.assign(e, tz, n), o4.extend(t, e, n), ez(t, e), Ii("vtkActor", XW.newInstance), Ii("vtkActor2D", QW.newInstance), Ii("vtkCamera", tA.newInstance), Ii("vtkGlyph3DMapper", P$.newInstance), Ii("vtkImageMapper", YU.newInstance), Ii("vtkImageCPRMapper", tF.newInstance), Ii("vtkImageSlice", aF.newInstance), Ii("vtkMapper", Bp.newInstance), Ii("vtkPixelSpaceCallbackMapper", SF.newInstance), Ii("vtkRenderer", oA.newInstance), Ii("vtkSkybox", k$.newInstance), Ii("vtkSphereMapper", $$.newInstance), Ii("vtkStickMapper", q$.newInstance), Ii("vtkTexture", Qn.newInstance), Ii("vtkVolume", lF.newInstance), Ii("vtkVolumeMapper", iE.newInstance), Ii("vtkSharedVolumeMapper", Q$.newInstance);
    }
    const nz = K.newInstance(aD, "vtkStreamingOpenGLViewNodeFactory"), rz = {
        newInstance: nz,
        extend: aD
    };
    function iz(t, e) {
        e.classHierarchy.push("vtkStreamingOpenGLRenderWindow");
    }
    function oD(t, e, n = {}) {
        Object.assign(e, n), jW.extend(t, e, n), e.myFactory = rz.newInstance(), Ii("vtkRenderWindow", sD), iz(t, e);
    }
    const sD = K.newInstance(oD, "vtkStreamingOpenGLRenderWindow"), az = {
        newInstance: sD,
        extend: oD
    }, { vtkDebugMacro: R1 } = K;
    function oz(t, e) {
        e.classHierarchy.push("vtkCamera");
        const n = new Float64Array(3), r = new Float64Array([
            0,
            0,
            -1
        ]), i = new Float64Array([
            0,
            1,
            0
        ]), a = Ot(new Float64Array(16)), o = Ot(new Float64Array(16)), s = new Float64Array(3), c = new Float64Array(3), l = new Float64Array(3), f = Ot(new Float64Array(16)), u = Ot(new Float64Array(16)), g = new Float64Array(3), h = new Float64Array(3);
        function v() {
            e.viewPlaneNormal[0] = -e.directionOfProjection[0], e.viewPlaneNormal[1] = -e.directionOfProjection[1], e.viewPlaneNormal[2] = -e.directionOfProjection[2];
        }
        t.orthogonalizeViewUp = ()=>{
            const m = t.getViewMatrix();
            e.viewUp[0] = m[4], e.viewUp[1] = m[5], e.viewUp[2] = m[6], t.modified();
        }, t.setPosition = (m, y, C)=>{
            m === e.position[0] && y === e.position[1] && C === e.position[2] || (e.position[0] = m, e.position[1] = y, e.position[2] = C, t.computeDistance(), t.modified());
        }, t.setFocalPoint = (m, y, C)=>{
            m === e.focalPoint[0] && y === e.focalPoint[1] && C === e.focalPoint[2] || (e.focalPoint[0] = m, e.focalPoint[1] = y, e.focalPoint[2] = C, t.computeDistance(), t.modified());
        }, t.setDistance = (m)=>{
            if (e.distance === m) return;
            e.distance = m, e.distance < 1e-20 && (e.distance = 1e-20, R1("Distance is set to minimum."));
            const y = e.directionOfProjection;
            e.focalPoint[0] = e.position[0] + y[0] * e.distance, e.focalPoint[1] = e.position[1] + y[1] * e.distance, e.focalPoint[2] = e.position[2] + y[2] * e.distance, t.modified();
        }, t.computeDistance = ()=>{
            const m = e.focalPoint[0] - e.position[0], y = e.focalPoint[1] - e.position[1], C = e.focalPoint[2] - e.position[2];
            if (e.distance = Math.sqrt(m * m + y * y + C * C), e.distance < 1e-20) {
                e.distance = 1e-20, R1("Distance is set to minimum.");
                const T = e.directionOfProjection;
                e.focalPoint[0] = e.position[0] + T[0] * e.distance, e.focalPoint[1] = e.position[1] + T[1] * e.distance, e.focalPoint[2] = e.position[2] + T[2] * e.distance;
            }
            e.directionOfProjection[0] = m / e.distance, e.directionOfProjection[1] = y / e.distance, e.directionOfProjection[2] = C / e.distance, v();
        }, t.dolly = (m)=>{
            if (m <= 0) return;
            const y = e.distance / m;
            t.setPosition(e.focalPoint[0] - y * e.directionOfProjection[0], e.focalPoint[1] - y * e.directionOfProjection[1], e.focalPoint[2] - y * e.directionOfProjection[2]);
        }, t.roll = (m)=>{
            const y = e.position, C = e.focalPoint, T = e.viewUp, x = new Float64Array([
                T[0],
                T[1],
                T[2],
                0
            ]);
            Ot(f);
            const S = new Float64Array([
                C[0] - y[0],
                C[1] - y[1],
                C[2] - y[2]
            ]);
            fs(f, f, Sr(m), S), Ll(x, x, f), e.viewUp[0] = x[0], e.viewUp[1] = x[1], e.viewUp[2] = x[2], t.modified();
        }, t.azimuth = (m)=>{
            const y = e.focalPoint;
            Ot(u), qr(u, u, y), fs(u, u, Sr(m), e.viewUp), qr(u, u, [
                -y[0],
                -y[1],
                -y[2]
            ]), pn(g, e.position, u), t.setPosition(g[0], g[1], g[2]);
        }, t.yaw = (m)=>{
            const y = e.position;
            Ot(u), qr(u, u, y), fs(u, u, Sr(m), e.viewUp), qr(u, u, [
                -y[0],
                -y[1],
                -y[2]
            ]), pn(h, e.focalPoint, u), t.setFocalPoint(h[0], h[1], h[2]);
        }, t.elevation = (m)=>{
            const y = e.focalPoint, C = t.getViewMatrix(), T = [
                -C[0],
                -C[1],
                -C[2]
            ];
            Ot(u), qr(u, u, y), fs(u, u, Sr(m), T), qr(u, u, [
                -y[0],
                -y[1],
                -y[2]
            ]), pn(g, e.position, u), t.setPosition(g[0], g[1], g[2]);
        }, t.pitch = (m)=>{
            const y = e.position, C = t.getViewMatrix(), T = [
                C[0],
                C[1],
                C[2]
            ];
            Ot(u), qr(u, u, y), fs(u, u, Sr(m), T), qr(u, u, [
                -y[0],
                -y[1],
                -y[2]
            ]), pn(h, e.focalPoint, u), t.setFocalPoint(...h);
        }, t.zoom = (m)=>{
            m <= 0 || (e.parallelProjection ? e.parallelScale /= m : e.viewAngle /= m, t.modified());
        }, t.translate = (m, y, C)=>{
            const T = [
                m,
                y,
                C
            ];
            Uh(e.position, T, e.position), Uh(e.focalPoint, T, e.focalPoint), t.computeDistance(), t.modified();
        }, t.applyTransform = (m)=>{
            const y = [
                ...e.viewUp,
                1
            ], C = [], T = [], x = [];
            y[0] += e.position[0], y[1] += e.position[1], y[2] += e.position[2], Ll(C, [
                ...e.position,
                1
            ], m), Ll(T, [
                ...e.focalPoint,
                1
            ], m), Ll(x, y, m), x[0] -= C[0], x[1] -= C[1], x[2] -= C[2], t.setPosition(...C.slice(0, 3)), t.setFocalPoint(...T.slice(0, 3)), t.setViewUp(...x.slice(0, 3));
        }, t.getThickness = ()=>e.clippingRange[1] - e.clippingRange[0], t.setThickness = (m)=>{
            let y = m;
            y < 1e-20 && (y = 1e-20, R1("Thickness is set to minimum.")), t.setClippingRange(e.clippingRange[0], e.clippingRange[0] + y);
        }, t.setThicknessFromFocalPoint = (m)=>{
            let y = m;
            y < 1e-20 && (y = 1e-20, R1("Thickness is set to minimum.")), t.setClippingRange(e.distance - y / 2, e.distance + y / 2);
        }, t.setRoll = (m)=>{}, t.getRoll = ()=>{}, t.setObliqueAngles = (m, y)=>{}, t.getOrientation = ()=>{}, t.getOrientationWXYZ = ()=>{}, t.getFrustumPlanes = (m)=>{}, t.getCameraLightTransformMatrix = (m)=>(Ur(m, e.cameraLightTransform), m), t.computeCameraLightTransform = ()=>{
            Ur(a, t.getViewMatrix()), Xr(a, a), F3(o, [
                e.distance,
                e.distance,
                e.distance
            ]), Qt(a, a, o), Ot(e.cameraLightTransform), qr(e.cameraLightTransform, a, [
                0,
                0,
                -1
            ]);
        }, t.deepCopy = (m)=>{}, t.physicalOrientationToWorldDirection = (m)=>{
            const y = M9(m[0], m[1], m[2], m[3]), C = G0(), T = M9(0, 0, 1, 0);
            return XV(C, y), I9(T, y, T), I9(T, T, C), [
                T[0],
                T[1],
                T[2]
            ];
        }, t.getPhysicalToWorldMatrix = (m)=>{
            t.getWorldToPhysicalMatrix(m), Xr(m, m);
        }, t.getWorldToPhysicalMatrix = (m)=>{
            Ot(m);
            const y = [
                3
            ];
            tc(e.physicalViewNorth, e.physicalViewUp, y), m[0] = y[0], m[1] = y[1], m[2] = y[2], m[4] = e.physicalViewUp[0], m[5] = e.physicalViewUp[1], m[6] = e.physicalViewUp[2], m[8] = -e.physicalViewNorth[0], m[9] = -e.physicalViewNorth[1], m[10] = -e.physicalViewNorth[2], cn(m, m), Sn(s, 1 / e.physicalScale, 1 / e.physicalScale, 1 / e.physicalScale), nc(m, m, s), qr(m, m, e.physicalTranslation);
        }, t.computeViewParametersFromViewMatrix = (m)=>{
            Xr(a, m), pn(s, n, a), t.computeDistance();
            const y = e.distance;
            t.setPosition(s[0], s[1], s[2]), pn(c, r, a), kr(c, c, s), jn(c, c), t.setDirectionOfProjection(c[0], c[1], c[2]), pn(l, i, a), kr(l, l, s), jn(l, l), t.setViewUp(l[0], l[1], l[2]), t.setDistance(y);
        }, t.computeViewParametersFromPhysicalMatrix = (m)=>{
            t.getWorldToPhysicalMatrix(a), Qt(a, m, a), t.computeViewParametersFromViewMatrix(a);
        }, t.setViewMatrix = (m)=>{
            e.viewMatrix = m, e.viewMatrix && (Ur(a, e.viewMatrix), t.computeViewParametersFromViewMatrix(a), cn(e.viewMatrix, e.viewMatrix));
        }, t.getViewMatrix = ()=>{
            if (e.viewMatrix) return e.viewMatrix;
            dx(a, e.position, e.focalPoint, e.viewUp), cn(a, a);
            const m = new Float64Array(16);
            return Ur(m, a), m;
        }, t.setProjectionMatrix = (m)=>{
            e.projectionMatrix = m;
        }, t.getProjectionMatrix = (m, y, C)=>{
            const T = new Float64Array(16);
            if (Ot(T), e.projectionMatrix) {
                const D = 1 / e.physicalScale;
                return Sn(s, D, D, D), Ur(T, e.projectionMatrix), nc(T, T, s), cn(T, T), T;
            }
            Ot(a);
            const x = e.clippingRange[1] - e.clippingRange[0], S = [
                e.clippingRange[0] + (y + 1) * x / 2,
                e.clippingRange[0] + (C + 1) * x / 2
            ];
            if (e.parallelProjection) {
                const D = e.parallelScale * m, _ = e.parallelScale, M = (e.windowCenter[0] - 1) * D, P = (e.windowCenter[0] + 1) * D, F = (e.windowCenter[1] - 1) * _, N = (e.windowCenter[1] + 1) * _;
                G3(a, M, P, F, N, S[0], S[1]), cn(a, a);
            } else {
                if (e.useOffAxisProjection) throw new Error("Off-Axis projection is not supported at this time");
                {
                    const D = Math.tan(Sr(e.viewAngle) / 2);
                    let _, M;
                    e.useHorizontalViewAngle === !0 ? (_ = e.clippingRange[0] * D, M = e.clippingRange[0] * D / m) : (_ = e.clippingRange[0] * D * m, M = e.clippingRange[0] * D);
                    const P = (e.windowCenter[0] - 1) * _, F = (e.windowCenter[0] + 1) * _, N = (e.windowCenter[1] - 1) * M, B = (e.windowCenter[1] + 1) * M, G = S[0], Z = S[1];
                    a[0] = 2 * G / (F - P), a[5] = 2 * G / (B - N), a[2] = (P + F) / (F - P), a[6] = (N + B) / (B - N), a[10] = -(G + Z) / (Z - G), a[14] = -1, a[11] = -2 * G * Z / (Z - G), a[15] = 0;
                }
            }
            return Ur(T, a), T;
        }, t.getCompositeProjectionMatrix = (m, y, C)=>{
            const T = t.getViewMatrix(), x = t.getProjectionMatrix(m, y, C);
            return Qt(x, T, x), x;
        }, t.setDirectionOfProjection = (m, y, C)=>{
            if (e.directionOfProjection[0] === m && e.directionOfProjection[1] === y && e.directionOfProjection[2] === C) return;
            e.directionOfProjection[0] = m, e.directionOfProjection[1] = y, e.directionOfProjection[2] = C;
            const T = e.directionOfProjection;
            e.focalPoint[0] = e.position[0] + T[0] * e.distance, e.focalPoint[1] = e.position[1] + T[1] * e.distance, e.focalPoint[2] = e.position[2] + T[2] * e.distance, v();
        }, t.setDeviceAngles = (m, y, C, T)=>{
            const x = [
                3
            ];
            tc(e.physicalViewNorth, e.physicalViewUp, x);
            const S = Ot(new Float64Array(16));
            fs(S, S, Sr(m), e.physicalViewUp), fs(S, S, Sr(y), x), fs(S, S, Sr(C), e.physicalViewNorth), fs(S, S, Sr(-T), e.physicalViewUp);
            const D = new Float64Array([
                -e.physicalViewUp[0],
                -e.physicalViewUp[1],
                -e.physicalViewUp[2]
            ]), _ = new Float64Array(e.physicalViewNorth);
            pn(D, D, S), pn(_, _, S), t.setDirectionOfProjection(D[0], D[1], D[2]), t.setViewUp(_[0], _[1], _[2]), t.modified();
        }, t.setOrientationWXYZ = (m, y, C, T)=>{
            const x = Ot(new Float64Array(16));
            if (m !== 0 && (y !== 0 || C !== 0 || T !== 0)) {
                const _ = Sr(m), M = G0();
                W3(M, [
                    y,
                    C,
                    T
                ], _), Wh(x, M);
            }
            const S = new Float64Array(3);
            pn(S, [
                0,
                0,
                -1
            ], x);
            const D = new Float64Array(3);
            pn(D, [
                0,
                1,
                0
            ], x), t.setDirectionOfProjection(...S), t.setViewUp(...D), t.modified();
        }, t.computeClippingRange = (m)=>{
            let y = null, C = null;
            y = e.viewPlaneNormal, C = e.position;
            const T = -y[0], x = -y[1], S = -y[2], D = -(T * C[0] + x * C[1] + S * C[2]), _ = [
                T * m[0] + x * m[2] + S * m[4] + D,
                1e-18
            ];
            for(let M = 0; M < 2; M++)for(let P = 0; P < 2; P++)for(let F = 0; F < 2; F++){
                const N = T * m[F] + x * m[2 + P] + S * m[4 + M] + D;
                _[0] = N < _[0] ? N : _[0], _[1] = N > _[1] ? N : _[1];
            }
            return _;
        };
    }
    const sz = {
        position: [
            0,
            0,
            1
        ],
        focalPoint: [
            0,
            0,
            0
        ],
        viewUp: [
            0,
            1,
            0
        ],
        directionOfProjection: [
            0,
            0,
            -1
        ],
        parallelProjection: !1,
        useHorizontalViewAngle: !1,
        viewAngle: 30,
        parallelScale: 1,
        clippingRange: [
            .01,
            1000.01
        ],
        windowCenter: [
            0,
            0
        ],
        viewPlaneNormal: [
            0,
            0,
            1
        ],
        useOffAxisProjection: !1,
        screenBottomLeft: [
            -.5,
            -.5,
            -.5
        ],
        screenBottomRight: [
            .5,
            -.5,
            -.5
        ],
        screenTopRight: [
            .5,
            .5,
            -.5
        ],
        freezeFocalPoint: !1,
        projectionMatrix: null,
        viewMatrix: null,
        cameraLightTransform: xs(),
        physicalTranslation: [
            0,
            0,
            0
        ],
        physicalScale: 1,
        physicalViewUp: [
            0,
            1,
            0
        ],
        physicalViewNorth: [
            0,
            0,
            -1
        ]
    };
    function cD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, sz, n), K.obj(t, e), K.get(t, e, [
            "distance"
        ]), K.setGet(t, e, [
            "parallelProjection",
            "useHorizontalViewAngle",
            "viewAngle",
            "parallelScale",
            "useOffAxisProjection",
            "freezeFocalPoint",
            "physicalScale"
        ]), K.getArray(t, e, [
            "directionOfProjection",
            "viewPlaneNormal",
            "position",
            "focalPoint"
        ]), K.setGetArray(t, e, [
            "clippingRange",
            "windowCenter"
        ], 2), K.setGetArray(t, e, [
            "viewUp",
            "screenBottomLeft",
            "screenBottomRight",
            "screenTopRight",
            "physicalTranslation",
            "physicalViewUp",
            "physicalViewNorth"
        ], 3), oz(t, e);
    }
    const cz = K.newInstance(cD, "vtkCamera");
    var C4 = {
        newInstance: cz,
        extend: cD
    };
    function lz(t, e) {
        e.classHierarchy.push("vtkLight");
        const n = new Float64Array(3);
        t.getTransformedPosition = ()=>(e.transformMatrix ? pn(n, e.position, e.transformMatrix) : Sn(n, e.position[0], e.position[1], e.position[2]), n), t.getTransformedFocalPoint = ()=>(e.transformMatrix ? pn(n, e.focalPoint, e.transformMatrix) : Sn(n, e.focalPoint[0], e.focalPoint[1], e.focalPoint[2]), n), t.getDirection = ()=>(e.directionMTime < e.mtime && (In(e.direction, e.focalPoint, e.position), F0(e.direction), e.directionMTime = e.mtime), e.direction), t.setDirection = (r)=>{
            const i = new Float64Array(3);
            In(i, e.position, r), e.focalPoint = i;
        }, t.setDirectionAngle = (r, i)=>{
            const a = Sr(r), o = Sr(i);
            t.setPosition(Math.cos(a) * Math.sin(o), Math.sin(a), Math.cos(a) * Math.cos(o)), t.setFocalPoint(0, 0, 0), t.setPositional(0);
        }, t.setLightTypeToHeadLight = ()=>{
            t.setLightType("HeadLight");
        }, t.setLightTypeToCameraLight = ()=>{
            t.setLightType("CameraLight");
        }, t.setLightTypeToSceneLight = ()=>{
            t.setTransformMatrix(null), t.setLightType("SceneLight");
        }, t.lightTypeIsHeadLight = ()=>e.lightType === "HeadLight", t.lightTypeIsSceneLight = ()=>e.lightType === "SceneLight", t.lightTypeIsCameraLight = ()=>e.lightType === "CameraLight";
    }
    const uz = {
        switch: !0,
        intensity: 1,
        color: [
            1,
            1,
            1
        ],
        position: [
            0,
            0,
            1
        ],
        focalPoint: [
            0,
            0,
            0
        ],
        positional: !1,
        exponent: 1,
        coneAngle: 30,
        coneFalloff: 5,
        attenuationValues: [
            1,
            0,
            0
        ],
        transformMatrix: null,
        lightType: "SceneLight",
        shadowAttenuation: 1,
        direction: [
            0,
            0,
            0
        ],
        directionMTime: 0
    };
    function fz(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, uz, n), K.obj(t, e), K.setGet(t, e, [
            "intensity",
            "switch",
            "positional",
            "exponent",
            "coneAngle",
            "coneFalloff",
            "transformMatrix",
            "lightType",
            "shadowAttenuation",
            "attenuationValues"
        ]), K.setGetArray(t, e, [
            "color",
            "position",
            "focalPoint",
            "attenuationValues"
        ], 3), lz(t, e);
    }
    const dz = K.newInstance(fz, "vtkLight");
    var gz = {
        newInstance: dz
    };
    const { vtkErrorMacro: gh } = K;
    function hz(t) {
        return ()=>gh(`vtkViewport::${t} - NOT IMPLEMENTED`);
    }
    function pz(t, e) {
        e.classHierarchy.push("vtkViewport"), t.getViewProps = ()=>e.props, t.hasViewProp = (r)=>e.props.includes(r), t.addViewProp = (r)=>{
            r && !t.hasViewProp(r) && e.props.push(r);
        }, t.removeViewProp = (r)=>{
            const i = e.props.filter((a)=>a !== r);
            e.props.length !== i.length && (e.props = i);
        }, t.removeAllViewProps = ()=>{
            e.props = [];
        };
        function n(r) {
            let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            i.push(r);
            const a = r.getNestedProps();
            if (a && a.length) for(let o = 0; o < a.length; o++)n(a[o], i);
            return i;
        }
        t.getViewPropsWithNestedProps = ()=>{
            const r = [];
            for(let i = 0; i < e.props.length; i++)n(e.props[i], r);
            return r;
        }, t.addActor2D = t.addViewProp, t.removeActor2D = (r)=>{
            t.removeViewProp(r);
        }, t.getActors2D = ()=>(e.actors2D = [], e.props.forEach((r)=>{
                e.actors2D = e.actors2D.concat(r.getActors2D());
            }), e.actors2D), t.displayToView = ()=>gh("call displayToView on your view instead"), t.viewToDisplay = ()=>gh("callviewtodisplay on your view instead"), t.getSize = ()=>gh("call getSize on your View instead"), t.normalizedDisplayToProjection = (r, i, a)=>{
            const o = t.normalizedDisplayToNormalizedViewport(r, i, a);
            return t.normalizedViewportToProjection(o[0], o[1], o[2]);
        }, t.normalizedDisplayToNormalizedViewport = (r, i, a)=>{
            const o = [
                e.viewport[2] - e.viewport[0],
                e.viewport[3] - e.viewport[1]
            ];
            return [
                (r - e.viewport[0]) / o[0],
                (i - e.viewport[1]) / o[1],
                a
            ];
        }, t.normalizedViewportToProjection = (r, i, a)=>[
                r * 2 - 1,
                i * 2 - 1,
                a * 2 - 1
            ], t.projectionToNormalizedDisplay = (r, i, a)=>{
            const o = t.projectionToNormalizedViewport(r, i, a);
            return t.normalizedViewportToNormalizedDisplay(o[0], o[1], o[2]);
        }, t.normalizedViewportToNormalizedDisplay = (r, i, a)=>{
            const o = [
                e.viewport[2] - e.viewport[0],
                e.viewport[3] - e.viewport[1]
            ];
            return [
                r * o[0] + e.viewport[0],
                i * o[1] + e.viewport[1],
                a
            ];
        }, t.projectionToNormalizedViewport = (r, i, a)=>[
                (r + 1) * .5,
                (i + 1) * .5,
                (a + 1) * .5
            ], t.PickPropFrom = hz("PickPropFrom");
    }
    const mz = {
        background: [
            0,
            0,
            0
        ],
        background2: [
            .2,
            .2,
            .2
        ],
        gradientBackground: !1,
        viewport: [
            0,
            0,
            1,
            1
        ],
        aspect: [
            1,
            1
        ],
        pixelAspect: [
            1,
            1
        ],
        props: [],
        actors2D: []
    };
    function lD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, mz, n), K.obj(t, e), K.event(t, e, "event"), K.setGetArray(t, e, [
            "viewport"
        ], 4), K.setGetArray(t, e, [
            "background",
            "background2"
        ], 3), pz(t, e);
    }
    const vz = K.newInstance(lD, "vtkViewport");
    var yz = {
        newInstance: vz,
        extend: lD
    };
    const { vtkDebugMacro: $f, vtkErrorMacro: xl, vtkWarningMacro: Cz } = da;
    function yC(t) {
        return ()=>xl(`vtkRenderer::${t} - NOT IMPLEMENTED`);
    }
    function wz(t, e) {
        e.classHierarchy.push("vtkRenderer");
        const n = {
            type: "ComputeVisiblePropBoundsEvent",
            renderer: t
        }, r = {
            type: "ResetCameraClippingRangeEvent",
            renderer: t
        }, i = {
            type: "ResetCameraEvent",
            renderer: t
        };
        t.updateCamera = ()=>(e.activeCamera || ($f("No cameras are on, creating one."), t.getActiveCameraAndResetIfCreated()), e.activeCamera.render(t), !0), t.updateLightsGeometryToFollowCamera = ()=>{
            const a = t.getActiveCameraAndResetIfCreated();
            e.lights.forEach((o)=>{
                o.lightTypeIsSceneLight() || (o.lightTypeIsHeadLight() ? (o.setPositionFrom(a.getPositionByReference()), o.setFocalPointFrom(a.getFocalPointByReference()), o.modified(a.getMTime())) : o.lightTypeIsCameraLight() ? o.setTransformMatrix(a.getCameraLightTransformMatrix(xs())) : xl("light has unknown light type", o.get()));
            });
        }, t.updateLightGeometry = ()=>e.lightFollowCamera ? t.updateLightsGeometryToFollowCamera() : !0, t.allocateTime = yC("allocateTime"), t.updateGeometry = yC("updateGeometry"), t.getVTKWindow = ()=>e._renderWindow, t.setLayer = (a)=>{
            $f(t.getClassName(), t, "setting Layer to ", a), e.layer !== a && (e.layer = a, t.modified()), t.setPreserveColorBuffer(!!a);
        }, t.setActiveCamera = (a)=>e.activeCamera === a ? !1 : (e.activeCamera = a, t.modified(), t.invokeEvent({
                type: "ActiveCameraEvent",
                camera: a
            }), !0), t.makeCamera = ()=>{
            const a = C4.newInstance();
            return t.invokeEvent({
                type: "CreateCameraEvent",
                camera: a
            }), a;
        }, t.getActiveCamera = ()=>(e.activeCamera || (e.activeCamera = t.makeCamera()), e.activeCamera), t.getActiveCameraAndResetIfCreated = ()=>(e.activeCamera || (t.getActiveCamera(), t.resetCamera()), e.activeCamera), t.getActors = ()=>(e.actors = [], e.props.forEach((a)=>{
                e.actors = e.actors.concat(a.getActors());
            }), e.actors), t.addActor = t.addViewProp, t.removeActor = (a)=>{
            e.actors = e.actors.filter((o)=>o !== a), t.removeViewProp(a), t.modified();
        }, t.removeAllActors = ()=>{
            t.getActors().forEach((o)=>{
                t.removeViewProp(o);
            }), e.actors = [], t.modified();
        }, t.getVolumes = ()=>(e.volumes = [], e.props.forEach((a)=>{
                e.volumes = e.volumes.concat(a.getVolumes());
            }), e.volumes), t.addVolume = t.addViewProp, t.removeVolume = (a)=>{
            e.volumes = e.volumes.filter((o)=>o !== a), t.removeViewProp(a), t.modified();
        }, t.removeAllVolumes = ()=>{
            t.getVolumes().forEach((o)=>{
                t.removeViewProp(o);
            }), e.volumes = [], t.modified();
        }, t.hasLight = (a)=>e.lights.includes(a), t.addLight = (a)=>{
            a && !t.hasLight(a) && (e.lights.push(a), t.modified());
        }, t.removeLight = (a)=>{
            e.lights = e.lights.filter((o)=>o !== a), t.modified();
        }, t.removeAllLights = ()=>{
            e.lights = [], t.modified();
        }, t.setLightCollection = (a)=>{
            e.lights = a, t.modified();
        }, t.makeLight = gz.newInstance, t.createLight = ()=>{
            e.automaticLightCreation && (e._createdLight && (t.removeLight(e._createdLight), e._createdLight.delete(), e._createdLight = null), e._createdLight = t.makeLight(), t.addLight(e._createdLight), e._createdLight.setLightTypeToHeadLight(), e._createdLight.setPosition(t.getActiveCamera().getPosition()), e._createdLight.setFocalPoint(t.getActiveCamera().getFocalPoint()));
        }, t.normalizedDisplayToWorld = (a, o, s, c)=>{
            let l = t.normalizedDisplayToProjection(a, o, s);
            return l = t.projectionToView(l[0], l[1], l[2], c), t.viewToWorld(l[0], l[1], l[2]);
        }, t.worldToNormalizedDisplay = (a, o, s, c)=>{
            let l = t.worldToView(a, o, s);
            return l = t.viewToProjection(l[0], l[1], l[2], c), t.projectionToNormalizedDisplay(l[0], l[1], l[2]);
        }, t.viewToWorld = (a, o, s)=>{
            if (e.activeCamera === null) return xl("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"), [
                0,
                0,
                0
            ];
            const c = e.activeCamera.getViewMatrix();
            Xr(c, c), cn(c, c);
            const l = new Float64Array([
                a,
                o,
                s
            ]);
            return pn(l, l, c), l;
        }, t.projectionToView = (a, o, s, c)=>{
            if (e.activeCamera === null) return xl("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"), [
                0,
                0,
                0
            ];
            const l = e.activeCamera.getProjectionMatrix(c, -1, 1);
            Xr(l, l), cn(l, l);
            const f = new Float64Array([
                a,
                o,
                s
            ]);
            return pn(f, f, l), f;
        }, t.worldToView = (a, o, s)=>{
            if (e.activeCamera === null) return xl("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"), [
                0,
                0,
                0
            ];
            const c = e.activeCamera.getViewMatrix();
            cn(c, c);
            const l = new Float64Array([
                a,
                o,
                s
            ]);
            return pn(l, l, c), l;
        }, t.viewToProjection = (a, o, s, c)=>{
            if (e.activeCamera === null) return xl("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"), [
                0,
                0,
                0
            ];
            const l = e.activeCamera.getProjectionMatrix(c, -1, 1);
            cn(l, l);
            const f = new Float64Array([
                a,
                o,
                s
            ]);
            return pn(f, f, l), f;
        }, t.computeVisiblePropBounds = ()=>{
            e.allBounds[0] = zn.INIT_BOUNDS[0], e.allBounds[1] = zn.INIT_BOUNDS[1], e.allBounds[2] = zn.INIT_BOUNDS[2], e.allBounds[3] = zn.INIT_BOUNDS[3], e.allBounds[4] = zn.INIT_BOUNDS[4], e.allBounds[5] = zn.INIT_BOUNDS[5];
            let a = !0;
            t.invokeEvent(n);
            for(let o = 0; o < e.props.length; ++o){
                const s = e.props[o];
                if (s.getVisibility() && s.getUseBounds()) {
                    const c = s.getBounds();
                    c && rh(c) && (a = !1, c[0] < e.allBounds[0] && (e.allBounds[0] = c[0]), c[1] > e.allBounds[1] && (e.allBounds[1] = c[1]), c[2] < e.allBounds[2] && (e.allBounds[2] = c[2]), c[3] > e.allBounds[3] && (e.allBounds[3] = c[3]), c[4] < e.allBounds[4] && (e.allBounds[4] = c[4]), c[5] > e.allBounds[5] && (e.allBounds[5] = c[5]));
                }
            }
            return a && (af(e.allBounds), $f("Can't compute bounds, no 3D props are visible")), e.allBounds;
        }, t.resetCamera = function() {
            const o = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || t.computeVisiblePropBounds(), s = [
                0,
                0,
                0
            ];
            if (!rh(o)) return $f("Cannot reset camera!"), !1;
            let c = null;
            if (t.getActiveCamera()) c = e.activeCamera.getViewPlaneNormal();
            else return xl("Trying to reset non-existent camera"), !1;
            e.activeCamera.setViewAngle(30), s[0] = (o[0] + o[1]) / 2, s[1] = (o[2] + o[3]) / 2, s[2] = (o[4] + o[5]) / 2;
            let l = o[1] - o[0], f = o[3] - o[2], u = o[5] - o[4];
            l *= l, f *= f, u *= u;
            let g = l + f + u;
            g = g === 0 ? 1 : g, g = Math.sqrt(g) * .5;
            const h = Sr(e.activeCamera.getViewAngle()), v = g, m = g / Math.sin(h * .5), y = e.activeCamera.getViewUp();
            return Math.abs($t(y, c)) > .999 && (Cz("Resetting view-up since view plane normal is parallel"), e.activeCamera.setViewUp(-y[2], y[0], y[1])), e.activeCamera.setFocalPoint(s[0], s[1], s[2]), e.activeCamera.setPosition(s[0] + m * c[0], s[1] + m * c[1], s[2] + m * c[2]), t.resetCameraClippingRange(o), e.activeCamera.setParallelScale(v), e.activeCamera.setPhysicalScale(g), e.activeCamera.setPhysicalTranslation(-s[0], -s[1], -s[2]), t.invokeEvent(i), !0;
        }, t.resetCameraClippingRange = function() {
            const o = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || t.computeVisiblePropBounds();
            if (!rh(o)) return $f("Cannot reset camera clipping range!"), !1;
            if (t.getActiveCameraAndResetIfCreated(), !e.activeCamera) return xl("Trying to reset clipping range of non-existent camera"), !1;
            const s = e.activeCamera.computeClippingRange(o);
            let c = 0;
            if (e.activeCamera.getParallelProjection()) c = .2 * e.activeCamera.getParallelScale();
            else {
                const l = Sr(e.activeCamera.getViewAngle());
                c = .2 * Math.tan(l / 2) * s[1];
            }
            return s[1] - s[0] < c && (c = c - s[1] + s[0], s[1] += c / 2, s[0] -= c / 2), s[0] < 0 && (s[0] = 0), s[0] = .99 * s[0] - (s[1] - s[0]) * e.clippingRangeExpansion, s[1] = 1.01 * s[1] + (s[1] - s[0]) * e.clippingRangeExpansion, s[0] = s[0] >= s[1] ? .01 * s[1] : s[0], e.nearClippingPlaneTolerance || (e.nearClippingPlaneTolerance = .01), s[0] < e.nearClippingPlaneTolerance * s[1] && (s[0] = e.nearClippingPlaneTolerance * s[1]), e.activeCamera.setClippingRange(s[0], s[1]), t.invokeEvent(r), !1;
        }, t.setRenderWindow = (a)=>{
            a !== e._renderWindow && (e._vtkWindow = a, e._renderWindow = a);
        }, t.visibleActorCount = ()=>e.props.filter((a)=>a.getVisibility()).length, t.visibleVolumeCount = t.visibleActorCount, t.getMTime = ()=>{
            let a = e.mtime;
            const o = e.activeCamera ? e.activeCamera.getMTime() : 0;
            o > a && (a = o);
            const s = e._createdLight ? e._createdLight.getMTime() : 0;
            return s > a && (a = s), a;
        }, t.getTransparent = ()=>!!e.preserveColorBuffer, t.isActiveCameraCreated = ()=>!!e.activeCamera;
    }
    const Tz = {
        pickedProp: null,
        activeCamera: null,
        allBounds: [],
        ambient: [
            1,
            1,
            1
        ],
        allocatedRenderTime: 100,
        timeFactor: 1,
        automaticLightCreation: !0,
        twoSidedLighting: !0,
        lastRenderTimeInSeconds: -1,
        renderWindow: null,
        lights: [],
        actors: [],
        volumes: [],
        lightFollowCamera: !0,
        numberOfPropsRendered: 0,
        propArray: null,
        pathArray: null,
        layer: 0,
        preserveColorBuffer: !1,
        preserveDepthBuffer: !1,
        computeVisiblePropBounds: Gl(),
        interactive: !0,
        nearClippingPlaneTolerance: 0,
        clippingRangeExpansion: .05,
        erase: !0,
        draw: !0,
        useShadows: !1,
        useDepthPeeling: !1,
        occlusionRatio: 0,
        maximumNumberOfPeels: 4,
        selector: null,
        delegate: null,
        texturedBackground: !1,
        backgroundTexture: null,
        environmentTexture: null,
        environmentTextureDiffuseStrength: 1,
        environmentTextureSpecularStrength: 1,
        useEnvironmentTextureAsBackground: !1,
        pass: 0
    };
    function uD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        for(Object.assign(e, Tz, n), yz.extend(t, e, n), e.background || (e.background = [
            0,
            0,
            0,
            1
        ]); e.background.length < 3;)e.background.push(0);
        e.background.length === 3 && e.background.push(1), La(t, e, [
            "_renderWindow",
            "allocatedRenderTime",
            "timeFactor",
            "lastRenderTimeInSeconds",
            "numberOfPropsRendered",
            "lastRenderingUsedDepthPeeling",
            "selector"
        ]), si(t, e, [
            "twoSidedLighting",
            "lightFollowCamera",
            "automaticLightCreation",
            "erase",
            "draw",
            "nearClippingPlaneTolerance",
            "clippingRangeExpansion",
            "backingStore",
            "interactive",
            "layer",
            "preserveColorBuffer",
            "preserveDepthBuffer",
            "useDepthPeeling",
            "occlusionRatio",
            "maximumNumberOfPeels",
            "delegate",
            "backgroundTexture",
            "texturedBackground",
            "environmentTexture",
            "environmentTextureDiffuseStrength",
            "environmentTextureSpecularStrength",
            "useEnvironmentTextureAsBackground",
            "useShadows",
            "pass"
        ]), rf(t, e, [
            "actors",
            "volumes",
            "lights"
        ]), v3(t, e, [
            "background"
        ], 4, 1), zd(t, e, [
            "renderWindow"
        ]), wz(t, e);
    }
    const xz = kn(uD, "vtkRenderer");
    var Sz = {
        newInstance: xz,
        extend: uD
    };
    const Ez = {
        Unknown: 0,
        LeftController: 1,
        RightController: 2
    }, Dz = {
        Unknown: 0,
        Trigger: 1,
        TrackPad: 2,
        Grip: 3,
        Thumbstick: 4,
        A: 5,
        B: 6,
        ApplicationMenu: 7
    }, _z = {
        Unknown: 0,
        TouchpadX: 1,
        TouchpadY: 2,
        ThumbstickX: 3,
        ThumbstickY: 4
    };
    var fD = {
        Device: Ez,
        Input: Dz,
        Axis: _z
    };
    const { Device: O1, Input: S0 } = fD, { vtkWarningMacro: I1, vtkErrorMacro: M1, normalizeWheel: Rz, vtkOnceErrorMacro: Oz } = K, vu = {
        ctrlKey: !1,
        altKey: !1,
        shiftKey: !1
    }, D5 = {
        "xr-standard": [
            S0.Trigger,
            S0.Grip,
            S0.TrackPad,
            S0.Thumbstick,
            S0.A,
            S0.B
        ]
    }, w4 = [
        "StartAnimation",
        "Animation",
        "EndAnimation",
        "PointerEnter",
        "PointerLeave",
        "MouseEnter",
        "MouseLeave",
        "StartMouseMove",
        "MouseMove",
        "EndMouseMove",
        "LeftButtonPress",
        "LeftButtonRelease",
        "MiddleButtonPress",
        "MiddleButtonRelease",
        "RightButtonPress",
        "RightButtonRelease",
        "KeyPress",
        "KeyDown",
        "KeyUp",
        "StartMouseWheel",
        "MouseWheel",
        "EndMouseWheel",
        "StartPinch",
        "Pinch",
        "EndPinch",
        "StartPan",
        "Pan",
        "EndPan",
        "StartRotate",
        "Rotate",
        "EndRotate",
        "Button3D",
        "Move3D",
        "StartPointerLock",
        "EndPointerLock",
        "StartInteraction",
        "Interaction",
        "EndInteraction",
        "AnimationFrameRateUpdate"
    ];
    function zf(t) {
        t.cancelable && t.preventDefault();
    }
    function b1(t) {
        const e = Object.create(null);
        return t.forEach((n)=>{
            let { pointerId: r, position: i } = n;
            e[r] = i;
        }), e;
    }
    function Iz(t, e) {
        e.classHierarchy.push("vtkRenderWindowInteractor");
        const n = {
            ...t
        }, r = new Set, i = new Map;
        let a = 1;
        t.start = ()=>{
            !e.initialized && (t.initialize(), !e.initialized) || t.startEventLoop();
        }, t.setRenderWindow = (m)=>{
            M1("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
        }, t.setInteractorStyle = (m)=>{
            e.interactorStyle !== m && (e.interactorStyle != null && e.interactorStyle.setInteractor(null), e.interactorStyle = m, e.interactorStyle != null && e.interactorStyle.getInteractor() !== t && e.interactorStyle.setInteractor(t));
        }, t.initialize = ()=>{
            e.initialized = !0, t.enable(), t.render();
        }, t.enable = ()=>t.setEnabled(!0), t.disable = ()=>t.setEnabled(!1), t.startEventLoop = ()=>I1("empty event loop");
        function o(m, y) {
            e._forcedRenderer || (e.currentRenderer = t.findPokedRenderer(m, y));
        }
        t.getCurrentRenderer = ()=>(e.currentRenderer || o(0, 0), e.currentRenderer);
        function s(m) {
            const y = e._view.getCanvas(), C = y.getBoundingClientRect(), T = y.width / C.width, x = y.height / C.height, S = {
                x: T * (m.clientX - C.left),
                y: x * (C.height - m.clientY + C.top),
                z: 0
            };
            return (i.size <= 1 || !e.currentRenderer) && o(S.x, S.y), S;
        }
        const c = e._getScreenEventPositionFor || s;
        function l(m) {
            return {
                controlKey: m.ctrlKey,
                altKey: m.altKey,
                shiftKey: m.shiftKey
            };
        }
        function f(m) {
            const y = l(m);
            return {
                key: m.key,
                keyCode: m.charCode,
                ...y
            };
        }
        function u(m) {
            return m.pointerType || "";
        }
        const g = ()=>{
            if (e.container === null) return;
            const { container: m } = e;
            m.addEventListener("contextmenu", zf), m.addEventListener("wheel", t.handleWheel), m.addEventListener("DOMMouseScroll", t.handleWheel), m.addEventListener("pointerenter", t.handlePointerEnter), m.addEventListener("pointerleave", t.handlePointerLeave), m.addEventListener("pointermove", t.handlePointerMove, {
                passive: !1
            }), m.addEventListener("pointerdown", t.handlePointerDown, {
                passive: !1
            }), m.addEventListener("pointerup", t.handlePointerUp), m.addEventListener("pointercancel", t.handlePointerCancel), document.addEventListener("keypress", t.handleKeyPress), document.addEventListener("keydown", t.handleKeyDown), document.addEventListener("keyup", t.handleKeyUp), document.addEventListener("pointerlockchange", t.handlePointerLockChange), m.style.touchAction = "none", m.style.userSelect = "none", m.style.webkitTapHighlightColor = "rgba(0,0,0,0)";
        };
        t.bindEvents = (m)=>{
            if (m === null) return;
            n.setContainer(m) && g();
        };
        const h = ()=>{
            clearTimeout(e.moveTimeoutID), clearTimeout(e.wheelTimeoutID), e.moveTimeoutID = 0, e.wheelTimeoutID = 0, a = 1;
            const { container: m } = e;
            m && (m.removeEventListener("contextmenu", zf), m.removeEventListener("wheel", t.handleWheel), m.removeEventListener("DOMMouseScroll", t.handleWheel), m.removeEventListener("pointerenter", t.handlePointerEnter), m.removeEventListener("pointerleave", t.handlePointerLeave), m.removeEventListener("pointermove", t.handlePointerMove, {
                passive: !1
            }), m.removeEventListener("pointerdown", t.handlePointerDown, {
                passive: !1
            }), m.removeEventListener("pointerup", t.handlePointerUp), m.removeEventListener("pointercancel", t.handlePointerCancel)), document.removeEventListener("keypress", t.handleKeyPress), document.removeEventListener("keydown", t.handleKeyDown), document.removeEventListener("keyup", t.handleKeyUp), document.removeEventListener("pointerlockchange", t.handlePointerLockChange), i.clear();
        };
        t.unbindEvents = ()=>{
            h(), n.setContainer(null);
        }, t.handleKeyPress = (m)=>{
            const y = f(m);
            t.keyPressEvent(y);
        }, t.handleKeyDown = (m)=>{
            const y = f(m);
            t.keyDownEvent(y);
        }, t.handleKeyUp = (m)=>{
            const y = f(m);
            t.keyUpEvent(y);
        }, t.handlePointerEnter = (m)=>{
            const y = {
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            t.pointerEnterEvent(y), y.deviceType === "mouse" && t.mouseEnterEvent(y);
        }, t.handlePointerLeave = (m)=>{
            const y = {
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            t.pointerLeaveEvent(y), y.deviceType === "mouse" && t.mouseLeaveEvent(y);
        }, t.handlePointerDown = (m)=>{
            if (!(m.button > 2 || t.isPointerLocked())) switch(e.preventDefaultOnPointerDown && zf(m), m.target.hasPointerCapture(m.pointerId) && m.target.releasePointerCapture(m.pointerId), e.container.setPointerCapture(m.pointerId), i.has(m.pointerId) && I1("[RenderWindowInteractor] duplicate pointerId detected"), i.set(m.pointerId, {
                pointerId: m.pointerId,
                position: c(m)
            }), m.pointerType){
                case "pen":
                case "touch":
                    t.handleTouchStart(m);
                    break;
                case "mouse":
                default:
                    t.handleMouseDown(m);
                    break;
            }
        }, t.handlePointerUp = (m)=>{
            if (i.has(m.pointerId)) switch(e.preventDefaultOnPointerUp && zf(m), i.delete(m.pointerId), e.container.releasePointerCapture(m.pointerId), m.pointerType){
                case "pen":
                case "touch":
                    t.handleTouchEnd(m);
                    break;
                case "mouse":
                default:
                    t.handleMouseUp(m);
                    break;
            }
        }, t.handlePointerCancel = (m)=>{
            if (i.has(m.pointerId)) switch(i.delete(m.pointerId), m.pointerType){
                case "pen":
                case "touch":
                    t.handleTouchEnd(m);
                    break;
                case "mouse":
                default:
                    t.handleMouseUp(m);
                    break;
            }
        }, t.handlePointerMove = (m)=>{
            if (i.has(m.pointerId)) {
                const y = i.get(m.pointerId);
                y.position = c(m);
            }
            switch(m.pointerType){
                case "pen":
                case "touch":
                    t.handleTouchMove(m);
                    break;
                case "mouse":
                default:
                    t.handleMouseMove(m);
                    break;
            }
        }, t.handleMouseDown = (m)=>{
            const y = {
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            switch(m.button){
                case 0:
                    t.leftButtonPressEvent(y);
                    break;
                case 1:
                    t.middleButtonPressEvent(y);
                    break;
                case 2:
                    t.rightButtonPressEvent(y);
                    break;
                default:
                    M1(`Unknown mouse button pressed: ${m.button}`);
                    break;
            }
        }, t.requestPointerLock = ()=>{
            e.container && e.container.requestPointerLock();
        }, t.exitPointerLock = ()=>document.exitPointerLock?.(), t.isPointerLocked = ()=>!!e.container && document.pointerLockElement === e.container, t.handlePointerLockChange = ()=>{
            t.isPointerLocked() ? t.startPointerLockEvent() : t.endPointerLockEvent();
        };
        function v() {
            e._view && e.enabled && e.enableRender && (e.inRender = !0, e._view.traverseAllPasses(), e.inRender = !1), t.invokeRenderEvent();
        }
        t.requestAnimation = (m)=>{
            if (m === void 0) {
                M1("undefined requester, can not start animating");
                return;
            }
            if (r.has(m)) {
                I1("requester is already registered for animating");
                return;
            }
            r.add(m), !e.animationRequest && r.size === 1 && !e.xrAnimation && (e._animationStartTime = Date.now(), e._animationFrameCount = 0, e.animationRequest = requestAnimationFrame(t.handleAnimation), t.startAnimationEvent());
        }, t.extendAnimation = (m)=>{
            const y = Date.now() + m;
            e._animationExtendedEnd = Math.max(e._animationExtendedEnd, y), !e.animationRequest && r.size === 0 && !e.xrAnimation && (e._animationStartTime = Date.now(), e._animationFrameCount = 0, e.animationRequest = requestAnimationFrame(t.handleAnimation), t.startAnimationEvent());
        }, t.isAnimating = ()=>e.xrAnimation || e.animationRequest !== null, t.cancelAnimation = function(m) {
            let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            if (!r.has(m)) {
                if (!y) {
                    const C = m && m.getClassName ? m.getClassName() : m;
                    I1(`${C} did not request an animation`);
                }
                return;
            }
            r.delete(m), e.animationRequest && r.size === 0 && Date.now() > e._animationExtendedEnd && (cancelAnimationFrame(e.animationRequest), e.animationRequest = null, t.endAnimationEvent(), t.render());
        }, t.switchToXRAnimation = ()=>{
            e.animationRequest && (cancelAnimationFrame(e.animationRequest), e.animationRequest = null), e.xrAnimation = !0;
        }, t.returnFromXRAnimation = ()=>{
            e.xrAnimation = !1, r.size !== 0 && (e.recentAnimationFrameRate = 10, e.animationRequest = requestAnimationFrame(t.handleAnimation));
        }, t.updateXRGamepads = (m, y, C)=>{
            m.inputSources.forEach((T)=>{
                const x = T.gripSpace == null ? null : y.getPose(T.gripSpace, C), S = T.gripSpace == null ? null : y.getPose(T.targetRaySpace, C), D = T.gamepad, _ = T.handedness;
                if (D) {
                    D.index in e.lastGamepadValues || (e.lastGamepadValues[D.index] = {
                        left: {
                            buttons: {}
                        },
                        right: {
                            buttons: {}
                        },
                        none: {
                            buttons: {}
                        }
                    });
                    for(let M = 0; M < D.buttons.length; ++M)M in e.lastGamepadValues[D.index][_].buttons || (e.lastGamepadValues[D.index][_].buttons[M] = !1), e.lastGamepadValues[D.index][_].buttons[M] !== D.buttons[M].pressed && x != null && (t.button3DEvent({
                        gamepad: D,
                        position: x.transform.position,
                        orientation: x.transform.orientation,
                        targetPosition: S.transform.position,
                        targetOrientation: S.transform.orientation,
                        pressed: D.buttons[M].pressed,
                        device: T.handedness === "left" ? O1.LeftController : O1.RightController,
                        input: D5[D.mapping] && D5[D.mapping][M] ? D5[D.mapping][M] : S0.Trigger
                    }), e.lastGamepadValues[D.index][_].buttons[M] = D.buttons[M].pressed), e.lastGamepadValues[D.index][_].buttons[M] && x != null && t.move3DEvent({
                        gamepad: D,
                        position: x.transform.position,
                        orientation: x.transform.orientation,
                        targetPosition: S.transform.position,
                        targetOrientation: S.transform.orientation,
                        device: T.handedness === "left" ? O1.LeftController : O1.RightController
                    });
                }
            });
        }, t.handleMouseMove = (m)=>{
            const y = {
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            e.moveTimeoutID === 0 ? t.startMouseMoveEvent(y) : (t.mouseMoveEvent(y), clearTimeout(e.moveTimeoutID)), e.moveTimeoutID = setTimeout(()=>{
                t.endMouseMoveEvent(), e.moveTimeoutID = 0;
            }, 200);
        }, t.handleAnimation = ()=>{
            const m = Date.now();
            e._animationFrameCount++, m - e._animationStartTime > 1e3 && e._animationFrameCount > 1 && (e.recentAnimationFrameRate = 1e3 * (e._animationFrameCount - 1) / (m - e._animationStartTime), e.lastFrameTime = 1 / e.recentAnimationFrameRate, t.animationFrameRateUpdateEvent(), e._animationStartTime = m, e._animationFrameCount = 1), t.animationEvent(), v(), r.size > 0 || Date.now() < e._animationExtendedEnd ? e.animationRequest = requestAnimationFrame(t.handleAnimation) : (cancelAnimationFrame(e.animationRequest), e.animationRequest = null, t.endAnimationEvent(), t.render());
        }, t.handleWheel = (m)=>{
            zf(m);
            const y = {
                ...Rz(m),
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            e.wheelTimeoutID === 0 && (Math.abs(y.spinY) >= .3 ? a = Math.abs(y.spinY) : a = 1), y.spinY /= a, e.wheelTimeoutID === 0 ? (t.startMouseWheelEvent(y), t.mouseWheelEvent(y)) : (t.mouseWheelEvent(y), clearTimeout(e.wheelTimeoutID)), e.mouseScrollDebounceByPass ? (t.extendAnimation(600), t.endMouseWheelEvent(), e.wheelTimeoutID = 0) : e.wheelTimeoutID = setTimeout(()=>{
                t.extendAnimation(600), t.endMouseWheelEvent(), e.wheelTimeoutID = 0;
            }, 200);
        }, t.handleMouseUp = (m)=>{
            const y = {
                ...l(m),
                position: c(m),
                deviceType: u(m)
            };
            switch(m.button){
                case 0:
                    t.leftButtonReleaseEvent(y);
                    break;
                case 1:
                    t.middleButtonReleaseEvent(y);
                    break;
                case 2:
                    t.rightButtonReleaseEvent(y);
                    break;
                default:
                    M1(`Unknown mouse button released: ${m.button}`);
                    break;
            }
        }, t.handleTouchStart = (m)=>{
            const y = [
                ...i.values()
            ];
            if (e.recognizeGestures && y.length > 1) {
                const C = b1(i);
                if (y.length === 2) {
                    const T = {
                        ...l(vu),
                        position: y[0].position,
                        deviceType: u(m)
                    };
                    t.leftButtonReleaseEvent(T);
                }
                t.recognizeGesture("TouchStart", C);
            } else if (y.length === 1) {
                const C = {
                    ...l(vu),
                    position: c(m),
                    deviceType: u(m)
                };
                t.leftButtonPressEvent(C);
            }
        }, t.handleTouchMove = (m)=>{
            const y = [
                ...i.values()
            ];
            if (e.recognizeGestures && y.length > 1) {
                const C = b1(i);
                t.recognizeGesture("TouchMove", C);
            } else if (y.length === 1) {
                const C = {
                    ...l(vu),
                    position: y[0].position,
                    deviceType: u(m)
                };
                t.mouseMoveEvent(C);
            }
        }, t.handleTouchEnd = (m)=>{
            const y = [
                ...i.values()
            ];
            if (e.recognizeGestures) if (y.length === 0) {
                const C = {
                    ...l(vu),
                    position: c(m),
                    deviceType: u(m)
                };
                t.leftButtonReleaseEvent(C);
            } else if (y.length === 1) {
                const C = b1(i);
                t.recognizeGesture("TouchEnd", C);
                const T = {
                    ...l(vu),
                    position: y[0].position,
                    deviceType: u(m)
                };
                t.leftButtonPressEvent(T);
            } else {
                const C = b1(i);
                t.recognizeGesture("TouchMove", C);
            }
            else if (y.length === 1) {
                const C = {
                    ...l(vu),
                    position: y[0].position,
                    deviceType: u(m)
                };
                t.leftButtonReleaseEvent(C);
            }
        }, t.setView = (m)=>{
            e._view !== m && (e._view = m, e._view.getRenderable().setInteractor(t), t.modified());
        }, t.getFirstRenderer = ()=>e._view?.getRenderable()?.getRenderersByReference()?.[0], t.findPokedRenderer = function() {
            let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            if (!e._view) return null;
            const C = e._view?.getRenderable()?.getRenderers();
            if (!C || C.length === 0) return null;
            C.sort((_, M)=>_.getLayer() - M.getLayer());
            let T = null, x = null, S = null, D = C.length;
            for(; D--;){
                const _ = C[D];
                if (e._view.isInViewport(m, y, _) && _.getInteractive()) {
                    S = _;
                    break;
                }
                T === null && _.getInteractive() && (T = _), x === null && e._view.isInViewport(m, y, _) && (x = _);
            }
            return S === null && (S = T), S === null && (S = x), S == null && (S = C[0]), S;
        }, t.render = ()=>{
            !t.isAnimating() && !e.inRender && v();
        }, w4.forEach((m)=>{
            const y = m.charAt(0).toLowerCase() + m.slice(1);
            t[`${y}Event`] = (C)=>{
                if (!e.enabled) return;
                if (!t.getCurrentRenderer()) {
                    Oz(`
          Can not forward events without a current renderer on the interactor.
        `);
                    return;
                }
                const x = {
                    type: m,
                    pokedRenderer: e.currentRenderer,
                    firstRenderer: t.getFirstRenderer(),
                    ...C
                };
                t[`invoke${m}`](x);
            };
        }), t.recognizeGesture = (m, y)=>{
            if (Object.keys(y).length > 2) return;
            if (e.startingEventPositions || (e.startingEventPositions = {}), m === "TouchStart") {
                Object.keys(y).forEach((N)=>{
                    e.startingEventPositions[N] = y[N];
                }), e.currentGesture = "Start";
                return;
            }
            if (m === "TouchEnd") {
                e.currentGesture === "Pinch" && (t.render(), t.endPinchEvent()), e.currentGesture === "Rotate" && (t.render(), t.endRotateEvent()), e.currentGesture === "Pan" && (t.render(), t.endPanEvent()), e.currentGesture = "Start", e.startingEventPositions = {};
                return;
            }
            let C = 0;
            const T = [], x = [];
            Object.keys(y).forEach((N)=>{
                T[C] = y[N], x[C] = e.startingEventPositions[N], C++;
            });
            const S = Math.sqrt((x[0].x - x[1].x) * (x[0].x - x[1].x) + (x[0].y - x[1].y) * (x[0].y - x[1].y)), D = Math.sqrt((T[0].x - T[1].x) * (T[0].x - T[1].x) + (T[0].y - T[1].y) * (T[0].y - T[1].y));
            let _ = kh(Math.atan2(x[1].y - x[0].y, x[1].x - x[0].x)), M = kh(Math.atan2(T[1].y - T[0].y, T[1].x - T[0].x)), P = M - _;
            M = M + 180 >= 360 ? M - 180 : M + 180, _ = _ + 180 >= 360 ? _ - 180 : _ + 180, Math.abs(M - _) < Math.abs(P) && (P = M - _);
            const F = [];
            if (F[0] = (T[0].x - x[0].x + T[1].x - x[1].x) / 2, F[1] = (T[0].y - x[0].y + T[1].y - x[1].y) / 2, m === "TouchMove") if (e.currentGesture === "Start") {
                let N = .01 * Math.sqrt(e.container.clientWidth * e.container.clientWidth + e.container.clientHeight * e.container.clientHeight);
                N < 15 && (N = 15);
                const B = Math.abs(D - S), G = D * 3.1415926 * Math.abs(P) / 360, Z = Math.sqrt(F[0] * F[0] + F[1] * F[1]);
                if (B > N && B > G && B > Z) {
                    e.currentGesture = "Pinch";
                    const H = {
                        scale: 1,
                        touches: y
                    };
                    t.startPinchEvent(H);
                } else if (G > N && G > Z) {
                    e.currentGesture = "Rotate";
                    const H = {
                        rotation: 0,
                        touches: y
                    };
                    t.startRotateEvent(H);
                } else if (Z > N) {
                    e.currentGesture = "Pan";
                    const H = {
                        translation: [
                            0,
                            0
                        ],
                        touches: y
                    };
                    t.startPanEvent(H);
                }
            } else {
                if (e.currentGesture === "Rotate") {
                    const N = {
                        rotation: P,
                        touches: y
                    };
                    t.rotateEvent(N);
                }
                if (e.currentGesture === "Pinch") {
                    const N = {
                        scale: D / S,
                        touches: y
                    };
                    t.pinchEvent(N);
                }
                if (e.currentGesture === "Pan") {
                    const N = {
                        translation: F,
                        touches: y
                    };
                    t.panEvent(N);
                }
            }
        }, t.handleVisibilityChange = ()=>{
            e._animationStartTime = Date.now(), e._animationFrameCount = 0;
        }, t.setCurrentRenderer = (m)=>{
            e._forcedRenderer = !!m, e.currentRenderer = m;
        }, t.setContainer = (m)=>{
            h();
            const y = n.setContainer(m ?? null);
            return y && g(), y;
        }, t.delete = ()=>{
            for(; r.size;)t.cancelAnimation(r.values().next().value);
            typeof document.hidden < "u" && document.removeEventListener("visibilitychange", t.handleVisibilityChange), e.container && t.setContainer(null), n.delete();
        }, typeof document.hidden < "u" && document.addEventListener("visibilitychange", t.handleVisibilityChange, !1);
    }
    const Mz = {
        renderWindow: null,
        interactorStyle: null,
        picker: null,
        pickingManager: null,
        initialized: !1,
        enabled: !1,
        enableRender: !0,
        currentRenderer: null,
        lightFollowCamera: !0,
        desiredUpdateRate: 30,
        stillUpdateRate: 2,
        container: null,
        recognizeGestures: !0,
        currentGesture: "Start",
        animationRequest: null,
        lastFrameTime: .1,
        recentAnimationFrameRate: 10,
        wheelTimeoutID: 0,
        moveTimeoutID: 0,
        lastGamepadValues: {},
        preventDefaultOnPointerDown: !1,
        preventDefaultOnPointerUp: !1,
        mouseScrollDebounceByPass: !1
    };
    function dD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Mz, n), K.obj(t, e), e._animationExtendedEnd = 0, K.event(t, e, "RenderEvent"), w4.forEach((r)=>K.event(t, e, r)), K.get(t, e, [
            "initialized",
            "interactorStyle",
            "lastFrameTime",
            "recentAnimationFrameRate",
            "_view"
        ]), K.setGet(t, e, [
            "container",
            "lightFollowCamera",
            "enabled",
            "enableRender",
            "recognizeGestures",
            "desiredUpdateRate",
            "stillUpdateRate",
            "picker",
            "preventDefaultOnPointerDown",
            "preventDefaultOnPointerUp",
            "mouseScrollDebounceByPass"
        ]), K.moveToProtected(t, e, [
            "view"
        ]), Iz(t, e);
    }
    const bz = K.newInstance(dD, "vtkRenderWindowInteractor");
    var Lz = {
        newInstance: bz,
        extend: dD,
        handledEvents: w4,
        ...fD
    };
    const { vtkDebugMacro: Pz } = K;
    function Vz(t, e) {
        e.classHierarchy.push("vtkActor");
        const n = {
            ...t
        };
        t.getActors = ()=>[
                t
            ], t.getIsOpaque = ()=>{
            if (e.forceOpaque) return !0;
            if (e.forceTranslucent) return !1;
            e.property || t.getProperty();
            let r = e.property.getOpacity() >= 1;
            return r = r && (!e.texture || !e.texture.isTranslucent()), r = r && (!e.mapper || e.mapper.getIsOpaque()), r;
        }, t.hasTranslucentPolygonalGeometry = ()=>e.mapper === null ? !1 : (e.property === null && t.setProperty(t.makeProperty()), !t.getIsOpaque()), t.makeProperty = eg.newInstance, t.getProperty = ()=>(e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = ()=>{
            if (e.mapper === null) return e.bounds;
            const r = e.mapper.getBounds();
            if (!r || r.length !== 6) return r;
            if (r[0] > r[1]) return e.mapperBounds = r.concat(), e.bounds = [
                1,
                -1,
                1,
                -1,
                1,
                -1
            ], e.boundsMTime.modified(), r;
            if (!e.mapperBounds || r[0] !== e.mapperBounds[0] || r[1] !== e.mapperBounds[1] || r[2] !== e.mapperBounds[2] || r[3] !== e.mapperBounds[3] || r[4] !== e.mapperBounds[4] || r[5] !== e.mapperBounds[5] || t.getMTime() > e.boundsMTime.getMTime()) {
                Pz("Recomputing bounds..."), e.mapperBounds = r.concat();
                const i = [];
                zn.getCorners(r, i), t.computeMatrix();
                const a = new Float64Array(16);
                cn(a, e.matrix), i.forEach((o)=>pn(o, o, a)), e.bounds[0] = e.bounds[2] = e.bounds[4] = Number.MAX_VALUE, e.bounds[1] = e.bounds[3] = e.bounds[5] = -Number.MAX_VALUE, e.bounds = e.bounds.map((o, s)=>s % 2 === 0 ? i.reduce((c, l)=>c > l[s / 2] ? l[s / 2] : c, o) : i.reduce((c, l)=>c < l[(s - 1) / 2] ? l[(s - 1) / 2] : c, o)), e.boundsMTime.modified();
            }
            return e.bounds;
        }, t.getMTime = ()=>{
            let r = n.getMTime();
            if (e.property !== null) {
                const i = e.property.getMTime();
                r = i > r ? i : r;
            }
            if (e.backfaceProperty !== null) {
                const i = e.backfaceProperty.getMTime();
                r = i > r ? i : r;
            }
            return r;
        }, t.getRedrawMTime = ()=>{
            let r = e.mtime;
            if (e.mapper !== null) {
                let i = e.mapper.getMTime();
                r = i > r ? i : r, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), i = e.mapper.getInput().getMTime(), r = i > r ? i : r);
            }
            return r;
        }, t.getSupportsSelection = ()=>e.mapper ? e.mapper.getSupportsSelection() : !1, t.processSelectorPixelBuffers = (r, i)=>{
            e.mapper && e.mapper.processSelectorPixelBuffers && e.mapper.processSelectorPixelBuffers(r, i);
        };
    }
    const Nz = {
        mapper: null,
        property: null,
        backfaceProperty: null,
        forceOpaque: !1,
        forceTranslucent: !1,
        bounds: [
            1,
            -1,
            1,
            -1,
            1,
            -1
        ]
    };
    function gD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Nz, n), a4.extend(t, e, n), e.boundsMTime = {}, K.obj(e.boundsMTime), K.set(t, e, [
            "property"
        ]), K.setGet(t, e, [
            "backfaceProperty",
            "forceOpaque",
            "forceTranslucent",
            "mapper"
        ]), Vz(t, e);
    }
    const Az = K.newInstance(gD, "vtkActor");
    kz = {
        newInstance: Az,
        extend: gD
    };
    function Uz(t, e) {
        const n = t.invokeResize;
        delete t.invokeResize, e.renderWindow = BG.newInstance(), e.rendererMap = {}, e.openGLRenderWindow = az.newInstance(), e.renderWindow.addView(e.openGLRenderWindow), e.interactor = Lz.newInstance(), e.interactor.setView(e.openGLRenderWindow), e.interactor.initialize(), t.addRenderer = ({ viewport: r, id: i, background: a })=>{
            const o = Sz.newInstance({
                viewport: r,
                background: a || e.background
            });
            e.renderWindow.addRenderer(o), e.rendererMap[i] = o;
        }, t.destroy = ()=>{
            e.renderWindow.getInteractor().delete();
        }, t.removeRenderer = (r)=>{
            const i = t.getRenderer(r);
            e.renderWindow.removeRenderer(i), i.delete(), delete e.rendererMap[r];
        }, t.getRenderer = (r)=>e.rendererMap[r], t.getRenderers = ()=>{
            const { rendererMap: r } = e;
            return Object.keys(r).map((a)=>({
                    id: a,
                    renderer: r[a]
                }));
        }, t.resize = ()=>{
            if (e.container) {
                const { width: r, height: i } = e.container;
                e.openGLRenderWindow.setSize(Math.floor(r), Math.floor(i)), n(), e.renderWindow.render();
            }
        }, t.setContainer = (r)=>{
            e.container = r, e.openGLRenderWindow.setContainer(e.container);
        }, t.delete = K.chain(t.setContainer, t.destroy, e.openGLRenderWindow.delete, t.delete), t.resize();
    }
    const Fz = {
        background: [
            0,
            0,
            0
        ],
        container: null
    };
    function hD(t, e, n = {}) {
        Object.assign(e, Fz, n), K.obj(t, e), K.get(t, e, [
            "renderWindow",
            "openGLRenderWindow",
            "interactor",
            "container"
        ]), K.event(t, e, "resize"), Uz(t, e);
    }
    const Bz = K.newInstance(hD), pD = {
        newInstance: Bz,
        extend: hD
    }, { BlendMode: Sl, FilterMode: ld } = W7;
    function Gz(t, e, n, r, i) {
        let a = null;
        return i ? (a = i, a.removeAllPoints()) : a = B0.newInstance(), a.addPointLong(-1024, 0, 1, 1), a.addPoint(t, e), a.addPoint(n, r), a;
    }
    const Wz = {
        createRadonTransferFunction: Gz
    };
    function $z(t, e) {
        e.classHierarchy.push("vtkVolumeMapper");
        const n = {
            ...t
        };
        t.getBounds = ()=>{
            const r = t.getInputData();
            return r ? (e.static || t.update(), e.bounds = r.getBounds()) : e.bounds = Gl(), e.bounds;
        }, t.update = ()=>{
            t.getInputData();
        }, t.setBlendModeToComposite = ()=>{
            t.setBlendMode(Sl.COMPOSITE_BLEND);
        }, t.setBlendModeToMaximumIntensity = ()=>{
            t.setBlendMode(Sl.MAXIMUM_INTENSITY_BLEND);
        }, t.setBlendModeToMinimumIntensity = ()=>{
            t.setBlendMode(Sl.MINIMUM_INTENSITY_BLEND);
        }, t.setBlendModeToAverageIntensity = ()=>{
            t.setBlendMode(Sl.AVERAGE_INTENSITY_BLEND);
        }, t.setBlendModeToAdditiveIntensity = ()=>{
            t.setBlendMode(Sl.ADDITIVE_INTENSITY_BLEND);
        }, t.setBlendModeToRadonTransform = ()=>{
            t.setBlendMode(Sl.RADON_TRANSFORM_BLEND);
        }, t.getBlendModeAsString = ()=>K.enumToString(Sl, e.blendMode), t.setAverageIPScalarRange = (r, i)=>{
            console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"), t.setIpScalarRange(r, i);
        }, t.getFilterModeAsString = ()=>K.enumToString(ld, e.filterMode), t.setFilterModeToOff = ()=>{
            t.setFilterMode(ld.OFF);
        }, t.setFilterModeToNormalized = ()=>{
            t.setFilterMode(ld.NORMALIZED);
        }, t.setFilterModeToRaw = ()=>{
            t.setFilterMode(ld.RAW);
        }, t.setGlobalIlluminationReach = (r)=>n.setGlobalIlluminationReach(ys(r, 0, 1)), t.setVolumetricScatteringBlending = (r)=>n.setVolumetricScatteringBlending(ys(r, 0, 1)), t.setVolumeShadowSamplingDistFactor = (r)=>n.setVolumeShadowSamplingDistFactor(r >= 1 ? r : 1), t.setAnisotropy = (r)=>n.setAnisotropy(ys(r, -.99, .99)), t.setLAOKernelSize = (r)=>n.setLAOKernelSize(D3(ys(r, 1, 32))), t.setLAOKernelRadius = (r)=>n.setLAOKernelRadius(r >= 1 ? r : 1);
    }
    const zz = (t)=>({
            bounds: [
                1,
                -1,
                1,
                -1,
                1,
                -1
            ],
            sampleDistance: 1,
            imageSampleDistance: 1,
            maximumSamplesPerRay: 1e3,
            autoAdjustSampleDistances: !0,
            initialInteractionScale: 1,
            interactionSampleDistanceFactor: 1,
            blendMode: Sl.COMPOSITE_BLEND,
            ipScalarRange: [
                -1e6,
                1e6
            ],
            filterMode: ld.OFF,
            preferSizeOverAccuracy: !1,
            computeNormalFromOpacity: !1,
            volumetricScatteringBlending: 0,
            globalIlluminationReach: 0,
            volumeShadowSamplingDistFactor: 5,
            anisotropy: 0,
            localAmbientOcclusion: !1,
            LAOKernelSize: 15,
            LAOKernelRadius: 7,
            updatedExtents: [],
            ...t
        });
    function mD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, zz(n)), m4.extend(t, e, n), K.setGet(t, e, [
            "sampleDistance",
            "imageSampleDistance",
            "maximumSamplesPerRay",
            "autoAdjustSampleDistances",
            "initialInteractionScale",
            "interactionSampleDistanceFactor",
            "blendMode",
            "filterMode",
            "preferSizeOverAccuracy",
            "computeNormalFromOpacity",
            "volumetricScatteringBlending",
            "globalIlluminationReach",
            "volumeShadowSamplingDistFactor",
            "anisotropy",
            "localAmbientOcclusion",
            "LAOKernelSize",
            "LAOKernelRadius",
            "updatedExtents"
        ]), K.setGetArray(t, e, [
            "ipScalarRange"
        ], 2), K.event(t, e, "lightingActivated"), $z(t, e);
    }
    const jz = K.newInstance(mD, "vtkVolumeMapper");
    var vD = {
        newInstance: jz,
        extend: mD,
        ...Wz
    };
    function Hz(t, e) {
        e.classHierarchy.push("vtkSharedVolumeMapper");
        const n = t.delete;
        t.delete = ()=>{
            e.scalarTexture = null, n();
        };
    }
    const Kz = {
        scalarTexture: null
    };
    function yD(t, e, n = {}) {
        Object.assign(e, Kz, n), vD.extend(t, e, n), K.setGet(t, e, [
            "scalarTexture"
        ]), Hz(t, e);
    }
    const qz = K.newInstance(yD, "vtkSharedVolumeMapper"), Xz = {
        newInstance: qz,
        extend: yD
    };
    function CC(t, e) {
        const n = v4(e), r = new n(t.length);
        return r.set(t), r;
    }
    function Yz(t, e) {
        e.classHierarchy.push("vtkStreamingOpenGLTexture"), e.updatedFrames = [], e.volumeId = null;
        const n = t.create3DFilterableFromRaw;
        t.create3DFilterableFromRaw = (s, c, l, f, u, g, h)=>{
            e.inputDataType = u, e.inputNumComps = f, n(s, c, l, f, u, g, h);
        };
        const r = t.updateVolumeInfoForGL;
        t.updateVolumeInfoForGL = (s, c)=>{
            const l = r(s, c);
            return e.volumeInfo.dataComputedScale = [
                1
            ], e.volumeInfo.dataComputedOffset = [
                0
            ], l;
        }, t.update3DFromRaw = ()=>{
            const { volumeId: s } = e;
            if (!s) return;
            const c = ot.getVolume(s);
            if (e._openGLRenderWindow.activateTexture(t), t.createTexture(), t.bind(), c.isDynamicVolume()) {
                o();
                return;
            }
            return t.hasUpdatedFrames() && a();
        };
        const i = t.modified;
        t.setUpdatedFrame = (s)=>{
            e.updatedFrames[s] = !0, i();
        }, t.modified = ()=>{
            i();
            const s = ot.getVolume(e.volumeId);
            if (!s) return;
            const c = s.imageIds;
            for(let l = 0; l < c.length; l++)e.updatedFrames[l] = !0;
        };
        function a() {
            const s = ot.getVolume(e.volumeId), c = s.imageIds;
            for(let l = 0; l < e.updatedFrames.length; l++)if (e.updatedFrames[l]) {
                const f = ot.getImage(c[l]);
                if (!f) continue;
                let u = f.voxelManager.getScalarData();
                const g = e.context;
                s.dataType !== u.constructor.name && (u = CC(u, s.dataType));
                const [h] = t.updateArrayDataTypeForGL(s.dataType, [
                    u
                ]);
                t.bind();
                const v = l;
                g.texSubImage3D(e.target, 0, 0, 0, v, e.width, e.height, 1, e.format, e.openGLDataType, h), t.deactivate(), e.updatedFrames[l] = null;
            }
            return e.generateMipmap && e.context.generateMipmap(e.target), t.deactivate(), !0;
        }
        function o() {
            const s = ot.getVolume(e.volumeId), c = s.getCurrentDimensionGroupImageIds();
            if (!c.length) return !1;
            let l;
            for(let f = 0; f < c.length; f++){
                const u = c[f], g = ot.getImage(u);
                let h;
                g ? (h = g.voxelManager.getScalarData(), l = h.constructor) : (l = v4(s.dataType, !0), h = new l(e.width * e.height));
                const v = e.context;
                s.dataType !== h.constructor.name && (h = CC(h, s.dataType));
                const [m] = t.updateArrayDataTypeForGL(s.dataType, [
                    h
                ]);
                t.bind();
                let y = f;
                v.texSubImage3D(e.target, 0, 0, 0, y, e.width, e.height, 1, e.format, e.openGLDataType, m), t.deactivate();
            }
            return e.generateMipmap && e.context.generateMipmap(e.target), t.deactivate(), !0;
        }
        t.hasUpdatedFrames = ()=>!e.updatedFrames.length || e.updatedFrames.some((s)=>s), t.getUpdatedFrames = ()=>e.updatedFrames, t.setVolumeId = (s)=>{
            e.volumeId = s;
        }, t.getVolumeId = ()=>e.volumeId, t.setTextureParameters = ({ width: s, height: c, depth: l, numberOfComponents: f, dataType: u })=>{
            e.width ??= s, e.height ??= c, e.depth ??= l, e.inputNumComps ??= f, e.inputDataType ??= u;
        }, t.getTextureParameters = ()=>({
                width: e.width,
                height: e.height,
                depth: e.depth,
                numberOfComponents: e.inputNumComps,
                dataType: e.inputDataType
            });
    }
    const Zz = {
        updatedFrames: []
    };
    function CD(t, e, n = {}) {
        Object.assign(e, Zz, n), Qn.extend(t, e, n), Yz(t, e);
    }
    const Jz = K.newInstance(CD, "vtkStreamingOpenGLTexture"), Qz = {
        newInstance: Jz,
        extend: CD
    }, ej = {
        isPerformingCoordinateTransformation: !1
    };
    function wD(t, e, n = {}) {
        Object.assign(e, ej, n), C4.extend(t, e, n), K.setGet(t, e, [
            "isPerformingCoordinateTransformation"
        ]), nj(t, e);
    }
    const tj = K.newInstance(wD, "vtkSlabCamera");
    function nj(t, e) {
        e.classHierarchy.push("vtkSlabCamera");
        const n = Ot(new Float64Array(16)), r = new Float64Array(3);
        t.getProjectionMatrix = (i, a, o)=>{
            const s = xs();
            if (e.projectionMatrix) {
                const g = 1 / e.physicalScale;
                return Sn(r, g, g, g), Ur(s, e.projectionMatrix), nc(s, s, r), cn(s, s), s;
            }
            Ot(n);
            let c = e.clippingRange[0], l = e.clippingRange[1];
            e.isPerformingCoordinateTransformation && (c = e.distance, l = e.distance + .1);
            const f = l - c, u = [
                c + (a + 1) * f / 2,
                c + (o + 1) * f / 2
            ];
            if (e.parallelProjection) {
                const g = e.parallelScale * i, h = e.parallelScale, v = (e.windowCenter[0] - 1) * g, m = (e.windowCenter[0] + 1) * g, y = (e.windowCenter[1] - 1) * h, C = (e.windowCenter[1] + 1) * h;
                G3(n, v, m, y, C, u[0], u[1]), cn(n, n);
            } else {
                if (e.useOffAxisProjection) throw new Error("Off-Axis projection is not supported at this time");
                {
                    const g = Math.tan(Xo.radiansFromDegrees(e.viewAngle) / 2);
                    let h, v;
                    e.useHorizontalViewAngle === !0 ? (h = c * g, v = c * g / i) : (h = c * g * i, v = c * g);
                    const m = (e.windowCenter[0] - 1) * h, y = (e.windowCenter[0] + 1) * h, C = (e.windowCenter[1] - 1) * v, T = (e.windowCenter[1] + 1) * v, x = u[0], S = u[1];
                    n[0] = 2 * x / (y - m), n[5] = 2 * x / (T - C), n[2] = (m + y) / (y - m), n[6] = (C + T) / (T - C), n[10] = -(x + S) / (S - x), n[14] = -1, n[11] = -2 * x * S / (S - x), n[15] = 0;
                }
            }
            return Ur(s, n), s;
        };
    }
    const rj = {
        newInstance: tj,
        extend: wD
    };
    tg = class {
        constructor(e){
            this._imageIdsIndexMap = new Map, this._imageURIsIndexMap = new Map, this.cornerstoneImageMetaData = null, this.isPreScaled = !1, this.numTimePoints = null, this.numFrames = null;
            const { imageIds: n, scaling: r, dimensions: i, spacing: a, origin: o, direction: s, dataType: c, volumeId: l, referencedVolumeId: f, metadata: u, referencedImageIds: g, additionalDetails: h, voxelManager: v, numberOfComponents: m } = e;
            if (!c) throw new Error('Data type is required, please provide a data type as string such as "Uint8Array", "Float32Array", etc.');
            let { imageData: y } = e;
            this.suppressWarnings = !0, this.imageIds = n, this.volumeId = l, this.metadata = u, this.dimensions = i, this.spacing = a, this.origin = o, this.direction = s, this.dataType = c, this.vtkOpenGLTexture = Qz.newInstance(), this.vtkOpenGLTexture.setVolumeId(l), this.voxelManager = v ?? $n.createImageVolumeVoxelManager({
                dimensions: i,
                imageIds: n,
                numberOfComponents: m
            }), this.numVoxels = this.dimensions[0] * this.dimensions[1] * this.dimensions[2], y || (y = Up.newInstance(), y.setDimensions(i), y.setSpacing(a), y.setDirection(s), y.setOrigin(o)), y.set({
                dataType: c,
                voxelManager: this.voxelManager,
                id: l,
                numberOfComponents: m || 1
            }, this.suppressWarnings), y.set({
                hasScalarVolume: !1
            }, this.suppressWarnings), this.imageData = y, this.numFrames = this._getNumFrames(), this._reprocessImageIds(), r && (this.scaling = r), f && (this.referencedVolumeId = f), g && (this.referencedImageIds = g), h && (this.additionalDetails = h);
        }
        get sizeInBytes() {
            return this.voxelManager.sizeInBytes;
        }
        get imageIds() {
            return this._imageIds;
        }
        set imageIds(e) {
            this._imageIds = e, this._reprocessImageIds();
        }
        _reprocessImageIds() {
            this._imageIdsIndexMap.clear(), this._imageURIsIndexMap.clear(), this._imageIds.forEach((e, n)=>{
                const r = ur(e);
                this._imageIdsIndexMap.set(e, n), this._imageURIsIndexMap.set(r, n);
            });
        }
        isDynamicVolume() {
            return this.numTimePoints > 1;
        }
        getImageIdIndex(e) {
            return this._imageIdsIndexMap.get(e);
        }
        getImageIdByIndex(e) {
            return this._imageIds[e];
        }
        getImageURIIndex(e) {
            return this._imageURIsIndexMap.get(e);
        }
        load(e) {}
        destroy() {
            this.imageData.delete(), this.imageData = null, this.voxelManager.clear(), this.vtkOpenGLTexture.releaseGraphicsResources(), this.vtkOpenGLTexture.delete();
        }
        invalidate() {
            for(let e = 0; e < this.imageIds.length; e++)this.vtkOpenGLTexture.setUpdatedFrame(e);
            this.imageData.modified();
        }
        modified() {
            this.imageData.modified(), this.vtkOpenGLTexture.modified(), this.numFrames = this._getNumFrames();
        }
        removeFromCache() {
            ot.removeVolumeLoadObject(this.volumeId);
        }
        getScalarDataLength() {
            return this.voxelManager.getScalarDataLength();
        }
        _getNumFrames() {
            return this.isDynamicVolume() ? this.numTimePoints : this.imageIds.length;
        }
        imageIdIndexToFrameIndex(e) {
            return e % this.numFrames;
        }
        getCornerstoneImages() {
            const { imageIds: e } = this;
            return e.map((n)=>ot.getImage(n));
        }
    };
    const Zs = [];
    function cf(t, e = 0) {
        let n;
        for(n = 0; n < Zs.length && !(Zs[n].priority <= e); n++);
        Zs.splice(n, 0, {
            priority: e,
            provider: t
        });
    }
    function ij(t) {
        for(let e = 0; e < Zs.length; e++)if (Zs[e].provider === t) {
            Zs.splice(e, 1);
            break;
        }
    }
    function aj() {
        for(; Zs.length > 0;)Zs.pop();
    }
    function ct(t, ...e) {
        for(let n = 0; n < Zs.length; n++){
            const r = Zs[n].provider(t, ...e);
            if (r !== void 0) return r;
        }
    }
    oj = Object.freeze(Object.defineProperty({
        __proto__: null,
        addProvider: cf,
        get: ct,
        removeAllProviders: aj,
        removeProvider: ij
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    let jf = {};
    const Vl = {
        add: (t, e)=>{
            Vl.addRaw(t, {
                ...e,
                metadata: structuredClone(e.metadata)
            });
        },
        addRaw: (t, e)=>{
            const n = e.type;
            jf[t] || (jf[t] = {}), jf[t][n] = e.metadata;
        },
        get: (t, e)=>jf[e]?.[t],
        clear: ()=>{
            jf = {};
        }
    };
    cf(Vl.get);
    xo = new d3("imageLoadPool");
    xo.grabDelay = 0;
    xo.setMaxSimultaneousRequests(Gt.Interaction, 1e3);
    xo.setMaxSimultaneousRequests(Gt.Thumbnail, 1e3);
    xo.setMaxSimultaneousRequests(Gt.Prefetch, 1e3);
    const tp = {};
    let np;
    function TD(t, e) {
        const n = ot.getImageLoadObject(t);
        if (n) return wC(n.promise, t), n;
        const r = t.split(":")[0], i = tp[r] || np;
        if (!i) throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${r}'`);
        const a = i(t, e);
        return wC(a.promise, t), a;
    }
    function wC(t, e) {
        Promise.resolve(t).then((n)=>{
            sj(n), We(Ke, Ge.IMAGE_LOADED, {
                image: n
            });
        }).catch((n)=>{
            const r = {
                imageId: e,
                error: n
            };
            We(Ke, Ge.IMAGE_LOAD_FAILED, r);
        });
    }
    function sj(t) {
        if (!t.voxelManager) {
            const { width: e, height: n, numberOfComponents: r } = t, i = $n.createImageVoxelManager({
                scalarData: t.getPixelData(),
                width: e,
                height: n,
                numberOfComponents: r
            });
            t.voxelManager = i, t.getPixelData = ()=>i.getScalarData(), delete t.imageFrame.pixelData;
        }
    }
    function xD(t, e = {
        priority: 0,
        requestType: "prefetch"
    }) {
        if (t === void 0) throw new Error("loadImage: parameter imageId must not be undefined");
        return TD(t, e).promise;
    }
    function $l(t, e = {
        priority: 0,
        requestType: "prefetch"
    }) {
        if (t === void 0) throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
        const n = TD(t, e);
        return ot.getImageLoadObject(t) || ot.putImageLoadObject(t, n), n.promise;
    }
    function cj(t, e = {
        priority: 0,
        requestType: "prefetch"
    }) {
        if (!t || t.length === 0) throw new Error("loadAndCacheImages: parameter imageIds must be list of image Ids");
        return t.map((r)=>$l(r, e));
    }
    function T4(t, e = {}) {
        if (t === void 0) throw new Error("createAndCacheDerivedImage: parameter imageId must not be undefined");
        e.imageId === void 0 && (e.imageId = `derived:${Vn()}`);
        const { imageId: n, skipCreateBuffer: r, onCacheAdd: i, voxelRepresentation: a } = e, o = ct("imagePlaneModule", t), s = o.rows * o.columns, { TypedArrayConstructor: c } = y4(e.targetBuffer?.type, s), l = new c(r ? 1 : s), f = n, u = ct("imagePlaneModule", t);
        Vl.add(f, {
            type: "imagePlaneModule",
            metadata: u
        });
        const g = ct("generalSeriesModule", t);
        Vl.add(f, {
            type: "generalSeriesModule",
            metadata: g
        }), Vl.add(f, {
            type: "generalImageModule",
            metadata: {
                instanceNumber: e.instanceNumber
            }
        });
        const h = ct("imagePixelModule", t);
        Vl.add(f, {
            type: "imagePixelModule",
            metadata: {
                ...h,
                bitsAllocated: 8,
                bitsStored: 8,
                highBit: 7,
                samplesPerPixel: 1,
                pixelRepresentation: 0
            }
        });
        const v = S4(n, {
            scalarData: l,
            onCacheAdd: i,
            skipCreateBuffer: r,
            targetBuffer: {
                type: l.constructor.name
            },
            voxelRepresentation: a,
            dimensions: [
                o.columns,
                o.rows
            ],
            spacing: [
                o.columnPixelSpacing,
                o.rowPixelSpacing
            ],
            origin: o.imagePositionPatient,
            direction: o.imageOrientationPatient,
            frameOfReferenceUID: o.frameOfReferenceUID,
            referencedImageId: t
        });
        return v.referencedImageId = t, ot.getImageLoadObject(n) || ot.putImageSync(n, v), v;
    }
    function x4(t, e = {}) {
        if (t.length === 0) throw new Error("createAndCacheDerivedImages: parameter imageIds must be list of image Ids");
        return t.map((r, i)=>{
            const a = {
                imageId: e?.getDerivedImageId?.(r) || `derived:${Vn()}`,
                ...e
            };
            return T4(r, {
                ...a,
                instanceNumber: i + 1
            });
        });
    }
    function S4(t, e) {
        const { scalarData: n, origin: r, direction: i, targetBuffer: a, skipCreateBuffer: o, onCacheAdd: s, frameOfReferenceUID: c, voxelRepresentation: l, referencedImageId: f } = e, u = e.dimensions, g = e.spacing;
        if (!u || !g) throw new Error("createAndCacheLocalImage: dimensions and spacing are required");
        const h = u[0], v = u[1], m = g[0], y = g[1], C = {
            frameOfReferenceUID: c,
            rows: v,
            columns: h,
            imageOrientationPatient: i ?? [
                1,
                0,
                0,
                0,
                1,
                0
            ],
            rowCosines: i ? i.slice(0, 3) : [
                1,
                0,
                0
            ],
            columnCosines: i ? i.slice(3, 6) : [
                0,
                1,
                0
            ],
            imagePositionPatient: r ?? [
                0,
                0,
                0
            ],
            pixelSpacing: [
                y,
                m
            ],
            rowPixelSpacing: y,
            columnPixelSpacing: m
        }, T = h * v, x = n.length / T;
        let S;
        if (n) {
            if (!(n instanceof Uint8Array || n instanceof Float32Array || n instanceof Uint16Array || n instanceof Int16Array)) throw new Error("createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array");
            S = n;
        } else if (!o) {
            const { TypedArrayConstructor: ne } = y4(a?.type, T);
            S = new ne(T);
        }
        let D, _, M;
        if (S instanceof Uint8Array) D = 8, _ = 8, M = 7;
        else if (S instanceof Uint16Array) D = 16, _ = 16, M = 15;
        else if (S instanceof Int16Array) D = 16, _ = 16, M = 15;
        else if (S instanceof Float32Array) D = 32, _ = 32, M = 31;
        else throw new Error("Unsupported scalarData type");
        const P = {
            samplesPerPixel: 1,
            photometricInterpretation: S.length > u[0] * u[1] ? "RGB" : "MONOCHROME2",
            rows: v,
            columns: h,
            bitsAllocated: D,
            bitsStored: _,
            highBit: M
        }, F = {
            imagePlaneModule: C,
            imagePixelModule: P
        };
        [
            "imagePlaneModule",
            "imagePixelModule"
        ].forEach((ne)=>{
            Vl.add(t, {
                type: ne,
                metadata: F[ne] || {}
            });
        });
        const N = t, B = l === Mh.RLE && $n.createRLEImageVoxelManager({
            dimensions: u,
            id: N
        }) || $n.createImageVoxelManager({
            height: v,
            width: h,
            numberOfComponents: x,
            scalarData: S,
            id: N
        });
        let G = S[0], Z = S[0];
        for(let ne = 1; ne < S.length; ne++)S[ne] < G && (G = S[ne]), S[ne] > Z && (Z = S[ne]);
        const H = {
            imageId: t,
            intercept: 0,
            windowCenter: 0,
            windowWidth: 0,
            color: P.photometricInterpretation === "RGB",
            numberOfComponents: P.samplesPerPixel,
            dataType: a?.type,
            slope: 1,
            minPixelValue: G,
            maxPixelValue: Z,
            rows: P.rows,
            columns: P.columns,
            getCanvas: void 0,
            height: P.rows,
            width: P.columns,
            rgba: void 0,
            columnPixelSpacing: C.columnPixelSpacing,
            rowPixelSpacing: C.rowPixelSpacing,
            FrameOfReferenceUID: C.frameOfReferenceUID,
            invert: !1,
            getPixelData: ()=>B.getScalarData(),
            voxelManager: B,
            sizeInBytes: n.byteLength,
            referencedImageId: f
        };
        return s?.(H), ot.putImageSync(H.imageId, H), H;
    }
    function SD(t) {
        const e = ({ additionalDetails: r })=>r.imageId ? r.imageId !== t : !0;
        xo.filterRequests(e);
        const n = ot.getImageLoadObject(t);
        n && n.cancelFn();
    }
    function lj(t) {
        t.forEach((e)=>{
            SD(e);
        });
    }
    function uj() {
        const t = xo.getRequestPool();
        Object.keys(t).forEach((e)=>{
            const n = t[e];
            Object.keys(n).forEach((r)=>{
                const i = n[r].pop();
                if (!i) return;
                const a = i.additionalDetails, { imageId: o, volumeId: s } = a;
                let c;
                o ? c = ot.getImageLoadObject(o) : s && (c = ot.getVolumeLoadObject(s)), c && c.cancel();
            }), xo.clearRequestStack(e);
        });
    }
    L0 = function(t, e) {
        tp[t] = e;
    };
    function fj(t) {
        const e = np;
        return np = t, e;
    }
    function dj() {
        Object.keys(tp).forEach((t)=>delete tp[t]), np = void 0;
    }
    function gj(t, e = {}) {
        return x4(t, {
            ...e,
            targetBuffer: {
                type: "Uint8Array"
            }
        });
    }
    function hj(t, e = {}) {
        return T4(t, {
            ...e,
            targetBuffer: {
                type: "Uint8Array"
            }
        });
    }
    $ae = Object.freeze(Object.defineProperty({
        __proto__: null,
        cancelLoadAll: uj,
        cancelLoadImage: SD,
        cancelLoadImages: lj,
        createAndCacheDerivedImage: T4,
        createAndCacheDerivedImages: x4,
        createAndCacheDerivedLabelmapImage: hj,
        createAndCacheDerivedLabelmapImages: gj,
        createAndCacheLocalImage: S4,
        loadAndCacheImage: $l,
        loadAndCacheImages: cj,
        loadImage: xD,
        registerImageLoader: L0,
        registerUnknownImageLoader: fj,
        unregisterAllImageLoaders: dj
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function ED(t) {
        const e = t[0], { pixelRepresentation: n, bitsAllocated: r, bitsStored: i, highBit: a, photometricInterpretation: o, samplesPerPixel: s } = ct("imagePixelModule", e), c = [], l = ct("voiLutModule", e);
        let f;
        if (l) {
            const { windowWidth: T, windowCenter: x } = l;
            if (f = l?.voiLUTFunction, Array.isArray(T)) for(let S = 0; S < T.length; S++)c.push({
                windowWidth: T[S],
                windowCenter: x[S]
            });
            else c.push({
                windowWidth: T,
                windowCenter: x
            });
        } else c.push({
            windowWidth: void 0,
            windowCenter: void 0
        });
        const { modality: u, seriesInstanceUID: g } = ct("generalSeriesModule", e), { imageOrientationPatient: h, pixelSpacing: v, frameOfReferenceUID: m, columns: y, rows: C } = ct("imagePlaneModule", e);
        return {
            BitsAllocated: r,
            BitsStored: i,
            SamplesPerPixel: s,
            HighBit: a,
            PhotometricInterpretation: o,
            PixelRepresentation: n,
            Modality: u,
            ImageOrientationPatient: h,
            PixelSpacing: v,
            FrameOfReferenceUID: m,
            Columns: y,
            Rows: C,
            voiLut: c,
            VOILUTFunction: f,
            SeriesInstanceUID: g
        };
    }
    function DD(t) {
        const { imagePositionPatient: e, imageOrientationPatient: n } = ct("imagePlaneModule", t[0]), r = en(n[0], n[1], n[2]), i = en(n[3], n[4], n[5]), a = Xe();
        bn(a, r, i);
        const o = en(e[0], e[1], e[2]), s = t[0].split(":")[0] === "wadouri";
        let c;
        function l(h) {
            const { imagePositionPatient: v } = ct("imagePlaneModule", h), m = Xe(), y = en(v[0], v[1], v[2]);
            return In(m, o, y), xt(m, a);
        }
        if (s) {
            const h = [
                t[0],
                t[Math.floor(t.length / 2)]
            ];
            l(h[0]), l(h[1]);
            const v = ct("imagePlaneModule", h[1]);
            if (!v) throw new Error("Incomplete metadata required for volume construction.");
            const m = Xe(), y = en(v.imagePositionPatient[0], v.imagePositionPatient[1], v.imagePositionPatient[2]);
            In(m, o, y);
            const C = xt(m, a);
            c = Math.abs(C) / Math.floor(t.length / 2);
        } else {
            const h = t.map((m)=>({
                    distance: l(m),
                    imageId: m
                }));
            h.sort((m, y)=>y.distance - m.distance);
            const v = h.length;
            c = Math.abs(h[v - 1].distance - h[0].distance) / (v - 1);
        }
        const { sliceThickness: f, spacingBetweenSlices: u } = ct("imagePlaneModule", t[0]), { strictZSpacingForVolumeViewport: g } = tf().rendering;
        return (c === 0 || isNaN(c)) && !g && (u ? (console.debug("Could not calculate spacing. Using spacingBetweenSlices"), c = u) : f ? (console.debug("Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness"), c = f) : (console.debug("Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render"), c = 1)), c;
    }
    _D = function(t, e) {
        const { imagePositionPatient: n, imageOrientationPatient: r } = ct("imagePlaneModule", t[0]);
        if (!e) {
            const f = en(r[0], r[1], r[2]), u = en(r[3], r[4], r[5]);
            e = Xe(), bn(e, f, u);
        }
        const i = t[0].split(":")[0] === "wadouri", a = DD(t);
        let o;
        function s(f) {
            const { imagePositionPatient: u } = ct("imagePlaneModule", f), g = Xe();
            return In(g, n, u), xt(g, e);
        }
        if (i) {
            const f = [
                t[0],
                t[Math.floor(t.length / 2)]
            ];
            o = t;
            const u = s(f[0]), g = s(f[1]);
            u - g < 0 && o.reverse();
        } else {
            const f = t.map((u)=>({
                    distance: s(u),
                    imageId: u
                }));
            f.sort((u, g)=>g.distance - u.distance), o = f.map((u)=>u.imageId);
        }
        const { imagePositionPatient: c } = ct("imagePlaneModule", o[0]);
        return {
            zSpacing: a,
            origin: c,
            sortedImageIds: o
        };
    };
    function RD(t) {
        const e = ct("modalityLutModule", t) || {}, n = ct("generalSeriesModule", t) || {}, { modality: r } = n, i = {
            rescaleSlope: e.rescaleSlope || 1,
            rescaleIntercept: e.rescaleIntercept ?? 0,
            modality: r
        }, a = ct("scalingModule", t) || {};
        return {
            ...i,
            ...r === "PT" && {
                suvbw: a.suvbw,
                suvbsa: a.suvbsa,
                suvlbm: a.suvlbm
            },
            ...r === "RTDOSE" && {
                doseGridScaling: a.DoseGridScaling,
                doseSummation: a.DoseSummation,
                doseType: a.DoseType,
                doseUnit: a.DoseUnit
            }
        };
    }
    const E4 = (t)=>Object.values(t).some((n)=>typeof n == "number" && !Number.isInteger(n)), TC = {
        Uint8Array: "Uint8Array",
        Int16Array: "Int16Array",
        Uint16Array: "Uint16Array",
        Float32Array: "Float32Array"
    };
    D4 = function(t, e) {
        const n = ED(t), { ImageOrientationPatient: r, PixelSpacing: i, Columns: a, Rows: o } = n, s = en(r[0], r[1], r[2]), c = en(r[3], r[4], r[5]), l = Xe();
        bn(l, s, c);
        const { zSpacing: f, origin: u, sortedImageIds: g } = _D(t, l), h = t.length, v = [
            i[1],
            i[0],
            f
        ], m = [
            a,
            o,
            h
        ].map((C)=>Math.floor(C)), y = [
            ...s,
            ...c,
            ...l
        ];
        return {
            dimensions: m,
            spacing: v,
            origin: u,
            dataType: pj(g, n),
            direction: y,
            metadata: n,
            imageIds: g,
            volumeId: e,
            voxelManager: null,
            numberOfComponents: n.PhotometricInterpretation === "RGB" ? 3 : 1
        };
    };
    function pj(t, e) {
        const { BitsAllocated: n, PixelRepresentation: r } = e, i = r === 1, a = mj(t);
        if (a) return a;
        const [o, s, c] = [
            0,
            Math.floor(t.length / 2),
            t.length - 1
        ], l = [
            o,
            s,
            c
        ].map((h)=>RD(t[h])), f = l.some((h)=>h.rescaleIntercept < 0 || h.rescaleSlope < 0), u = l.some((h)=>E4(h)), g = g3();
        switch(n){
            case 8:
                return "Uint8Array";
            case 16:
                return g && u ? "Float32Array" : i || f ? "Int16Array" : !i && !f ? "Uint16Array" : "Float32Array";
            case 24:
                return "Uint8Array";
            case 32:
                return "Float32Array";
            default:
                throw new Error(`Bits allocated of ${n} is not defined to generate scalarData for the volume.`);
        }
    }
    function mj(t) {
        const n = [
            0,
            Math.floor(t.length / 2),
            t.length - 1
        ].map((i)=>ot.getImage(t[i]));
        if (!n.every(Boolean)) return null;
        const r = n[0].getPixelData().constructor.name;
        return n.every((i)=>i.getPixelData().constructor.name === r) && r in TC ? TC[r] : null;
    }
    let rp = class OD {
        constructor(e){
            this.name = e || "unknown";
        }
        static as(e) {
            if (e.iterator) return e.iterator;
            const n = new OD("as iterator");
            return e.then((r)=>{
                try {
                    n.add(r, !0);
                } catch (i) {
                    n.reject(i);
                }
            }, (r)=>{
                n.reject(r);
            }), n;
        }
        add(e, n = !1) {
            this.nextValue = e, this.done ||= n, this.waiting && (this.waiting.resolve(e), this.waiting = void 0);
        }
        resolve() {
            this.done = !0, this.waiting && (this.waiting.resolve(this.nextValue), this.waiting = void 0);
        }
        reject(e) {
            this.rejectReason = e, this.waiting?.reject(e);
        }
        getRecent() {
            if (this.rejectReason) throw this.rejectReason;
            return this.nextValue;
        }
        async *[Symbol.asyncIterator]() {
            for(; !this.done;){
                if (this.rejectReason) throw this.rejectReason;
                if (this.nextValue !== void 0 && (yield this.nextValue, this.done)) break;
                this.waiting || (this.waiting = {}, this.waiting.promise = new Promise((e, n)=>{
                    this.waiting.resolve = e, this.waiting.reject = n;
                })), await this.waiting.promise;
            }
            yield this.nextValue;
        }
        async forEach(e, n) {
            let r = 0;
            try {
                for await (const i of this){
                    const { done: a } = this;
                    try {
                        await e(i, a, r), r++;
                    } catch (o) {
                        if (!a) {
                            console.warn("Caught exception in intermediate value", o);
                            continue;
                        }
                        if (n) n(o, a);
                        else throw o;
                    }
                }
            } catch (i) {
                if (n) n(i, !0);
                else throw i;
            }
        }
        generate(e, n) {
            return e(this, this.reject.bind(this)).then(()=>{
                this.done || this.resolve();
            }, (r)=>{
                this.reject(r), n ? n(r) : console.warn("Couldn't process because", r);
            });
        }
        async nextPromise() {
            for await (const e of this)if (e) return e;
            return this.nextValue;
        }
        async donePromise() {
            for await (const e of this);
            return this.nextValue;
        }
        getNextPromise() {
            const e = this.nextPromise();
            return e.iterator = this, e;
        }
        getDonePromise() {
            const e = this.donePromise();
            return e.iterator = this, e;
        }
    };
    const yu = new Map, xC = "imageRetrieveConfiguration", Zu = {
        IMAGE_RETRIEVE_CONFIGURATION: xC,
        clear: ()=>{
            yu.clear();
        },
        add: (t, e)=>{
            yu.set(t, e);
        },
        clone: ()=>new Map(yu),
        restore: (t)=>{
            yu.clear(), t.forEach((e, n)=>{
                yu.set(n, e);
            });
        },
        get: (t, ...e)=>{
            if (t === xC) return e.map((n)=>yu.get(n)).find((n)=>n !== void 0);
        }
    };
    cf(Zu.get.bind(Zu));
    function Gp(t) {
        const e = Es(), n = [];
        return e.forEach((r)=>{
            const a = r.getVolumeViewports().filter((o)=>o.hasVolumeId(t));
            n.push(...a);
        }), n;
    }
    const Gv = (t)=>{
        const e = vj(t);
        e?.length && e.forEach(({ renderingEngine: n, viewportIds: r })=>{
            n.hasBeenDestroyed || n.renderViewports(r);
        });
    };
    function vj(t) {
        const e = Es(), n = [];
        return e.forEach((r)=>{
            const i = Gp(t);
            i.length && n.push({
                renderingEngine: r,
                viewportIds: i.map((a)=>a.id)
            });
        }), n;
    }
    const SC = [
        {
            id: "initialImages",
            retrieveType: "single"
        }
    ], yj = [
        {
            id: "lossySequential",
            retrieveType: "singleFast"
        },
        {
            id: "finalSequential",
            retrieveType: "singleFinal"
        }
    ], _5 = [
        {
            offset: -1,
            imageQualityStatus: To.ADJACENT_REPLICATE
        },
        {
            offset: 1,
            imageQualityStatus: To.ADJACENT_REPLICATE
        },
        {
            offset: 2,
            imageQualityStatus: To.FAR_REPLICATE
        }
    ], Cj = [
        {
            id: "initialImages",
            positions: [
                .5,
                0,
                -1
            ],
            retrieveType: "default",
            requestType: Gt.Thumbnail,
            priority: 5,
            nearbyFrames: _5
        },
        {
            id: "quarterThumb",
            decimate: 4,
            offset: 3,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFast",
            priority: 6,
            nearbyFrames: _5
        },
        {
            id: "halfThumb",
            decimate: 4,
            offset: 1,
            priority: 7,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFast",
            nearbyFrames: _5
        },
        {
            id: "quarterFull",
            decimate: 4,
            offset: 2,
            priority: 8,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFinal"
        },
        {
            id: "halfFull",
            decimate: 4,
            offset: 0,
            priority: 9,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFinal"
        },
        {
            id: "threeQuarterFull",
            decimate: 4,
            offset: 1,
            priority: 10,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFinal"
        },
        {
            id: "finalFull",
            decimate: 4,
            offset: 3,
            priority: 11,
            requestType: Gt.Thumbnail,
            retrieveType: "multipleFinal"
        },
        {
            id: "errorRetrieve"
        }
    ];
    function ID(t, e, n = 0) {
        const r = [];
        for(let i = n; i < t.length; i += e)r.push(i);
        return r;
    }
    function wj(t, e, n) {
        if (e?.nearbyRequests?.length) for (const r of e.nearbyRequests)try {
            const { itemId: i, imageQualityStatus: a } = r, o = ot.getImageQuality(i);
            if (o !== void 0 && o >= a) continue;
            const s = {
                ...n,
                imageId: i,
                imageQualityStatus: a
            };
            ot.setPartialImage(i, s), t.successCallback(i, s);
        } catch (i) {
            console.warn("Couldn't fill nearby item ", r.itemId, i);
        }
    }
    MD = class {
        static{
            this.createProgressive = bD;
        }
        static{
            this.interleavedRetrieveStages = {
                stages: Cj
            };
        }
        static{
            this.singleRetrieveStages = {
                stages: SC
            };
        }
        static{
            this.sequentialRetrieveStages = {
                stages: yj
            };
        }
        constructor(e){
            this.stages = e.stages || SC, this.retrieveOptions = e.retrieveOptions || {};
        }
        loadImages(e, n) {
            return new Tj(this, e, n).loadImages();
        }
    };
    class Tj {
        constructor(e, n, r){
            this.outstandingRequests = 0, this.stageStatusMap = new Map, this.displayedIterator = new rp("displayed"), this.stages = e.stages, this.retrieveOptions = e.retrieveOptions, this.imageIds = n, this.listener = r;
        }
        async loadImages() {
            const e = this.createStageRequests();
            this.outstandingRequests = e.length;
            for (const n of e)this.addRequest(n);
            return this.outstandingRequests === 0 ? Promise.resolve(null) : this.displayedIterator.getDonePromise();
        }
        sendRequest(e, n) {
            const { imageId: r, next: i } = e, a = (f, u)=>{
                this.listener.errorCallback(r, c || !i, f), u && this.updateStageStatus(e.stage, f);
            }, o = (n.loader || $l)(r, n), s = rp.as(o);
            let c = !1;
            return s.forEach(async (f, u)=>{
                const g = ot.getImageQuality(r);
                if (!f) {
                    console.warn("No image retrieved", r);
                    return;
                }
                const { imageQualityStatus: h } = f;
                if (c ||= h === To.FULL_RESOLUTION, g !== void 0 && g > h) {
                    this.updateStageStatus(e.stage, null, !0);
                    return;
                }
                this.listener.successCallback(r, f), this.displayedIterator.add(f), u && this.updateStageStatus(e.stage), wj(this.listener, e, f);
            }, a).finally(()=>{
                if (!c && i) ot.setPartialImage(r), this.addRequest(i, n.streamingData);
                else {
                    c || this.listener.errorCallback(r, !0, "Couldn't decode"), this.outstandingRequests--;
                    for(let f = i; f; f = f.next)this.updateStageStatus(f.stage, null, !0);
                }
                this.outstandingRequests <= 0 && this.displayedIterator.resolve();
            }), s.getDonePromise().catch((f)=>null);
        }
        addRequest(e, n = {}) {
            const { imageId: r, stage: i } = e, a = this.listener.getLoaderImageOptions(r);
            if (!a) return;
            const { retrieveType: o = "default" } = i, { retrieveOptions: s } = this, c = s[o] || s.default, l = {
                ...a,
                retrieveType: o,
                retrieveOptions: c,
                streamingData: n
            }, f = i.priority ?? -5, u = i.requestType || Gt.Interaction, g = {
                imageId: r
            };
            xo.addRequest(this.sendRequest.bind(this, e, l), u, g, f);
        }
        updateStageStatus(e, n, r = !1) {
            const { id: i } = e, a = this.stageStatusMap.get(i);
            if (a && (a.imageLoadPendingCount--, n ? a.imageLoadFailedCount++ : r || a.totalImageCount++, !r && !a.stageStartTime && (a.stageStartTime = Date.now()), !a.imageLoadPendingCount)) {
                const { imageLoadFailedCount: o, totalImageCount: s, stageStartTime: c = Date.now(), startTime: l } = a, f = {
                    stageId: i,
                    numberOfFailures: o,
                    numberOfImages: s,
                    stageDurationInMS: c ? Date.now() - c : null,
                    startDurationInMS: Date.now() - l
                };
                We(Ke, Ge.IMAGE_RETRIEVAL_STAGE, f), this.stageStatusMap.delete(i);
            }
        }
        createStageRequests() {
            const e = new Array, n = new Map, r = (i, a)=>{
                const o = a < 0 ? this.imageIds.length + a : a < 1 ? Math.floor((this.imageIds.length - 1) * a) : a, s = this.imageIds[o];
                if (!s) throw new Error(`No value found to add to requests at ${a}`);
                const c = {
                    imageId: s,
                    stage: i,
                    index: o,
                    nearbyRequests: this.findNearbyRequests(o, i)
                };
                this.addStageStatus(i);
                const l = n.get(s);
                l ? l.next = c : e.push(c), n.set(s, c);
            };
            for (const i of this.stages)(i.positions || ID(this.imageIds, i.decimate || 1, i.offset ?? 0)).forEach((o)=>{
                r(i, o);
            });
            return e;
        }
        findNearbyRequests(e, n) {
            const r = new Array;
            if (!n.nearbyFrames) return r;
            for (const i of n.nearbyFrames){
                const a = e + i.offset;
                a < 0 || a >= this.imageIds.length || r.push({
                    itemId: this.imageIds[a],
                    imageQualityStatus: i.imageQualityStatus,
                    index: a
                });
            }
            return r;
        }
        addStageStatus(e) {
            const { id: n } = e, r = this.stageStatusMap.get(n) || {
                stageId: n,
                startTime: Date.now(),
                stageStartTime: null,
                totalImageCount: 0,
                imageLoadFailedCount: 0,
                imageLoadPendingCount: 0
            };
            return r.imageLoadPendingCount++, this.stageStatusMap.set(n, r), r;
        }
    }
    function bD(t) {
        return new MD(t);
    }
    const EC = Gt.Prefetch;
    xj = class extends tg {
        constructor(e, n){
            super(e), this.framesLoaded = 0, this.framesProcessed = 0, this.framesUpdated = 0, this.autoRenderOnLoad = !0, this.cachedFrames = [], this.reRenderTarget = 0, this.reRenderFraction = 2, this.imagesLoader = this, this.cancelLoading = ()=>{
                const { loadStatus: r } = this;
                if (!r || !r.loading) return;
                r.loading = !1, r.cancelled = !0, this.clearLoadCallbacks();
                const i = ({ additionalDetails: a })=>a.volumeId !== this.volumeId;
                xo.filterRequests(i);
            }, this.loadStatus = n.loadStatus;
        }
        invalidateVolume(e) {
            const { vtkOpenGLTexture: n } = this, { numFrames: r } = this;
            for(let i = 0; i < r; i++)n.setUpdatedFrame(i);
            this.modified(), e && Gv(this.volumeId);
        }
        clearLoadCallbacks() {
            this.loadStatus.callbacks = [];
        }
        callLoadStatusCallback(e) {
            const { framesUpdated: n, framesProcessed: r, totalNumFrames: i } = e, { volumeId: a, reRenderFraction: o, loadStatus: s, metadata: c } = this, { FrameOfReferenceUID: l } = c;
            if (this.autoRenderOnLoad && (n > this.reRenderTarget || r === i) && (this.reRenderTarget += o, Gv(a)), r === i) {
                s.callbacks.forEach((u)=>u(e));
                const f = {
                    FrameOfReferenceUID: l,
                    volumeId: a
                };
                We(Ke, Ge.IMAGE_VOLUME_LOADING_COMPLETED, f);
            }
        }
        updateTextureAndTriggerEvents(e, n, r = To.FULL_RESOLUTION) {
            const i = this.imageIdIndexToFrameIndex(e), { cachedFrames: a, numFrames: o, totalNumFrames: s } = this, { FrameOfReferenceUID: c } = this.metadata;
            if (a[i] > r || a[i] === To.FULL_RESOLUTION) return;
            const f = r === To.FULL_RESOLUTION;
            a[e] = r, this.framesUpdated++, f && (this.framesLoaded++, this.framesProcessed++);
            const u = {
                FrameOfReferenceUID: c,
                volumeId: this.volumeId,
                numberOfFrames: o,
                framesProcessed: this.framesProcessed
            };
            We(Ke, Ge.IMAGE_VOLUME_MODIFIED, u), f && this.framesProcessed === this.totalNumFrames && (this.loadStatus.loaded = !0, this.loadStatus.loading = !1), this.callLoadStatusCallback({
                success: !0,
                imageIdIndex: e,
                imageId: n,
                framesLoaded: this.framesLoaded,
                framesProcessed: this.framesProcessed,
                framesUpdated: this.framesUpdated,
                numFrames: o,
                totalNumFrames: s,
                complete: f,
                imageQualityStatus: r
            }), this.vtkOpenGLTexture.setUpdatedFrame(i), this.loadStatus.loaded && (this.loadStatus.callbacks = []);
        }
        successCallback(e, n) {
            const r = this.getImageIdIndex(e), { imageQualityStatus: i } = n;
            if (this.loadStatus.cancelled) {
                console.warn("volume load cancelled, returning for imageIdIndex: ", r);
                return;
            }
            this.updateTextureAndTriggerEvents(r, e, i), this.isDynamicVolume() && this.checkDimensionGroupCompletion(r);
        }
        errorCallback(e, n, r) {
            if (!n) return;
            const { totalNumFrames: i, numFrames: a } = this, o = this.getImageIdIndex(e);
            this.framesProcessed++, this.framesProcessed === i && (this.loadStatus.loaded = !0, this.loadStatus.loading = !1), this.callLoadStatusCallback({
                success: !1,
                imageId: e,
                imageIdIndex: o,
                error: r,
                framesLoaded: this.framesLoaded,
                framesProcessed: this.framesProcessed,
                framesUpdated: this.framesUpdated,
                numFrames: a,
                totalNumFrames: i
            }), this.loadStatus.loaded && (this.loadStatus.callbacks = []);
            const s = {
                error: r,
                imageIdIndex: o,
                imageId: e
            };
            We(Ke, Ge.IMAGE_LOAD_ERROR, s);
        }
        load(e) {
            const { imageIds: n, loadStatus: r, numFrames: i } = this, { transferSyntaxUID: a } = ct("transferSyntax", n[0]) || {}, o = ct(Zu.IMAGE_RETRIEVE_CONFIGURATION, this.volumeId, a, "volume");
            if (this.imagesLoader = this.isDynamicVolume() ? this : o ? (o.create || MD.createProgressive)(o) : this, r.loading === !0) return;
            const { loaded: s } = this.loadStatus, c = n.length;
            if (s) {
                e && e({
                    success: !0,
                    framesLoaded: c,
                    framesProcessed: c,
                    numFrames: i,
                    totalNumFrames: c
                });
                return;
            }
            e && this.loadStatus.callbacks.push(e), this._prefetchImageIds();
        }
        getLoaderImageOptions(e) {
            const { transferSyntaxUID: n } = ct("transferSyntax", e) || {}, r = ct("imagePlaneModule", e) || {}, { rows: i, columns: a } = r, o = this.getImageIdIndex(e), s = ct("modalityLutModule", e) || {}, c = ct("generalSeriesModule", e) || {}, l = {
                rescaleSlope: s.rescaleSlope,
                rescaleIntercept: s.rescaleIntercept,
                modality: c.modality
            }, f = l.modality;
            if (f === "PT" || f === "RTDOSE") {
                const v = ct("scalingModule", e);
                v && (this._addScalingToVolume(v), Object.assign(l, v));
            }
            const u = E4(l), g = g3();
            if (this.isPreScaled = !0, l && l.rescaleSlope !== void 0 && l.rescaleIntercept !== void 0) {
                const { rescaleSlope: v, rescaleIntercept: m } = l;
                this.isPreScaled = typeof v == "number" && typeof m == "number";
            }
            return !g && u && (this.isPreScaled = !1), {
                targetBuffer: {
                    type: this.dataType,
                    rows: i,
                    columns: a
                },
                allowFloatRendering: g,
                preScale: {
                    enabled: this.isPreScaled,
                    scalingParameters: l
                },
                transferPixelData: !0,
                requestType: EC,
                transferSyntaxUID: n,
                additionalDetails: {
                    imageId: e,
                    imageIdIndex: o,
                    volumeId: this.volumeId
                },
                retrieveOptions: void 0
            };
        }
        callLoadImage(e, n, r) {
            const { cachedFrames: i } = this;
            if (i[n] === To.FULL_RESOLUTION) return;
            const a = (s)=>{
                const { image: c } = s.detail;
                c.imageId === e && (this.vtkOpenGLTexture.setUpdatedFrame(n), Ke.removeEventListener(Ge.IMAGE_CACHE_IMAGE_ADDED, a));
            };
            return Ke.addEventListener(Ge.IMAGE_CACHE_IMAGE_ADDED, a), rp.as($l(e, r)).forEach((s)=>{
                this.successCallback(e, s);
            }, this.errorCallback.bind(this, n, e));
        }
        getImageIdsRequests(e, n) {
            this.totalNumFrames = this.imageIds.length;
            const r = 2;
            return this.autoRenderOnLoad && (this.reRenderFraction = this.totalNumFrames * (r / 100), this.reRenderTarget = this.reRenderFraction), e.map((a)=>{
                const o = this.getImageIdIndex(a), s = EC, c = n, l = this.getLoaderImageOptions(a), { retrieveOptions: f = {} } = ct(Zu.IMAGE_RETRIEVE_CONFIGURATION, a, "volume") || {};
                return l.retrieveOptions = {
                    ...l.retrieveOptions,
                    ...f.default || Object.values(f)?.[0] || {}
                }, {
                    callLoadImage: this.callLoadImage.bind(this),
                    imageId: a,
                    imageIdIndex: o,
                    options: l,
                    priority: c,
                    requestType: s,
                    additionalDetails: {
                        volumeId: this.volumeId
                    }
                };
            });
        }
        getImageLoadRequests(e) {
            throw new Error("Abstract method");
        }
        getImageIdsToLoad() {
            throw new Error("Abstract method");
        }
        loadImages() {
            return this.loadStatus.loading = !0, this.getImageLoadRequests(5).reverse().forEach((n)=>{
                if (!n) return;
                const { callLoadImage: r, imageId: i, imageIdIndex: a, options: o, priority: s, requestType: c, additionalDetails: l } = n;
                xo.addRequest(r.bind(this, i, a, o), c, l, s);
            }), Promise.resolve(!0);
        }
        _prefetchImageIds() {
            this.loadStatus.loading = !0;
            const e = [
                ...this.getImageIdsToLoad()
            ];
            this.totalNumFrames = this.imageIds.length;
            const n = 2;
            return this.autoRenderOnLoad && (this.reRenderFraction = this.totalNumFrames * (n / 100), this.reRenderTarget = this.reRenderFraction), this.imagesLoader.loadImages(e, this).catch((r)=>{
                console.debug("progressive loading failed to complete", r);
            });
        }
        _addScalingToVolume(e) {
            if (this.scaling) return;
            const { suvbw: n, suvlbm: r, suvbsa: i } = e, a = {};
            r && (a.suvbwToSuvlbm = r / n), i && (a.suvbwToSuvbsa = i / n), n && (a.suvbw = n), this.scaling = {
                PT: a
            };
        }
        checkDimensionGroupCompletion(e) {}
    };
    Sj = class extends xj {
        constructor(e, n){
            e.imageIds || (e.imageIds = n.imageIds), super(e, n), this.getImageIdsToLoad = ()=>{
                const { imageIds: r } = this;
                return this.numFrames = r.length, r;
            };
        }
        getScalarData() {
            return this.voxelManager.getScalarData();
        }
        getImageLoadRequests(e) {
            const { imageIds: n } = this;
            return this.getImageIdsRequests(n, e);
        }
    };
    Ej = function(t, e) {
        if (!e || !e.imageIds || !e.imageIds.length) throw new Error("ImageIds must be provided to create a streaming image volume");
        async function n() {
            if (e.imageIds[0].split(":")[0] === "wadouri") {
                const [v, m] = [
                    Math.floor(e.imageIds.length / 2),
                    e.imageIds.length - 1
                ], y = [
                    0,
                    v,
                    m
                ];
                await Promise.all(y.map((C)=>ot.isLoaded(e.imageIds[C]) ? Promise.resolve(!0) : new Promise((T, x)=>{
                        const S = e.imageIds[C];
                        xo.addRequest(async ()=>{
                            xD(S).then(()=>{
                                console.log(`Prefetched imageId: ${S}`), T(!0);
                            }).catch((D)=>{
                                x(D);
                            });
                        }, Gt.Prefetch, {
                            volumeId: t
                        }, 1);
                    }))).catch(console.error);
            }
            const i = D4(e.imageIds, t), { dimensions: a, spacing: o, origin: s, direction: c, metadata: l, imageIds: f, dataType: u, numberOfComponents: g } = i;
            return new Sj({
                volumeId: t,
                metadata: l,
                dimensions: a,
                spacing: o,
                origin: s,
                direction: c,
                imageIds: f,
                dataType: u,
                numberOfComponents: g
            }, {
                imageIds: f,
                loadStatus: {
                    loaded: !1,
                    loading: !1,
                    cancelled: !1,
                    cachedFrames: [],
                    callbacks: []
                }
            });
        }
        const r = n();
        return {
            promise: r,
            decache: ()=>{
                r.then((i)=>{
                    i.destroy(), i = null;
                });
            },
            cancel: ()=>{
                r.then((i)=>{
                    i.cancelLoading();
                });
            }
        };
    };
    const _4 = {};
    let Bu = Ej;
    function LD(t, e) {
        const n = t.indexOf(":"), r = t.substring(0, n);
        let i = _4[r];
        if (i == null) {
            if (Bu == null || typeof Bu != "function") throw new Error(`No volume loader for scheme ${r} has been registered`);
            i = Bu;
        }
        const a = i(t, e);
        return a.promise.then(function(o) {
            We(Ke, Ge.VOLUME_LOADED, {
                volume: o
            });
        }, function(o) {
            const s = {
                volumeId: t,
                error: o
            };
            We(Ke, Ge.VOLUME_LOADED_FAILED, s);
        }), a;
    }
    function R4(t, e = {
        imageIds: []
    }) {
        if (t === void 0) throw new Error("loadVolume: parameter volumeId must not be undefined");
        let n = ot.getVolumeLoadObject(t);
        return n !== void 0 ? n.promise : (n = LD(t, e), n.promise.then((r)=>r));
    }
    async function O4(t, e) {
        if (t === void 0) throw new Error("createAndCacheVolume: parameter volumeId must not be undefined");
        let n = ot.getVolumeLoadObject(t);
        return n !== void 0 || (n = LD(t, e), ot.putVolumeLoadObject(t, n)), n.promise;
    }
    function PD(t, e) {
        const n = ot.getVolume(t);
        if (!n) throw new Error(`Cannot created derived volume: Referenced volume with id ${t} does not exist.`);
        let { volumeId: r } = e;
        const { voxelRepresentation: i } = e;
        r === void 0 && (r = Vn());
        const { metadata: a, dimensions: o, spacing: s, origin: c, direction: l } = n, f = n.isDynamicVolume() ? n.getCurrentDimensionGroupImageIds() : n.imageIds ?? [], u = x4(f, {
            targetBuffer: e.targetBuffer,
            voxelRepresentation: i
        }), g = u[0].dataType, h = u.map((m)=>m.imageId), v = new tg({
            volumeId: r,
            dataType: g,
            metadata: structuredClone(a),
            dimensions: [
                o[0],
                o[1],
                o[2]
            ],
            spacing: s,
            origin: c,
            direction: l,
            referencedVolumeId: t,
            imageIds: h,
            referencedImageIds: n.imageIds ?? []
        });
        return ot.putVolumeSync(r, v), v;
    }
    async function VD(t, e) {
        if (e === void 0) throw new Error("createAndCacheVolumeFromImages: parameter imageIds must not be undefined");
        if (t === void 0) throw new Error("createAndCacheVolumeFromImages: parameter volumeId must not be undefined");
        const n = ot.getVolume(t);
        return n || (e.filter((a)=>!ot.getImage(a)).length === 0 ? ND(t, e) : await O4(t, {
            imageIds: e
        }));
    }
    function ND(t, e) {
        if (e === void 0) throw new Error("createAndCacheVolumeFromImagesSync: parameter imageIds must not be undefined");
        if (t === void 0) throw new Error("createAndCacheVolumeFromImagesSync: parameter volumeId must not be undefined");
        const n = ot.getVolume(t);
        if (n) return n;
        const r = D4(e, t), i = new tg({
            volumeId: t,
            dataType: r.dataType,
            metadata: structuredClone(r.metadata),
            dimensions: r.dimensions,
            spacing: r.spacing,
            origin: r.origin,
            direction: r.direction,
            referencedVolumeId: r.referencedVolumeId,
            imageIds: r.imageIds,
            referencedImageIds: r.referencedImageIds
        });
        return ot.putVolumeSync(t, i), i;
    }
    function I4(t, e = {}) {
        const { metadata: n, dimensions: r, spacing: i, origin: a, direction: o, scalarData: s, targetBuffer: c, preventCache: l = !1 } = e, f = ot.getVolume(t);
        if (f) return f;
        const u = r[0] * r[1], g = s ? s.constructor.name : c?.type ?? "Float32Array", h = u * r[2];
        let v;
        switch(g){
            case "Uint8Array":
            case "Int8Array":
                v = h;
                break;
            case "Uint16Array":
            case "Int16Array":
                v = h * 2;
                break;
            case "Float32Array":
                v = h * 4;
                break;
        }
        if (!ot.isCacheable(v)) throw new Error(`Cannot created derived volume: Volume with id ${t} is not cacheable.`);
        const y = [];
        for(let x = 0; x < r[2]; x++){
            const S = `${t}_slice_${x}`;
            y.push(S);
            const D = s.subarray(x * u, (x + 1) * u);
            S4(S, {
                scalarData: D,
                dimensions: [
                    r[0],
                    r[1]
                ],
                spacing: [
                    i[0],
                    i[1]
                ],
                origin: a,
                direction: o,
                targetBuffer: {
                    type: g
                }
            });
        }
        const C = new tg({
            volumeId: t,
            metadata: structuredClone(n),
            dimensions: [
                r[0],
                r[1],
                r[2]
            ],
            spacing: i,
            origin: a,
            direction: o,
            imageIds: y,
            dataType: g
        }), T = $n.createImageVolumeVoxelManager({
            imageIds: y,
            dimensions: r,
            numberOfComponents: 1,
            id: t
        });
        return C.voxelManager = T, l || ot.putVolumeSync(t, C), C;
    }
    function Dj(t, e) {
        _4[t] = e;
    }
    function AD() {
        return Object.keys(_4);
    }
    function _j(t) {
        const e = Bu;
        return Bu = t, e;
    }
    function kD() {
        return Bu.name;
    }
    function Rj(t, e = {}) {
        return PD(t, {
            ...e,
            targetBuffer: {
                type: "Uint8Array",
                ...e?.targetBuffer
            }
        });
    }
    function Oj(t, e, n = !1) {
        return t.scalarData || (t.scalarData = new Uint8Array(t.dimensions[0] * t.dimensions[1] * t.dimensions[2])), I4(e, {
            ...t,
            preventCache: n
        });
    }
    zae = Object.freeze(Object.defineProperty({
        __proto__: null,
        createAndCacheDerivedLabelmapVolume: Rj,
        createAndCacheDerivedVolume: PD,
        createAndCacheVolume: O4,
        createAndCacheVolumeFromImages: VD,
        createAndCacheVolumeFromImagesSync: ND,
        createLocalLabelmapVolume: Oj,
        createLocalVolume: I4,
        getUnknownVolumeLoaderSchema: kD,
        getVolumeLoaderSchemes: AD,
        loadVolume: R4,
        registerUnknownVolumeLoader: _j,
        registerVolumeLoader: Dj
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    Ij = function(t, e) {
        const n = Xz.newInstance();
        tf().rendering.preferSizeOverAccuracy && n.setPreferSizeOverAccuracy(!0), n.setInputData(t);
        const r = t.getSpacing(), i = (r[0] + r[1] + r[2]) / 6;
        return n.setMaximumSamplesPerRay(4e3), n.setSampleDistance(i), n.setScalarTexture(e), n;
    };
    Mj = function(t) {
        const e = vD.newInstance();
        e.setBlendMode(t.getBlendMode());
        const n = t.getInputData(), { voxelManager: r } = n.get("voxelManager"), i = r.getCompleteScalarDataArray(), a = Wt.newInstance({
            name: "Pixels",
            values: i
        });
        return n.getPointData().setScalars(a), e.setInputData(n), e.setMaximumSamplesPerRay(t.getMaximumSamplesPerRay()), e.setSampleDistance(t.getSampleDistance()), e;
    };
    const bj = 0, Lj = Gt.Prefetch;
    async function M4(t, e) {
        let n = Vj(e);
        !n && e.imageIds.length && (n = await Nj(e), n = Pj(e, n)), !(n.lower === 0 && n.upper === 0 || n.lower === void 0 || n.upper === void 0) && t.getProperty().getRGBTransferFunction(0).setMappingRange(n.lower, n.upper);
    }
    function Pj(t, e) {
        const n = t.imageIds, r = Math.floor(n.length / 2), i = n[r], a = ct("generalSeriesModule", i) || {};
        return Aj(a.modality, t) ? {
            lower: 0,
            upper: 5
        } : e;
    }
    function Vj(t) {
        const { imageIds: e, metadata: n } = t;
        let r;
        if (e?.length) {
            const i = Math.floor(e.length / 2), a = e[i], o = ct("voiLutModule", a);
            if (o && o.windowWidth && o.windowCenter) {
                o?.voiLUTFunction && (r = {}, r.voiLUTFunction = o?.voiLUTFunction);
                const { windowWidth: s, windowCenter: c } = o, l = Array.isArray(s) ? s[0] : s, f = Array.isArray(c) ? c[0] : c;
                l !== 0 && (r = {
                    windowWidth: l,
                    windowCenter: f
                });
            }
        } else r = n.voiLut[0];
        if (r && (r.windowWidth !== 0 || r.windowCenter !== 0)) {
            const { lower: i, upper: a } = Fu(Number(r.windowWidth), Number(r.windowCenter), r.voiLUTFunction);
            return {
                lower: i,
                upper: a
            };
        }
    }
    async function Nj(t) {
        const { imageIds: e } = t, n = Math.floor(e.length / 2), r = t.imageIds[n], i = ct("generalSeriesModule", r) || {}, { modality: a } = i, o = ct("modalityLutModule", r) || {}, s = {
            rescaleSlope: o.rescaleSlope,
            rescaleIntercept: o.rescaleIntercept,
            modality: a
        };
        let c;
        if (a === "PT") {
            const h = ct("scalingModule", r);
            h && (c = {
                ...s,
                suvbw: h.suvbw
            });
        }
        const l = {
            priority: bj,
            requestType: Lj,
            preScale: {
                scalingParameters: c
            }
        };
        let f = ot.getImage(r);
        t.referencedImageIds?.length || (f = await $l(r, {
            ...l,
            ignoreCache: !0
        }));
        let { min: u, max: g } = f.voxelManager.getMinMax();
        return u?.length > 1 && (u = Math.min(...u), g = Math.max(...g)), {
            lower: u,
            upper: g
        };
    }
    function Aj(t, e) {
        return !(t !== "PT" || !e.isPreScaled || !e.scaling?.PT.suvbw);
    }
    Wv = async function(t, e, n, r = !1) {
        const { volumeId: i, callback: a, blendMode: o } = t, s = await R4(i);
        if (!s) throw new Error(`imageVolume with id: ${s.volumeId} does not exist`);
        const { imageData: c, vtkOpenGLTexture: l } = s, f = Ij(c, l);
        o && f.setBlendMode(o);
        const u = FN.newInstance();
        u.setMapper(f);
        const { numberOfComponents: g } = c.get("numberOfComponents");
        return u.getProperty().set({
            viewportId: n
        }, !0), g === 3 && u.getProperty().setIndependentComponents(!1), await M4(u, s), a && a({
            volumeActor: u,
            volumeId: i
        }), r || kj(e, n, u, i), u;
    };
    function kj(t, e, n, r) {
        const i = n.getProperty().getRGBTransferFunction(0).getRange(), a = {
            viewportId: e,
            range: {
                lower: i[0],
                upper: i[1]
            },
            volumeId: r
        };
        We(t, Ge.VOI_MODIFIED, a);
    }
    function UD(t) {
        const e = t.getMapper().getInputData(), n = e.extentToBounds(e.getExtent());
        return [
            [
                n[0],
                n[2],
                n[4]
            ],
            [
                n[0],
                n[2],
                n[5]
            ],
            [
                n[0],
                n[3],
                n[4]
            ],
            [
                n[0],
                n[3],
                n[5]
            ],
            [
                n[1],
                n[2],
                n[4]
            ],
            [
                n[1],
                n[2],
                n[5]
            ],
            [
                n[1],
                n[3],
                n[4]
            ],
            [
                n[1],
                n[3],
                n[5]
            ]
        ];
    }
    const Uj = Jo * Jo, R5 = (t)=>Math.abs(Math.abs(t) - 1) < Uj, O5 = (t, e)=>R5(t[e]) || R5(t[e + 1]) || R5(t[e + 2]), Fj = (t)=>O5(t, 0) && O5(t, 3) && O5(t, 6);
    function Wp(t, e, n) {
        const r = t.getMapper().getInputData();
        let i;
        const a = r.getDirection();
        if (Fj(a)) i = UD(t);
        else {
            const [u, g, h] = r.getDimensions();
            i = [
                [
                    0,
                    0,
                    0
                ],
                [
                    u - 1,
                    0,
                    0
                ],
                [
                    0,
                    g - 1,
                    0
                ],
                [
                    u - 1,
                    g - 1,
                    0
                ],
                [
                    0,
                    0,
                    h - 1
                ],
                [
                    u - 1,
                    0,
                    h - 1
                ],
                [
                    0,
                    g - 1,
                    h - 1
                ],
                [
                    u - 1,
                    g - 1,
                    h - 1
                ]
            ].map((m)=>r.indexToWorld(m));
        }
        const o = M0.buildFromDegree().identity().rotateFromDirections(e, [
            1,
            0,
            0
        ]);
        i.forEach((u)=>o.apply(u));
        const s = [
            ...n
        ];
        o.apply(s);
        const c = s[0];
        let l = 1 / 0, f = -1 / 0;
        for(let u = 0; u < 8; u++){
            const g = i[u][0];
            g > f && (f = g), g < l && (l = g);
        }
        return {
            min: l,
            max: f,
            current: c,
            actor: t,
            viewPlaneNormal: e,
            focalPoint: n
        };
    }
    function ng(t, e) {
        const { direction: n, spacing: r } = t, i = n.slice(0, 3), a = n.slice(3, 6), o = n.slice(6, 9), s = [
            xt(i, e),
            xt(a, e),
            xt(o, e)
        ], c = Xe();
        return Sn(c, s[0] * r[0], s[1] * r[1], s[2] * r[2]), Xa(c);
    }
    const lf = (t)=>{
        const e = "volumeId:", n = t.includes(e) ? t.substring(e.length) : t, r = n.indexOf("sliceIndex=");
        return r === -1 ? n : n.substring(0, r - 1);
    }, Bj = 1 + Jo, Gj = (t, e)=>e === t.substring(0, Math.min(t.length, e.length)), DC = (t)=>!!AD().find((e)=>Gj(t.volumeId, e));
    function rg(t, e, n, r = !1) {
        const { viewPlaneNormal: i } = e, a = t.getActors();
        if (!a.length) return {
            spacingInNormalDirection: null,
            imageVolume: null,
            actorUID: null
        };
        const o = a.map((l)=>{
            const f = l.referencedId ?? l.uid;
            return ot.getVolume(f);
        }).filter((l)=>!!l);
        if (n) {
            const l = lf(n), f = o.findIndex((v)=>l.includes(v.volumeId)), u = o[f], { uid: g } = a[f], h = _C(u, i, t, r);
            return {
                imageVolume: u,
                spacingInNormalDirection: h,
                actorUID: g
            };
        }
        if (!o.length) return {
            spacingInNormalDirection: null,
            imageVolume: null,
            actorUID: null
        };
        const s = {
            spacingInNormalDirection: 1 / 0,
            imageVolume: null,
            actorUID: null
        }, c = o.find(DC);
        for(let l = 0; l < o.length; l++){
            const f = o[l];
            if (c && !DC(f)) continue;
            const u = _C(f, i, t);
            u * Bj < s.spacingInNormalDirection && (s.spacingInNormalDirection = u, s.imageVolume = f, s.actorUID = a[l].uid);
        }
        return s;
    }
    function _C(t, e, n, r = !1) {
        const { slabThickness: i } = n.getProperties();
        let a = i;
        return (!i || !r) && (a = ng(t, e)), a;
    }
    function ip(t) {
        const e = t.getCamera(), { spacingInNormalDirection: n, imageVolume: r } = rg(t, e);
        if (!r) return;
        const { viewPlaneNormal: i, focalPoint: a } = e, o = t.getActors().find((v)=>v.referencedId === r.volumeId || v.uid === r.volumeId);
        o || console.warn("No actor found for with actorUID of", r.volumeId);
        const s = o.actor, c = Wp(s, i, a), { min: l, max: f, current: u } = c, g = Math.round((f - l) / n) + 1;
        let h = (u - l) / (f - l) * g;
        return h = Math.floor(h), h > g - 1 ? h = g - 1 : h < 0 && (h = 0), {
            numberOfSlices: g,
            imageIndex: h
        };
    }
    const Mu = {};
    function Wj(t) {
        Mu[t] !== void 0 && delete Mu[t];
    }
    function $j(t) {
        const { renderingEngineId: e, viewportId: n } = t.detail, i = ws(e).getViewport(n);
        if (!("setVolumes" in i)) throw new Error("volumeNewImageEventDispatcher: viewport does not have setVolumes method");
        Mu[i.id] === void 0 && (Mu[i.id] = 0);
        const a = ip(i);
        if (!a) {
            console.warn(`volumeNewImageEventDispatcher: sliceData is undefined for viewport ${i.id}`);
            return;
        }
        const { numberOfSlices: o, imageIndex: s } = a;
        if (Mu[i.id] === s) return;
        Mu[i.id] = s;
        const c = {
            imageIndex: s,
            viewportId: n,
            renderingEngineId: e,
            numberOfSlices: o
        };
        We(i.element, Ge.VOLUME_NEW_IMAGE, c);
    }
    function FD(t, e, n) {
        const [r, i, a] = t, [o, s, c] = e, [l, f, u, g] = n, h = o - r, v = s - i, m = c - a, y = -1 * (l * r + f * i + u * a - g) / (l * h + f * v + u * m), C = h * y + r, T = v * y + i, x = m * y + a;
        return [
            C,
            T,
            x
        ];
    }
    function BD(t, e, n = !1) {
        const [r, i, a] = t, o = r * e[0] + i * e[1] + a * e[2];
        if (n) {
            const s = Math.sqrt(r * r + i * i + a * a);
            return [
                r / s,
                i / s,
                a / s,
                o / s
            ];
        }
        return [
            r,
            i,
            a,
            o
        ];
    }
    function zj(t, e, n) {
        const [r, i, a, o] = t, [s, c, l, f] = e, [u, g, h, v] = n, m = rd(r, s, u, i, c, g, a, l, h), y = rd(o, f, v, i, c, g, a, l, h), C = rd(r, s, u, o, f, v, a, l, h), T = rd(r, s, u, i, c, g, o, f, v), x = x0(y) / x0(m), S = x0(C) / x0(m), D = x0(T) / x0(m);
        return [
            x,
            S,
            D
        ];
    }
    function b4(t, e, n = !1) {
        const [r, i, a, o] = t, [s, c, l] = e, f = r * s + i * c + a * l - o, u = Math.abs(f) / Math.sqrt(r * r + i * i + a * a);
        return (n ? Math.sign(f) : 1) * u;
    }
    function jj(t, e, n = Jo) {
        return b4(e, t) < n;
    }
    const Hj = Object.freeze(Object.defineProperty({
        __proto__: null,
        isPointOnPlane: jj,
        linePlaneIntersection: FD,
        planeDistanceToPoint: b4,
        planeEquation: BD,
        threePlaneIntersection: zj
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function $v(t) {
        return Array.isArray(t) ? t.some((e)=>Number.isNaN(e)) : Number.isNaN(t);
    }
    function ms(t) {
        if (t === null || typeof t != "object" || typeof t == "function" || typeof structuredClone == "function") return t;
        if (Array.isArray(t)) return t.map(ms);
        {
            const e = {};
            for(const n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = ms(t[n]));
            return e;
        }
    }
    uf = class {
        static{
            this.CameraViewPresentation = {
                rotation: !0,
                pan: !0,
                zoom: !0,
                displayArea: !0
            };
        }
        static{
            this.TransferViewPresentation = {
                windowLevel: !0,
                paletteLut: !0
            };
        }
        constructor(e){
            this.insetImageMultiplier = 1.1, this.flipHorizontal = !1, this.flipVertical = !1, this.viewportStatus = sa.NO_DATA, this._suppressCameraModifiedEvents = !1, this.hasPixelSpacing = !0, this.getProperties = ()=>({}), this.setRotation = (n)=>{}, this.viewportWidgets = new Map, this.addWidget = (n, r)=>{
                this.viewportWidgets.set(n, r);
            }, this.getWidget = (n)=>this.viewportWidgets.get(n), this.getWidgets = ()=>Array.from(this.viewportWidgets.values()), this.removeWidgets = ()=>{
                this.getWidgets().forEach((r)=>{
                    if (r.getEnabled() && r.setEnabled(!1), r.getActor && r.getRenderer) {
                        const i = r.getActor(), a = r.getRenderer();
                        a && i && a.removeActor(i);
                    }
                });
            }, this.id = e.id, this.renderingEngineId = e.renderingEngineId, this.type = e.type, this.element = e.element, this.canvas = e.canvas, this.sx = e.sx, this.sy = e.sy, this.sWidth = e.sWidth, this.sHeight = e.sHeight, this._actors = new Map, this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.defaultOptions = ms(e.defaultOptions), this.suppressEvents = e.defaultOptions.suppressEvents ? e.defaultOptions.suppressEvents : !1, this.options = ms(e.defaultOptions), this.isDisabled = !1;
        }
        static get useCustomRenderingPipeline() {
            return !1;
        }
        setRendered() {
            this.viewportStatus === sa.NO_DATA || this.viewportStatus === sa.LOADING || (this.viewportStatus = sa.RENDERED);
        }
        setColorTransform(e, n) {
            let r = null;
            if (!e && !n) return;
            const i = n || [
                255,
                255,
                255
            ], a = Math.max(...i), o = i.map((u)=>a / u), { lower: s = 0, upper: c = 255 } = e || {}, l = (c - s + 1) / 255, f = s / 255;
            return r = `url('data:image/svg+xml,      <svg xmlns="http://www.w3.org/2000/svg">        <filter id="colour" color-interpolation-filters="linearRGB">        <feColorMatrix type="matrix"         values="          ${o[0] * l} 0 0 0 ${f}           0 ${o[1] * l} 0 0 ${f}           0 0 ${o[2] * l} 0 ${f}           0 0 0 1 0" />        </filter>      </svg>#colour')`, r;
        }
        getRenderingEngine() {
            return Rd.get(this.renderingEngineId);
        }
        getRenderer() {
            const e = this.getRenderingEngine();
            if (!e || e.hasBeenDestroyed) throw new Error("Rendering engine has been destroyed");
            return e.offscreenMultiRenderWindow?.getRenderer(this.id);
        }
        render() {
            this.getRenderingEngine().renderViewport(this.id);
        }
        setOptions(e, n = !1) {
            this.options = structuredClone(e), this.options?.displayArea && this.setDisplayArea(this.options?.displayArea), n && this.render();
        }
        reset(e = !1) {
            this.options = structuredClone(this.defaultOptions), e && this.render();
        }
        getSliceViewInfo() {
            throw new Error("Method not implemented.");
        }
        flip({ flipHorizontal: e, flipVertical: n }) {
            const r = this.getDefaultImageData();
            if (!r) return;
            const i = this.getCamera(), { viewPlaneNormal: a, viewUp: o, focalPoint: s, position: c } = i, l = bn(Xe(), a, o);
            let f = GV(Xe(), o);
            const u = jc(Xe(), a), g = rc(c, s), v = r.getDimensions().map((D)=>Math.floor(D / 2)), m = [
                v[0],
                v[1],
                v[2]
            ], y = r.indexToWorld(m, Xe()), C = this._getFocalPointForResetCamera(y, i, {
                resetPan: !0,
                resetToCenter: !1
            }), T = kr(Xe(), s, C), x = Xa(T), S = (D)=>{
                const _ = Ys(Xe(), D, 2 * xt(T, D));
                return kr(_, _, T), jn(_, _), _;
            };
            if (e) {
                const D = S(f), _ = $i(Xe(), C, D, x), M = $i(Xe(), _, u, g);
                this.setCamera({
                    viewPlaneNormal: u,
                    position: M,
                    focalPoint: _
                }), this.flipHorizontal = !this.flipHorizontal;
            }
            if (n) {
                f = jc(f, o);
                const D = S(l), _ = $i(Xe(), C, D, x), M = $i(Xe(), _, u, g);
                this.setCamera({
                    focalPoint: _,
                    viewPlaneNormal: u,
                    viewUp: f,
                    position: M
                }), this.flipVertical = !this.flipVertical;
            }
            this.render();
        }
        getDefaultImageData() {
            const e = this.getDefaultActor();
            if (e && ps(e)) return e.actor.getMapper().getInputData();
        }
        getDefaultActor() {
            return this.getActors()[0];
        }
        getActors() {
            return Array.from(this._actors.values());
        }
        getActorUIDs() {
            return Array.from(this._actors.keys());
        }
        getActor(e) {
            return this._actors.get(e);
        }
        getImageActor(e) {
            const n = this.getActors();
            let r = n[0];
            return e && (r = n.find((a)=>a.referencedId === e)), !r || !ps(r) ? null : r.actor;
        }
        getActorUIDByIndex(e) {
            const n = this.getActors()[e];
            if (n) return n.uid;
        }
        getActorByIndex(e) {
            return this.getActors()[e];
        }
        setActors(e) {
            const n = this.getActors();
            this.removeAllActors(), this.addActors(e, {
                resetCamera: !0
            }), We(this.element, Ge.ACTORS_CHANGED, {
                viewportId: this.id,
                removedActors: n,
                addedActors: e,
                currentActors: e
            });
        }
        _removeActor(e) {
            const n = this.getActor(e);
            if (!n) {
                console.warn(`Actor ${e} does not exist in ${this.id}, can't remove`);
                return;
            }
            return this.getRenderer().removeActor(n.actor), this._actors.delete(e), n;
        }
        removeActors(e) {
            const n = [];
            e.forEach((i)=>{
                const a = this._removeActor(i);
                a && n.push(a);
            });
            const r = this.getActors();
            We(this.element, Ge.ACTORS_CHANGED, {
                viewportId: this.id,
                removedActors: n,
                addedActors: [],
                currentActors: r
            });
        }
        addActors(e, n = {}) {
            const { resetCamera: r = !1 } = n, i = this.getRenderingEngine();
            if (!i || i.hasBeenDestroyed) {
                console.warn("Viewport::addActors::Rendering engine has not been initialized or has been destroyed");
                return;
            }
            e.forEach((s)=>{
                this.addActor(s);
            });
            const a = this.getViewPresentation(), o = this.getViewReference();
            this.resetCamera(), r || (this.setViewReference(o), this.setViewPresentation(a)), We(this.element, Ge.ACTORS_CHANGED, {
                viewportId: this.id,
                removedActors: [],
                addedActors: e,
                currentActors: this.getActors()
            });
        }
        addActor(e) {
            const { uid: n, actor: r } = e, i = this.getRenderingEngine();
            if (!i || i.hasBeenDestroyed) {
                console.warn(`Cannot add actor UID of ${n} Rendering Engine has been destroyed`);
                return;
            }
            if (!n || !r) throw new Error("Actors should have uid and vtk Actor properties");
            if (this.getActor(n)) {
                console.warn(`Actor ${n} already exists for this viewport`);
                return;
            }
            this.getRenderer()?.addActor(r), this._actors.set(n, Object.assign({}, e)), this.updateCameraClippingPlanesAndRange(), We(this.element, Ge.ACTORS_CHANGED, {
                viewportId: this.id,
                removedActors: [],
                addedActors: [
                    e
                ],
                currentActors: this.getActors()
            });
        }
        removeAllActors() {
            const e = this.getActors();
            this.getRenderer()?.removeAllViewProps(), this._actors = new Map, We(this.element, Ge.ACTORS_CHANGED, {
                viewportId: this.id,
                removedActors: e,
                addedActors: [],
                currentActors: []
            });
        }
        resetCameraNoEvent() {
            const e = this._suppressCameraModifiedEvents;
            this._suppressCameraModifiedEvents = !0, this.resetCamera(), this._suppressCameraModifiedEvents = e;
        }
        setCameraNoEvent(e) {
            const n = this._suppressCameraModifiedEvents;
            this._suppressCameraModifiedEvents = !0, this.setCamera(e), this._suppressCameraModifiedEvents = n;
        }
        _getViewImageDataIntersections(e, n, r) {
            const i = r[0], a = r[1], o = r[2], s = i * n[0] + a * n[1] + o * n[2], c = e.getBounds(), l = this._getEdges(c), f = [];
            for (const u of l){
                const [[g, h, v], [m, y, C]] = u;
                if (i * (m - g) + a * (y - h) + o * (C - v) === 0) continue;
                const T = FD([
                    g,
                    h,
                    v
                ], [
                    m,
                    y,
                    C
                ], [
                    i,
                    a,
                    o,
                    s
                ]);
                this._isInBounds(T, c) && f.push(T);
            }
            return f;
        }
        setInterpolationType(e, n) {}
        setDisplayArea(e, n = !1) {
            if (!e) return;
            const { storeAsInitialCamera: r, type: i } = e;
            r && (this.options.displayArea = e);
            const { _suppressCameraModifiedEvents: a } = this;
            if (this._suppressCameraModifiedEvents = !0, this.setCamera(this.fitToCanvasCamera), i === "SCALE" ? this.setDisplayAreaScale(e) : (this.setInterpolationType(this.getProperties()?.interpolationType ?? Wc.LINEAR), this.setDisplayAreaFit(e)), r && (this.initialCamera = this.getCamera()), this._suppressCameraModifiedEvents = a, !n && !a) {
                const o = {
                    viewportId: this.id,
                    displayArea: e,
                    storeAsInitialCamera: r
                };
                We(this.element, Ge.DISPLAY_AREA_MODIFIED, o), this.setCamera(this.getCamera());
            }
        }
        setDisplayAreaScale(e) {
            const { scale: n = 1 } = e, r = this.canvas, i = r.height, a = r.width;
            if (i < 8 || a < 8) return;
            const c = this.getDefaultImageData().getSpacing()[1];
            this.setInterpolationType(Wc.NEAREST), this.setCamera({
                parallelScale: i * c / (2 * n)
            }), delete e.imageArea, this.setDisplayAreaFit(e);
            const { focalPoint: l, position: f, viewUp: u, viewPlaneNormal: g } = this.getCamera(), h = Xe();
            if (r.height % 2 && $i(h, h, u, n * .5 * c), r.width % 2) {
                const v = bn(Xe(), u, g);
                $i(h, h, v, n * .5 * c);
            }
            !h[0] && !h[1] && !h[2] || this.setCamera({
                focalPoint: Qc(Xe(), l, h),
                position: Qc(Xe(), f, h)
            });
        }
        setDisplayAreaFit(e) {
            const { imageArea: n, imageCanvasPoint: r } = e, i = window?.devicePixelRatio || 1, a = this.getDefaultImageData();
            if (!a) return;
            const o = this.sWidth / i, s = this.sHeight / i, c = a.getDimensions(), l = this.worldToCanvas(a.indexToWorld([
                0,
                0,
                0
            ])), f = this.worldToCanvas(a.indexToWorld([
                c[0],
                c[1],
                c[2]
            ])), u = [
                Math.abs(f[0] - l[0]),
                Math.abs(f[1] - l[1])
            ], [g, h] = u;
            let v = this.getZoom() / this.insetImageMultiplier;
            if (n) {
                const [m, y] = n, C = Math.max(Math.abs(g / o), Math.abs(h / s)), T = Math.abs(m * g / o), x = Math.abs(y * h / s), S = this.getZoom(), D = this.getZoom(this.fitToCanvasCamera);
                v = (T > x ? C / T : C / x) * S / D, this.setZoom(this.insetImageMultiplier * v, !1);
            }
            if (r) {
                const { imagePoint: m, canvasPoint: y = m || [
                    .5,
                    .5
                ] } = r, [C, T] = y, x = o * (C - .5), S = s * (T - .5), [D, _] = m || y, M = v, P = this.insetImageMultiplier * M * g * (.5 - D), F = this.insetImageMultiplier * M * h * (.5 - _), N = P + x, B = F + S, G = [
                    N,
                    B
                ];
                $3(G, G, this.getPan()), this.setPan(G, !1);
            }
        }
        getDisplayArea() {
            return this.options?.displayArea;
        }
        resetCamera(e) {
            const { resetPan: n = !0, resetZoom: r = !0, resetToCenter: i = !0, storeAsInitialCamera: a = !0 } = e || {}, o = this.getRenderer();
            this.setCameraNoEvent({
                flipHorizontal: !1,
                flipVertical: !1
            });
            const s = this.getCamera();
            let c;
            const l = this.getDefaultActor();
            l && ps(l) ? c = l.actor.getMapper().getInputData().getBounds() : c = o.computeVisiblePropBounds();
            const f = [
                0,
                0,
                0
            ], u = this.getDefaultImageData();
            if (u) {
                const H = u.getSpacing();
                c[0] = c[0] + H[0] / 2, c[1] = c[1] - H[0] / 2, c[2] = c[2] + H[1] / 2, c[3] = c[3] - H[1] / 2, c[4] = c[4] + H[2] / 2, c[5] = c[5] - H[2] / 2;
            }
            const g = this.getVtkActiveCamera(), h = g.getViewPlaneNormal(), v = g.getViewUp();
            if (f[0] = (c[0] + c[1]) / 2, f[1] = (c[2] + c[3]) / 2, f[2] = (c[4] + c[5]) / 2, u) {
                const ne = u.getDimensions().map((ue)=>Math.floor(ue / 2)), ae = [
                    ne[0],
                    ne[1],
                    ne[2]
                ];
                u.indexToWorld(ae, f);
            }
            const { widthWorld: m, heightWorld: y } = this._getWorldDistanceViewUpAndViewRight(c, v, h), C = [
                this.sWidth,
                this.sHeight
            ], T = m / y, x = C[0] / C[1], S = T / x, D = S < 1 ? this.insetImageMultiplier * y / 2 : this.insetImageMultiplier * y * S / 2, _ = uf.boundsRadius(c) * (this.type === On.VOLUME_3D ? 10 : 1), M = this.insetImageMultiplier * _, P = Math.abs(Xo.dot(v, h)) > .999 ? [
                -v[2],
                v[0],
                v[1]
            ] : v, F = this._getFocalPointForResetCamera(f, s, {
                resetPan: n,
                resetToCenter: i
            }), N = [
                F[0] + M * h[0],
                F[1] + M * h[1],
                F[2] + M * h[2]
            ];
            o.resetCameraClippingRange(c);
            const B = [
                -Er.MAXIMUM_RAY_DISTANCE,
                Er.MAXIMUM_RAY_DISTANCE
            ];
            g.setPhysicalScale(_), g.setPhysicalTranslation(-F[0], -F[1], -F[2]), this.setCamera({
                parallelScale: r ? D : s.parallelScale,
                focalPoint: F,
                position: N,
                viewAngle: 90,
                viewUp: P,
                clippingRange: B
            });
            const G = this.getCamera();
            this.setFitToCanvasCamera(this.getCamera()), a && this.setInitialCamera(G), r && this.setZoom(1, a);
            const Z = {
                type: "ResetCameraEvent",
                renderer: o
            };
            return o.invokeEvent(Z), this.triggerCameraModifiedEventIfNecessary(s, G), u && this.options.displayArea && r && n && i && this.setDisplayArea(this.options.displayArea), !0;
        }
        setInitialCamera(e) {
            this.initialCamera = e;
        }
        setFitToCanvasCamera(e) {
            this.fitToCanvasCamera = e;
        }
        getPan(e = this.initialCamera) {
            if (!e) return [
                0,
                0
            ];
            const r = this.getVtkActiveCamera().getFocalPoint(), i = this.canvasToWorld([
                0,
                0
            ]), a = this.worldToCanvas(kr([
                0,
                0,
                0
            ], e.focalPoint, i)), o = this.worldToCanvas(kr([
                0,
                0,
                0
            ], r, i));
            return yi([
                0,
                0
            ], a, o);
        }
        getCurrentImageIdIndex() {
            throw new Error("Not implemented");
        }
        getSliceIndex() {
            throw new Error("Not implemented");
        }
        getImageData() {
            throw new Error("Not implemented");
        }
        getViewReferenceId(e) {
            return null;
        }
        setPan(e, n = !1) {
            const r = this.getCamera(), { focalPoint: i, position: a } = r, o = this.canvasToWorld([
                0,
                0
            ]), s = yi([
                0,
                0
            ], e, this.getPan());
            if (Math.abs(s[0]) < 1 && Math.abs(s[1]) < 1 && !n) return;
            const c = kr(Xe(), this.canvasToWorld(s), o), l = kr(Xe(), i, c), f = kr(Xe(), a, c);
            this.setCamera({
                ...r,
                focalPoint: l,
                position: f
            }, n);
        }
        getZoom(e = this.initialCamera) {
            if (!e) return 1;
            const n = this.getVtkActiveCamera(), { parallelScale: r } = e;
            return r / n.getParallelScale();
        }
        setZoom(e, n = !1) {
            const r = this.getCamera(), { parallelScale: i } = this.initialCamera, a = i / e;
            r.parallelScale === a && !n || this.setCamera({
                ...r,
                parallelScale: a
            }, n);
        }
        _getFocalPointForViewPlaneReset(e) {
            const { focalPoint: n, viewPlaneNormal: r } = this.getCamera(), i = this._getViewImageDataIntersections(e, n, r);
            let a = 0, o = 0, s = 0;
            return i.forEach(([l, f, u])=>{
                a += l, o += f, s += u;
            }), [
                a / i.length,
                o / i.length,
                s / i.length
            ];
        }
        getCanvas() {
            return this.canvas;
        }
        getVtkActiveCamera() {
            const e = this.getRenderer();
            return e ? e.getActiveCamera() : (console.warn("No renderer found for the viewport"), null);
        }
        getCameraNoRotation() {
            const e = this.getVtkActiveCamera(), n = (s, c)=>s.some((l)=>isNaN(l)) ? c : s, r = n([
                ...e.getViewUp()
            ], [
                0,
                1,
                0
            ]), i = n([
                ...e.getViewPlaneNormal()
            ], [
                0,
                0,
                -1
            ]), a = n([
                ...e.getPosition()
            ], [
                0,
                0,
                1
            ]), o = n([
                ...e.getFocalPoint()
            ], [
                0,
                0,
                0
            ]);
            return {
                viewUp: r,
                viewPlaneNormal: i,
                position: a,
                focalPoint: o,
                parallelProjection: e.getParallelProjection(),
                parallelScale: e.getParallelScale(),
                viewAngle: e.getViewAngle(),
                flipHorizontal: this.flipHorizontal,
                flipVertical: this.flipVertical
            };
        }
        getCamera() {
            return {
                ...this.getCameraNoRotation(),
                rotation: this.getRotation()
            };
        }
        setCamera(e, n = !1) {
            const r = this.getVtkActiveCamera(), i = this.getCamera(), a = Object.assign({}, i, e), { viewUp: o, viewPlaneNormal: s, position: c, focalPoint: l, parallelScale: f, viewAngle: u, flipHorizontal: g, flipVertical: h, clippingRange: v } = e;
            if (g !== void 0) {
                const C = g && !this.flipHorizontal || !g && this.flipHorizontal;
                C && this.flip({
                    flipHorizontal: C
                });
            }
            if (h !== void 0) {
                const C = h && !this.flipVertical || !h && this.flipVertical;
                C && this.flip({
                    flipVertical: C
                });
            }
            o !== void 0 && r.setViewUp(o), s !== void 0 && r.setDirectionOfProjection(-s[0], -s[1], -s[2]), c !== void 0 && r.setPosition(...c), l !== void 0 && r.setFocalPoint(...l), f !== void 0 && r.setParallelScale(f), u !== void 0 && r.setViewAngle(u), v !== void 0 && r.setClippingRange(v);
            const m = i.focalPoint, y = i.viewUp;
            if (m && l || y && o) {
                const C = r.getViewPlaneNormal(), T = r.getViewUp();
                let x = !1, S = !1;
                if (l) {
                    const D = [
                        l[0] - m[0],
                        l[1] - m[1],
                        l[2] - m[2]
                    ];
                    x = Math.abs(Xo.dot(D, C)) > 0;
                }
                if (o && (S = !lr(T, y)), x || S) {
                    const D = this.getDefaultActor();
                    if (!D?.actor) return;
                    Ya(D, "vtkActor") || this.updateClippingPlanesForActors(a), (Ya(D, "vtkImageSlice") || this.type === On.VOLUME_3D) && this.getRenderer().resetCameraClippingRange();
                }
            }
            n && this.setInitialCamera(a), this.triggerCameraModifiedEventIfNecessary(i, this.getCamera());
        }
        triggerCameraModifiedEventIfNecessary(e, n) {
            if (!this._suppressCameraModifiedEvents && !this.suppressEvents) {
                const r = {
                    previousCamera: e,
                    camera: n,
                    element: this.element,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId
                };
                We(this.element, Ge.CAMERA_MODIFIED, r);
            }
        }
        updateCameraClippingPlanesAndRange() {
            const e = this.getCamera();
            this.updateClippingPlanesForActors(e), this.getRenderer().resetCameraClippingRange();
        }
        async updateClippingPlanesForActors(e) {
            this.getActors().map((r)=>{
                if (!r.actor) return;
                const i = r.actor.getMapper();
                let a = r?.clippingFilter ? r?.clippingFilter.getClippingPlanes() : i.getClippingPlanes();
                a.length === 0 && r?.clippingFilter && (a = [
                    ca.newInstance(),
                    ca.newInstance()
                ]);
                let o = Er.MINIMUM_SLAB_THICKNESS;
                r.slabThickness && (o = r.slabThickness);
                const { viewPlaneNormal: s, focalPoint: c } = e;
                this.setOrientationOfClippingPlanes(a, o, s, c), We(this.element, Ge.CLIPPING_PLANES_UPDATED, {
                    actorEntry: r,
                    focalPoint: c,
                    vtkPlanes: a,
                    viewport: this
                });
            });
        }
        setOrientationOfClippingPlanes(e, n, r, i) {
            if (e.length < 2) return;
            const a = [
                r[0],
                r[1],
                r[2]
            ];
            Xo.multiplyScalar(a, n), e[0].setNormal(r);
            const o = [
                0,
                0,
                0
            ];
            Xo.subtract(i, a, o), e[0].setOrigin(o), e[1].setNormal(-r[0], -r[1], -r[2]);
            const s = [
                0,
                0,
                0
            ];
            Xo.add(i, a, s), e[1].setOrigin(s);
        }
        getClippingPlanesForActor(e) {
            if (e || (e = this.getDefaultActor()), !e.actor) throw new Error("Invalid actor entry: Actor is undefined");
            const n = e.actor.getMapper();
            let r = e?.clippingFilter ? e?.clippingFilter.getClippingPlanes() : n.getClippingPlanes();
            return r.length === 0 && e?.clippingFilter && (r = [
                ca.newInstance(),
                ca.newInstance()
            ]), r;
        }
        _getWorldDistanceViewUpAndViewRight(e, n, r) {
            const i = this._getCorners(e), a = this._getCorners(e), o = bn(Xe(), n, r);
            let s = M0.buildFromDegree().identity().rotateFromDirections(n, [
                1,
                0,
                0
            ]);
            i.forEach((g)=>s.apply(g));
            let c = 1 / 0, l = -1 / 0;
            for(let g = 0; g < 8; g++){
                const h = i[g][0];
                h > l && (l = h), h < c && (c = h);
            }
            s = M0.buildFromDegree().identity().rotateFromDirections([
                o[0],
                o[1],
                o[2]
            ], [
                1,
                0,
                0
            ]), a.forEach((g)=>s.apply(g));
            let f = 1 / 0, u = -1 / 0;
            for(let g = 0; g < 8; g++){
                const h = a[g][0];
                h > u && (u = h), h < f && (f = h);
            }
            return {
                widthWorld: u - f,
                heightWorld: l - c
            };
        }
        getViewReference(e) {
            const { focalPoint: n, viewPlaneNormal: r, viewUp: i } = this.getCamera();
            return {
                FrameOfReferenceUID: this.getFrameOfReferenceUID(),
                cameraFocalPoint: n,
                viewPlaneNormal: r,
                viewUp: i,
                sliceIndex: e?.sliceIndex ?? this.getSliceIndex()
            };
        }
        isReferenceViewable(e, n) {
            if (e.FrameOfReferenceUID && e.FrameOfReferenceUID !== this.getFrameOfReferenceUID()) return !1;
            const { viewPlaneNormal: r } = e, i = this.getCamera();
            return r && !lr(r, i.viewPlaneNormal) && !lr(jc(i.viewPlaneNormal, i.viewPlaneNormal), r) ? n?.withOrientation : !0;
        }
        getViewPresentation(e = {
            rotation: !0,
            displayArea: !0,
            zoom: !0,
            pan: !0,
            flipHorizontal: !0,
            flipVertical: !0
        }) {
            const n = {}, { rotation: r, displayArea: i, zoom: a, pan: o, flipHorizontal: s, flipVertical: c } = e;
            r && (n.rotation = this.getRotation()), i && (n.displayArea = this.getDisplayArea());
            const l = this.getZoom();
            return a && (n.zoom = l), o && (n.pan = this.getPan(), L9(n.pan, n.pan, 1 / l)), s && (n.flipHorizontal = this.flipHorizontal), c && (n.flipVertical = this.flipVertical), n;
        }
        setViewReference(e) {}
        setViewPresentation(e) {
            if (!e) return;
            const { displayArea: n, zoom: r = this.getZoom(), pan: i, rotation: a, flipHorizontal: o = this.flipHorizontal, flipVertical: s = this.flipVertical } = e;
            n !== this.getDisplayArea() && this.setDisplayArea(n), this.setZoom(r), i && this.setPan(L9([
                0,
                0
            ], i, r)), o !== void 0 && o !== this.flipHorizontal && this.flip({
                flipHorizontal: o
            }), s !== void 0 && s !== this.flipVertical && this.flip({
                flipVertical: s
            }), a >= 0 && this.setRotation(a);
        }
        _getCorners(e) {
            return [
                [
                    e[0],
                    e[2],
                    e[4]
                ],
                [
                    e[0],
                    e[2],
                    e[5]
                ],
                [
                    e[0],
                    e[3],
                    e[4]
                ],
                [
                    e[0],
                    e[3],
                    e[5]
                ],
                [
                    e[1],
                    e[2],
                    e[4]
                ],
                [
                    e[1],
                    e[2],
                    e[5]
                ],
                [
                    e[1],
                    e[3],
                    e[4]
                ],
                [
                    e[1],
                    e[3],
                    e[5]
                ]
            ];
        }
        _getFocalPointForResetCamera(e, n, { resetPan: r = !0, resetToCenter: i = !0 }) {
            if (i && r) return e;
            if (i && !r) return $v(n.focalPoint) ? e : n.focalPoint;
            if (!i && r) {
                const a = n, o = a.focalPoint, s = a.viewPlaneNormal, c = kr(Xe(), e, o), l = xt(c, s), f = $i(Xe(), e, s, -1 * l);
                return [
                    f[0],
                    f[1],
                    f[2]
                ];
            }
            if (!r && !i) return $v(n.focalPoint) ? e : n.focalPoint;
        }
        _isInBounds(e, n) {
            const [r, i, a, o, s, c] = n, [l, f, u] = e;
            return !(l < r || l > i || f < a || f > o || u < s || u > c);
        }
        _getEdges(e) {
            const [n, r, i, a, o, s, c, l] = this._getCorners(e);
            return [
                [
                    n,
                    r
                ],
                [
                    n,
                    o
                ],
                [
                    n,
                    i
                ],
                [
                    r,
                    a
                ],
                [
                    r,
                    s
                ],
                [
                    i,
                    a
                ],
                [
                    i,
                    c
                ],
                [
                    a,
                    l
                ],
                [
                    o,
                    c
                ],
                [
                    o,
                    s
                ],
                [
                    s,
                    l
                ],
                [
                    c,
                    l
                ]
            ];
        }
        static boundsRadius(e) {
            const n = (e[1] - e[0]) ** 2, r = (e[3] - e[2]) ** 2, i = (e[5] - e[4]) ** 2;
            return Math.sqrt(n + r + i || 1) * .5;
        }
        setDataIds(e, n) {
            throw new Error("Unsupported operatoin setDataIds");
        }
    };
    function GD(t, e, n = !1) {
        const r = t.getCamera(), { focalPoint: i, viewPlaneNormal: a } = r, { spacingInNormalDirection: o, actorUID: s } = rg(t, r, e, n);
        if (!s) throw new Error(`Could not find image volume with id ${e} in the viewport`);
        const c = t.getActor(s);
        if (!c) return console.warn("No actor found for with actorUID of", s), null;
        const l = c.actor;
        return {
            sliceRange: Wp(l, a, i),
            spacingInNormalDirection: o,
            camera: r
        };
    }
    function Gu(t, e, n = !1) {
        const { sliceRange: r, spacingInNormalDirection: i, camera: a } = GD(t, e, n), { min: o, max: s, current: c } = r, l = Math.round((s - o) / i), u = (c - o) / (s - o) * l, g = Math.round(u);
        return {
            numScrollSteps: l,
            currentStepIndex: g,
            sliceRangeInfo: {
                sliceRange: r,
                spacingInNormalDirection: i,
                camera: a
            }
        };
    }
    function Wu(t, e, n, r, i, a) {
        const { min: o, max: s, current: c } = n, l = Xe();
        In(l, e, t);
        const f = Math.round((s - o) / i), g = (c - o) / (s - o) * f;
        let h = Math.round(g), v = [
            t[0] - r[0] * g * i,
            t[1] - r[1] * g * i,
            t[2] - r[2] * g * i
        ];
        h += a, h > f ? h = f : h < 0 && (h = 0);
        const m = h * i;
        v = [
            v[0] + r[0] * m,
            v[1] + r[1] * m,
            v[2] + r[2] * m
        ];
        const y = [
            v[0] + l[0],
            v[1] + l[1],
            v[2] + l[2]
        ];
        return {
            newFocalPoint: v,
            newPosition: y
        };
    }
    function WD(t) {
        let e = [];
        const [n, r] = t.getRange();
        t.getTable(n, r, 1024, e), e = e.filter((h, v)=>v % 3 === 0);
        const i = [
            ...Array(1024).keys()
        ].map((h, v)=>n + (r - n) / 1023 * v), a = e[256], o = Math.log((1 - a) / a), s = i[256], c = e[256 * 3], l = Math.log((1 - c) / c), f = i[256 * 3], u = Math.round(4 * (f - s) / (o - l)), g = Math.round(s + u * o / 4);
        return [
            Math.round(g - u / 2),
            Math.round(g + u / 2)
        ];
    }
    function $D(t, e) {
        const n = e.colorTransfer.split(" ").splice(1).map(parseFloat), { shiftRange: r } = Kj(n), i = r[0], a = r[1] - r[0], o = Jc.newInstance(), s = [];
        for(let S = 0; S < n.length; S += 4){
            let D = n[S];
            const _ = n[S + 1], M = n[S + 2], P = n[S + 3];
            D = (D - i) / a, s.push([
                D,
                _,
                M,
                P
            ]);
        }
        qj(s, r, o), t.getProperty().setRGBTransferFunction(0, o);
        const c = e.scalarOpacity.split(" ").splice(1).map(parseFloat), l = B0.newInstance(), f = [];
        for(let S = 0; S < c.length; S += 2){
            let D = c[S];
            const _ = c[S + 1];
            D = (D - i) / a, f.push([
                D,
                _
            ]);
        }
        Xj(f, r, l);
        const u = t.getProperty();
        u.setScalarOpacity(0, l);
        const [g, h, v, m] = e.gradientOpacity.split(" ").splice(1).map(parseFloat);
        u.setUseGradientOpacity(0, !0), u.setGradientOpacityMinimumValue(0, g), u.setGradientOpacityMinimumOpacity(0, h), u.setGradientOpacityMaximumValue(0, v), u.setGradientOpacityMaximumOpacity(0, m), e.interpolation === "1" && u.setInterpolationTypeToFastLinear(), u.setShade(e.shade === "1");
        const y = parseFloat(e.ambient), C = parseFloat(e.diffuse), T = parseFloat(e.specular), x = parseFloat(e.specularPower);
        u.setAmbient(y), u.setDiffuse(C), u.setSpecular(T), u.setSpecularPower(x);
    }
    function Kj(t) {
        let e = 1 / 0, n = -1 / 0;
        for(let i = 0; i < t.length; i += 4)e = Math.min(e, t[i]), n = Math.max(n, t[i]);
        const r = (n - e) / 2;
        return {
            shiftRange: [
                -r,
                r
            ],
            min: e,
            max: n
        };
    }
    function qj(t, e, n) {
        const r = e[1] - e[0], i = t.map(([a, o, s, c])=>[
                a * r + e[0],
                o,
                s,
                c
            ]);
        return n.removeAllPoints(), i.forEach(([a, o, s, c])=>n.addRGBPoint(a, o, s, c)), i;
    }
    function Xj(t, e, n) {
        const r = e[1] - e[0], i = t.map(([a, o])=>[
                a * r + e[0],
                o
            ]);
        return n.removeAllPoints(), i.forEach(([a, o])=>n.addPoint(a, o)), i;
    }
    const { MPR_CAMERA_VALUES: mo } = u3, { OrientationAxis: Fc } = sc;
    function zD(t, e, n, r) {
        let i;
        switch(r){
            case Fc.AXIAL:
            case Fc.AXIAL_REFORMAT:
                i = mo.axial;
                break;
            case Fc.SAGITTAL:
            case Fc.SAGITTAL_REFORMAT:
                i = mo.sagittal;
                break;
            case Fc.CORONAL:
            case Fc.CORONAL_REFORMAT:
                i = mo.coronal;
                break;
            default:
                i = mo.axial;
                break;
        }
        const a = jn(Xe(), t), o = jn(Xe(), e), s = jn(Xe(), n), c = [
            a,
            o,
            s
        ], l = [
            en(i.viewRight[0], i.viewRight[1], i.viewRight[2]),
            en(i.viewUp[0], i.viewUp[1], i.viewUp[2]),
            en(i.viewPlaneNormal[0], i.viewPlaneNormal[1], i.viewPlaneNormal[2])
        ], f = new Set, u = (m)=>{
            let y = 0, C = -2, T = !1;
            c.forEach((S, D)=>{
                if (f.has(D)) return;
                const _ = xt(m, S), M = Math.abs(_);
                M > C && (C = M, y = D, T = _ < 0);
            }), f.add(y);
            const x = px(c[y]);
            return T && jc(x, x), x;
        }, g = u(l[0]), h = u(l[1]), v = u(l[2]);
        return {
            viewPlaneNormal: [
                v[0],
                v[1],
                v[2]
            ],
            viewUp: [
                h[0],
                h[1],
                h[2]
            ],
            viewRight: [
                g[0],
                g[1],
                g[2]
            ]
        };
    }
    function jD(t, e) {
        if (!t.getActors()?.length) return;
        t.type !== On.ORTHOGRAPHIC && console.warn("Viewport should be a volume viewport");
        let n = t.getCurrentImageId();
        if (n || (n = t.getImageIds()?.[0]), !n) return;
        const { imageOrientationPatient: r } = ct("imagePlaneModule", n), i = en(r[0], r[1], r[2]), a = en(r[3], r[4], r[5]), o = bn(Xe(), i, a);
        let { orientation: s } = e || {};
        const { useViewportNormal: c } = e || {};
        let l = o;
        return c && (l = t.getCamera().viewPlaneNormal), s || (s = Yj(l)), zD(i, a, o, s);
    }
    function Yj(t) {
        const e = jn(Xe(), t), n = en(mo.axial.viewPlaneNormal[0], mo.axial.viewPlaneNormal[1], mo.axial.viewPlaneNormal[2]), r = en(mo.sagittal.viewPlaneNormal[0], mo.sagittal.viewPlaneNormal[1], mo.sagittal.viewPlaneNormal[2]), i = en(mo.coronal.viewPlaneNormal[0], mo.coronal.viewPlaneNormal[1], mo.coronal.viewPlaneNormal[2]), a = Math.abs(xt(e, n)), o = Math.abs(xt(e, r)), s = Math.abs(xt(e, i));
        return a >= o && a >= s ? Fc.AXIAL : o >= s ? Fc.SAGITTAL : Fc.CORONAL;
    }
    function HD() {
        return tf()?.rendering?.renderingEngineMode === k0.ContextPool;
    }
    So = class extends uf {
        constructor(e){
            if (super(e), this.useCPURendering = !1, this.perVolumeIdDefaultProperties = new Map, this.viewportProperties = {}, this.volumeIds = new Set, this.setRotation = (i)=>{
                const a = this.getPan(this.fitToCanvasCamera), o = this.getPan(), s = this.getCamera(), c = Yu([
                    0,
                    0
                ], a, o);
                this.setPan(c, !1);
                const { flipVertical: l } = this.getCamera(), f = l ? jc([
                    0,
                    0,
                    0
                ], this.initialViewUp) : this.initialViewUp;
                this.setCameraNoEvent({
                    viewUp: f
                }), this.rotateCamera(i);
                const u = this.getPan(), g = this.getPan(this.fitToCanvasCamera), h = Yu([
                    0,
                    0
                ], u, g), v = $3([
                    0,
                    0
                ], a, h);
                if (this.setPan(v, !1), this._suppressCameraModifiedEvents) return;
                const m = this.getCamera(), y = {
                    previousCamera: s,
                    camera: m,
                    element: this.element,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId
                };
                We(this.element, Ge.CAMERA_MODIFIED, y);
            }, this.getDefaultProperties = (i)=>{
                let a;
                return i !== void 0 && (a = this.perVolumeIdDefaultProperties.get(i)), a !== void 0 ? a : {
                    ...this.globalDefaultProperties
                };
            }, this.getProperties = (i)=>{
                if (!this._getApplicableVolumeActor(i)) return;
                const { colormap: o, VOILUTFunction: s, interpolationType: c, invert: l, slabThickness: f, preset: u } = this.viewportProperties;
                if (i ||= this.getVolumeId(), !ot.getVolume(i)) return null;
                const h = this.getActors().find((D)=>D.referencedId === i);
                if (!h) return;
                const m = h.actor.getProperty().getRGBTransferFunction(0), [y, C] = this.viewportProperties?.VOILUTFunction === "SIGMOID" ? WD(m) : m.getRange(), T = {
                    lower: y,
                    upper: C
                }, x = this.getColormap(i);
                return {
                    colormap: i && x ? x : o,
                    voiRange: T,
                    VOILUTFunction: s,
                    interpolationType: c,
                    invert: l,
                    slabThickness: f,
                    preset: u
                };
            }, this.getColormap = (i)=>{
                const a = this._getApplicableVolumeActor(i);
                if (!a) return;
                const { volumeActor: o } = a, s = this._getOrCreateColorTransferFunction(i), { nodes: c } = s.getState(), l = c.reduce((h, v)=>(h.push(v.x, v.r, v.g, v.b), h), []), f = H3(l, o) || {}, u = q3(o), g = X3(o);
                return f.threshold = u, f.opacity = g, f;
            }, this.getRotation = ()=>{
                const { viewUp: i, viewPlaneNormal: a, flipVertical: o } = this.getCameraNoRotation(), s = o ? jc([
                    0,
                    0,
                    0
                ], this.initialViewUp) : this.initialViewUp;
                if (!s) return 0;
                const c = vx(s, i) * 180 / Math.PI, l = bn([
                    0,
                    0,
                    0
                ], s, i);
                return xt(l, a) >= 0 ? c : (360 - c) % 360;
            }, this.getFrameOfReferenceUID = ()=>this._FrameOfReferenceUID, this.canvasToWorldTiled = (i)=>{
                const a = this.getVtkActiveCamera();
                a.setIsPerformingCoordinateTransformation?.(!0);
                const o = this.getRenderer(), s = this.getVtkDisplayCoordsTiled(i), f = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow().displayToWorld(s[0], s[1], s[2], o);
                return a.setIsPerformingCoordinateTransformation?.(!1), [
                    f[0],
                    f[1],
                    f[2]
                ];
            }, this.canvasToWorldContextPool = (i)=>{
                const a = this.getVtkActiveCamera();
                a.setIsPerformingCoordinateTransformation?.(!0);
                const o = this.getRenderer(), s = window.devicePixelRatio || 1, { width: c, height: l } = this.canvas, f = c / l, u = [
                    i[0] * s,
                    i[1] * s
                ], g = [
                    u[0] / c,
                    1 - u[1] / l,
                    0
                ], h = o.normalizedDisplayToProjection(g[0], g[1], g[2]), v = o.projectionToView(h[0], h[1], h[2], f), m = o.viewToWorld(v[0], v[1], v[2]);
                return a.setIsPerformingCoordinateTransformation?.(!1), [
                    m[0],
                    m[1],
                    m[2]
                ];
            }, this.getVtkDisplayCoordsTiled = (i)=>{
                const a = window.devicePixelRatio || 1, o = [
                    i[0] * a,
                    i[1] * a
                ], l = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow().getSize(), f = [
                    o[0] + this.sx,
                    o[1] + this.sy
                ];
                return f[1] = l[1] - f[1], [
                    f[0],
                    f[1],
                    0
                ];
            }, this.getVtkDisplayCoordsContextPool = (i)=>{
                const a = window.devicePixelRatio || 1, o = [
                    i[0] * a,
                    i[1] * a
                ], { height: s } = this.canvas, c = [
                    o[0],
                    s - o[1]
                ];
                return [
                    c[0],
                    c[1],
                    0
                ];
            }, this.worldToCanvasTiled = (i)=>{
                const a = this.getVtkActiveCamera();
                a.setIsPerformingCoordinateTransformation?.(!0);
                const o = this.getRenderer(), c = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), l = c.getSize(), f = c.worldToDisplay(...i, o);
                f[1] = l[1] - f[1];
                const u = [
                    f[0] - this.sx,
                    f[1] - this.sy
                ], g = window.devicePixelRatio || 1, h = [
                    u[0] / g,
                    u[1] / g
                ];
                return a.setIsPerformingCoordinateTransformation(!1), h;
            }, this.worldToCanvasContextPool = (i)=>{
                const a = this.getVtkActiveCamera();
                a.setIsPerformingCoordinateTransformation?.(!0);
                const o = this.getRenderer(), { width: s, height: c } = this.canvas, l = s / c, f = o.worldToView(i[0], i[1], i[2]), u = o.viewToProjection(f[0], f[1], f[2], l), g = o.projectionToNormalizedDisplay(u[0], u[1], u[2]), h = g[0] * s, v = (1 - g[1]) * c, m = window.devicePixelRatio || 1, y = [
                    h / m,
                    v / m
                ];
                return a.setIsPerformingCoordinateTransformation(!1), y;
            }, this.hasImageURI = (i)=>this.getActors().filter((o)=>Ya(o, "vtkVolume")).some(({ uid: o, referencedId: s })=>{
                    const c = ot.getVolume(s || o);
                    return c?.imageIds ? c.imageIds.map(ur).includes(i) : !1;
                }), this.getImageIds = (i)=>{
                const a = this._getApplicableVolumeActor(i);
                if (!a) throw new Error(`No actor found for the given volumeId: ${i}`);
                const o = a.volumeId, s = ot.getVolume(o);
                if (!s) throw new Error(`imageVolume with id: ${o} does not exist in cache`);
                return s.imageIds;
            }, this.renderingPipelineFunctions = {
                worldToCanvas: {
                    tiled: this.worldToCanvasTiled,
                    contextPool: this.worldToCanvasContextPool
                },
                canvasToWorld: {
                    tiled: this.canvasToWorldTiled,
                    contextPool: this.canvasToWorldContextPool
                },
                getVtkDisplayCoords: {
                    tiled: this.getVtkDisplayCoordsTiled,
                    contextPool: this.getVtkDisplayCoordsContextPool
                },
                getRenderer: {
                    tiled: this.getRendererTiled,
                    contextPool: this.getRendererContextPool
                }
            }, this.useCPURendering = gd(), this.useCPURendering) throw new Error("VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.");
            this._configureRenderingPipeline();
            const n = this.getRenderer(), r = rj.newInstance();
            switch(n.setActiveCamera(r), this.type){
                case On.ORTHOGRAPHIC:
                    r.setParallelProjection(!0);
                    break;
                case On.VOLUME_3D:
                    r.setParallelProjection(!0);
                    break;
                case On.PERSPECTIVE:
                    r.setParallelProjection(!1);
                    break;
                default:
                    throw new Error(`Unrecognized viewport type: ${this.type}`);
            }
            this.initializeVolumeNewImageEventDispatcher();
        }
        static get useCustomRenderingPipeline() {
            return !1;
        }
        getSliceViewInfo() {
            throw new Error("Method not implemented.");
        }
        applyViewOrientation(e, n = !0) {
            const { viewPlaneNormal: r, viewUp: i } = this._getOrientationVectors(e) || {};
            if (!r || !i) return;
            const a = this.getVtkActiveCamera();
            a.setDirectionOfProjection(-r[0], -r[1], -r[2]), a.setViewUpFrom(i), this.initialViewUp = i, n && this.resetCamera({
                resetOrientation: !1,
                resetRotation: !1
            });
        }
        initializeVolumeNewImageEventDispatcher() {
            const e = r.bind(this), n = i.bind(this);
            function r(a) {
                const { viewportId: o } = a.detail;
                o !== this.id || this.isDisabled || !this.getImageData() || $j(a);
            }
            function i(a) {
                const { viewportId: o } = a.detail;
                o === this.id && (this.element.removeEventListener(Ge.CAMERA_MODIFIED, e), Ke.removeEventListener(Ge.ELEMENT_DISABLED, n), Wj(o));
            }
            this.element.removeEventListener(Ge.CAMERA_MODIFIED, e), this.element.addEventListener(Ge.CAMERA_MODIFIED, e), Ke.addEventListener(Ge.ELEMENT_DISABLED, n);
        }
        setVOILUTFunction(e, n, r) {
            Object.values(zi).includes(e) || (e = zi.LINEAR);
            const { voiRange: i } = this.getProperties();
            this.setVOI(i, n, r), this.viewportProperties.VOILUTFunction = e;
        }
        setColormap(e, n, r) {
            const i = this._getApplicableVolumeActor(n);
            if (!i) return;
            const { volumeActor: a } = i, o = Jc.newInstance();
            let s = Md(e.name);
            const { name: c } = e;
            if (s || (s = Id.getPresetByName(c)), !s) throw new Error(`Colormap ${e} not found`);
            const l = a.getProperty().getRGBTransferFunction(0).getRange();
            if (o.applyColorMap(s), o.setMappingRange(l[0], l[1]), a.getProperty().setRGBTransferFunction(0, o), this.viewportProperties.colormap = e, !r) {
                const f = this.getColormap(n), u = {
                    viewportId: this.id,
                    colormap: f,
                    volumeId: n
                };
                We(this.element, Ge.VOI_MODIFIED, u), We(this.element, Ge.COLORMAP_MODIFIED, u);
            }
        }
        setOpacity(e, n) {
            const r = this._getApplicableVolumeActor(n);
            if (!r) return;
            const { volumeActor: i } = r, a = B0.newInstance();
            typeof e.opacity == "number" ? Dx(i, e.opacity) : (e.opacity.forEach(({ opacity: c, value: l })=>{
                a.addPoint(l, c);
            }), i.getProperty().setScalarOpacity(0, a)), this.viewportProperties.colormap || (this.viewportProperties.colormap = {}), this.viewportProperties.colormap.opacity = e.opacity;
            const o = this.getColormap(n), s = {
                viewportId: this.id,
                colormap: o,
                volumeId: n
            };
            We(this.element, Ge.COLORMAP_MODIFIED, s);
        }
        setInvert(e, n, r) {
            const i = this._getApplicableVolumeActor(n);
            if (!i) return;
            const a = i.volumeId, o = this._getOrCreateColorTransferFunction(a);
            if (pd(o), this.viewportProperties.invert = e, !r) {
                const s = {
                    ...this.getVOIModifiedEventDetail(a),
                    invertStateChanged: !0
                };
                We(this.element, Ge.VOI_MODIFIED, s);
            }
        }
        getVOIModifiedEventDetail(e) {
            const n = this._getApplicableVolumeActor(e);
            if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
            const a = n.volumeActor.getProperty().getRGBTransferFunction(0).getMappingRange(), o = this.getColormap(e), { VOILUTFunction: s, invert: c } = this.getProperties(e);
            return {
                viewportId: this.id,
                range: {
                    lower: a[0],
                    upper: a[1]
                },
                volumeId: n.volumeId,
                VOILUTFunction: s,
                colormap: o,
                invert: c
            };
        }
        _getOrCreateColorTransferFunction(e) {
            const n = this._getApplicableVolumeActor(e);
            if (!n) return null;
            const { volumeActor: r } = n, i = r.getProperty().getRGBTransferFunction(0);
            if (i) return i;
            const a = Jc.newInstance();
            return r.getProperty().setRGBTransferFunction(0, a), a;
        }
        setInterpolationType(e, n) {
            const r = this._getApplicableVolumeActor(n);
            if (!r) return;
            const { volumeActor: i } = r;
            i.getProperty().setInterpolationType(e), this.viewportProperties.interpolationType = e;
        }
        setVOI(e, n, r = !1) {
            const i = this._getApplicableVolumeActor(n);
            if (!i) return;
            const { volumeActor: a } = i, o = i.volumeId, s = e;
            if (typeof s > "u") throw new Error("voiRangeToUse is undefined, need to implement this in the new volume model");
            const { VOILUTFunction: c } = this.getProperties(o);
            if (c === zi.SAMPLED_SIGMOID) {
                const l = Y3(s);
                a.getProperty().setRGBTransferFunction(0, l);
            } else {
                const { lower: l, upper: f } = s;
                a.getProperty().getRGBTransferFunction(0).setRange(l, f);
            }
            if (!r) {
                const l = {
                    ...this.getVOIModifiedEventDetail(o)
                };
                We(this.element, Ge.VOI_MODIFIED, l);
            }
            this.viewportProperties.voiRange = s;
        }
        rotateCamera(e) {
            const n = e - this.getRotation();
            this.getVtkActiveCamera().roll(-n);
        }
        setDefaultProperties(e, n) {
            n == null ? this.globalDefaultProperties = e : this.perVolumeIdDefaultProperties.set(n, e);
        }
        clearDefaultProperties(e) {
            e == null ? (this.globalDefaultProperties = {}, this.resetProperties()) : (this.perVolumeIdDefaultProperties.delete(e), this.resetToDefaultProperties(e));
        }
        getViewReference(e = {}) {
            const n = super.getViewReference(e), r = this.getVolumeId(e);
            if (e?.forFrameOfReference !== !1 && (n.volumeId = r), typeof e?.sliceIndex != "number") return n;
            const { viewPlaneNormal: i } = n, a = e?.sliceIndex - this.getSliceIndex(), { sliceRangeInfo: o } = Gu(this, r, !0), { sliceRange: s, spacingInNormalDirection: c, camera: l } = o, { focalPoint: f, position: u } = l, { newFocalPoint: g } = Wu(f, u, s, i, c, a);
            return n.cameraFocalPoint = g, n;
        }
        isReferenceViewable(e, n) {
            if (!e.FrameOfReferenceUID || !super.isReferenceViewable(e, n)) return !1;
            if (n?.withNavigation) return !0;
            const r = this.getSliceIndex(), { sliceIndex: i } = e;
            return Array.isArray(i) ? i[0] <= r && r <= i[1] : i === void 0 || i === r;
        }
        scroll(e = 1) {
            const n = this.getVolumeId(), { sliceRangeInfo: r } = Gu(this, n, !0);
            if (!r) return;
            const { sliceRange: i, spacingInNormalDirection: a, camera: o } = r, { focalPoint: s, viewPlaneNormal: c, position: l } = o, { newFocalPoint: f, newPosition: u } = Wu(s, l, i, c, a, e);
            this.setCamera({
                focalPoint: f,
                position: u
            }), this.render();
        }
        setViewReference(e) {
            if (!e) return;
            const n = this.getVolumeId(), { viewPlaneNormal: r, FrameOfReferenceUID: i, cameraFocalPoint: a, referencedImageId: o, viewUp: s } = e;
            let { sliceIndex: c } = e;
            const { focalPoint: l, viewPlaneNormal: f, position: u } = this.getCamera(), g = Sx(f, r), h = lr(f, r);
            if (typeof c == "number" && n !== void 0 && e.volumeId === n && (g || h)) {
                const { currentStepIndex: v, sliceRangeInfo: m, numScrollSteps: y } = Gu(this, n, !0), { sliceRange: C, spacingInNormalDirection: T } = m;
                g && (c = y - c - 1);
                const x = c - v, { newFocalPoint: S, newPosition: D } = Wu(l, u, C, f, T, x);
                this.setCamera({
                    focalPoint: S,
                    position: D
                });
            } else if (i === this.getFrameOfReferenceUID()) {
                if (r && !g && !h) {
                    this.setOrientation({
                        viewPlaneNormal: r,
                        viewUp: s
                    }), this.setViewReference(e);
                    return;
                }
                if (o && this.isInAcquisitionPlane()) {
                    const v = ct(Ia.IMAGE_PLANE, o), { imagePositionPatient: m } = v, { focalPoint: y } = this.getCamera(), C = kr(Xe(), y, m), T = xt(C, f), x = $i(Xe(), y, [
                        -f[0],
                        -f[1],
                        -f[2]
                    ], T);
                    this.setCamera({
                        focalPoint: x
                    }), this.render();
                    return;
                }
                if (a) {
                    const v = kr([
                        0,
                        0,
                        0
                    ], a, l), m = r ?? f, y = xt(v, m);
                    lr(y, 0) || Ys(v, m, y);
                    const C = Qc([
                        0,
                        0,
                        0
                    ], l, v), T = Qc([
                        0,
                        0,
                        0
                    ], u, v);
                    this.setCamera({
                        focalPoint: C,
                        position: T
                    });
                }
            } else throw new Error(`Incompatible view refs: ${i}!==${this.getFrameOfReferenceUID()}`);
        }
        setThreshold(e, n) {
            const r = this._getApplicableVolumeActor(n);
            if (!r) return;
            const { volumeActor: i } = r;
            _x(i, e.threshold), this.viewportProperties.colormap || (this.viewportProperties.colormap = {}), this.viewportProperties.colormap.threshold = e.threshold;
            const a = this.getColormap(n), o = {
                viewportId: this.id,
                colormap: a,
                volumeId: n
            };
            We(this.element, Ge.COLORMAP_MODIFIED, o);
        }
        setProperties({ voiRange: e, VOILUTFunction: n, invert: r, colormap: i, preset: a, interpolationType: o, slabThickness: s } = {}, c, l = !1) {
            this.globalDefaultProperties == null && this.setDefaultProperties({
                voiRange: e,
                VOILUTFunction: n,
                invert: r,
                colormap: i,
                preset: a,
                slabThickness: s
            }), r !== void 0 && this.viewportProperties.invert !== r && this.setInvert(r, c, l), i?.name && this.setColormap(i, c, l), i?.opacity != null && this.setOpacity(i, c), i?.threshold != null && this.setThreshold(i, c), e !== void 0 && this.setVOI(e, c, l), typeof o < "u" && this.setInterpolationType(o), n !== void 0 && this.setVOILUTFunction(n, c, l), a !== void 0 && this.setPreset(a, c, l), s !== void 0 && this.setSlabThickness(s);
        }
        resetToDefaultProperties(e) {
            const n = this.globalDefaultProperties;
            n.colormap?.name && this.setColormap(n.colormap, e), n.colormap?.opacity != null && this.setOpacity(n.colormap, e), n.voiRange !== void 0 && this.setVOI(n.voiRange, e), n.VOILUTFunction !== void 0 && this.setVOILUTFunction(n.VOILUTFunction, e), n.invert !== void 0 && this.setInvert(n.invert, e), n.slabThickness !== void 0 && (this.setSlabThickness(n.slabThickness), this.viewportProperties.slabThickness = n.slabThickness), n.preset !== void 0 && this.setPreset(n.preset, e, !1), n.preset !== void 0 && this.setPreset(n.preset, e, !1), this.render();
        }
        setPreset(e, n, r) {
            const i = this._getApplicableVolumeActor(n);
            if (!i) return;
            const { volumeActor: a } = i;
            let o = e;
            typeof o == "string" && (o = z7.find((s)=>s.name === e)), o && ($D(a, o), this.viewportProperties.preset = o, this.render(), r || We(this.element, Ge.PRESET_MODIFIED, {
                viewportId: this.id,
                volumeId: i.volumeId,
                actor: a,
                presetName: o.name
            }));
        }
        async setVolumes(e, n = !1, r = !1) {
            const i = e[0].volumeId, a = ot.getVolume(i);
            if (!a) throw new Error(`imageVolume with id: ${i} does not exist, you need to create/allocate the volume first`);
            const o = a.metadata.FrameOfReferenceUID;
            this._isValidVolumeInputArray(e, o), this._FrameOfReferenceUID = o, e.forEach((c)=>{
                this._addVolumeId(c.volumeId);
            });
            const s = [];
            for(let c = 0; c < e.length; c++){
                const { volumeId: l, actorUID: f, slabThickness: u, ...g } = e[c], h = await Wv(e[c], this.element, this.id, r), v = f || Vn();
                s.push({
                    uid: v,
                    actor: h,
                    slabThickness: u,
                    referencedId: l,
                    ...g
                });
            }
            this._setVolumeActors(s), this.viewportStatus = sa.PRE_RENDER, this.initializeColorTransferFunction(e), We(this.element, Ge.VOLUME_VIEWPORT_NEW_VOLUME, {
                viewportId: this.id,
                volumeActors: s
            }), n && this.render();
        }
        async addVolumes(e, n = !1, r = !1) {
            const i = ot.getVolume(e[0].volumeId);
            if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
            const a = [];
            this._isValidVolumeInputArray(e, this._FrameOfReferenceUID), e.forEach((o)=>{
                this._addVolumeId(o.volumeId);
            });
            for(let o = 0; o < e.length; o++){
                const { volumeId: s, visibility: c, actorUID: l, slabThickness: f, ...u } = e[o], g = await Wv(e[o], this.element, this.id, r);
                c || g.setVisibility(!1);
                const h = l || Vn();
                a.push({
                    uid: h,
                    actor: g,
                    slabThickness: f,
                    referencedId: s,
                    ...u
                });
            }
            this.addActors(a), this.initializeColorTransferFunction(e), n && this.render();
        }
        removeVolumeActors(e, n = !1) {
            this.removeActors(e), n && this.render();
        }
        setOrientation(e, n = !0) {
            console.warn('Method "setOrientation" needs implementation');
        }
        initializeColorTransferFunction(e) {
            const n = e[0].volumeId, r = this._getOrCreateColorTransferFunction(n);
            !this.initialTransferFunctionNodes && r && (this.initialTransferFunctionNodes = Hh(r));
        }
        _getApplicableVolumeActor(e) {
            const n = this.getActors();
            if (!n?.length) return;
            if (e) {
                const i = n.find((a)=>a.referencedId === e);
                return i ? {
                    volumeActor: i.actor,
                    volumeId: e,
                    actorUID: i.uid
                } : void 0;
            }
            const r = n[0];
            return {
                volumeActor: r.actor,
                volumeId: r.referencedId,
                actorUID: r.uid
            };
        }
        async _isValidVolumeInputArray(e, n) {
            const r = e.length;
            for(let i = 1; i < r; i++){
                const a = ot.getVolume(e[i].volumeId);
                if (n !== a.metadata.FrameOfReferenceUID) throw new Error(`Volumes being added to viewport ${this.id} do not share the same FrameOfReferenceUID. This is not yet supported`);
            }
            return !0;
        }
        getBounds() {
            return this.getRenderer().computeVisiblePropBounds();
        }
        flip(e) {
            super.flip(e);
        }
        hasVolumeId(e) {
            return this.volumeIds.has(e);
        }
        hasVolumeURI(e) {
            for (const n of this.volumeIds)if (n.includes(e)) return !0;
            return !1;
        }
        getImageData(e) {
            if (!this.getDefaultActor()) return;
            e ||= this.getVolumeId();
            const r = this.getActors()?.find((s)=>s.referencedId === e);
            if (!Ya(r, "vtkVolume")) return;
            const i = r.actor, a = ot.getVolume(e), o = i.getMapper().getInputData();
            return {
                dimensions: o.getDimensions(),
                spacing: o.getSpacing(),
                origin: o.getOrigin(),
                direction: o.getDirection(),
                imageData: i.getMapper().getInputData(),
                metadata: {
                    Modality: a?.metadata?.Modality,
                    FrameOfReferenceUID: a?.metadata?.FrameOfReferenceUID
                },
                get scalarData () {
                    return a?.voxelManager?.getScalarData();
                },
                scaling: a?.scaling,
                hasPixelSpacing: !0,
                voxelManager: a?.voxelManager
            };
        }
        setCameraClippingRange() {
            throw new Error("Method not implemented.");
        }
        getSliceIndex() {
            throw new Error("Method not implemented.");
        }
        setCamera(e, n) {
            super.setCamera(e, n), this.setCameraClippingRange();
        }
        _setVolumeActors(e) {
            for(let n = 0; n < e.length; n++)this.viewportProperties.invert = !1;
            this.setActors(e);
        }
        getRendererContextPool() {
            return this.getRenderingEngine().getRenderer(this.id);
        }
        getRendererTiled() {
            const e = this.getRenderingEngine();
            if (!e || e.hasBeenDestroyed) throw new Error("Rendering engine has been destroyed");
            return e.offscreenMultiRenderWindow?.getRenderer(this.id);
        }
        _getOrientationVectors(e) {
            if (typeof e == "object") {
                if (e.viewPlaneNormal && e.viewUp) return e;
                throw new Error("Invalid orientation object. It must contain viewPlaneNormal and viewUp");
            } else if (typeof e == "string") {
                if (e === "acquisition") return this._getAcquisitionPlaneOrientation();
                if (e === "reformat" || e.includes("_reformat")) return jD(this, {
                    useViewportNormal: !0
                });
                if (Il[e]) return this.viewportProperties.orientation = e, Il[e];
            }
            throw new Error(`Invalid orientation: ${e}. Valid orientations are: ${Object.keys(Il).join(", ")}`);
        }
        _getAcquisitionPlaneOrientation() {
            if (!this.getDefaultActor()) return;
            const n = this.getVolumeId(), r = ot.getVolume(n);
            if (!r) throw new Error(`imageVolume with id: ${n} does not exist in cache`);
            const { direction: i } = r, a = i.slice(6, 9).map((s)=>-s), o = i.slice(3, 6).map((s)=>-s);
            return {
                viewPlaneNormal: a,
                viewUp: o
            };
        }
        getSlabThickness() {
            const e = this.getActors();
            let n = Er.MINIMUM_SLAB_THICKNESS;
            return e.forEach((r)=>{
                r.slabThickness > n && (n = r.slabThickness);
            }), n;
        }
        getIntensityFromWorld(e) {
            const n = this.getDefaultActor();
            if (!Ya(n, "vtkVolume")) return;
            const { actor: r } = n, i = r.getMapper().getInputData(), a = ot.getVolume(this.getVolumeId()), o = Co(i, e);
            return a.voxelManager.getAtIJKPoint(o);
        }
        getVolumeId(e) {
            const n = this.getActors();
            if (!n) return;
            if (!e?.volumeId) {
                const i = n.find((a)=>a.actor.getClassName() === "vtkVolume");
                return i?.referencedId || i?.uid;
            }
            const r = n.find((i)=>i.actor.getClassName() === "vtkVolume" && i.referencedId === e?.volumeId);
            return r?.referencedId || r?.uid;
        }
        getViewReferenceId(e = {}) {
            let { volumeId: n, sliceIndex: r } = e;
            if (!n) {
                const c = this.getActors();
                if (!c) return;
                n = c.find((l)=>l.actor.getClassName() === "vtkVolume")?.referencedId;
            }
            const i = this.getSliceIndex();
            r ??= i;
            const { viewPlaneNormal: a, focalPoint: o } = this.getCamera(), s = n.includes("?") ? "&" : "?";
            return `volumeId:${n}${s}sliceIndex=${r}&viewPlaneNormal=${a.join(",")}`;
        }
        _addVolumeId(e) {
            this.volumeIds.add(e);
        }
        getAllVolumeIds() {
            return Array.from(this.volumeIds);
        }
        _configureRenderingPipeline() {
            const e = HD();
            for(const n in this.renderingPipelineFunctions)if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, n)) {
                const r = this.renderingPipelineFunctions[n];
                this[n] = e ? r.contextPool : r.tiled;
            }
        }
    };
    function Zj(t, e) {
        e.classHierarchy.push("vtkAbstractImageMapper"), t.getIsOpaque = ()=>!0, t.getCurrentImage = ()=>null, t.getBoundsForSlice = ()=>(K.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"), Gl());
    }
    const Jj = {
        slice: 0,
        customDisplayExtent: [
            0,
            0,
            0,
            0,
            0,
            0
        ],
        useCustomExtents: !1,
        backgroundColor: [
            0,
            0,
            0,
            1
        ]
    };
    function Qj(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, Jj, n), m4.extend(t, e, n), K.setGet(t, e, [
            "slice",
            "useCustomExtents"
        ]), K.setGetArray(t, e, [
            "customDisplayExtent"
        ], 6), K.setGetArray(t, e, [
            "backgroundColor"
        ], 4), Zj(t, e);
    }
    var eH = {
        extend: Qj
    };
    function KD(t, e, n) {
        const r = n.getCurrentImage(), i = r.getExtent(), a = [
            i[0],
            i[2],
            i[4]
        ], { ijkMode: o } = n.getClosestIJKAxis();
        let s = n.isA("vtkImageArrayMapper") ? n.getSubSlice() : n.getSlice();
        o !== n.getSlicingMode() && (s = n.getSliceAtPosition(s)), a[o] += s;
        const c = [
            0,
            0,
            0
        ];
        r.indexToWorld(a, c), a[o] += 1;
        const l = [
            0,
            0,
            0
        ];
        r.indexToWorld(a, l), l[0] -= c[0], l[1] -= c[1], l[2] -= c[2], jn(l, l);
        const f = ca.intersectWithLine(t, e, c, l);
        if (f.intersection) {
            const u = f.x, g = [
                0,
                0,
                0
            ];
            return r.worldToIndex(u, g), {
                t: f.t,
                absoluteIJK: g
            };
        }
        return null;
    }
    function tH(t, e, n) {
        const r = KD(t, e, n);
        if (r) {
            const a = n.getCurrentImage().getExtent(), o = [
                Math.round(r.absoluteIJK[0]),
                Math.round(r.absoluteIJK[1]),
                Math.round(r.absoluteIJK[2])
            ];
            return o[0] < a[0] || o[0] > a[1] || o[1] < a[2] || o[1] > a[3] || o[2] < a[4] || o[2] > a[5] ? null : {
                t: r.t,
                ijk: o
            };
        }
        return null;
    }
    function nH(t, e, n) {
        const r = KD(t, e, n);
        if (r) {
            const a = n.getCurrentImage().getExtent(), o = r.absoluteIJK, s = [
                Math.floor(o[0]),
                Math.floor(o[1]),
                Math.floor(o[2])
            ];
            if (s[0] < a[0] || s[0] > a[1] - 1 || s[1] < a[2] || s[1] > a[3] - 1 || s[2] < a[4] || s[2] > (a[5] ? a[5] - 1 : a[5])) return null;
            const c = [
                o[0] - s[0],
                o[1] - s[1],
                o[2] - s[2]
            ];
            return {
                t: r.t,
                ijk: s,
                pCoords: c
            };
        }
        return null;
    }
    const { staticOffsetAPI: rH, otherStaticMethods: iH } = Np, { SlicingMode: gn } = Ap;
    function aH(t, e) {
        e.classHierarchy.push("vtkImageMapper"), t.getSliceAtPosition = (r)=>{
            const i = t.getCurrentImage();
            let a;
            if (r.length === 3) a = r;
            else if (Number.isFinite(r)) {
                const f = i.getBounds();
                switch(e.slicingMode){
                    case gn.X:
                        a = [
                            r,
                            (f[3] + f[2]) / 2,
                            (f[5] + f[4]) / 2
                        ];
                        break;
                    case gn.Y:
                        a = [
                            (f[1] + f[0]) / 2,
                            r,
                            (f[5] + f[4]) / 2
                        ];
                        break;
                    case gn.Z:
                        a = [
                            (f[1] + f[0]) / 2,
                            (f[3] + f[2]) / 2,
                            r
                        ];
                        break;
                }
            }
            const o = [
                0,
                0,
                0
            ];
            i.worldToIndex(a, o);
            const s = i.getExtent(), { ijkMode: c } = t.getClosestIJKAxis();
            let l = 0;
            switch(c){
                case gn.I:
                    l = ys(o[0], s[0], s[1]);
                    break;
                case gn.J:
                    l = ys(o[1], s[2], s[3]);
                    break;
                case gn.K:
                    l = ys(o[2], s[4], s[5]);
                    break;
                default:
                    return 0;
            }
            return l;
        }, t.setSliceFromCamera = (r)=>{
            const i = r.getFocalPoint();
            switch(e.slicingMode){
                case gn.I:
                case gn.J:
                case gn.K:
                    {
                        const a = t.getSliceAtPosition(i);
                        t.setSlice(a);
                    }
                    break;
                case gn.X:
                    t.setSlice(i[0]);
                    break;
                case gn.Y:
                    t.setSlice(i[1]);
                    break;
                case gn.Z:
                    t.setSlice(i[2]);
                    break;
            }
        }, t.setXSlice = (r)=>{
            t.setSlicingMode(gn.X), t.setSlice(r);
        }, t.setYSlice = (r)=>{
            t.setSlicingMode(gn.Y), t.setSlice(r);
        }, t.setZSlice = (r)=>{
            t.setSlicingMode(gn.Z), t.setSlice(r);
        }, t.setISlice = (r)=>{
            t.setSlicingMode(gn.I), t.setSlice(r);
        }, t.setJSlice = (r)=>{
            t.setSlicingMode(gn.J), t.setSlice(r);
        }, t.setKSlice = (r)=>{
            t.setSlicingMode(gn.K), t.setSlice(r);
        }, t.getSlicingModeNormal = ()=>{
            const r = [
                0,
                0,
                0
            ], i = t.getCurrentImage().getDirection();
            switch(e.slicingMode){
                case gn.X:
                    r[0] = 1;
                    break;
                case gn.Y:
                    r[1] = 1;
                    break;
                case gn.Z:
                    r[2] = 1;
                    break;
                case gn.I:
                    th(i, [
                        1,
                        0,
                        0
                    ], r);
                    break;
                case gn.J:
                    th(i, [
                        0,
                        1,
                        0
                    ], r);
                    break;
                case gn.K:
                    th(i, [
                        0,
                        0,
                        1
                    ], r);
                    break;
            }
            return r;
        };
        function n() {
            let r;
            switch(e.slicingMode){
                case gn.X:
                    r = 0;
                    break;
                case gn.Y:
                    r = 1;
                    break;
                case gn.Z:
                    r = 2;
                    break;
                default:
                    e.closestIJKAxis = {
                        ijkMode: e.slicingMode,
                        flip: !1
                    };
                    return;
            }
            const i = t.getCurrentImage().getDirection(), a = XT(i);
            let o = 0;
            for(; o < 3 && a[r + 3 * o] === 0; ++o);
            const s = a[r + 3 * o] < 0;
            e.closestIJKAxis = {
                ijkMode: o,
                flip: s
            };
        }
        t.setSlicingMode = (r)=>{
            e.slicingMode !== r && (e.slicingMode = r, t.getCurrentImage() && n(), t.modified());
        }, t.getClosestIJKAxis = ()=>((e.closestIJKAxis === void 0 || e.closestIJKAxis.ijkMode === gn.NONE) && t.getCurrentImage() && n(), e.closestIJKAxis), t.getBounds = ()=>{
            const r = t.getCurrentImage();
            if (!r) return Gl();
            if (!e.useCustomExtents) return r.getBounds();
            const i = e.customDisplayExtent.slice(), { ijkMode: a } = t.getClosestIJKAxis();
            let o = e.slice;
            switch(a !== e.slicingMode && (o = t.getSliceAtPosition(e.slice)), a){
                case gn.I:
                    i[0] = o, i[1] = o;
                    break;
                case gn.J:
                    i[2] = o, i[3] = o;
                    break;
                case gn.K:
                    i[4] = o, i[5] = o;
                    break;
            }
            return r.extentToBounds(i);
        }, t.getBoundsForSlice = function() {
            let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.slice, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const a = t.getCurrentImage();
            if (!a) return Gl();
            const o = a.getSpatialExtent(), { ijkMode: s } = t.getClosestIJKAxis();
            let c = r;
            switch(s !== e.slicingMode && (c = t.getSliceAtPosition(r)), s){
                case gn.I:
                    o[0] = c - i, o[1] = c + i;
                    break;
                case gn.J:
                    o[2] = c - i, o[3] = c + i;
                    break;
                case gn.K:
                    o[4] = c - i, o[5] = c + i;
                    break;
            }
            return a.extentToBounds(o);
        }, t.intersectWithLineForPointPicking = (r, i)=>tH(r, i, t), t.intersectWithLineForCellPicking = (r, i)=>nH(r, i, t), t.getCurrentImage = ()=>t.getInputData();
    }
    const oH = {
        slicingMode: gn.NONE,
        closestIJKAxis: {
            ijkMode: gn.NONE,
            flip: !1
        },
        renderToRectangle: !1,
        sliceAtFocalPoint: !1,
        preferSizeOverAccuracy: !1
    };
    function qD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, oH, n), eH.extend(t, e, n), K.get(t, e, [
            "slicingMode"
        ]), K.setGet(t, e, [
            "closestIJKAxis",
            "renderToRectangle",
            "sliceAtFocalPoint",
            "preferSizeOverAccuracy"
        ]), Np.implementCoincidentTopologyMethods(t, e), aH(t, e);
    }
    const sH = K.newInstance(qD, "vtkImageMapper");
    var cH = {
        newInstance: sH,
        extend: qD,
        ...rH,
        ...iH,
        ...Ap
    };
    const { InterpolationType: hh } = IU, { vtkErrorMacro: RC } = K, ph = 4;
    function lH(t, e) {
        e.classHierarchy.push("vtkImageProperty"), t.getMTime = ()=>{
            let n = e.mtime, r;
            for(let i = 0; i < ph; i++)e.componentData[i].rGBTransferFunction && (r = e.componentData[i].rGBTransferFunction.getMTime(), n = n > r ? n : r), e.componentData[i].piecewiseFunction && (r = e.componentData[i].piecewiseFunction.getMTime(), n = n > r ? n : r);
            return n;
        }, t.setRGBTransferFunction = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
            return Number.isInteger(n) || (a = n, i = 0), e.componentData[i].rGBTransferFunction !== a ? (e.componentData[i].rGBTransferFunction = a, t.modified(), !0) : !1;
        }, t.getRGBTransferFunction = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.componentData[n].rGBTransferFunction;
        }, t.setPiecewiseFunction = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
            return Number.isInteger(n) || (a = n, i = 0), e.componentData[i].piecewiseFunction !== a ? (e.componentData[i].piecewiseFunction = a, t.modified(), !0) : !1;
        }, t.getPiecewiseFunction = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return e.componentData[n].piecewiseFunction;
        }, t.setScalarOpacity = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = n, a = r;
            return Number.isInteger(n) || (a = n, i = 0), t.setPiecewiseFunction(i, a);
        }, t.getScalarOpacity = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return t.getPiecewiseFunction(n);
        }, t.setComponentWeight = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            if (n < 0 || n >= ph) return RC("Invalid index"), !1;
            const i = Math.min(1, Math.max(0, r));
            return e.componentData[n].componentWeight !== i ? (e.componentData[n].componentWeight = i, t.modified(), !0) : !1;
        }, t.getComponentWeight = function() {
            let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return n < 0 || n >= ph ? (RC("Invalid index"), 0) : e.componentData[n].componentWeight;
        }, t.setInterpolationTypeToNearest = ()=>t.setInterpolationType(hh.NEAREST), t.setInterpolationTypeToLinear = ()=>t.setInterpolationType(hh.LINEAR), t.getInterpolationTypeAsString = ()=>K.enumToString(hh, e.interpolationType);
    }
    const uH = {
        independentComponents: !1,
        interpolationType: hh.LINEAR,
        colorWindow: 255,
        colorLevel: 127.5,
        ambient: 1,
        diffuse: 0,
        opacity: 1,
        useLookupTableScalarRange: !1,
        useLabelOutline: !1,
        labelOutlineThickness: [
            1
        ],
        labelOutlineOpacity: 1
    };
    function fH(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (Object.assign(e, uH, n), K.obj(t, e), !e.componentData) {
            e.componentData = [];
            for(let r = 0; r < ph; r++)e.componentData.push({
                rGBTransferFunction: null,
                piecewiseFunction: null,
                componentWeight: 1
            });
        }
        K.setGet(t, e, [
            "independentComponents",
            "interpolationType",
            "colorWindow",
            "colorLevel",
            "ambient",
            "diffuse",
            "opacity",
            "useLookupTableScalarRange",
            "useLabelOutline",
            "labelOutlineOpacity"
        ]), K.setGetArray(t, e, [
            "labelOutlineThickness"
        ]), lH(t, e);
    }
    const dH = K.newInstance(fH, "vtkImageProperty");
    var gH = {
        newInstance: dH
    };
    const { vtkDebugMacro: hH } = K;
    function pH(t, e) {
        e.classHierarchy.push("vtkImageSlice"), t.getActors = ()=>t, t.getImages = ()=>t, t.getIsOpaque = ()=>{
            if (e.forceOpaque) return !0;
            if (e.forceTranslucent) return !1;
            e.property || t.getProperty();
            let n = e.property.getOpacity() >= 1;
            return n = n && (!e.mapper || e.mapper.getIsOpaque()), n;
        }, t.hasTranslucentPolygonalGeometry = ()=>!1, t.makeProperty = gH.newInstance, t.getProperty = ()=>(e.property === null && (e.property = t.makeProperty()), e.property), t.getBounds = ()=>{
            if (e.mapper === null) return e.bounds;
            const n = e.mapper.getBounds();
            if (!n || n.length !== 6) return n;
            if (n[0] > n[1]) return e.mapperBounds = n.concat(), e.bounds = [
                1,
                -1,
                1,
                -1,
                1,
                -1
            ], e.boundsMTime.modified(), n;
            const r = (i)=>i[0].map((a, o)=>i.map((s)=>s[o]));
            if (!e.mapperBounds || !r([
                n,
                e.mapperBounds
            ]).reduce((i, a)=>i && a[0] === a[1], !0) || t.getMTime() > e.boundsMTime.getMTime()) {
                hH("Recomputing bounds..."), e.mapperBounds = n.map((a)=>a), t.computeMatrix();
                const i = new Float64Array(16);
                cn(i, e.matrix), zn.transformBounds(n, i, e.bounds), e.boundsMTime.modified();
            }
            return e.bounds;
        }, t.getBoundsForSlice = (n, r)=>{
            const i = e.mapper.getBoundsForSlice(n, r);
            if (!zn.isValid(i)) return i;
            t.computeMatrix();
            const a = new Float64Array(16);
            return cn(a, e.matrix), zn.transformBounds(i, a);
        }, t.getMinXBound = ()=>t.getBounds()[0], t.getMaxXBound = ()=>t.getBounds()[1], t.getMinYBound = ()=>t.getBounds()[2], t.getMaxYBound = ()=>t.getBounds()[3], t.getMinZBound = ()=>t.getBounds()[4], t.getMaxZBound = ()=>t.getBounds()[5], t.getMTime = ()=>{
            let n = e.mtime;
            if (e.property !== null) {
                const r = e.property.getMTime();
                n = r > n ? r : n;
            }
            return n;
        }, t.getRedrawMTime = ()=>{
            let n = e.mtime;
            if (e.mapper !== null) {
                let r = e.mapper.getMTime();
                n = r > n ? r : n, e.mapper.getInput() !== null && (e.mapper.getInputAlgorithm().update(), r = e.mapper.getInput().getMTime(), n = r > n ? r : n);
            }
            if (e.property !== null) {
                let r = e.property.getMTime();
                n = r > n ? r : n, e.property.getRGBTransferFunction() !== null && (r = e.property.getRGBTransferFunction().getMTime(), n = r > n ? r : n);
            }
            return n;
        }, t.getSupportsSelection = ()=>e.mapper ? e.mapper.getSupportsSelection() : !1;
    }
    const mH = {
        mapper: null,
        property: null,
        forceOpaque: !1,
        forceTranslucent: !1,
        bounds: [
            ...zn.INIT_BOUNDS
        ]
    };
    function XD(t, e) {
        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.assign(e, mH, n), a4.extend(t, e, n), e.boundsMTime = {}, K.obj(e.boundsMTime), K.set(t, e, [
            "property"
        ]), K.setGet(t, e, [
            "mapper",
            "forceOpaque",
            "forceTranslucent"
        ]), K.getArray(t, e, [
            "bounds"
        ], 6), pH(t, e);
    }
    const vH = K.newInstance(XD, "vtkImageSlice");
    var yH = {
        newInstance: vH,
        extend: XD
    };
    function CH(t) {
        return Object.values(zi).includes(t) ? t : zi.LINEAR;
    }
    function YD(t) {
        const n = {
            ...ct(Ia.IMAGE_PLANE, t)
        };
        return n.columnPixelSpacing || (n.columnPixelSpacing = 1), n.rowPixelSpacing || (n.rowPixelSpacing = 1), n.columnCosines || (n.columnCosines = [
            0,
            1,
            0
        ]), n.rowCosines || (n.rowCosines = [
            1,
            0,
            0
        ]), n.imagePositionPatient || (n.imagePositionPatient = [
            0,
            0,
            0
        ]), n.imageOrientationPatient || (n.imageOrientationPatient = new Float32Array([
            1,
            0,
            0,
            0,
            1,
            0
        ])), n;
    }
    function ZD(t) {
        const e = t.imageId, { pixelRepresentation: n, bitsAllocated: r, bitsStored: i, highBit: a, photometricInterpretation: o, samplesPerPixel: s } = ct("imagePixelModule", e), { windowWidth: c, windowCenter: l, voiLUTFunction: f } = t, { modality: u } = ct("generalSeriesModule", e), g = ct("scalingModule", e), h = ct(Ia.CALIBRATION, e), v = CH(f), m = YD(e);
        return {
            calibration: h,
            scalingFactor: g,
            voiLUTFunction: v,
            modality: u,
            imagePlaneModule: m,
            imagePixelModule: {
                bitsAllocated: r,
                bitsStored: i,
                samplesPerPixel: s,
                highBit: a,
                photometricInterpretation: o,
                pixelRepresentation: n,
                windowWidth: c,
                windowCenter: l,
                modality: u,
                voiLUTFunction: v
            }
        };
    }
    function JD(t) {
        const { imagePlaneModule: e, imagePixelModule: n, voiLUTFunction: r, modality: i, scalingFactor: a, calibration: o } = ZD(t);
        let { rowCosines: s, columnCosines: c } = e;
        (s == null || c == null) && (s = [
            1,
            0,
            0
        ], c = [
            0,
            1,
            0
        ]);
        const l = en(s[0], s[1], s[2]), f = en(c[0], c[1], c[2]), u = Xe();
        bn(u, l, f);
        let g = e.imagePositionPatient;
        g == null && (g = [
            0,
            0,
            0
        ]);
        const h = e.columnPixelSpacing || t.columnPixelSpacing, v = e.rowPixelSpacing || t.rowPixelSpacing, m = t.columns, y = t.rows, C = Jo, T = 1;
        return !n.photometricInterpretation && t.sizeInBytes === 3 * t.width * t.height && (t.numberOfComponents = 3), {
            numberOfComponents: t.numberOfComponents || wH(n.photometricInterpretation),
            origin: g,
            direction: [
                ...l,
                ...f,
                ...u
            ],
            dimensions: [
                m,
                y,
                T
            ],
            spacing: [
                h,
                v,
                C
            ],
            numVoxels: m * y * T,
            imagePlaneModule: e,
            imagePixelModule: n,
            bitsAllocated: n.bitsAllocated,
            voiLUTFunction: r,
            modality: i,
            scalingFactor: a,
            calibration: o,
            scanAxisNormal: u
        };
    }
    function wH(t) {
        let e = 1;
        return (t === "RGB" || t?.includes("YBR") || t === "PALETTE COLOR") && (e = 3), e;
    }
    var mh = {
        exports: {}
    }, TH = mh.exports, OC;
    function xH() {
        return OC || (OC = 1, function(t) {
            (function(e, n) {
                t.exports ? t.exports = n() : e.log = n();
            })(TH, function() {
                var e = function() {}, n = "undefined", r = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), i = [
                    "trace",
                    "debug",
                    "info",
                    "warn",
                    "error"
                ], a = {}, o = null;
                function s(m, y) {
                    var C = m[y];
                    if (typeof C.bind == "function") return C.bind(m);
                    try {
                        return Function.prototype.bind.call(C, m);
                    } catch  {
                        return function() {
                            return Function.prototype.apply.apply(C, [
                                m,
                                arguments
                            ]);
                        };
                    }
                }
                function c() {
                    console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [
                        console,
                        arguments
                    ])), console.trace && console.trace();
                }
                function l(m) {
                    return m === "debug" && (m = "log"), typeof console === n ? !1 : m === "trace" && r ? c : console[m] !== void 0 ? s(console, m) : console.log !== void 0 ? s(console, "log") : e;
                }
                function f() {
                    for(var m = this.getLevel(), y = 0; y < i.length; y++){
                        var C = i[y];
                        this[C] = y < m ? e : this.methodFactory(C, m, this.name);
                    }
                    if (this.log = this.debug, typeof console === n && m < this.levels.SILENT) return "No console available for logging";
                }
                function u(m) {
                    return function() {
                        typeof console !== n && (f.call(this), this[m].apply(this, arguments));
                    };
                }
                function g(m, y, C) {
                    return l(m) || u.apply(this, arguments);
                }
                function h(m, y) {
                    var C = this, T, x, S, D = "loglevel";
                    typeof m == "string" ? D += ":" + m : typeof m == "symbol" && (D = void 0);
                    function _(B) {
                        var G = (i[B] || "silent").toUpperCase();
                        if (!(typeof window === n || !D)) {
                            try {
                                window.localStorage[D] = G;
                                return;
                            } catch  {}
                            try {
                                window.document.cookie = encodeURIComponent(D) + "=" + G + ";";
                            } catch  {}
                        }
                    }
                    function M() {
                        var B;
                        if (!(typeof window === n || !D)) {
                            try {
                                B = window.localStorage[D];
                            } catch  {}
                            if (typeof B === n) try {
                                var G = window.document.cookie, Z = encodeURIComponent(D), H = G.indexOf(Z + "=");
                                H !== -1 && (B = /^([^;]+)/.exec(G.slice(H + Z.length + 1))[1]);
                            } catch  {}
                            return C.levels[B] === void 0 && (B = void 0), B;
                        }
                    }
                    function P() {
                        if (!(typeof window === n || !D)) {
                            try {
                                window.localStorage.removeItem(D);
                            } catch  {}
                            try {
                                window.document.cookie = encodeURIComponent(D) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
                            } catch  {}
                        }
                    }
                    function F(B) {
                        var G = B;
                        if (typeof G == "string" && C.levels[G.toUpperCase()] !== void 0 && (G = C.levels[G.toUpperCase()]), typeof G == "number" && G >= 0 && G <= C.levels.SILENT) return G;
                        throw new TypeError("log.setLevel() called with invalid level: " + B);
                    }
                    C.name = m, C.levels = {
                        TRACE: 0,
                        DEBUG: 1,
                        INFO: 2,
                        WARN: 3,
                        ERROR: 4,
                        SILENT: 5
                    }, C.methodFactory = y || g, C.getLevel = function() {
                        return S ?? x ?? T;
                    }, C.setLevel = function(B, G) {
                        return S = F(B), G !== !1 && _(S), f.call(C);
                    }, C.setDefaultLevel = function(B) {
                        x = F(B), M() || C.setLevel(B, !1);
                    }, C.resetLevel = function() {
                        S = null, P(), f.call(C);
                    }, C.enableAll = function(B) {
                        C.setLevel(C.levels.TRACE, B);
                    }, C.disableAll = function(B) {
                        C.setLevel(C.levels.SILENT, B);
                    }, C.rebuild = function() {
                        if (o !== C && (T = F(o.getLevel())), f.call(C), o === C) for(var B in a)a[B].rebuild();
                    }, T = F(o ? o.getLevel() : "WARN");
                    var N = M();
                    N != null && (S = F(N)), f.call(C);
                }
                o = new h, o.getLogger = function(y) {
                    if (typeof y != "symbol" && typeof y != "string" || y === "") throw new TypeError("You must supply a name when creating a logger.");
                    var C = a[y];
                    return C || (C = a[y] = new h(y, o.methodFactory)), C;
                };
                var v = typeof window !== n ? window.log : void 0;
                return o.noConflict = function() {
                    return typeof window !== n && window.log === o && (window.log = v), o;
                }, o.getLoggers = function() {
                    return a;
                }, o.default = o, o;
            });
        }(mh)), mh.exports;
    }
    var SH = xH();
    const EH = Qa(SH), QD = EH.noConflict();
    typeof window < "u" && (window.log = QD);
    function $p(t) {
        const e = QD.getLogger(t[0]);
        return e.getLogger = (...n)=>$p(`${t}.${n.join(".")}`), e;
    }
    function L4(...t) {
        return $p(t.join("."));
    }
    const ff = $p("cs3d"), P4 = ff.getLogger("core"), DH = ff.getLogger("tools"), _H = ff.getLogger("dicomImageLoader"), RH = ff.getLogger("ai"), OH = ff.getLogger("examples"), IH = L4("consistency", "dicom"), MH = L4("consistency", "image"), bH = Object.freeze(Object.defineProperty({
        __proto__: null,
        aiLog: RH,
        coreLog: P4,
        cs3dLog: ff,
        dicomConsistencyLog: IH,
        examplesLog: OH,
        getLogger: L4,
        getRootLogger: $p,
        imageConsistencyLog: MH,
        loaderLog: _H,
        toolsLog: DH
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function e_(t) {
        const e = Jc.newInstance();
        let n = 0, r = 1024;
        return t.lower !== void 0 && t.upper !== void 0 && (n = t.lower, r = t.upper), e.addRGBPoint(n, 0, 0, 0), e.addRGBPoint(r, 1, 1, 1), e;
    }
    function zp(t, e) {
        const n = e.voxelManager.getScalarData();
        if (!t.getPointData) return;
        const r = t.getPointData().getScalars().getData();
        if (e.color && e.rgba) {
            const i = new Uint8Array(e.columns * e.rows * 3);
            for(let a = 0; a < e.columns * e.rows; a++)i[a * 3] = n[a * 4], i[a * 3 + 1] = n[a * 4 + 1], i[a * 3 + 2] = n[a * 4 + 2];
            e.rgba = !1, e.getPixelData = ()=>i, r.set(i);
        } else r.set(n);
        t.modified();
    }
    function Xt() {
        return window.performance ? performance.now() : Date.now();
    }
    function LH(t, e) {
        return function(n) {
            const r = ((n - (e - .5)) / (t - 1) + .5) * 255;
            return Math.min(Math.max(r, 0), 255);
        };
    }
    function PH(t) {
        const n = Math.max(...t.lut).toString(2).length - 8, r = t.lut[0] >> n, i = t.lut[t.lut.length - 1] >> n, a = t.firstValueMapped + t.lut.length - 1;
        return function(o) {
            return o < t.firstValueMapped ? r : o >= a ? i : t.lut[o - t.firstValueMapped] >> n;
        };
    }
    function t_(t, e, n) {
        return n ? PH(n) : LH(t, e);
    }
    function VH(t, e, n, r, i) {
        const a = t.maxPixelValue, o = t.minPixelValue, s = Math.min(o, 0);
        if (t.cachedLut === void 0) {
            const f = a - s + 1;
            t.cachedLut = {}, t.cachedLut.lutArray = new Uint8ClampedArray(f);
        }
        const c = t.cachedLut.lutArray, l = t_(Array.isArray(e) ? e[0] : e, Array.isArray(n) ? n[0] : n, i);
        if (r) for(let f = o; f <= a; f++)c[f + -s] = 255 - l(f);
        else for(let f = o; f <= a; f++)c[f + -s] = l(f);
        return c;
    }
    function NH(t, e, n) {
        let r = Xt();
        const i = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - r;
        const a = t.minPixelValue;
        let o = 0, s = 0;
        const c = i.length;
        if (r = Xt(), a < 0) for(; s < c;)n[o++] = e[i[s++] + -a], n[o++] = e[i[s++] + -a], n[o++] = e[i[s++] + -a], n[o++] = 255;
        else for(; s < c;)n[o++] = e[i[s++]], n[o++] = e[i[s++]], n[o++] = e[i[s++]], n[o++] = 255;
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - r;
    }
    function AH(t, e, n) {
        let r = Xt();
        const i = t.getPixelData();
        t.stats.lastGetPixelDataTime = Xt() - r;
        const a = t.minPixelValue;
        let o = 0, s = 0;
        const c = i.length;
        if (r = Xt(), a < 0) for(; s < c;)n[o++] = e[i[s++] + -a], n[o++] = e[i[s++] + -a], n[o++] = e[i[s++] + -a], n[o++] = i[s++];
        else for(; s < c;)n[o++] = e[i[s++]], n[o++] = e[i[s++]], n[o++] = e[i[s++]], n[o++] = i[s++];
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - r;
    }
    class df {
        constructor(){
            this.reset();
        }
        getMatrix() {
            return this.m;
        }
        reset() {
            this.m = [
                1,
                0,
                0,
                1,
                0,
                0
            ];
        }
        clone() {
            const e = new df;
            return e.m[0] = this.m[0], e.m[1] = this.m[1], e.m[2] = this.m[2], e.m[3] = this.m[3], e.m[4] = this.m[4], e.m[5] = this.m[5], e;
        }
        multiply(e) {
            const n = this.m[0] * e[0] + this.m[2] * e[1], r = this.m[1] * e[0] + this.m[3] * e[1], i = this.m[0] * e[2] + this.m[2] * e[3], a = this.m[1] * e[2] + this.m[3] * e[3], o = this.m[0] * e[4] + this.m[2] * e[5] + this.m[4], s = this.m[1] * e[4] + this.m[3] * e[5] + this.m[5];
            this.m[0] = n, this.m[1] = r, this.m[2] = i, this.m[3] = a, this.m[4] = o, this.m[5] = s;
        }
        invert() {
            const e = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), n = this.m[3] * e, r = -this.m[1] * e, i = -this.m[2] * e, a = this.m[0] * e, o = e * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), s = e * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
            this.m[0] = n, this.m[1] = r, this.m[2] = i, this.m[3] = a, this.m[4] = o, this.m[5] = s;
        }
        rotate(e) {
            const n = Math.cos(e), r = Math.sin(e), i = this.m[0] * n + this.m[2] * r, a = this.m[1] * n + this.m[3] * r, o = this.m[0] * -r + this.m[2] * n, s = this.m[1] * -r + this.m[3] * n;
            this.m[0] = i, this.m[1] = a, this.m[2] = o, this.m[3] = s;
        }
        translate(e, n) {
            this.m[4] += this.m[0] * e + this.m[2] * n, this.m[5] += this.m[1] * e + this.m[3] * n;
        }
        scale(e, n) {
            this.m[0] *= e, this.m[1] *= e, this.m[2] *= n, this.m[3] *= n;
        }
        transformPoint(e) {
            const n = e[0], r = e[1];
            return [
                n * this.m[0] + r * this.m[2] + this.m[4],
                n * this.m[1] + r * this.m[3] + this.m[5]
            ];
        }
    }
    function Ld(t, e) {
        const n = new df;
        if (!t.viewport.displayedArea) return n;
        n.translate(t.canvas.width / 2, t.canvas.height / 2);
        const r = t.viewport.rotation;
        r !== 0 && n.rotate(r * Math.PI / 180);
        let i = t.viewport.scale, a = t.viewport.scale;
        const o = t.viewport.displayedArea.brhc.x - (t.viewport.displayedArea.tlhc.x - 1), s = t.viewport.displayedArea.brhc.y - (t.viewport.displayedArea.tlhc.y - 1);
        if (t.viewport.displayedArea.presentationSizeMode === "NONE") t.image.rowPixelSpacing < t.image.columnPixelSpacing ? i *= t.image.columnPixelSpacing / t.image.rowPixelSpacing : t.image.columnPixelSpacing < t.image.rowPixelSpacing && (a *= t.image.rowPixelSpacing / t.image.columnPixelSpacing);
        else if (i = t.viewport.displayedArea.columnPixelSpacing, a = t.viewport.displayedArea.rowPixelSpacing, t.viewport.displayedArea.presentationSizeMode === "SCALE TO FIT") {
            const c = t.canvas.height / (s * a), l = t.canvas.width / (o * i);
            i = a = Math.min(l, c), t.viewport.displayedArea.rowPixelSpacing < t.viewport.displayedArea.columnPixelSpacing ? i *= t.viewport.displayedArea.columnPixelSpacing / t.viewport.displayedArea.rowPixelSpacing : t.viewport.displayedArea.columnPixelSpacing < t.viewport.displayedArea.rowPixelSpacing && (a *= t.viewport.displayedArea.rowPixelSpacing / t.viewport.displayedArea.columnPixelSpacing);
        }
        return n.scale(i, a), r !== 0 && n.rotate(-r * Math.PI / 180), n.translate(t.viewport.translation.x, t.viewport.translation.y), r !== 0 && n.rotate(r * Math.PI / 180), t.viewport.hflip && n.scale(-1, 1), t.viewport.vflip && n.scale(1, -1), n.translate(-o / 2, -s / 2), n;
    }
    function V4(t, e, n) {
        if (t === void 0) throw new Error("setToPixelCoordinateSystem: parameter enabledElement must not be undefined");
        if (e === void 0) throw new Error("setToPixelCoordinateSystem: parameter context must not be undefined");
        const i = Ld(t).getMatrix();
        e.setTransform(i[0], i[1], i[2], i[3], i[4], i[5]);
    }
    function N4(t, e) {
        const n = t.renderingTools.lastRenderedImageId, r = t.renderingTools.lastRenderedViewport;
        return e.imageId !== n || !r || r.windowCenter !== t.viewport.voi.windowCenter || r.windowWidth !== t.viewport.voi.windowWidth || r.invert !== t.viewport.invert || r.rotation !== t.viewport.rotation || r.hflip !== t.viewport.hflip || r.vflip !== t.viewport.vflip || r.modalityLUT !== t.viewport.modalityLUT || r.voiLUT !== t.viewport.voiLUT || r.colormap !== t.viewport.colormap;
    }
    function ap(t, e) {
        const n = t.renderingTools.renderCanvas;
        n.width = e.width, n.height = e.height;
        const r = n.getContext("2d");
        r.fillStyle = "white", r.fillRect(0, 0, n.width, n.height);
        const i = r.getImageData(0, 0, e.width, e.height);
        t.renderingTools.renderCanvasContext = r, t.renderingTools.renderCanvasData = i;
    }
    function A4(t) {
        const e = t.image.imageId, n = t.viewport, r = t.image.color;
        return t.renderingTools.lastRenderedImageId = e, t.renderingTools.lastRenderedIsColor = r, t.renderingTools.lastRenderedViewport = {
            windowCenter: n.voi.windowCenter,
            windowWidth: n.voi.windowWidth,
            invert: n.invert,
            rotation: n.rotation,
            hflip: n.hflip,
            vflip: n.vflip,
            modalityLUT: n.modalityLUT,
            voiLUT: n.voiLUT,
            colormap: n.colormap
        }, t.renderingTools;
    }
    let n_, r_;
    n_ = "viewport-element";
    r_ = "cornerstone-canvas";
    Cd = 1e-4;
    let zv;
    jp = function(t, e = 512, n = 512) {
        const r = zv ? zv(e, n) : document.createElement("canvas");
        return t && (r.style.position = "absolute", r.style.width = "100%", r.style.height = "100%", r.style.imageRendering = "pixelated", r.classList.add(r_), t.appendChild(r)), r;
    };
    kH = function(t) {
        const e = document.createElement("div");
        return e.style.position = "relative", e.style.width = "100%", e.style.height = "100%", e.style.overflow = "hidden", e.classList.add(n_), t.appendChild(e), e;
    };
    jae = function(t) {
        zv = t;
    };
    Zo = function(t) {
        const e = `canvas.${r_}`, n = `div.${n_}`, r = t.querySelector(n) || kH(t), i = r.querySelector(e);
        if (i) return i;
        const a = jp(r), o = r.getBoundingClientRect(), s = window.devicePixelRatio || 1, c = Math.ceil(o.width * s), l = Math.ceil(o.height * s);
        return a.width = c, a.height = l, a;
    };
    function UH(t, e) {
        return t.cachedLut !== void 0 && t.cachedLut.windowCenter === e.voi.windowCenter && t.cachedLut.windowWidth === e.voi.windowWidth && t.cachedLut.invert === e.invert || (VH(t, e.voi.windowWidth, e.voi.windowCenter, e.invert), t.cachedLut.windowWidth = e.voi.windowWidth, t.cachedLut.windowCenter = e.voi.windowCenter, t.cachedLut.invert = e.invert), t.cachedLut.lutArray;
    }
    function FH(t, e, n) {
        const r = t.renderingTools.lastRenderedIsColor;
        (!t.renderingTools.renderCanvas || !r) && (t.renderingTools.renderCanvas = jp(null, e.width, e.height));
        const i = t.renderingTools.renderCanvas, { windowWidth: a, windowCenter: o } = t.viewport.voi;
        if ((a === 256 || a === 255) && (o === 128 || o === 127) && !t.viewport.invert && e.getCanvas && e.getCanvas()) return e.getCanvas();
        if (!N4(t, e) && !n) return i;
        (!t.renderingTools.renderCanvasContext || i.width !== e.width || i.height !== e.height) && ap(t, e);
        let s = Xt();
        const c = UH(e, t.viewport);
        e.stats = e.stats || {}, e.stats.lastLutGenerateTime = Xt() - s;
        const l = t.renderingTools.renderCanvasData, f = t.renderingTools.renderCanvasContext;
        return e.rgba ? AH(e, c, l.data) : NH(e, c, l.data), s = Xt(), f.putImageData(l, 0, 0), e.stats.lastPutImageDataTime = Xt() - s, i;
    }
    function BH(t, e) {
        if (t === void 0) throw new Error("renderColorImage: enabledElement parameter must not be undefined");
        const n = t.image;
        if (n === void 0) throw new Error("renderColorImage: image must be loaded before it can be drawn");
        const r = t.canvas.getContext("2d");
        r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, V4(t, r);
        const i = FH(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, o = t.viewport.displayedArea.tlhc.y - 1, s = t.viewport.displayedArea.brhc.x - a, c = t.viewport.displayedArea.brhc.y - o;
        r.drawImage(i, a, o, s, c, 0, 0, s, c), t.renderingTools = A4(t);
    }
    function GH(t, e, n) {
        let r = Xt();
        const i = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - r;
        const a = i.length, o = t.minPixelValue;
        let s = 3, c = 0;
        if (r = Xt(), i instanceof Int16Array) if (o < 0) for(; c < a;)n[s] = e[i[c++] + -o], s += 4;
        else for(; c < a;)n[s] = e[i[c++]], s += 4;
        else if (i instanceof Uint16Array) for(; c < a;)n[s] = e[i[c++]], s += 4;
        else if (o < 0) for(; c < a;)n[s] = e[i[c++] + -o], s += 4;
        else for(; c < a;)n[s] = e[i[c++]], s += 4;
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - r;
    }
    function WH(t, e, n) {
        let r = Xt();
        const i = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - r;
        const a = i.length;
        let o = 3, s = 0;
        for(r = Xt(); s < a;)n[o] = e(i[s++]), o += 4;
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - r;
    }
    function $H(t, e, n) {
        let r = Xt();
        const i = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - r;
        const a = i.length, o = t.minPixelValue;
        let s = 0, c = 0, l;
        if (r = Xt(), i instanceof Int16Array) if (o < 0) for(; c < a;)l = e[i[c++] + -o], n[s++] = l, n[s++] = l, n[s++] = l, n[s++] = 255;
        else for(; c < a;)l = e[i[c++]], n[s++] = l, n[s++] = l, n[s++] = l, n[s++] = 255;
        else if (i instanceof Uint16Array) for(; c < a;)l = e[i[c++]], n[s++] = l, n[s++] = l, n[s++] = l, n[s++] = 255;
        else if (o < 0) for(; c < a;)l = e[i[c++] + -o], n[s++] = l, n[s++] = l, n[s++] = l, n[s++] = 255;
        else for(; c < a;)l = e[i[c++]], n[s++] = l, n[s++] = l, n[s++] = l, n[s++] = 255;
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - r;
    }
    function zH(t, e) {
        if (jH(t)) return;
        const n = e.maxPixelValue * e.slope + e.intercept, r = e.minPixelValue * e.slope + e.intercept, i = n - r, a = (n + r) / 2;
        t.voi === void 0 ? t.voi = {
            windowWidth: i,
            windowCenter: a,
            voiLUTFunction: e.voiLUTFunction
        } : (t.voi.windowWidth = i, t.voi.windowCenter = a);
    }
    function jH(t) {
        return t.voiLUT && t.voiLUT.lut && t.voiLUT.lut.length > 0 || t.voi.windowWidth !== void 0 && t.voi.windowCenter !== void 0;
    }
    function IC(t, e) {
        return !t && !e ? !0 : !t || !e ? !1 : t.id === e.id;
    }
    function HH(t, e) {
        return (n)=>n * t + e;
    }
    function KH(t) {
        const e = t.lut[0], n = t.lut[t.lut.length - 1], r = t.firstValueMapped + t.lut.length;
        return (i)=>i < t.firstValueMapped ? e : i >= r ? n : t.lut[i];
    }
    function qH(t, e, n) {
        return n ? KH(n) : HH(t, e);
    }
    function XH(t, e, n, r, i, a) {
        const o = t.maxPixelValue, s = t.minPixelValue, c = Math.min(s, 0);
        if (t.cachedLut === void 0) {
            const g = o - c + 1;
            t.cachedLut = {}, t.cachedLut.lutArray = new Uint8ClampedArray(g);
        }
        const l = t.cachedLut.lutArray, f = qH(t.slope, t.intercept, i), u = t_(e, n, a);
        if (t.isPreScaled) if (r) for(let g = s; g <= o; g++)l[g + -c] = 255 - u(g);
        else for(let g = s; g <= o; g++)l[g + -c] = u(g);
        else if (r) for(let g = s; g <= o; g++)l[g + -c] = 255 - u(f(g));
        else for(let g = s; g <= o; g++)l[g + -c] = u(f(g));
        return l;
    }
    function i_(t, e, n) {
        return t.cachedLut !== void 0 && t.cachedLut.windowCenter === e.voi.windowCenter && t.cachedLut.windowWidth === e.voi.windowWidth && IC(t.cachedLut.modalityLUT, e.modalityLUT) && IC(t.cachedLut.voiLUT, e.voiLUT) && t.cachedLut.invert === e.invert && !n || (zH(e, t), XH(t, e.voi.windowWidth, e.voi.windowCenter, e.invert, e.modalityLUT, e.voiLUT), t.cachedLut.windowWidth = e.voi.windowWidth, t.cachedLut.windowCenter = e.voi.windowCenter, t.cachedLut.invert = e.invert, t.cachedLut.voiLUT = e.voiLUT, t.cachedLut.modalityLUT = e.modalityLUT), t.cachedLut.lutArray;
    }
    function YH(t, e, n, r = !0) {
        const i = t.renderingTools.lastRenderedIsColor;
        (!t.renderingTools.renderCanvas || i) && (t.renderingTools.renderCanvas = jp(null, e.width, e.height), ap(t, e));
        const a = t.renderingTools.renderCanvas;
        if (!N4(t, e) && !n) return a;
        (a.width !== e.width || a.height !== e.height) && ap(t, e), e.stats = e.stats || {};
        const o = t.renderingTools.renderCanvasData, s = t.renderingTools.renderCanvasContext;
        let c = Xt();
        e.stats.lastLutGenerateTime = Xt() - c;
        const { viewport: l } = t;
        if (l.modality === "PT" && e.isPreScaled) {
            const { windowWidth: f, windowCenter: u } = l.voi, g = u - f / 2, m = 255 / (u + f / 2 - g);
            let y;
            l.invert ? y = (C)=>255 - (C - g) * m : y = (C)=>(C - g) * m, WH(e, y, o.data);
        } else {
            const f = i_(e, l, n);
            r ? GH(e, f, o.data) : $H(e, f, o.data);
        }
        return c = Xt(), s.putImageData(o, 0, 0), e.stats.lastPutImageDataTime = Xt() - c, a;
    }
    function ZH(t, e) {
        if (t === void 0) throw new Error("drawImage: enabledElement parameter must not be undefined");
        const n = t.image;
        if (n === void 0) throw new Error("drawImage: image must be loaded before it can be drawn");
        const r = t.canvas.getContext("2d");
        r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, V4(t, r);
        const i = YH(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, o = t.viewport.displayedArea.tlhc.y - 1, s = t.viewport.displayedArea.brhc.x - a, c = t.viewport.displayedArea.brhc.y - o;
        r.drawImage(i, a, o, s, c, 0, 0, s, c), t.renderingTools = A4(t);
    }
    const jv = 0, Hv = 1, JH = 2;
    function QH(t, e, n) {
        if (t > 1) throw new Error("HSVToRGB expects hue < 1");
        const r = [];
        if (e === 0) return r[0] = n, r[1] = n, r[2] = n, r;
        const i = Math.floor(t * 6), a = 6 * t - i, o = n * (1 - e), s = n * (1 - e * a), c = n * (1 - e * (1 - a));
        switch(i){
            case 0:
            case 6:
                r[0] = n, r[1] = c, r[2] = o;
                break;
            case 1:
                r[0] = s, r[1] = n, r[2] = o;
                break;
            case 2:
                r[0] = o, r[1] = n, r[2] = c;
                break;
            case 3:
                r[0] = o, r[1] = s, r[2] = n;
                break;
            case 4:
                r[0] = c, r[1] = o, r[2] = n;
                break;
            case 5:
                r[0] = n, r[1] = o, r[2] = s;
                break;
        }
        return r;
    }
    function eK(t, e) {
        let n;
        return t < e.Range[0] ? n = e.MaxIndex + jv + 1.5 : t > e.Range[1] ? n = e.MaxIndex + Hv + 1.5 : n = (t + e.Shift) * e.Scale, Math.floor(n);
    }
    class k4 {
        constructor(){
            this.NumberOfColors = 256, this.Ramp = "linear", this.TableRange = [
                0,
                255
            ], this.HueRange = [
                0,
                .66667
            ], this.SaturationRange = [
                1,
                1
            ], this.ValueRange = [
                1,
                1
            ], this.AlphaRange = [
                1,
                1
            ], this.NaNColor = [
                128,
                0,
                0,
                255
            ], this.BelowRangeColor = [
                0,
                0,
                0,
                255
            ], this.UseBelowRangeColor = !0, this.AboveRangeColor = [
                255,
                255,
                255,
                255
            ], this.UseAboveRangeColor = !0, this.InputRange = [
                0,
                255
            ], this.Table = [];
        }
        setNumberOfTableValues(e) {
            this.NumberOfColors = e;
        }
        setRamp(e) {
            this.Ramp = e;
        }
        setTableRange(e, n) {
            this.TableRange[0] = e, this.TableRange[1] = n;
        }
        setHueRange(e, n) {
            this.HueRange[0] = e, this.HueRange[1] = n;
        }
        setSaturationRange(e, n) {
            this.SaturationRange[0] = e, this.SaturationRange[1] = n;
        }
        setValueRange(e, n) {
            this.ValueRange[0] = e, this.ValueRange[1] = n;
        }
        setRange(e, n) {
            this.InputRange[0] = e, this.InputRange[1] = n;
        }
        setAlphaRange(e, n) {
            this.AlphaRange[0] = e, this.AlphaRange[1] = n;
        }
        getColor(e) {
            return this.mapValue(e);
        }
        build(e) {
            if (this.Table.length > 1 && !e) return;
            this.Table = [];
            const n = this.NumberOfColors - 1;
            let r, i, a, o;
            n ? (r = (this.HueRange[1] - this.HueRange[0]) / n, i = (this.SaturationRange[1] - this.SaturationRange[0]) / n, a = (this.ValueRange[1] - this.ValueRange[0]) / n, o = (this.AlphaRange[1] - this.AlphaRange[0]) / n) : r = i = a = o = 0;
            for(let s = 0; s <= n; s++){
                const c = this.HueRange[0] + s * r, l = this.SaturationRange[0] + s * i, f = this.ValueRange[0] + s * a, u = this.AlphaRange[0] + s * o, g = QH(c, l, f), h = [
                    0,
                    0,
                    0,
                    0
                ];
                switch(this.Ramp){
                    case "scurve":
                        h[0] = Math.floor(127.5 * (1 + Math.cos((1 - g[0]) * Math.PI))), h[1] = Math.floor(127.5 * (1 + Math.cos((1 - g[1]) * Math.PI))), h[2] = Math.floor(127.5 * (1 + Math.cos((1 - g[2]) * Math.PI))), h[3] = Math.floor(u * 255);
                        break;
                    case "linear":
                        h[0] = Math.floor(g[0] * 255 + .5), h[1] = Math.floor(g[1] * 255 + .5), h[2] = Math.floor(g[2] * 255 + .5), h[3] = Math.floor(u * 255 + .5);
                        break;
                    case "sqrt":
                        h[0] = Math.floor(Math.sqrt(g[0]) * 255 + .5), h[1] = Math.floor(Math.sqrt(g[1]) * 255 + .5), h[2] = Math.floor(Math.sqrt(g[2]) * 255 + .5), h[3] = Math.floor(Math.sqrt(u) * 255 + .5);
                        break;
                    default:
                        throw new Error(`Invalid Ramp value (${this.Ramp})`);
                }
                this.Table.push(h);
            }
            this.buildSpecialColors();
        }
        buildSpecialColors() {
            const e = this.NumberOfColors, n = e + jv, r = e + Hv, i = e + JH;
            this.UseBelowRangeColor || e === 0 ? this.Table[n] = this.BelowRangeColor : this.Table[n] = this.Table[0], this.UseAboveRangeColor || e === 0 ? this.Table[r] = this.AboveRangeColor : this.Table[r] = this.Table[e - 1], this.Table[i] = this.NaNColor;
        }
        mapValue(e) {
            const n = this.getIndex(e);
            if (n < 0) return this.NaNColor;
            if (n === 0) {
                if (this.UseBelowRangeColor && e < this.TableRange[0]) return this.BelowRangeColor;
            } else if (n === this.NumberOfColors - 1 && this.UseAboveRangeColor && e > this.TableRange[1]) return this.AboveRangeColor;
            return this.Table[n];
        }
        getIndex(e) {
            const n = {
                Range: [],
                MaxIndex: this.NumberOfColors - 1,
                Shift: -this.TableRange[0],
                Scale: 1
            };
            if (this.TableRange[1] <= this.TableRange[0] ? n.Scale = Number.MAX_VALUE : n.Scale = n.MaxIndex / (this.TableRange[1] - this.TableRange[0]), n.Range[0] = this.TableRange[0], n.Range[1] = this.TableRange[1], isNaN(e)) return -1;
            let r = eK(e, n);
            return r === this.NumberOfColors + jv ? r = 0 : r === this.NumberOfColors + Hv && (r = this.NumberOfColors - 1), r;
        }
        setTableValue(e, n, r, i, a) {
            let o;
            if (typeof n == "number" && r !== void 0 && i !== void 0 && a !== void 0) o = [
                n,
                r,
                i,
                a
            ];
            else if (Array.isArray(n)) o = n;
            else throw new Error("Invalid arguments for setTableValue");
            if (e < 0) throw new Error(`Can't set the table value for negative index (${e})`);
            if (e >= this.NumberOfColors) throw new Error(`Index ${e} is greater than the number of colors ${this.NumberOfColors}`);
            this.Table[e] = o, (e === 0 || e === this.NumberOfColors - 1) && this.buildSpecialColors();
        }
    }
    const MC = [
        0,
        0,
        0,
        0
    ];
    function tK(t, e, n) {
        n = n === null ? 100 : n;
        const r = (e - t) / (n - 1), i = [];
        for(; n-- > 0;)i.push(t), t += r;
        return i[i.length - 1] = e, i;
    }
    function nK(t, e) {
        let n = 0, r = t.length - 1;
        for(; n <= r;){
            const i = n + Math.floor((r - n) / 2), a = t[i];
            if (a === e) return i;
            e < a ? r = i - 1 : n = i + 1;
        }
        return n;
    }
    function rK(t, e) {
        let n;
        const r = [], i = e.length;
        for(t.sort(function(a, o) {
            return a - o;
        }), n = 0; n < i; n++)r[n] = nK(t, e[n]);
        return r;
    }
    function I5(t, e, n) {
        let r;
        const i = [], a = [], o = [], s = [];
        for(n = n === null ? 1 : n, r = 0; r < e.length; r++){
            const f = e[r];
            i.push((t - 1) * f[0]), a.push(f[1]), o.push(f[1]);
        }
        const c = tK(0, 1, t);
        for(r = 0; r < t; r++)c[r] = (t - 1) * Math.pow(c[r], n);
        const l = rK(i, c);
        for(r = 1; r < t - 1; r++){
            const f = l[r], u = (c[r] - i[f - 1]) / (i[f] - i[f - 1]), g = a[f] - o[f - 1];
            s[r] = u * g + o[f - 1];
        }
        return s[0] = o[0], s[t - 1] = a[e.length - 1], s;
    }
    function iK(t, e, n) {
        let r;
        const i = [];
        e = e === null ? 256 : e, n = n === null ? 1 : n;
        const a = I5(e, t.red, n), o = I5(e, t.green, n), s = I5(e, t.blue, n);
        for(r = 0; r < e; r++){
            const c = Math.round(a[r] * 255), l = Math.round(o[r] * 255), f = Math.round(s[r] * 255), u = [
                c,
                l,
                f,
                255
            ];
            i.push(u);
        }
        return i;
    }
    function aK(t, e) {
        let n = dv[t];
        return n || (n = dv[t] = {
            name: "",
            colors: []
        }), !n.colors && n.segmentedData && (n.colors = iK(n.segmentedData, n.numColors, n.gamma)), {
            getId () {
                return t;
            },
            getColorSchemeName () {
                return n.name;
            },
            setColorSchemeName (i) {
                n.name = i;
            },
            getNumberOfColors () {
                return n.colors.length;
            },
            setNumberOfColors (i) {
                for(; n.colors.length < i;)n.colors.push(MC);
                n.colors.length = i;
            },
            getColor (i) {
                return this.isValidIndex(i) ? n.colors[i] : MC;
            },
            getColorRepeating (i) {
                const a = n.colors.length;
                return i = a ? i % a : 0, this.getColor(i);
            },
            setColor (i, a) {
                this.isValidIndex(i) && (n.colors[i] = a);
            },
            addColor (i) {
                n.colors.push(i);
            },
            insertColor (i, a) {
                this.isValidIndex(i) && n.colors.splice(i, 1, a);
            },
            removeColor (i) {
                this.isValidIndex(i) && n.colors.splice(i, 1);
            },
            clearColors () {
                n.colors = [];
            },
            buildLookupTable (i) {
                if (!i) return;
                const a = n.colors.length;
                i.setNumberOfTableValues(a);
                for(let o = 0; o < a; o++)i.setTableValue(o, n.colors[o]);
            },
            createLookupTable () {
                const i = new k4;
                return this.buildLookupTable(i), i;
            },
            isValidIndex (i) {
                return i >= 0 && i < n.colors.length;
            }
        };
    }
    function oK(t, e, n, r) {
        let i = Xt();
        const a = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - i;
        const o = a.length, s = t.minPixelValue;
        let c = 0, l = 0, f, u, g;
        if (i = Xt(), n instanceof k4 ? g = n.Table : g = n, s < 0) for(; l < o;)f = e[a[l++] + -s], u = g[f], r[c++] = u[0], r[c++] = u[1], r[c++] = u[2], r[c++] = u[3];
        else for(; l < o;)f = e[a[l++]], u = g[f], r[c++] = u[0], r[c++] = u[1], r[c++] = u[2], r[c++] = u[3];
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - i;
    }
    function sK(t, e, n, r) {
        let i = Xt();
        const a = t.voxelManager.getScalarData();
        t.stats.lastGetPixelDataTime = Xt() - i;
        const o = a.length, s = t.minPixelValue;
        let c = 0, l = 0, f, u, g;
        if (i = Xt(), n instanceof k4 ? g = n.Table : g = n, s < 0) for(; l < o;)f = e(a[l++] + -s), u = g[f], r[c++] = u[0], r[c++] = u[1], r[c++] = u[2], r[c++] = u[3];
        else for(; l < o;)f = e(a[l++]), u = g[f], r[c++] = u[0], r[c++] = u[1], r[c++] = u[2], r[c++] = u[3];
        t.stats.lastStoredPixelDataToCanvasImageDataTime = Xt() - i;
    }
    function Kv(t, e, n) {
        return Math.max(e, Math.min(n, t));
    }
    function cK(t, e, n) {
        t.renderingTools.renderCanvas || (t.renderingTools.renderCanvas = jp(null, e.width, e.height));
        const r = t.renderingTools.renderCanvas;
        let i = t.viewport.colormap || t.options.colormap;
        if (t.options && t.options.colormap && console.warn("enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead"), i && typeof i == "string" && (i = aK(i)), !i) throw new Error("renderPseudoColorImage: colormap not found.");
        const a = i.getId();
        if (!N4(t, e) && !n && t.renderingTools.colormapId === a) return r;
        (!t.renderingTools.renderCanvasContext || r.width !== e.width || r.height !== e.height) && ap(t, e);
        let o = Xt();
        (!t.renderingTools.colorLUT || n || t.renderingTools.colormapId !== a) && (i.setNumberOfColors(256), t.renderingTools.colorLUT = i.createLookupTable(), t.renderingTools.colormapId = a);
        const s = t.renderingTools.renderCanvasData, c = t.renderingTools.renderCanvasContext, { viewport: l } = t, f = t.renderingTools.colorLUT;
        if (l.modality === "PT") {
            const { windowWidth: u, windowCenter: g } = l.voi, h = g - u / 2, y = 255 / (g + u / 2 - h);
            let C;
            l.invert ? C = (T)=>Kv(Math.floor(255 - (T - h) * y), 0, 255) : C = (T)=>Kv(Math.floor((T - h) * y), 0, 255), sK(e, C, f, s.data);
        } else {
            const u = i_(e, t.viewport, n);
            e.stats = e.stats || {}, e.stats.lastLutGenerateTime = Xt() - o, oK(e, u, f, s.data);
        }
        return o = Xt(), c.putImageData(s, 0, 0), e.stats.lastPutImageDataTime = Xt() - o, r;
    }
    function lK(t, e) {
        if (t === void 0) throw new Error("drawImage: enabledElement parameter must not be undefined");
        const n = t.image;
        if (n === void 0) throw new Error("drawImage: image must be loaded before it can be drawn");
        const r = t.canvas.getContext("2d");
        r.setTransform(1, 0, 0, 1, 0, 0), r.fillStyle = "black", r.fillRect(0, 0, t.canvas.width, t.canvas.height), r.imageSmoothingEnabled = !t.viewport.pixelReplication, V4(t, r);
        const i = cK(t, n, e), a = t.viewport.displayedArea.tlhc.x - 1, o = t.viewport.displayedArea.tlhc.y - 1, s = t.viewport.displayedArea.brhc.x - a, c = t.viewport.displayedArea.brhc.y - o;
        r.drawImage(i, a, o, s, c, 0, 0, s, c), t.renderingTools = A4(t);
    }
    function a_(t, e) {
        const n = t.image;
        if (!t.canvas || !t.image) return;
        const r = Xt();
        if (n.stats = {
            lastGetPixelDataTime: -1,
            lastStoredPixelDataToCanvasImageDataTime: -1,
            lastPutImageDataTime: -1,
            lastRenderTime: -1,
            lastLutGenerateTime: -1
        }, n) {
            let a = n.render;
            a || (t.viewport.colormap ? a = lK : n.color ? a = BH : a = ZH), a(t, e);
        }
        const i = Xt() - r;
        n.stats.lastRenderTime = i, t.invalid = !1, t.needsRedraw = !1;
    }
    function o_(t) {
        return Ld(t);
    }
    function L1(t, e) {
        const n = o_(t);
        return n.invert(), n.transformPoint(e);
    }
    const uK = {
        viewport: {}
    };
    function fK() {
        return {
            tlhc: {
                x: 1,
                y: 1
            },
            brhc: {
                x: 1,
                y: 1
            },
            rowPixelSpacing: 1,
            columnPixelSpacing: 1,
            presentationSizeMode: "NONE"
        };
    }
    function dK() {
        const t = fK(), e = {
            scale: 1,
            translation: {
                x: 0,
                y: 0
            },
            voi: {
                windowWidth: void 0,
                windowCenter: void 0,
                voiLUTFunction: zi.LINEAR
            },
            invert: !1,
            pixelReplication: !1,
            rotation: 0,
            hflip: !1,
            vflip: !1,
            modalityLUT: void 0,
            voiLUT: void 0,
            colormap: void 0,
            labelmap: !1,
            displayedArea: t
        };
        return Object.assign({}, e, uK.viewport);
    }
    function wd(t, e) {
        if (t == null) throw new Error(e);
    }
    function gK(t) {
        return !(t == null || t === 0 || t === 180);
    }
    function s_(t, e = null) {
        return wd(t, "getImageSize: parameter image must not be undefined"), wd(t.width, "getImageSize: parameter image must have width"), wd(t.height, "getImageSize: parameter image must have height"), gK(e) ? {
            height: t.width,
            width: t.height
        } : {
            width: t.width,
            height: t.height
        };
    }
    function U4(t, e, n = null) {
        wd(t, "getImageScale: parameter canvas must not be undefined"), wd(e, "getImageScale: parameter image must not be undefined");
        const r = s_(e, n), i = e.rowPixelSpacing || 1, a = e.columnPixelSpacing || 1;
        let o = 1, s = 1;
        i < a ? s = a / i : o = i / a;
        const c = t.height / r.height / o, l = t.width / r.width / s;
        return {
            verticalScale: c,
            horizontalScale: l,
            scaleFactor: Math.min(l, c)
        };
    }
    function c_(t, e, n, r) {
        if (t === void 0) throw new Error("getDefaultViewport: parameter canvas must not be undefined");
        if (e === void 0) return dK();
        const i = U4(t, e, 0).scaleFactor;
        let a;
        return n === "PT" && e.isPreScaled ? a = {
            windowWidth: 5,
            windowCenter: 2.5
        } : e.windowWidth !== void 0 && e.windowCenter !== void 0 && (a = {
            windowWidth: Array.isArray(e.windowWidth) ? e.windowWidth[0] : e.windowWidth,
            windowCenter: Array.isArray(e.windowCenter) ? e.windowCenter[0] : e.windowCenter
        }), {
            scale: i,
            translation: {
                x: 0,
                y: 0
            },
            voi: a,
            invert: e.invert,
            pixelReplication: !1,
            rotation: 0,
            hflip: !1,
            vflip: !1,
            modalityLUT: e.modalityLUT,
            modality: n,
            voiLUT: e.voiLUT,
            colormap: r !== void 0 ? r : e.colormap,
            displayedArea: {
                tlhc: {
                    x: 1,
                    y: 1
                },
                brhc: {
                    x: e.columns,
                    y: e.rows
                },
                rowPixelSpacing: e.rowPixelSpacing === void 0 ? 1 : e.rowPixelSpacing,
                columnPixelSpacing: e.columnPixelSpacing === void 0 ? 1 : e.columnPixelSpacing,
                presentationSizeMode: "NONE"
            }
        };
    }
    function bC(t, e) {
        return o_(t).transformPoint(e);
    }
    function hK(t) {
        const { image: e } = t;
        t.viewport.scale = U4(t.canvas, e, t.viewport.rotation).scaleFactor, t.viewport.translation.x = 0, t.viewport.translation.y = 0;
    }
    function pK(t) {
        const { canvas: e } = t, { clientWidth: n, clientHeight: r } = e;
        (e.width !== n || e.height !== r) && (e.width = n, e.height = r);
    }
    function mK(t, e, n) {
        const r = t.viewport.scale, i = s_(t.image, t.viewport.rotation), a = Math.round(i.width * r), o = Math.round(i.height * r), s = t.viewport.translation.x, c = t.viewport.translation.y;
        return a === e && o <= n || a <= e && o === n && s === 0 && c === 0;
    }
    function vK(t, e, n) {
        const r = t.viewport.scale, i = t.canvas.width, a = t.canvas.height, o = i / e, s = a / n, c = Math.sqrt(o * s);
        t.viewport.scale = c * r;
    }
    function yK(t, e = !1) {
        const n = t.canvas.width, r = t.canvas.height;
        pK(t), t.image !== void 0 && (e || mK(t, n, r) ? hK(t) : vK(t, n, r));
    }
    function CK(t, e) {
        const { hflip: n, vflip: r, rotation: i } = e;
        if (t.x *= n ? -1 : 1, t.y *= r ? -1 : 1, i !== 0) {
            const a = i * Math.PI / 180, o = Math.cos(a), s = Math.sin(a), c = t.x * o - t.y * s, l = t.x * s + t.y * o;
            t.x = c, t.y = l;
        }
        return t;
    }
    function wK(t, e = !0, n = !0) {
        const { canvas: r, image: i, viewport: a } = t, o = U4(r, i, 0).scaleFactor;
        a.vflip = !1, a.hflip = !1, e && (a.translation.x = 0, a.translation.y = 0), n && (a.displayedArea.tlhc.x = 1, a.displayedArea.tlhc.y = 1, a.displayedArea.brhc.x = i.columns, a.displayedArea.brhc.y = i.rows, a.scale = o);
    }
    const LC = P4.getLogger("utilities", "getClosestImageId");
    function Pd(t, e, n, r) {
        const { direction: i, spacing: a, imageIds: o } = t, { ignoreSpacing: s = !1 } = r || {};
        if (!o?.length) return;
        const c = i.slice(6, 9), l = xt(c, n);
        if (Math.abs(l) < 1 - Jo) return;
        let f;
        s || (f = ng({
            direction: i,
            spacing: a
        }, n) / 2);
        let u, g = 1 / 0;
        for(let h = 0; h < o.length; h++){
            const v = o[h], m = ct("imagePlaneModule", v);
            if (!m?.imagePositionPatient) {
                LC.warn(`Missing imagePositionPatient for imageId: ${v}`);
                continue;
            }
            const { imagePositionPatient: y } = m, C = Xe();
            In(C, e, y);
            const T = Math.abs(xt(C, n));
            s ? T < g && (g = T, u = v) : T < f && T < g && (g = T, u = v);
        }
        return u === void 0 && LC.warn("No imageId found within the specified criteria (half spacing or absolute closest)."), u;
    }
    function TK(t, e) {
        const n = xt(t, e), r = Ys(Xe(), e, 2 * n);
        return In(Xe(), t, r);
    }
    function PC(t, e, n, r) {
        let i = px(t);
        if (n && jc(i, i), e) {
            const a = bn(Xe(), r, i);
            jn(a, a), i = TK(i, a);
        }
        return i;
    }
    const VC = P4.getLogger("RenderingEngine", "StackViewport");
    ua = class extends uf {
        constructor(e){
            super(e), this.imageIds = [], this.imageKeyToIndexMap = new Map, this.currentImageIdIndex = 0, this.targetImageIdIndex = 0, this.imagesLoader = this, this.globalDefaultProperties = {}, this.perImageIdDefaultProperties = new Map, this.voiUpdatedWithSetProperties = !1, this.invert = !1, this.initialInvert = !1, this.initialTransferFunctionNodes = null, this.stackInvalidated = !1, this._publishCalibratedEvent = !1, this.updateRenderingPipeline = ()=>{
                this._configureRenderingPipeline();
            }, this.resize = ()=>{
                this.useCPURendering && this._resizeCPU();
            }, this._resizeCPU = ()=>{
                this._cpuFallbackEnabledElement.viewport && yK(this._cpuFallbackEnabledElement);
            }, this.getFrameOfReferenceUID = (n)=>this.getImagePlaneReferenceData(n)?.FrameOfReferenceUID, this.getCornerstoneImage = ()=>this.csImage, this.createActorMapper = (n)=>{
                const r = cH.newInstance();
                r.setInputData(n);
                const i = yH.newInstance();
                i.setMapper(r);
                const { preferSizeOverAccuracy: a } = tf().rendering;
                return a && r.setPreferSizeOverAccuracy(!0), n.getPointData().getScalars().getNumberOfComponents() > 1 && i.getProperty().setIndependentComponents(!1), i;
            }, this.getNumberOfSlices = ()=>this.imageIds.length, this.getDefaultProperties = (n)=>{
                let r;
                return n !== void 0 && (r = this.perImageIdDefaultProperties.get(n)), r !== void 0 ? r : {
                    ...this.globalDefaultProperties
                };
            }, this.getProperties = ()=>{
                const { colormap: n, voiRange: r, VOILUTFunction: i, interpolationType: a, invert: o, voiUpdatedWithSetProperties: s } = this;
                return {
                    colormap: n,
                    voiRange: r,
                    VOILUTFunction: i,
                    interpolationType: a,
                    invert: o,
                    isComputedVOI: !s
                };
            }, this.resetCameraForResize = ()=>this.resetCamera({
                    resetPan: !0,
                    resetZoom: !0,
                    resetToCenter: !0,
                    suppressEvents: !0
                }), this.getRotationCPU = ()=>{
                const { viewport: n } = this._cpuFallbackEnabledElement;
                return n.rotation;
            }, this.getRotationGPU = ()=>{
                const { viewUp: n, viewPlaneNormal: r, flipVertical: i, flipHorizontal: a } = this.getCameraNoRotation(), o = PC(this.initialViewUp, a, i, r), c = vx(o, n) * 180 / Math.PI, l = bn(Xe(), o, n);
                return xt(l, r) >= 0 ? c : (360 - c) % 360;
            }, this.setRotation = (n)=>{
                const r = this.getCamera();
                if (this.useCPURendering ? this.setRotationCPU(n) : this.setRotationGPU(n), this._suppressCameraModifiedEvents) return;
                const i = this.getCamera(), a = {
                    previousCamera: r,
                    camera: i,
                    element: this.element,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId
                };
                We(this.element, Ge.CAMERA_MODIFIED, a);
            }, this.renderImageObject = (n)=>{
                this._setCSImage(n), (this.useCPURendering ? this._updateToDisplayImageCPU : this._updateActorToDisplayImageId).call(this, n);
            }, this._setCSImage = (n)=>{
                n.isPreScaled = n.preScale?.scaled, this.csImage = n;
            }, this.canvasToWorldCPU = (n, r = [
                0,
                0,
                0
            ])=>{
                if (!this._cpuFallbackEnabledElement.image) return;
                const [i, a] = L1(this._cpuFallbackEnabledElement, n), { origin: o, spacing: s, direction: c } = this.getImageData(), l = c.slice(0, 3), f = c.slice(3, 6);
                return $i(r, o, l, i * s[0]), $i(r, r, f, a * s[1]), r;
            }, this.worldToCanvasCPU = (n)=>{
                const { spacing: r, direction: i, origin: a } = this.getImageData(), o = i.slice(0, 3), s = i.slice(3, 6), c = kr(Xe(), n, a), l = [
                    xt(c, o) / r[0],
                    xt(c, s) / r[1]
                ];
                return bC(this._cpuFallbackEnabledElement, l);
            }, this.canvasToWorldGPUContextPool = (n)=>{
                const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), o = i.getDistance();
                i.setClippingRange(o, o + .1);
                const s = window.devicePixelRatio || 1, { width: c, height: l } = this.canvas, f = c / l, u = [
                    n[0] * s,
                    n[1] * s
                ], g = [
                    u[0] / c,
                    1 - u[1] / l,
                    0
                ], h = r.normalizedDisplayToProjection(g[0], g[1], g[2]), v = r.projectionToView(h[0], h[1], h[2], f), m = r.viewToWorld(v[0], v[1], v[2]);
                return i.setClippingRange(a[0], a[1]), [
                    m[0],
                    m[1],
                    m[2]
                ];
            }, this.canvasToWorldGPUTiled = (n)=>{
                const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), o = i.getDistance();
                i.setClippingRange(o, o + .1);
                const c = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), l = c.getSize(), f = window.devicePixelRatio || 1, u = [
                    n[0] * f,
                    n[1] * f
                ], g = [
                    u[0] + this.sx,
                    u[1] + this.sy
                ];
                g[1] = l[1] - g[1];
                const h = c.displayToWorld(g[0], g[1], 0, r);
                return i.setClippingRange(a[0], a[1]), [
                    h[0],
                    h[1],
                    h[2]
                ];
            }, this.worldToCanvasGPUContextPool = (n)=>{
                const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), o = i.getDistance();
                i.setClippingRange(o, o + .1);
                const s = window.devicePixelRatio || 1, { width: c, height: l } = this.canvas, f = c / l, u = r.worldToView(n[0], n[1], n[2]), g = r.viewToProjection(u[0], u[1], u[2], f), h = r.projectionToNormalizedDisplay(g[0], g[1], g[2]), v = h[0] * c, m = (1 - h[1]) * l;
                return i.setClippingRange(a[0], a[1]), [
                    v / s,
                    m / s
                ];
            }, this.worldToCanvasGPUTiled = (n)=>{
                const r = this.getRenderer(), i = this.getVtkActiveCamera(), a = i.getClippingRange(), o = i.getDistance();
                i.setClippingRange(o, o + .1);
                const c = this.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), l = c.getSize(), f = c.worldToDisplay(...n, r);
                f[1] = l[1] - f[1];
                const u = [
                    f[0] - this.sx,
                    f[1] - this.sy
                ];
                i.setClippingRange(a[0], a[1]);
                const g = window.devicePixelRatio || 1;
                return [
                    u[0] / g,
                    u[1] / g
                ];
            }, this.getCurrentImageIdIndex = ()=>this.currentImageIdIndex, this.getSliceIndex = ()=>this.currentImageIdIndex, this.getTargetImageIdIndex = ()=>this.targetImageIdIndex, this.getImageIds = ()=>this.imageIds, this.getCurrentImageId = (n = this.getCurrentImageIdIndex())=>this.imageIds[n], this.hasImageId = (n)=>this.imageKeyToIndexMap.has(n), this.hasImageURI = (n)=>this.imageKeyToIndexMap.has(n), this.customRenderViewportToCanvas = ()=>{
                if (!this.useCPURendering) throw new Error("Custom cpu rendering pipeline should only be hit in CPU rendering mode");
                return this._cpuFallbackEnabledElement.image ? (a_(this._cpuFallbackEnabledElement, this.cpuRenderingInvalidated), this.cpuRenderingInvalidated = !1) : this.fillWithBackgroundColor(), {
                    canvas: this.canvas,
                    element: this.element,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId,
                    viewportStatus: this.viewportStatus
                };
            }, this.renderingPipelineFunctions = {
                getImageData: {
                    cpu: this.getImageDataCPU,
                    gpu: this.getImageDataGPU
                },
                setColormap: {
                    cpu: this.setColormapCPU,
                    gpu: this.setColormapGPU
                },
                getCamera: {
                    cpu: this.getCameraCPU,
                    gpu: super.getCamera
                },
                setCamera: {
                    cpu: this.setCameraCPU,
                    gpu: super.setCamera
                },
                getPan: {
                    cpu: this.getPanCPU,
                    gpu: super.getPan
                },
                setPan: {
                    cpu: this.setPanCPU,
                    gpu: super.setPan
                },
                getZoom: {
                    cpu: this.getZoomCPU,
                    gpu: super.getZoom
                },
                setZoom: {
                    cpu: this.setZoomCPU,
                    gpu: super.setZoom
                },
                setVOI: {
                    cpu: this.setVOICPU,
                    gpu: this.setVOIGPU
                },
                getRotation: {
                    cpu: this.getRotationCPU,
                    gpu: this.getRotationGPU
                },
                setInterpolationType: {
                    cpu: this.setInterpolationTypeCPU,
                    gpu: this.setInterpolationTypeGPU
                },
                setInvertColor: {
                    cpu: this.setInvertColorCPU,
                    gpu: this.setInvertColorGPU
                },
                resetCamera: {
                    cpu: (n = {})=>{
                        const { resetPan: r = !0, resetZoom: i = !0 } = n;
                        return this.resetCameraCPU({
                            resetPan: r,
                            resetZoom: i
                        }), !0;
                    },
                    gpu: (n = {})=>{
                        const { resetPan: r = !0, resetZoom: i = !0 } = n;
                        return this.resetCameraGPU({
                            resetPan: r,
                            resetZoom: i
                        }), !0;
                    }
                },
                canvasToWorld: {
                    cpu: this.canvasToWorldCPU,
                    gpu: {
                        tiled: this.canvasToWorldGPUTiled,
                        contextPool: this.canvasToWorldGPUContextPool
                    }
                },
                worldToCanvas: {
                    cpu: this.worldToCanvasCPU,
                    gpu: {
                        tiled: this.worldToCanvasGPUTiled,
                        contextPool: this.worldToCanvasGPUContextPool
                    }
                },
                getRenderer: {
                    cpu: ()=>this.getCPUFallbackError("getRenderer"),
                    gpu: {
                        tiled: this.getRendererTiled,
                        contextPool: this.getRendererContextPool
                    }
                },
                getDefaultActor: {
                    cpu: ()=>this.getCPUFallbackError("getDefaultActor"),
                    gpu: super.getDefaultActor
                },
                getActors: {
                    cpu: ()=>this.getCPUFallbackError("getActors"),
                    gpu: super.getActors
                },
                getActor: {
                    cpu: ()=>this.getCPUFallbackError("getActor"),
                    gpu: super.getActor
                },
                setActors: {
                    cpu: ()=>this.getCPUFallbackError("setActors"),
                    gpu: super.setActors
                },
                addActors: {
                    cpu: ()=>this.getCPUFallbackError("addActors"),
                    gpu: super.addActors
                },
                addActor: {
                    cpu: ()=>this.getCPUFallbackError("addActor"),
                    gpu: super.addActor
                },
                removeAllActors: {
                    cpu: ()=>this.getCPUFallbackError("removeAllActors"),
                    gpu: super.removeAllActors
                },
                unsetColormap: {
                    cpu: this.unsetColormapCPU,
                    gpu: this.unsetColormapGPU
                }
            }, this.scaling = {}, this.modality = null, this.useCPURendering = gd(), this._configureRenderingPipeline(), this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport(), this.currentImageIdIndex = 0, this.targetImageIdIndex = 0, this.resetCamera(), this.initializeElementDisabledHandler();
        }
        setUseCPURendering(e) {
            this.useCPURendering = e, this._configureRenderingPipeline(e);
        }
        static get useCustomRenderingPipeline() {
            return gd();
        }
        _configureRenderingPipeline(e) {
            const n = HD();
            this.useCPURendering = e ?? gd();
            for(const r in this.renderingPipelineFunctions)if (Object.prototype.hasOwnProperty.call(this.renderingPipelineFunctions, r)) {
                const i = this.renderingPipelineFunctions[r];
                this.useCPURendering ? this[r] = i.cpu : typeof i.gpu == "object" && i.gpu.tiled && i.gpu.contextPool ? this[r] = n ? i.gpu.contextPool : i.gpu.tiled : this[r] = i.gpu;
            }
            this.useCPURendering ? this._resetCPUFallbackElement() : this._resetGPUViewport();
        }
        _resetCPUFallbackElement() {
            this._cpuFallbackEnabledElement = {
                canvas: this.canvas,
                renderingTools: {},
                transform: new df,
                viewport: {
                    rotation: 0
                }
            };
        }
        _resetGPUViewport() {
            const e = this.getRenderer(), n = C4.newInstance();
            e.setActiveCamera(n), this.initialViewUp = [
                0,
                -1,
                0
            ], n.setDirectionOfProjection(-0, -0, 1), n.setViewUp(...this.initialViewUp), n.setParallelProjection(!0), n.setThicknessFromFocalPoint(.1), n.setFreezeFocalPoint(!0);
        }
        initializeElementDisabledHandler() {
            Ke.addEventListener(Ge.ELEMENT_DISABLED, function e() {
                clearTimeout(this.debouncedTimeout), Ke.removeEventListener(Ge.ELEMENT_DISABLED, e);
            });
        }
        getImageDataGPU() {
            const e = this.getDefaultActor();
            if (!e || !ps(e)) return;
            const { actor: n } = e, r = n.getMapper().getInputData(), i = this.csImage;
            return {
                dimensions: r.getDimensions(),
                spacing: r.getSpacing(),
                origin: r.getOrigin(),
                direction: r.getDirection(),
                get scalarData () {
                    return i?.voxelManager.getScalarData();
                },
                imageData: n.getMapper().getInputData(),
                metadata: {
                    Modality: this.modality,
                    FrameOfReferenceUID: this.getFrameOfReferenceUID()
                },
                scaling: this.scaling,
                hasPixelSpacing: this.hasPixelSpacing,
                calibration: {
                    ...i?.calibration,
                    ...this.calibration
                },
                preScale: {
                    ...i?.preScale
                },
                voxelManager: i?.voxelManager
            };
        }
        getImageDataCPU() {
            const { metadata: e } = this._cpuFallbackEnabledElement;
            if (!e) return;
            const n = e.spacing, r = this.csImage;
            return {
                dimensions: e.dimensions,
                spacing: n,
                origin: e.origin,
                direction: e.direction,
                metadata: {
                    Modality: this.modality,
                    FrameOfReferenceUID: this.getFrameOfReferenceUID()
                },
                scaling: this.scaling,
                imageData: {
                    getDirection: ()=>e.direction,
                    getDimensions: ()=>e.dimensions,
                    getScalarData: ()=>this.cpuImagePixelData,
                    getSpacing: ()=>n,
                    worldToIndex: (i)=>{
                        const a = this.worldToCanvasCPU(i), o = L1(this._cpuFallbackEnabledElement, a);
                        return [
                            o[0],
                            o[1],
                            0
                        ];
                    },
                    indexToWorld: (i, a)=>{
                        const o = bC(this._cpuFallbackEnabledElement, [
                            i[0],
                            i[1]
                        ]);
                        return this.canvasToWorldCPU(o, a);
                    }
                },
                scalarData: this.cpuImagePixelData,
                hasPixelSpacing: this.hasPixelSpacing,
                calibration: {
                    ...r?.calibration,
                    ...this.calibration
                },
                preScale: {
                    ...r?.preScale
                },
                voxelManager: r?.voxelManager
            };
        }
        calibrateIfNecessary(e, n) {
            const r = ct("calibratedPixelSpacing", e), i = this.calibration !== r, { scale: a } = r || {};
            return this.hasPixelSpacing = a > 0 || n.rowPixelSpacing > 0, n.calibration = r, i && (this.calibration = r, this._publishCalibratedEvent = !0, this._calibrationEvent = {
                scale: a,
                calibration: r
            }), n;
        }
        setDefaultProperties(e, n) {
            n == null ? this.globalDefaultProperties = e : (this.perImageIdDefaultProperties.set(n, e), this.getCurrentImageId() === n && this.setProperties(e));
        }
        clearDefaultProperties(e) {
            e == null ? (this.globalDefaultProperties = {}, this.resetProperties()) : (this.perImageIdDefaultProperties.delete(e), this.resetToDefaultProperties());
        }
        setProperties({ colormap: e, voiRange: n, VOILUTFunction: r, invert: i, interpolationType: a } = {}, o = !1) {
            this.viewportStatus = this.csImage ? sa.PRE_RENDER : sa.LOADING, this.globalDefaultProperties = {
                colormap: this.globalDefaultProperties.colormap ?? e,
                voiRange: this.globalDefaultProperties.voiRange ?? n,
                VOILUTFunction: this.globalDefaultProperties.VOILUTFunction ?? r,
                invert: this.globalDefaultProperties.invert ?? i,
                interpolationType: this.globalDefaultProperties.interpolationType ?? a
            }, typeof e < "u" && this.setColormap(e), typeof n < "u" && this.setVOI(n, {
                suppressEvents: o,
                voiUpdatedWithSetProperties: !0
            }), typeof r < "u" && this.setVOILUTFunction(r, o), typeof i < "u" && this.setInvertColor(i), typeof a < "u" && this.setInterpolationType(a);
        }
        resetProperties() {
            this.cpuRenderingInvalidated = !0, this.voiUpdatedWithSetProperties = !1, this.viewportStatus = sa.PRE_RENDER, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}), this._resetProperties(), this.render();
        }
        _resetProperties() {
            let e;
            if (this._isCurrentImagePTPrescaled() ? e = this._getDefaultPTPrescaledVOIRange() : e = this._getVOIRangeForCurrentImage(), this.setVOI(e), this.setInvertColor(this.initialInvert), this.setInterpolationType(Wc.LINEAR), !this.useCPURendering) {
                const n = this.getTransferFunction();
                bp(n, this.initialTransferFunctionNodes);
                const i = Hh(n).reduce((s, c)=>(s.push(c[0], c[1], c[2], c[3]), s), []), a = this.getDefaultActor(), o = H3(i, a.actor);
                this.setColormap(o);
            }
        }
        resetToDefaultProperties() {
            this.cpuRenderingInvalidated = !0, this.viewportStatus = sa.PRE_RENDER, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {});
            const e = this.getCurrentImageId(), n = this.perImageIdDefaultProperties.get(e) || this.globalDefaultProperties;
            n.colormap?.name && this.setColormap(n.colormap);
            let r;
            n.voiRange == null ? r = this._getVOIRangeForCurrentImage() : r = n.voiRange, this.setVOI(r), this.setInterpolationType(Wc.LINEAR), this.setInvertColor(!1), this.render();
        }
        _getVOIFromCache() {
            let e;
            return this.voiUpdatedWithSetProperties ? e = this.voiRange : this._isCurrentImagePTPrescaled() ? e = this._getDefaultPTPrescaledVOIRange() : e = this._getVOIRangeForCurrentImage() ?? this.voiRange, e;
        }
        _setPropertiesFromCache() {
            const e = this._getVOIFromCache(), { interpolationType: n, invert: r } = this;
            this.setVOI(e), this.setInterpolationType(n), this.setInvertColor(r);
        }
        getCameraCPU() {
            const { metadata: e, viewport: n } = this._cpuFallbackEnabledElement;
            if (!e) return {};
            const { direction: r } = e, i = r.slice(6, 9).map((u)=>-u);
            let a = r.slice(3, 6).map((u)=>-u);
            if (n.rotation) {
                const u = B3(xs(), n.rotation * Math.PI / 180, i);
                a = pn(Xe(), a, u);
            }
            const o = [
                this.element.clientWidth / 2,
                this.element.clientHeight / 2
            ], s = this.canvasToWorld(o), c = this.canvasToWorld([
                0,
                0
            ]), l = this.canvasToWorld([
                0,
                this.element.clientHeight
            ]), f = rc(c, l) / 2;
            return {
                parallelProjection: !0,
                focalPoint: s,
                position: [
                    0,
                    0,
                    0
                ],
                parallelScale: f,
                scale: n.scale,
                viewPlaneNormal: [
                    i[0],
                    i[1],
                    i[2]
                ],
                viewUp: [
                    a[0],
                    a[1],
                    a[2]
                ],
                flipHorizontal: this.flipHorizontal,
                flipVertical: this.flipVertical
            };
        }
        setCameraCPU(e) {
            const { viewport: n, image: r } = this._cpuFallbackEnabledElement, i = this.getCameraCPU(), { focalPoint: a, parallelScale: o, scale: s, flipHorizontal: c, flipVertical: l } = e, { clientHeight: f } = this.element;
            if (a) {
                const g = this.worldToCanvasCPU(a), h = L1(this._cpuFallbackEnabledElement, g), v = this.worldToCanvasCPU(i.focalPoint), m = L1(this._cpuFallbackEnabledElement, v), y = sn();
                yi(y, b9(h[0], h[1]), b9(m[0], m[1]));
                const C = CK({
                    x: y[0],
                    y: y[1]
                }, n);
                n.translation.x -= C.x, n.translation.y -= C.y;
            }
            if (o) {
                const { rowPixelSpacing: g } = r, h = f * g * .5 / o;
                n.scale = h, n.parallelScale = o;
            }
            if (s) {
                const { rowPixelSpacing: g } = r;
                n.scale = s, n.parallelScale = f * g * .5 / s;
            }
            (c !== void 0 || l !== void 0) && this.setFlipCPU({
                flipHorizontal: c,
                flipVertical: l
            }), this._cpuFallbackEnabledElement.transform = Ld(this._cpuFallbackEnabledElement);
            const u = {
                previousCamera: i,
                camera: this.getCamera(),
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId
            };
            We(this.element, Ge.CAMERA_MODIFIED, u);
        }
        getPanCPU() {
            const { viewport: e } = this._cpuFallbackEnabledElement;
            return [
                e.translation.x,
                e.translation.y
            ];
        }
        setPanCPU(e) {
            const n = this.getCameraCPU();
            this.setCameraCPU({
                ...n,
                focalPoint: [
                    ...e.map((r)=>-r),
                    0
                ]
            });
        }
        getZoomCPU() {
            const { viewport: e } = this._cpuFallbackEnabledElement;
            return e.scale;
        }
        setZoomCPU(e) {
            const n = this.getCameraCPU();
            this.setCameraCPU({
                ...n,
                scale: e
            });
        }
        setFlipCPU({ flipHorizontal: e, flipVertical: n }) {
            const { viewport: r } = this._cpuFallbackEnabledElement;
            e !== void 0 && (r.hflip = e, this.flipHorizontal = r.hflip), n !== void 0 && (r.vflip = n, this.flipVertical = r.vflip);
        }
        setVOILUTFunction(e, n) {
            if (this.useCPURendering) throw new Error("VOI LUT function is not supported in CPU rendering");
            const r = this._getValidVOILUTFunction(e);
            let i = !1;
            this.VOILUTFunction !== r && (i = !0), this.VOILUTFunction = r;
            const { voiRange: a } = this.getProperties();
            this.setVOI(a, {
                suppressEvents: n,
                forceRecreateLUTFunction: i
            });
        }
        setRotationCPU(e) {
            const { viewport: n } = this._cpuFallbackEnabledElement;
            n.rotation = e;
        }
        setRotationGPU(e) {
            const n = this.getPan(this.fitToCanvasCamera), r = this.getPan(), i = Yu([
                0,
                0
            ], n, r);
            this.setPan(i, !1);
            const { flipVertical: a, flipHorizontal: o, viewPlaneNormal: s } = this.getCamera(), c = PC(this.initialViewUp, o, a, s);
            this.setCameraNoEvent({
                viewUp: c
            }), this.getVtkActiveCamera().roll(-e);
            const l = this.getPan(), f = this.getPan(this.fitToCanvasCamera), u = Yu([
                0,
                0
            ], l, f), g = $3([
                0,
                0
            ], n, u);
            this.setPan(g, !1);
        }
        setInterpolationTypeGPU(e) {
            const n = this.getDefaultActor();
            if (!n || !ps(n)) return;
            const { actor: r } = n;
            r.getProperty().setInterpolationType(e), this.interpolationType = e;
        }
        setInterpolationTypeCPU(e) {
            const { viewport: n } = this._cpuFallbackEnabledElement;
            n.pixelReplication = e !== Wc.LINEAR, this.interpolationType = e;
        }
        setInvertColorCPU(e) {
            const { viewport: n } = this._cpuFallbackEnabledElement;
            n && (n.invert = e, this.invert = e);
        }
        setInvertColorGPU(e) {
            const n = this.getDefaultActor();
            if (n && ps(n)) {
                if (Ya(n, "vtkVolume")) {
                    const i = n.actor.getProperty().getRGBTransferFunction(0);
                    (!this.invert && e || this.invert && !e) && pd(i), this.invert = e;
                } else if (Ya(n, "vtkImageSlice")) {
                    const i = n.actor.getProperty().getRGBTransferFunction(0);
                    (!this.invert && e || this.invert && !e) && pd(i), this.invert = e;
                }
            }
        }
        setVOICPU(e, n = {}) {
            const { suppressEvents: r = !1 } = n, { viewport: i, image: a } = this._cpuFallbackEnabledElement;
            if (!i || !a) return;
            if (typeof e > "u") {
                const { windowWidth: s, windowCenter: c } = a, l = Array.isArray(s) ? s[0] : s, f = Array.isArray(c) ? c[0] : c;
                i.voi = {
                    windowWidth: l,
                    windowCenter: f,
                    voiLUTFunction: a.voiLUTFunction
                };
                const { lower: u, upper: g } = Fu(l, f, a.voiLUTFunction);
                e = {
                    lower: u,
                    upper: g
                };
            } else {
                const { lower: s, upper: c } = e, { windowCenter: l, windowWidth: f } = Zd(s, c);
                i.voi || (i.voi = {
                    windowWidth: 0,
                    windowCenter: 0,
                    voiLUTFunction: a.voiLUTFunction
                }), i.voi.windowWidth = f, i.voi.windowCenter = l;
            }
            this.voiRange = e;
            const o = {
                viewportId: this.id,
                range: e
            };
            r || We(this.element, Ge.VOI_MODIFIED, o);
        }
        getTransferFunction() {
            const e = this.getDefaultActor();
            return !e || !ps(e) ? void 0 : e.actor.getProperty().getRGBTransferFunction(0);
        }
        setVOIGPU(e, n = {}) {
            const { suppressEvents: r = !1, forceRecreateLUTFunction: i = !1, voiUpdatedWithSetProperties: a = !1 } = n;
            if (e && this.voiRange && this.voiRange.lower === e.lower && this.voiRange.upper === e.upper && !i && !this.stackInvalidated) return;
            const o = this.getDefaultActor();
            if (!o || !ps(o)) return;
            const s = o.actor;
            let c = e;
            if (typeof c > "u") {
                const h = s.getMapper().getInputData().getPointData().getScalars().getRange();
                c = {
                    lower: h[0],
                    upper: h[1]
                };
            }
            s.getProperty().setUseLookupTableScalarRange(!0);
            let l = s.getProperty().getRGBTransferFunction(0);
            const f = this.VOILUTFunction === zi.SAMPLED_SIGMOID;
            if ((f || !l || i) && (l = (f ? Y3 : e_)(c), this.invert && pd(l), s.getProperty().setRGBTransferFunction(0, l), this.initialTransferFunctionNodes = Hh(l)), f || l.setRange(c.lower, c.upper), this.voiRange = c, this.voiUpdatedWithSetProperties || (this.voiUpdatedWithSetProperties = a), r) return;
            const u = {
                viewportId: this.id,
                range: c,
                VOILUTFunction: this.VOILUTFunction
            };
            We(this.element, Ge.VOI_MODIFIED, u);
        }
        _addScalingToViewport(e) {
            if (this.scaling.PT) return;
            const { suvbw: n, suvlbm: r, suvbsa: i } = e, a = {};
            r && (a.suvbwToSuvlbm = r / n), i && (a.suvbwToSuvbsa = i / n), this.scaling.PT = a;
        }
        getImageDataMetadata(e) {
            const n = e.imageId, r = JD(e), { numberOfComponents: i, origin: a, direction: o, dimensions: s, spacing: c, numVoxels: l, imagePixelModule: f, voiLUTFunction: u, modality: g, scalingFactor: h, calibration: v } = r;
            g === "PT" && h && this._addScalingToViewport(h), this.modality = g;
            const m = this._getValidVOILUTFunction(u);
            this.VOILUTFunction = m, this.calibration = v;
            let y = this._getImagePlaneModule(n);
            return this.useCPURendering || (y = this.calibrateIfNecessary(n, y)), {
                bitsAllocated: f.bitsAllocated,
                numberOfComponents: i,
                origin: a,
                direction: o,
                dimensions: s,
                spacing: c,
                numVoxels: l,
                imagePlaneModule: y,
                imagePixelModule: f
            };
        }
        matchImagesForOverlay(e, n) {
            return ((i)=>{
                const a = ct(Ia.IMAGE_PLANE, n), o = ct(Ia.IMAGE_PLANE, i), s = a.imageOrientationPatient, c = o.imageOrientationPatient;
                if (s && c) {
                    if (lr(a.imageOrientationPatient, o.imageOrientationPatient)) {
                        const f = a.imagePositionPatient, u = o.imagePositionPatient;
                        if (f && u && lr(f, u)) {
                            const h = a.rows, v = a.columns, m = o.rows, y = o.columns;
                            if (h === m && v === y) return i;
                        }
                    }
                } else {
                    const l = a.rows, f = a.columns, u = o.rows, g = o.columns;
                    if (l === u && f === g) return i;
                }
            })(e);
        }
        getImagePlaneReferenceData(e = this.getCurrentImageIdIndex()) {
            const n = this.imageIds[e];
            if (!n) return;
            const r = ct(Ia.IMAGE_PLANE, n);
            if (!r) return;
            const { imagePositionPatient: i, frameOfReferenceUID: a } = r;
            let { rowCosines: o, columnCosines: s } = r;
            o ||= [
                1,
                0,
                0
            ], s ||= [
                0,
                1,
                0
            ];
            const c = bn([
                0,
                0,
                0
            ], s, o);
            return {
                FrameOfReferenceUID: a,
                viewPlaneNormal: c,
                cameraFocalPoint: i,
                referencedImageId: n,
                sliceIndex: e
            };
        }
        _getCameraOrientation(e) {
            const n = e.slice(6, 9).map((i)=>-i), r = e.slice(3, 6).map((i)=>-i);
            return {
                viewPlaneNormal: [
                    n[0],
                    n[1],
                    n[2]
                ],
                viewUp: [
                    r[0],
                    r[1],
                    r[2]
                ]
            };
        }
        createVTKImageData({ origin: e, direction: n, dimensions: r, spacing: i, numberOfComponents: a, pixelArray: o }) {
            const s = new o.constructor(o.length), c = Wt.newInstance({
                name: "Pixels",
                numberOfComponents: a,
                values: s
            }), l = Up.newInstance();
            return l.setDimensions(r), l.setSpacing(i), l.setDirection(n), l.setOrigin(e), l.getPointData().setScalars(c), l;
        }
        _createVTKImageData({ origin: e, direction: n, dimensions: r, spacing: i, numberOfComponents: a, pixelArray: o }) {
            try {
                this._imageData = this.createVTKImageData({
                    origin: e,
                    direction: n,
                    dimensions: r,
                    spacing: i,
                    numberOfComponents: a,
                    pixelArray: o
                });
            } catch (s) {
                VC.error(s);
            }
        }
        async setStack(e, n = 0) {
            if (this._throwIfDestroyed(), this.imageIds = e, n > e.length) throw new Error("Current image index is greater than the number of images in the stack");
            this.imageKeyToIndexMap.clear(), e.forEach((o, s)=>{
                this.imageKeyToIndexMap.set(o, s), this.imageKeyToIndexMap.set(ur(o), s);
            }), this.currentImageIdIndex = n, this.targetImageIdIndex = n;
            const r = ct(Zu.IMAGE_RETRIEVE_CONFIGURATION, e[n], "stack");
            this.imagesLoader = r ? (r.create || bD)(r) : this, this.stackInvalidated = !0, this.flipVertical = !1, this.flipHorizontal = !1, this.voiRange = null, this.interpolationType = Wc.LINEAR, this.invert = !1, this.viewportStatus = sa.LOADING, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}, delete this._cpuFallbackEnabledElement.viewport.colormap);
            const i = await this._setImageIdIndex(n), a = {
                imageIds: e,
                viewportId: this.id,
                element: this.element,
                currentImageIdIndex: n
            };
            return We(this.element, Ge.VIEWPORT_NEW_IMAGE_SET, a), i;
        }
        _throwIfDestroyed() {
            if (this.isDisabled) throw new Error("The stack viewport has been destroyed and is no longer usable. Renderings will not be performed. If you are using the same viewportId and have re-enabled the viewport, you need to grab the new viewport instance using renderingEngine.getViewport(viewportId), instead of using your lexical scoped reference to the viewport instance.");
        }
        _checkVTKImageDataMatchesCornerstoneImage(e, n) {
            if (!n) return !1;
            const [r, i] = n.getSpacing(), [a, o] = n.getDimensions(), s = this._getImagePlaneModule(e.imageId), c = n.getDirection(), l = c.slice(0, 3), f = c.slice(3, 6), u = n.getPointData().getScalars().getDataType(), g = lr(r, e.columnPixelSpacing), h = lr(i, e.rowPixelSpacing), v = g || e.columnPixelSpacing === null && r === 1, m = h || e.rowPixelSpacing === null && i === 1, y = a === e.columns, C = o === e.rows, T = lr(s.rowCosines, l), x = lr(s.columnCosines, f), S = u === e.voxelManager.getScalarData().constructor.name;
            return v && m && y && C && T && x && S;
        }
        _updateVTKImageDataFromCornerstoneImage(e) {
            let r = this._getImagePlaneModule(e.imageId).imagePositionPatient;
            r == null && (r = [
                0,
                0,
                0
            ]), this._imageData.setOrigin(r);
            const i = this.getActor(this.id);
            i && (i.referencedId = e.imageId), zp(this._imageData, e);
        }
        _loadAndDisplayImage(e, n) {
            return this.useCPURendering ? this._loadAndDisplayImageCPU(e, n) : this._loadAndDisplayImageGPU(e, n);
        }
        _loadAndDisplayImageCPU(e, n) {
            return new Promise((r, i)=>{
                function a(h, v, m) {
                    if (this.currentImageIdIndex !== v) return;
                    const y = h.voxelManager.getScalarData(), C = h.preScale, T = C?.scalingParameters, x = C?.scaled && T?.rescaleIntercept % 1 !== 0 || T?.rescaleSlope % 1 !== 0;
                    if (y instanceof Float32Array && x) {
                        const D = {
                            min: h.minPixelValue,
                            max: h.maxPixelValue
                        }, P = Math.abs(D.max - D.min) / 65535, F = D.min, N = y.length, B = new Uint16Array(N);
                        let G = 65535, Z = 0;
                        for(let H = 0; H < N; H++){
                            const ne = Math.floor((y[H] - F) / P);
                            B[H] = ne, G = Math.min(G, ne), Z = Math.max(Z, ne);
                        }
                        h.minPixelValue = G, h.maxPixelValue = Z, h.slope = P, h.intercept = F, h.voxelManager ? h.voxelManager.getScalarData = ()=>B : h.getPixelData = ()=>B, h.preScale = {
                            ...h.preScale,
                            scaled: !1
                        };
                    }
                    this._setCSImage(h), this.viewportStatus = sa.PRE_RENDER;
                    const S = {
                        image: h,
                        imageId: m,
                        imageIdIndex: v,
                        viewportId: this.id,
                        renderingEngineId: this.renderingEngineId
                    };
                    We(this.element, Ge.STACK_NEW_IMAGE, S), this._updateToDisplayImageCPU(h), this.render(), this.currentImageIdIndex = v, r(m);
                }
                function o(h, v, m) {
                    const y = {
                        error: h,
                        imageIdIndex: v,
                        imageId: m
                    };
                    this.suppressEvents || We(Ke, Ge.IMAGE_LOAD_ERROR, y), i(h);
                }
                function s(h, v, m) {
                    return $l(h, m).then((y)=>{
                        a.call(this, y, v, h);
                    }, (y)=>{
                        o.call(this, y, v, h);
                    });
                }
                const c = -5, l = Gt.Interaction, f = {
                    imageId: e,
                    imageIdIndex: n
                }, u = {
                    useRGBA: !0,
                    requestType: l
                }, g = {
                    imageId: e,
                    imageIdIndex: n,
                    viewportId: this.id,
                    renderingEngineId: this.renderingEngineId
                };
                We(this.element, Ge.PRE_STACK_NEW_IMAGE, g), xo.addRequest(s.bind(this, e, n, u), l, f, c);
            });
        }
        successCallback(e, n) {
            const r = this.imageIds.indexOf(e);
            if (this.currentImageIdIndex !== r) return;
            const i = this.csImage?.imageFrame, a = n?.imageFrame, o = i?.photometricInterpretation || this.csImage?.photometricInterpretation, s = a?.photometricInterpretation || n?.photometricInterpretation;
            o !== s && (this.stackInvalidated = !0), this._setCSImage(n);
            const c = {
                image: n,
                imageId: e,
                imageIdIndex: r,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId
            };
            this._updateActorToDisplayImageId(n), We(this.element, Ge.STACK_NEW_IMAGE, c), this.render(), this.currentImageIdIndex = r;
        }
        errorCallback(e, n, r) {
            if (!n) return;
            const i = this.imageIds.indexOf(e), a = {
                error: r,
                imageIdIndex: i,
                imageId: e
            };
            We(Ke, Ge.IMAGE_LOAD_ERROR, a);
        }
        getLoaderImageOptions(e) {
            const n = this.imageIds.indexOf(e), { transferSyntaxUID: r } = ct("transferSyntax", e) || {};
            return {
                useRGBA: !1,
                transferSyntaxUID: r,
                priority: 5,
                requestType: Gt.Interaction,
                additionalDetails: {
                    imageId: e,
                    imageIdIndex: n
                }
            };
        }
        async loadImages(e, n) {
            const r = await Promise.allSettled(e.map((a)=>{
                const o = this.getLoaderImageOptions(a);
                return $l(a, o).then((s)=>(n.successCallback(a, s), a), (s)=>(n.errorCallback(a, !0, s), a));
            })), i = r.filter((a)=>a.status === "rejected");
            if (i && i.length) {
                const a = new CustomEvent(Ge.IMAGE_LOAD_ERROR, {
                    detail: i,
                    cancelable: !0
                });
                Ke.dispatchEvent(a);
            }
            return r;
        }
        _loadAndDisplayImageGPU(e, n) {
            if (!e) {
                console.warn("No image id set yet to load");
                return;
            }
            const r = {
                imageId: e,
                imageIdIndex: n,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId
            };
            return We(this.element, Ge.PRE_STACK_NEW_IMAGE, r), this.imagesLoader.loadImages([
                e
            ], this).then((i)=>e);
        }
        _updateToDisplayImageCPU(e) {
            const n = this.getImageDataMetadata(e), r = c_(this.canvas, e, this.modality, this._cpuFallbackEnabledElement.viewport.colormap), { windowCenter: i, windowWidth: a, voiLUTFunction: o } = r.voi;
            this.voiRange = Fu(a, i, o), this._cpuFallbackEnabledElement.image = e, this._cpuFallbackEnabledElement.metadata = {
                ...n
            }, this.cpuImagePixelData = e.voxelManager.getScalarData();
            const s = Object.assign({}, r, this._cpuFallbackEnabledElement.viewport);
            this._cpuFallbackEnabledElement.viewport = this.stackInvalidated ? r : s, this.stackInvalidated = !1, this.cpuRenderingInvalidated = !0, this._cpuFallbackEnabledElement.transform = Ld(this._cpuFallbackEnabledElement);
        }
        getSliceViewInfo() {
            throw new Error("Method not implemented.");
        }
        addImages(e) {
            const n = [];
            e.forEach((r)=>{
                const { imageId: i, ...a } = r, o = ot.getImage(i), { origin: s, dimensions: c, direction: l, spacing: f, numberOfComponents: u } = this.getImageDataMetadata(o), g = this.createVTKImageData({
                    origin: s,
                    dimensions: c,
                    direction: l,
                    spacing: f,
                    numberOfComponents: u,
                    pixelArray: o.voxelManager.getScalarData()
                }), h = this.createActorMapper(g);
                h && (n.push({
                    uid: r.actorUID ?? Vn(),
                    actor: h,
                    referencedId: i,
                    ...a
                }), r.callback && r.callback({
                    imageActor: h,
                    imageId: r.imageId
                }));
            }), this.addActors(n);
        }
        _updateActorToDisplayImageId(e) {
            const n = this._checkVTKImageDataMatchesCornerstoneImage(e, this._imageData), r = this.getViewPresentation();
            if (n && !this.stackInvalidated) {
                this._updateVTKImageDataFromCornerstoneImage(e), this.resetCameraNoEvent(), this.setViewPresentation(r), this._setPropertiesFromCache(), this.stackActorReInitialized = !1;
                return;
            }
            const { origin: i, direction: a, dimensions: o, spacing: s, numberOfComponents: c, imagePixelModule: l } = this.getImageDataMetadata(e), f = e.voxelManager.getScalarData();
            this._createVTKImageData({
                origin: i,
                direction: a,
                dimensions: o,
                spacing: s,
                numberOfComponents: c,
                pixelArray: f
            }), this._updateVTKImageDataFromCornerstoneImage(e);
            const u = this.createActorMapper(this._imageData), g = this.getActors();
            g.length && g[0].uid === this.id ? g[0].actor = u : g.unshift({
                uid: this.id,
                actor: u,
                referencedId: e.imageId
            }), this.setActors(g);
            const { viewPlaneNormal: h, viewUp: v } = this._getCameraOrientation(a), m = this.getCamera();
            this.setCameraNoEvent({
                viewUp: v,
                viewPlaneNormal: h
            }), this.initialViewUp = v, this.resetCameraNoEvent(), this.setViewPresentation(r), this.triggerCameraEvent(this.getCamera(), m);
            const y = l.photometricInterpretation === "MONOCHROME1";
            this.stackInvalidated = !0;
            const C = this._getInitialVOIRange(e);
            this.setVOI(C, {
                forceRecreateLUTFunction: !!y
            }), this.initialInvert = !!y, this.setInvertColor(this.invert || this.initialInvert), this.stackInvalidated = !1, this.stackActorReInitialized = !0, this._publishCalibratedEvent && this.triggerCalibrationEvent();
        }
        _getInitialVOIRange(e) {
            if (this.voiRange && this.voiUpdatedWithSetProperties) return this.voiRange;
            const { windowCenter: n, windowWidth: r, voiLUTFunction: i } = e;
            let a = this._getVOIRangeFromWindowLevel(r, n, i);
            return a = this._getPTPreScaledRange() || a, a;
        }
        _getPTPreScaledRange() {
            if (this._isCurrentImagePTPrescaled()) return this._getDefaultPTPrescaledVOIRange();
        }
        _isCurrentImagePTPrescaled() {
            return !(this.modality !== "PT" || !this.csImage.isPreScaled || !this.csImage.preScale?.scalingParameters.suvbw);
        }
        _getDefaultPTPrescaledVOIRange() {
            return {
                lower: 0,
                upper: 5
            };
        }
        _getVOIRangeFromWindowLevel(e, n, r = zi.LINEAR) {
            let i, a;
            if (typeof n == "number" && typeof e == "number" ? (i = n, a = e) : Array.isArray(n) && Array.isArray(e) && (i = n[0], a = e[0]), i !== void 0 && a !== void 0) return Fu(a, i, r);
        }
        async _setImageIdIndex(e) {
            if (e >= this.imageIds.length) throw new Error(`ImageIdIndex provided ${e} is invalid, the stack only has ${this.imageIds.length} elements`);
            this.currentImageIdIndex = e, this.hasPixelSpacing = !0, this.viewportStatus = sa.PRE_RENDER;
            const n = await this._loadAndDisplayImage(this.imageIds[e], e);
            if (this.perImageIdDefaultProperties.size >= 1) {
                const r = this.perImageIdDefaultProperties.get(n);
                r !== void 0 ? this.setProperties(r) : this.globalDefaultProperties !== void 0 && this.setProperties(this.globalDefaultProperties);
            }
            return n;
        }
        resetCameraCPU({ resetPan: e = !0, resetZoom: n = !0 }) {
            const { image: r } = this._cpuFallbackEnabledElement;
            if (!r) return;
            wK(this._cpuFallbackEnabledElement, e, n);
            const { scale: i } = this._cpuFallbackEnabledElement.viewport, { clientWidth: a, clientHeight: o } = this.element, s = [
                a / 2,
                o / 2
            ], c = this.canvasToWorldCPU(s);
            this.setCameraCPU({
                focalPoint: c,
                scale: i
            });
        }
        resetCameraGPU({ resetPan: e, resetZoom: n }) {
            return this.setCamera({
                flipHorizontal: !1,
                flipVertical: !1,
                viewUp: this.initialViewUp
            }), super.resetCamera({
                resetPan: e,
                resetZoom: n,
                resetToCenter: !0
            });
        }
        scroll(e, n = !0, r = !1) {
            const i = this.imageIds;
            if (isNaN(this.targetImageIdIndex)) return;
            const a = this.targetImageIdIndex, o = i.length;
            let s = a + e;
            r ? s = (s + o) % o : s = Math.max(0, Math.min(o - 1, s)), this.targetImageIdIndex = s;
            const c = i[s];
            ot.isLoaded(c) || !n ? this.setImageIdIndex(s) : (clearTimeout(this.debouncedTimeout), this.debouncedTimeout = window.setTimeout(()=>{
                this.setImageIdIndex(s);
            }, 40));
            const f = {
                newImageIdIndex: s,
                imageId: c,
                direction: e
            };
            s !== a && We(this.element, Ge.STACK_VIEWPORT_SCROLL, f);
        }
        setImageIdIndex(e) {
            if (this._throwIfDestroyed(), this.currentImageIdIndex === e) return Promise.resolve(this.getCurrentImageId());
            const n = this._setImageIdIndex(e);
            return this.targetImageIdIndex = e, n;
        }
        calibrateSpacing(e) {
            const n = this.getImageIds().indexOf(e);
            this.stackInvalidated = !0, this._loadAndDisplayImage(e, n);
        }
        triggerCameraEvent(e, n) {
            const r = {
                previousCamera: n,
                camera: e,
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId
            };
            this.suppressEvents || We(this.element, Ge.CAMERA_MODIFIED, r);
        }
        triggerCalibrationEvent() {
            const { imageData: e } = this.getImageData(), n = {
                element: this.element,
                viewportId: this.id,
                renderingEngineId: this.renderingEngineId,
                imageId: this.getCurrentImageId(),
                imageData: e,
                worldToIndex: e.getWorldToIndex(),
                ...this._calibrationEvent
            };
            this.suppressEvents || We(this.element, Ge.IMAGE_SPACING_CALIBRATED, n), this._publishCalibratedEvent = !1;
        }
        jumpToWorld(e) {
            const n = this.getImageIds(), r = this.getImageData(), { direction: i, spacing: a } = r, o = Pd({
                direction: i,
                spacing: a,
                imageIds: n
            }, e, this.getCamera().viewPlaneNormal, {
                ignoreSpacing: !0
            }), s = n.indexOf(o);
            return s === -1 ? !1 : (this.setImageIdIndex(s), this.render(), !0);
        }
        getRendererContextPool() {
            return this.getRenderingEngine().getRenderer(this.id);
        }
        getRendererTiled() {
            const e = this.getRenderingEngine();
            if (!e || e.hasBeenDestroyed) throw new Error("Rendering engine has been destroyed");
            return e.offscreenMultiRenderWindow?.getRenderer(this.id);
        }
        _getVOIRangeForCurrentImage() {
            const { windowCenter: e, windowWidth: n, voiLUTFunction: r } = this.csImage;
            return this._getVOIRangeFromWindowLevel(n, e, r);
        }
        _getValidVOILUTFunction(e) {
            return Object.values(zi).includes(e) ? e : zi.LINEAR;
        }
        getSliceInfo() {
            const e = this.getSliceIndex(), { dimensions: n } = this.getImageData();
            return {
                width: n[0],
                height: n[1],
                sliceIndex: e,
                slicePlane: 2
            };
        }
        isReferenceViewable(e, n = {}) {
            const r = this.getCurrentImageIdIndex(), i = this.imageIds[r];
            if (!i || !e) return !1;
            const { referencedImageId: a, multiSliceReference: o } = e;
            if (a) {
                if (a === i) return !0;
                e.referencedImageURI ||= ur(a);
                const { referencedImageURI: c } = e, l = this.imageKeyToIndexMap.get(c);
                if (n.asOverlay && this.matchImagesForOverlay(i, a)) return !0;
                if (l === void 0) return !1;
                if (n.withNavigation) return !0;
                const f = o && this.imageKeyToIndexMap.get(o.referencedImageId);
                return r <= f && r >= l;
            }
            if (!super.isReferenceViewable(e, n)) return !1;
            if (e.volumeId) return n.asVolume;
            const { cameraFocalPoint: s } = e;
            if (n.asNearbyProjection && s) {
                const { spacing: c, direction: l, origin: f } = this.getImageData(), u = l.slice(6, 9), g = ng({
                    direction: l,
                    spacing: c
                }, u), h = kr(Xe(), s, f), v = xt(h, u), m = g / 2;
                if (Math.abs(v) <= m) return !0;
            }
            return !1;
        }
        getViewReference(e = {}) {
            const { sliceIndex: n = this.getCurrentImageIdIndex() } = e, r = super.getViewReference(e), i = this.getCurrentImageId(n);
            if (i) {
                if (r.referencedImageId = i, this.getCurrentImageIdIndex() !== n) {
                    const a = this.getImagePlaneReferenceData(n);
                    if (!a) return;
                    Object.assign(r, a);
                }
                return r;
            }
        }
        setViewReference(e) {
            if (!e?.referencedImageId) {
                e?.sliceIndex !== void 0 && this.scroll(e.sliceIndex - this.targetImageIdIndex);
                return;
            }
            const { referencedImageId: n } = e;
            e.referencedImageURI ||= ur(n);
            const { referencedImageURI: r } = e, i = this.imageKeyToIndexMap.get(r);
            if (i === void 0) {
                VC.error(`No image URI found for ${r}`);
                return;
            }
            this.scroll(i - this.targetImageIdIndex);
        }
        getViewReferenceId(e = {}) {
            const { sliceIndex: n = this.currentImageIdIndex } = e;
            return `imageId:${this.imageIds[n]}`;
        }
        getSliceIndexForImage(e) {
            if (e) {
                if (typeof e == "string") return this.imageKeyToIndexMap.get(e);
                if (e.referencedImageId) return this.imageKeyToIndexMap.get(e.referencedImageId);
            }
        }
        getCPUFallbackError(e) {
            return new Error(`method ${e} cannot be used during CPU Fallback mode`);
        }
        fillWithBackgroundColor() {
            const e = this.getRenderingEngine();
            e && e.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
        }
        unsetColormapCPU() {
            delete this._cpuFallbackEnabledElement.viewport.colormap, this._cpuFallbackEnabledElement.renderingTools = {}, this.cpuRenderingInvalidated = !0, this.fillWithBackgroundColor(), this.render();
        }
        setColormapCPU(e) {
            this.colormap = e;
            const n = Md(e.name);
            this._cpuFallbackEnabledElement.viewport.colormap = n, this._cpuFallbackEnabledElement.renderingTools = {}, this.fillWithBackgroundColor(), this.cpuRenderingInvalidated = !0, this.render();
            const r = {
                viewportId: this.id,
                colormap: e
            };
            We(this.element, Ge.COLORMAP_MODIFIED, r);
        }
        setColormapGPU(e) {
            const i = this.getDefaultActor().actor.getProperty(), a = i.getRGBTransferFunction(), o = Md(e.name) || Id.getPresetByName(e.name);
            if (a) a.applyColorMap(o), a.setMappingRange(this.voiRange.lower, this.voiRange.upper), i.setRGBTransferFunction(0, a);
            else {
                const c = Jc.newInstance();
                c.applyColorMap(o), c.setMappingRange(this.voiRange.lower, this.voiRange.upper), i.setRGBTransferFunction(0, c);
            }
            this.colormap = e, this.render();
            const s = {
                viewportId: this.id,
                colormap: e
            };
            We(this.element, Ge.COLORMAP_MODIFIED, s);
        }
        unsetColormapGPU() {
            throw new Error("unsetColormapGPU not implemented.");
        }
        _getImagePlaneModule(e) {
            const n = YD(e);
            return this.hasPixelSpacing = !n.usingDefaultValues || this.calibration?.scale > 0 || this.calibration?.rowPixelSpacing > 0, this.calibration ||= n.calibration, n;
        }
        isInAcquisitionPlane() {
            return !0;
        }
    };
    function Rl(t, e) {
        const { imageData: n } = t.getImageData(), r = t.canvasToWorld(e);
        return Co(n, r);
    }
    function op(t, e) {
        return t.indexToWorld(e);
    }
    function xK(t, e) {
        const { imageData: n } = t.getImageData(), r = op(n, e);
        return t.worldToCanvas(r);
    }
    wi = class extends So {
        constructor(e){
            super(e), this._useAcquisitionPlaneForViewPlane = !1, this.getNumberOfSlices = ()=>{
                const { numberOfSlices: r } = ip(this) || {};
                return r;
            }, this.resetCameraForResize = ()=>this.resetCamera({
                    resetPan: !0,
                    resetZoom: !0,
                    resetToCenter: !0,
                    resetRotation: !1,
                    suppressEvents: !0
                }), this.getCurrentImageIdIndex = (r, i = !0)=>{
                const { currentStepIndex: a } = Gu(this, r || this.getVolumeId(), i);
                return a;
            }, this.getSliceIndex = ()=>{
                const { imageIndex: r } = ip(this) || {};
                return r;
            }, this.getCurrentImageId = ()=>{
                const r = this.getDefaultActor();
                if (!r || !Ya(r, "vtkVolume")) return;
                const i = ot.getVolume(this.getVolumeId());
                if (!i) return;
                const { viewPlaneNormal: a, focalPoint: o } = this.getCamera();
                return Pd(i, o, a);
            }, this.getSlicePlaneCoordinates = ()=>{
                const r = this.getDefaultActor();
                if (!r?.actor) return console.warn("No image data found for calculating vtkPlanes."), [];
                const i = this.getVolumeId(), a = ot.getVolume(i), o = this.getCamera(), { focalPoint: s, position: c, viewPlaneNormal: l } = o, f = ng(a, l), u = Wp(r.actor, l, s), g = Math.round((u.current - u.min) / f), h = Math.round((u.max - u.current) / f), v = this.getSliceIndex(), m = [];
                for(let y = -g; y <= h; y++){
                    const { newFocalPoint: C } = Wu(s, c, u, l, f, y);
                    m.push({
                        sliceIndex: v + y,
                        point: C
                    });
                }
                return m;
            };
            const { orientation: n } = this.options;
            if (n && n !== kl.ACQUISITION) {
                this.applyViewOrientation(n);
                return;
            }
            this._useAcquisitionPlaneForViewPlane = !0;
        }
        async setVolumes(e, n = !1, r = !1) {
            const i = e[0].volumeId, a = ot.getVolume(i);
            if (!a) throw new Error(`imageVolume with id: ${i} does not exist`);
            return this._useAcquisitionPlaneForViewPlane ? (this._setViewPlaneToAcquisitionPlane(a), this._useAcquisitionPlaneForViewPlane = !1) : this.options.orientation && typeof this.options.orientation == "string" && this.options.orientation.includes("_reformat") && this._setViewPlaneToReformatOrientation(this.options.orientation, a), super.setVolumes(e, n, r);
        }
        async addVolumes(e, n = !1, r = !1) {
            const i = ot.getVolume(e[0].volumeId);
            if (!i) throw new Error(`imageVolume with id: ${i.volumeId} does not exist`);
            return this._useAcquisitionPlaneForViewPlane ? (this._setViewPlaneToAcquisitionPlane(i), this._useAcquisitionPlaneForViewPlane = !1) : this.options.orientation && typeof this.options.orientation == "string" && this.options.orientation.includes("_reformat") && this._setViewPlaneToReformatOrientation(this.options.orientation, i), super.addVolumes(e, n, r);
        }
        jumpToWorld(e) {
            const { focalPoint: n } = this.getCamera(), r = [
                0,
                0,
                0
            ];
            In(r, e, n);
            const i = this.getCamera(), a = i.viewPlaneNormal, o = xt(r, a), s = en(a[0], a[1], a[2]);
            if (Ys(s, s, o), Math.abs(s[0]) > .001 || Math.abs(s[1]) > .001 || Math.abs(s[2]) > .001) {
                const c = [
                    0,
                    0,
                    0
                ], l = [
                    0,
                    0,
                    0
                ];
                Qc(c, i.focalPoint, s), Qc(l, i.position, s), this.setCamera({
                    focalPoint: c,
                    position: l
                }), this.render();
            }
            return !0;
        }
        setOrientation(e, n = !0) {
            let r, i;
            if (typeof e == "string") {
                if (e === kl.ACQUISITION) ({ viewPlaneNormal: r, viewUp: i } = super._getAcquisitionPlaneOrientation());
                else if (e === kl.REFORMAT || e.includes("_reformat")) ({ viewPlaneNormal: r, viewUp: i } = jD(this, {
                    useViewportNormal: !0
                }));
                else if (Il[e]) ({ viewPlaneNormal: r, viewUp: i } = Il[e]);
                else throw new Error(`Invalid orientation: ${e}. Use Enums.OrientationAxis instead.`);
                this.setCamera({
                    viewPlaneNormal: r,
                    viewUp: i
                }), this.viewportProperties.orientation = e, this.resetCamera();
            } else ({ viewPlaneNormal: r, viewUp: i } = e), this.applyViewOrientation(e);
            n && this.render();
        }
        setCameraClippingRange() {
            const e = this.getVtkActiveCamera();
            if (!e) {
                console.warn("No active camera found");
                return;
            }
            e.getParallelProjection() ? e.setClippingRange(-Er.MAXIMUM_RAY_DISTANCE, Er.MAXIMUM_RAY_DISTANCE) : e.setClippingRange(Er.MINIMUM_SLAB_THICKNESS, Er.MAXIMUM_RAY_DISTANCE);
        }
        _setViewPlaneToReformatOrientation(e, n) {
            let r, i;
            if (n) {
                const { direction: a } = n;
                ({ viewPlaneNormal: r, viewUp: i } = zD(a.slice(0, 3), a.slice(3, 6), a.slice(6, 9), e));
            } else ({ viewPlaneNormal: r, viewUp: i } = this._getAcquisitionPlaneOrientation());
            this.setCamera({
                viewPlaneNormal: r,
                viewUp: i
            }), this.initialViewUp = i, this.resetCamera();
        }
        _setViewPlaneToAcquisitionPlane(e) {
            let n, r;
            if (e) {
                const { direction: i } = e;
                n = i.slice(6, 9).map((a)=>-a), r = i.slice(3, 6).map((a)=>-a);
            } else ({ viewPlaneNormal: n, viewUp: r } = this._getAcquisitionPlaneOrientation());
            this.setCamera({
                viewPlaneNormal: n,
                viewUp: r
            }), this.initialViewUp = r, this.resetCamera();
        }
        getBlendMode(e) {
            const n = this.getActors(), r = e?.length > 0 ? n.find((i)=>e.includes(i.uid)) : n[0];
            return r?.blendMode || r?.actor.getMapper().getBlendMode();
        }
        setBlendMode(e, n = [], r = !1) {
            let i = this.getActors();
            n?.length > 0 && (i = i.filter((a)=>n.includes(a.uid))), i.forEach((a)=>{
                const { actor: o } = a;
                o.getMapper().setBlendMode?.(e), a.blendMode = e;
            }), r && this.render();
        }
        resetCamera(e) {
            const { resetPan: n = !0, resetZoom: r = !0, resetRotation: i = !0, resetToCenter: a = !0, suppressEvents: o = !1, resetOrientation: s = !0 } = e || {}, { orientation: c } = this.viewportProperties;
            c && s && this.applyViewOrientation(c, !1), super.resetCamera({
                resetPan: n,
                resetZoom: r,
                resetToCenter: a
            });
            const l = this.getVtkActiveCamera(), f = l.getViewPlaneNormal(), u = l.getFocalPoint();
            if (this.getActors().forEach((h)=>{
                if (!h.actor) return;
                const v = h.actor.getMapper();
                if (v.getClippingPlanes().length === 0 && !h?.clippingFilter) {
                    const y = ca.newInstance(), C = ca.newInstance(), T = [
                        y,
                        C
                    ];
                    let x = Er.MINIMUM_SLAB_THICKNESS;
                    h.slabThickness && (x = h.slabThickness), this.setOrientationOfClippingPlanes(T, x, f, u), v.addClippingPlane(y), v.addClippingPlane(C);
                }
            }), i && Il[this.viewportProperties.orientation] !== void 0) {
                const h = Il[this.viewportProperties.orientation];
                this.setCameraNoEvent({
                    viewUp: h.viewUp,
                    viewPlaneNormal: h.viewPlaneNormal
                });
            }
            if (!o) {
                const h = {
                    viewportId: this.id,
                    camera: this.getCamera(),
                    renderingEngineId: this.renderingEngineId,
                    element: this.element
                };
                We(this.element, Ge.CAMERA_RESET, h);
            }
            return !0;
        }
        setSlabThickness(e, n = []) {
            e < .1 && (e = .1);
            let r = this.getActors();
            n?.length > 0 && (r = r.filter((a)=>n.includes(a.uid))), r.forEach((a)=>{
                Ya(a, "vtkVolume") && (a.slabThickness = e);
            });
            const i = this.getCamera();
            this.updateClippingPlanesForActors(i), this.triggerCameraModifiedEventIfNecessary(i, i), this.viewportProperties.slabThickness = e;
        }
        resetSlabThickness() {
            this.getActors().forEach((r)=>{
                Ya(r, "vtkVolume") && (r.slabThickness = Er.MINIMUM_SLAB_THICKNESS);
            });
            const n = this.getCamera();
            this.updateClippingPlanesForActors(n), this.triggerCameraModifiedEventIfNecessary(n, n), this.viewportProperties.slabThickness = void 0;
        }
        isInAcquisitionPlane() {
            const e = this.getImageData();
            if (!e) return !1;
            const { direction: n } = e, { viewPlaneNormal: r } = this.getCamera(), i = [
                n[6],
                n[7],
                n[8]
            ];
            return Math.abs(xt(r, i)) > .99;
        }
        getSliceViewInfo() {
            const { width: e, height: n } = this.getCanvas(), r = Rl(this, [
                0,
                0
            ]), i = Rl(this, [
                e - 1,
                0
            ]), a = Rl(this, [
                0,
                n - 1
            ]), o = In(Xe(), i, r), s = In(Xe(), a, r), c = bn(Xe(), o, s);
            jn(o, o), jn(s, s), jn(c, c);
            const { dimensions: l } = this.getImageData(), [f, u, g] = l, m = [
                [
                    0,
                    0,
                    0
                ],
                [
                    f - 1,
                    0,
                    0
                ],
                [
                    0,
                    u - 1,
                    0
                ],
                [
                    f - 1,
                    u - 1,
                    0
                ],
                [
                    0,
                    0,
                    g - 1
                ],
                [
                    f - 1,
                    0,
                    g - 1
                ],
                [
                    0,
                    u - 1,
                    g - 1
                ],
                [
                    f - 1,
                    u - 1,
                    g - 1
                ]
            ].map((N)=>xK(this, N)).reduce((N, B)=>(N.minX = Math.min(N.minX, B[0]), N.minY = Math.min(N.minY, B[1]), N.maxX = Math.max(N.maxX, B[0]), N.maxY = Math.max(N.maxY, B[1]), N), {
                minX: 1 / 0,
                minY: 1 / 0,
                maxX: -1 / 0,
                maxY: -1 / 0
            }), y = Rl(this, [
                m.minX,
                m.minY
            ]), C = N3(o[0], o[1], o[2], 0, s[0], s[1], s[2], 0, c[0], c[1], c[2], 0, y[0], y[1], y[2], 1), T = Rl(this, [
                m.maxX,
                m.maxY
            ]), x = In(Xe(), T, y), S = Xr(xs(), C), { viewPlaneNormal: D } = this.getCamera();
            if (D.filter((N)=>Math.abs(N) > Jo).length > 1) throw new Error("getSliceInfo is not supported for oblique views");
            const M = D.findIndex((N)=>Math.abs(N) > 1 - Jo);
            if (M === -1) throw new Error("Unable to determine slice axis");
            const P = xt(o, x) + 1, F = xt(s, x) + 1;
            return {
                sliceIndex: this.getSliceIndex(),
                width: P,
                height: F,
                slicePlane: M,
                sliceToIndexMatrix: C,
                indexToSliceMatrix: S
            };
        }
        getCurrentSlicePixelData() {
            const { voxelManager: e } = this.getImageData();
            return e.getSliceData(this.getSliceViewInfo());
        }
        getViewReference(e = {}) {
            const n = super.getViewReference(e);
            if (!n?.volumeId) return;
            const r = ot.getVolume(n.volumeId);
            return n.referencedImageId = Pd(r, n.cameraFocalPoint, n.viewPlaneNormal), n;
        }
        resetProperties(e) {
            this._resetProperties(e);
        }
        _resetProperties(e) {
            const n = e ? this.getActor(e) : this.getDefaultActor();
            if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
            n.slabThickness && (n.slabThickness = Er.MINIMUM_SLAB_THICKNESS, this.viewportProperties.slabThickness = void 0, this.updateClippingPlanesForActors(this.getCamera())), e ||= this.getVolumeId();
            const r = ot.getVolume(e);
            if (!r) throw new Error(`imageVolume with id: ${e} does not exist in cache`);
            if (M4(n.actor, r), ps(n)) {
                const l = n.actor.getProperty().getRGBTransferFunction(0);
                bp(l, this.initialTransferFunctionNodes);
            }
            const i = {
                ...super.getVOIModifiedEventDetail(e)
            };
            this.resetCamera({
                resetPan: !0,
                resetZoom: !0,
                resetToCenter: !0,
                resetCameraRotation: !0
            }), We(this.element, Ge.VOI_MODIFIED, i);
        }
        getSlicesClippingPlanes() {
            const e = this.getSlicePlaneCoordinates(), { viewPlaneNormal: n } = this.getCamera(), r = Er.MINIMUM_SLAB_THICKNESS;
            return e.map(({ point: i, sliceIndex: a })=>{
                const o = [
                    ca.newInstance(),
                    ca.newInstance()
                ];
                return this.setOrientationOfClippingPlanes(o, r, n, i), {
                    sliceIndex: a,
                    planes: o.map((s)=>({
                            normal: s.getNormal(),
                            origin: s.getOrigin()
                        }))
                };
            });
        }
    };
    F4 = class extends So {
        constructor(e){
            super(e), this.getNumberOfSlices = ()=>1, this.getRotation = ()=>0, this.getCurrentImageIdIndex = ()=>0, this.getCurrentImageId = ()=>null, this.resetCameraForResize = ()=>this.resetCamera({
                    resetPan: !0,
                    resetZoom: !0,
                    resetToCenter: !0
                });
            const { parallelProjection: n, orientation: r } = this.options, i = this.getVtkActiveCamera();
            n != null && i.setParallelProjection(n), r && r !== kl.ACQUISITION && this.applyViewOrientation(r);
        }
        isInAcquisitionPlane() {
            return !1;
        }
        resetCamera({ resetPan: e = !0, resetZoom: n = !0, resetToCenter: r = !0 } = {}) {
            super.resetCamera({
                resetPan: e,
                resetZoom: n,
                resetToCenter: r
            });
            const i = this.getVtkActiveCamera();
            return i.getParallelProjection() ? i.setClippingRange(-Er.MAXIMUM_RAY_DISTANCE, Er.MAXIMUM_RAY_DISTANCE) : i.setClippingRange(Er.MINIMUM_SLAB_THICKNESS, Er.MAXIMUM_RAY_DISTANCE), this.getRenderer().resetCameraClippingRange(), !0;
        }
        setSlabThickness(e, n) {
            return null;
        }
        setBlendMode(e, n, r) {
            return null;
        }
        resetProperties(e) {
            const n = e ? this.getActor(e) : this.getDefaultActor();
            if (!n) throw new Error(`No actor found for the given volumeId: ${e}`);
            n.slabThickness && (n.slabThickness = Er.MINIMUM_SLAB_THICKNESS, this.viewportProperties.slabThickness = void 0, this.updateClippingPlanesForActors(this.getCamera())), e ||= this.getVolumeId();
            const r = ot.getVolume(e);
            if (!r) throw new Error(`imageVolume with id: ${e} does not exist in cache`);
            if (M4(n.actor, r), ps(n)) {
                const i = n.actor.getProperty().getRGBTransferFunction(0);
                bp(i, this.initialTransferFunctionNodes);
            }
            this.setCamera(this.initialCamera), We(this.element, Ge.VOI_MODIFIED, super.getVOIModifiedEventDetail(e));
        }
        getSliceIndex() {
            return null;
        }
        setCamera(e) {
            super.setCamera(e), this.getRenderer().resetCameraClippingRange(), this.render();
        }
        setCameraClippingRange() {
            const e = this.getVtkActiveCamera();
            e.getParallelProjection() ? e.setClippingRange(-Er.MAXIMUM_RAY_DISTANCE, Er.MAXIMUM_RAY_DISTANCE) : e.setClippingRange(Er.MINIMUM_SLAB_THICKNESS, Er.MAXIMUM_RAY_DISTANCE);
        }
        resetSlabThickness() {
            return null;
        }
    };
    SK = async function(t, e, n, r = !1, i = !1) {
        n.forEach((o)=>{
            const s = t.getViewport(o);
            if (!s) throw new Error(`Viewport with Id ${o} does not exist`);
            if (!(s instanceof So)) throw new Error("setVolumesForViewports only supports VolumeViewport and VolumeViewport3D");
        });
        const a = n.map(async (o)=>{
            await t.getViewport(o).setVolumes(e, r, i);
        });
        await Promise.all(a);
    };
    EK = async function(t, e, n, r = !1, i = !1) {
        for (const o of n){
            const s = t.getViewport(o);
            if (!s) throw new Error(`Viewport with Id ${o} does not exist`);
            if (!(s instanceof So)) {
                console.warn(`Viewport with Id ${o} is not a BaseVolumeViewport. Cannot add volume to this viewport.`);
                return;
            }
        }
        const a = n.map(async (o)=>{
            await t.getViewport(o).addVolumes(e, r, i);
        });
        await Promise.all(a);
    };
    DK = function(t, e, n) {
        for (const r of n){
            const i = t.getViewport(r);
            if (!i) throw new Error(`Viewport with Id ${r} does not exist`);
            if (!i.addImages) {
                console.warn(`Viewport with Id ${r} does not have addImages. Cannot add image segmentation to this viewport.`);
                return;
            }
        }
        n.forEach((r)=>{
            t.getViewport(r).addImages(e);
        });
    };
    class _K {
        constructor(e){
            this.opacity = .4, this.outlineOpacity = .4, this.transferFunction = [], this.actor = e;
        }
        setRGBTransferFunction(e, n) {
            this.transferFunction[e] = n;
        }
        setScalarOpacity(e) {}
        setInterpolationTypeToNearest() {}
        setUseLabelOutline() {}
        setLabelOutlineOpacity(e) {
            this.outlineOpacity = e;
        }
        setLabelOutlineThickness() {}
        getColor(e) {
            const n = this.transferFunction[0], r = n.getRedValue(e), i = n.getGreenValue(e), a = n.getBlueValue(e);
            return [
                r,
                i,
                a,
                this.opacity
            ];
        }
    }
    class RK {
        constructor(e){
            this.actor = e;
        }
        getInputData() {
            return this.actor.getImage();
        }
    }
    class OK {
        constructor(e, n){
            this.canvasProperties = new _K(this), this.visibility = !1, this.mapper = new RK(this), this.className = "CanvasActor", this.derivedImage = n, this.viewport = e;
        }
        renderRLE(e, n, r) {
            const { width: i, height: a } = this.image;
            let { canvas: o } = this;
            (!o || o.width !== i || o.height !== a) && (this.canvas = o = new window.OffscreenCanvas(i, a));
            const s = o.getContext("2d"), c = s.createImageData(i, a), { data: l } = c;
            l.fill(0);
            const { map: f } = r;
            let u = 1 / 0, g = 1 / 0, h = -1 / 0, v = -1 / 0;
            for(let C = 0; C < a; C++){
                const T = f.getRun(C, 0);
                if (!T) continue;
                g = Math.min(g, C), v = Math.max(v, C);
                const x = C * i << 2;
                let S;
                for (const D of T){
                    const { start: _, end: M, value: P } = D;
                    if (P === 0) {
                        S ||= [], S.push(T.indexOf(D));
                        continue;
                    }
                    u = Math.min(u, _), h = Math.max(h, M);
                    const F = this.canvasProperties.getColor(P).map((B)=>B * 255);
                    let N = x + (_ << 2);
                    for(let B = _; B < M; B++)l[N++] = F[0], l[N++] = F[1], l[N++] = F[2], l[N++] = F[3];
                }
            }
            if (u > i) return;
            const m = h - u, y = v - g;
            s.putImageData(c, 0, 0, u - 1, g - 1, m + 2, y + 2), n.drawImage(o, u, g, m, y, u, g, m, y);
        }
        setMapper(e) {
            this.mapper = e;
        }
        render(e, n) {
            if (!this.visibility) return;
            const r = this.image || this.getImage(), { width: i, height: a } = r, o = r.getScalarData();
            if (!o) return;
            const { voxelManager: s } = r;
            if (s && s.map.getRun) {
                this.renderRLE(e, n, s);
                return;
            }
            let { canvas: c } = this;
            (!c || c.width !== i || c.height !== a) && (this.canvas = c = new window.OffscreenCanvas(i, a));
            const l = c.getContext("2d"), f = l.createImageData(i, a), { data: u } = f;
            let g = 0, h = 0, v = 1 / 0, m = 1 / 0, y = -1 / 0, C = -1 / 0;
            for(let S = 0; S < a; S++)for(let D = 0; D < i; D++){
                const _ = o[g++];
                if (_) {
                    v = Math.min(D, v), m = Math.min(S, m), y = Math.max(D, y), C = Math.max(S, C);
                    const M = this.canvasProperties.getColor(_);
                    u[h] = M[0] * 255, u[h + 1] = M[1] * 255, u[h + 2] = M[2] * 255, u[h + 3] = 127;
                }
                h += 4;
            }
            if (v > i) return;
            const T = y - v + 1, x = C - m + 1;
            l.putImageData(f, 0, 0, v, m, T, x), n.drawImage(c, v, m, T, x, v, m, T, x);
        }
        getClassName() {
            return this.className;
        }
        getProperty() {
            return this.canvasProperties;
        }
        setVisibility(e) {
            this.visibility = e;
        }
        getMapper() {
            return this.mapper;
        }
        isA(e) {
            return e === this.className;
        }
        getImage() {
            if (this.image) return this.image;
            this.image = {
                ...this.derivedImage
            };
            const e = this.viewport.getImageData();
            return Object.assign(this.image, {
                worldToIndex: (n)=>e.imageData.worldToIndex(n),
                indexToWorld: (n, r)=>e.imageData.indexToWorld(n, r),
                getDimensions: ()=>e.dimensions,
                getScalarData: ()=>this.derivedImage?.getPixelData(),
                getDirection: ()=>e.direction,
                getSpacing: ()=>e.spacing,
                setOrigin: ()=>null,
                setDerivedImage: (n)=>{
                    this.derivedImage = n, this.image = null;
                },
                modified: ()=>null
            }), this.image;
        }
    }
    class vh {
        static{
            this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
        }
        static imageIdToFrames(e) {
            const n = e.match(this.frameRangeExtractor);
            if (!n || !n[2]) return null;
            const r = n[2].split("-").map((i)=>Number(i));
            return r.length === 1 ? r[0] : r;
        }
        static imageIdToFrameEnd(e) {
            const n = this.imageIdToFrames(e);
            return Array.isArray(n) ? n[1] : n;
        }
        static imageIdToFrameStart(e) {
            const n = this.imageIdToFrames(e);
            return Array.isArray(n) ? n[0] : n;
        }
        static framesToString(e) {
            return Array.isArray(e) ? `${e[0]}-${e[1]}` : String(e);
        }
        static framesToImageId(e, n) {
            const r = e.match(this.frameRangeExtractor);
            if (!r || !r[2]) return null;
            const i = this.framesToString(n);
            return e.replace(this.frameRangeExtractor, `${r[1]}${i}`);
        }
    }
    sp = class extends uf {
        static{
            this.frameRangeExtractor = /(\/frames\/|[&?]frameNumber=)([^/&?]*)/i;
        }
        constructor(e){
            super({
                ...e,
                canvas: e.canvas || Zo(e.element)
            }), this.videoWidth = 0, this.videoHeight = 0, this.loop = !0, this.mute = !0, this.isPlaying = !1, this.scrollSpeed = 1, this.playbackRate = 1, this.frameRange = [
                0,
                0
            ], this.fps = 30, this.videoCamera = {
                panWorld: [
                    0,
                    0
                ],
                parallelScale: 1
            }, this.voiRange = {
                lower: 0,
                upper: 255
            }, this.getProperties = ()=>({
                    loop: this.videoElement.loop,
                    muted: this.videoElement.muted,
                    playbackRate: this.playbackRate,
                    scrollSpeed: this.scrollSpeed,
                    voiRange: {
                        ...this.voiRange
                    }
                }), this.getMiddleSliceData = ()=>{
                throw new Error("Method not implemented.");
            }, this.useCustomRenderingPipeline = !0, this.resetCamera = ()=>(this.refreshRenderValues(), this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height), this.isPlaying || this.renderFrame(), !0), this.getNumberOfSlices = ()=>{
                const n = Math.round(this.videoElement.duration * this.fps / this.scrollSpeed);
                return isNaN(n) ? this.numberOfFrames : n;
            }, this.getFrameOfReferenceUID = ()=>this.videoElement.src, this.resize = ()=>{
                const n = this.canvas, { clientWidth: r, clientHeight: i } = n;
                (n.width !== r || n.height !== i) && (n.width = r, n.height = i), this.refreshRenderValues(), this.isPlaying || this.renderFrame();
            }, this.canvasToWorld = (n, r = [
                0,
                0,
                0
            ])=>{
                const i = this.videoCamera.panWorld, a = this.getWorldToCanvasRatio(), o = [
                    i[0] * a,
                    i[1] * a
                ], s = [
                    n[0] - o[0],
                    n[1] - o[1]
                ];
                return r.splice(0, 2, s[0] / a, s[1] / a), r;
            }, this.worldToCanvas = (n)=>{
                const r = this.videoCamera.panWorld, i = this.getWorldToCanvasRatio();
                return [
                    (n[0] + r[0]) * i,
                    (n[1] + r[1]) * i
                ];
            }, this.getRotation = ()=>0, this.canvasToIndex = (n)=>{
                const r = this.getTransform();
                return r.invert(), r.transformPoint(n.map((i)=>i * devicePixelRatio));
            }, this.indexToCanvas = (n)=>this.getTransform().transformPoint(n).map((i)=>i / devicePixelRatio), this.customRenderViewportToCanvas = ()=>{
                this.renderFrame();
            }, this.renderFrame = ()=>{
                const n = window.devicePixelRatio || 1, i = this.getTransform().getMatrix(), a = this.canvasContext;
                a.resetTransform(), a.clearRect(0, 0, this.canvas.width, this.canvas.height), a.transform(i[0] / n, i[1] / n, i[2] / n, i[3] / n, i[4] / n, i[5] / n), a.drawImage(this.videoElement, 0, 0, this.videoWidth, this.videoHeight);
                for (const s of this.getActors())s.actor.render(this, this.canvasContext);
                this.canvasContext.resetTransform(), We(this.element, Ge.STACK_NEW_IMAGE, {
                    element: this.element,
                    viewportId: this.id,
                    viewport: this,
                    renderingEngineId: this.renderingEngineId,
                    time: this.videoElement.currentTime,
                    duration: this.videoElement.duration
                }), We(this.element, Ge.IMAGE_RENDERED, {
                    element: this.element,
                    viewportId: this.id,
                    viewport: this,
                    imageIndex: this.getCurrentImageIdIndex(),
                    numberOfSlices: this.numberOfFrames,
                    renderingEngineId: this.renderingEngineId,
                    time: this.videoElement.currentTime,
                    duration: this.videoElement.duration
                }), this.initialRender?.();
                const o = this.getFrameNumber();
                this.isPlaying && (o < this.frameRange[0] ? this.setFrameNumber(this.frameRange[0]) : o > this.frameRange[1] && (this.loop ? this.setFrameNumber(this.frameRange[0]) : this.pause()));
            }, this.renderWhilstPlaying = ()=>{
                this.renderFrame(), this.isPlaying && requestAnimationFrame(this.renderWhilstPlaying);
            }, this.canvasContext = this.canvas.getContext("2d"), this.renderingEngineId = e.renderingEngineId, this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.videoElement = document.createElement("video"), this.videoElement.muted = this.mute, this.videoElement.loop = this.loop, this.videoElement.autoplay = !0, this.videoElement.crossOrigin = "anonymous", this.addEventListeners(), this.resize();
        }
        static get useCustomRenderingPipeline() {
            return !0;
        }
        addEventListeners() {
            this.canvas.addEventListener(Ge.ELEMENT_DISABLED, this.elementDisabledHandler);
        }
        removeEventListeners() {
            this.canvas.removeEventListener(Ge.ELEMENT_DISABLED, this.elementDisabledHandler);
        }
        elementDisabledHandler() {
            this.removeEventListeners(), this.videoElement.remove();
        }
        getImageDataMetadata(e) {
            const n = typeof e == "string" ? e : e.imageId, r = ct(Ia.IMAGE_PLANE, n);
            let i = r.rowCosines, a = r.columnCosines;
            (r.usingDefaultValues || i == null || a == null) && (i = [
                1,
                0,
                0
            ], a = [
                0,
                1,
                0
            ]);
            const s = en(i[0], i[1], i[2]), c = en(a[0], a[1], a[2]), { rows: l, columns: f } = r, u = Xe();
            bn(u, s, c);
            let g = r.imagePositionPatient;
            g == null && (g = [
                0,
                0,
                0
            ]);
            const h = r.columnPixelSpacing || 1, v = r.rowPixelSpacing || 1, m = r.columns, y = r.rows, C = 1, T = 1;
            return this.hasPixelSpacing = !!r.columnPixelSpacing, {
                bitsAllocated: 8,
                numberOfComponents: 3,
                origin: g,
                rows: l,
                columns: f,
                direction: [
                    ...s,
                    ...c,
                    ...u
                ],
                dimensions: [
                    m,
                    y,
                    T
                ],
                spacing: [
                    h,
                    v,
                    C
                ],
                hasPixelSpacing: this.hasPixelSpacing,
                numVoxels: m * y * T,
                imagePlaneModule: r
            };
        }
        setDataIds(e, n) {
            this.setVideo(e[0], (n.viewReference?.sliceIndex || 0) + 1);
        }
        setVideo(e, n) {
            this.imageId = Array.isArray(e) ? e[0] : e;
            const r = ct(Ia.IMAGE_URL, e);
            if (!r?.rendered) throw new Error(`Video Image ID ${e} does not have a rendered video view`);
            const { rendered: i } = r, a = ct(Ia.GENERAL_SERIES, e);
            this.modality = a?.Modality, this.metadata = this.getImageDataMetadata(e);
            let { cineRate: o, numberOfFrames: s } = ct(Ia.CINE, e);
            return this.numberOfFrames = s, this.setVideoURL(i).then(()=>((!s || s === 1) && (s = Math.round(this.videoElement.duration * (o || 30))), o || (o = Math.round(s / this.videoElement.duration)), this.fps = o, this.numberOfFrames = s, this.setFrameRange([
                    1,
                    s
                ]), this.initialRender = ()=>{
                    this.initialRender = null, this.pause(), this.setFrameNumber(n || 1);
                }, new Promise((c)=>{
                    window.setTimeout(()=>{
                        this.setFrameNumber(n || 1), c(this);
                    }, 25);
                })));
        }
        async setVideoURL(e) {
            return new Promise((n)=>{
                this.videoElement.src = e, this.videoElement.preload = "auto";
                const r = ()=>{
                    this.videoWidth = this.videoElement.videoWidth, this.videoHeight = this.videoElement.videoHeight, this.videoElement.removeEventListener("loadedmetadata", r), this.refreshRenderValues(), n(!0);
                };
                this.videoElement.addEventListener("loadedmetadata", r);
            });
        }
        getImageIds() {
            const e = new Array(this.numberOfFrames), n = this.imageId.replace(/[0-9]+$/, "");
            for(let r = 0; r < this.numberOfFrames; r++)e[r] = `${n}${r + 1}`;
            return e;
        }
        togglePlayPause() {
            return this.isPlaying ? (this.pause(), !1) : (this.play(), !0);
        }
        async play() {
            try {
                this.isPlaying || (this.isPlaying = !0, await this.videoElement.play(), this.renderWhilstPlaying());
            } catch  {}
        }
        pause() {
            try {
                this.isPlaying = !1, this.videoElement.pause();
            } catch  {}
        }
        async scroll(e = 1) {
            await this.pause();
            const n = this.videoElement, r = this.renderFrame, a = n.currentTime + e * this.scrollSpeed / this.fps;
            n.currentTime = a;
            const o = (s)=>{
                r(), n.removeEventListener("seeked", o);
            };
            n.addEventListener("seeked", o);
        }
        async start() {
            const e = this.videoElement, n = this.renderFrame;
            if (e.currentTime = 0, e.paused) {
                const r = (i)=>{
                    n(), e.removeEventListener("seeked", r);
                };
                e.addEventListener("seeked", r);
            }
        }
        async end() {
            const e = this.videoElement, n = this.renderFrame;
            if (e.currentTime = e.duration, e.paused) {
                const r = (i)=>{
                    n(), e.removeEventListener("seeked", r);
                };
                e.addEventListener("seeked", r);
            }
        }
        async setTime(e) {
            const n = this.videoElement, r = this.renderFrame;
            if (n.currentTime = e, n.paused) {
                const i = (a)=>{
                    r(), n.removeEventListener("seeked", i);
                };
                n.addEventListener("seeked", i);
            }
        }
        getSliceViewInfo() {
            throw new Error("Method not implemented.");
        }
        async setFrameNumber(e) {
            this.setTime((e - 1) / this.fps);
        }
        setFrameRange(e) {
            if (!e) {
                this.frameRange = [
                    1,
                    this.numberOfFrames
                ];
                return;
            }
            e.length !== 2 || e[0] === e[1] || (this.frameRange = [
                e[0],
                e[1]
            ]);
        }
        getSliceIndexForImage(e) {
            if (e) {
                if (typeof e == "string") return vh.imageIdToFrameStart(e);
                if (e.referencedImageId) return vh.imageIdToFrameStart(e.referencedImageId);
            }
        }
        getFrameRange() {
            return this.frameRange;
        }
        setProperties(e) {
            e.loop !== void 0 && (this.videoElement.loop = e.loop), e.muted !== void 0 && (this.videoElement.muted = e.muted), e.playbackRate !== void 0 && this.setPlaybackRate(e.playbackRate), e.scrollSpeed !== void 0 && this.setScrollSpeed(e.scrollSpeed), e.voiRange && this.setVOI(e.voiRange);
        }
        setPlaybackRate(e = 1) {
            if (this.playbackRate = e, e < .0625) {
                this.pause();
                return;
            }
            this.videoElement && (this.videoElement.playbackRate = e, this.play());
        }
        setScrollSpeed(e = 1, n = _d.FRAME) {
            this.scrollSpeed = n === _d.SECOND ? e * this.fps : e;
        }
        resetProperties() {
            this.setProperties({
                loop: !1,
                muted: !0,
                voiRange: {
                    lower: 0,
                    upper: 255
                }
            });
        }
        getScalarData() {
            if (this.scalarData?.frameNumber === this.getFrameNumber()) return this.scalarData;
            if (!this.videoElement || !this.videoElement.videoWidth || !this.videoElement.videoHeight) {
                console.debug("Video not ready yet, returning empty scalar data");
                const a = new Uint8ClampedArray;
                return a.getRange = ()=>[
                        0,
                        255
                    ], a.frameNumber = -1, a;
            }
            const e = document.createElement("canvas");
            e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;
            const n = e.getContext("2d");
            n.drawImage(this.videoElement, 0, 0);
            const i = n.getImageData(0, 0, e.width, e.height).data;
            return i.getRange = ()=>[
                    0,
                    255
                ], i.frameNumber = this.getFrameNumber(), this.scalarData = i, i;
        }
        getImageData() {
            const { metadata: e } = this, n = e.spacing, r = {
                getDirection: ()=>e.direction,
                getDimensions: ()=>e.dimensions,
                getRange: ()=>[
                        0,
                        255
                    ],
                getScalarData: ()=>this.getScalarData(),
                getSpacing: ()=>e.spacing,
                worldToIndex: (a)=>{
                    const o = this.worldToCanvas(a), s = this.canvasToIndex(o);
                    return [
                        s[0],
                        s[1],
                        0
                    ];
                },
                indexToWorld: (a, o)=>{
                    const s = this.indexToCanvas([
                        a[0],
                        a[1]
                    ]);
                    return this.canvasToWorld(s, o);
                }
            }, i = {
                dimensions: e.dimensions,
                spacing: n,
                origin: e.origin,
                direction: e.direction,
                metadata: {
                    Modality: this.modality,
                    FrameOfReferenceUID: e.FrameOfReferenceUID
                },
                getScalarData: ()=>this.getScalarData(),
                scalarData: this.getScalarData(),
                imageData: r,
                voxelManager: {
                    forEach: (a, o)=>_E(o.imageData, {
                            pointInShapeFn: o.isInObject ?? (()=>!0),
                            callback: a,
                            boundsIJK: o.boundsIJK,
                            returnPoints: o.returnPoints ?? !1
                        })
                },
                hasPixelSpacing: this.hasPixelSpacing,
                calibration: this.calibration,
                preScale: {
                    scaled: !1
                }
            };
            return Object.defineProperty(r, "scalarData", {
                get: ()=>this.getScalarData(),
                enumerable: !0
            }), i;
        }
        hasImageURI(e) {
            const n = e.match(sp.frameRangeExtractor), r = n ? e.substring(0, n.index) : e;
            return this.imageId.includes(r);
        }
        setVOI(e) {
            this.voiRange = e;
            const n = this.setColorTransform(e, this.averageWhite);
            this.canvas.style.filter = n;
        }
        setWindowLevel(e = 256, n = 128) {
            const r = n - e / 2, i = n + e / 2 - 1;
            this.setVOI({
                lower: r,
                upper: i
            }), this.setColorTransform({
                lower: r,
                upper: i
            }, this.averageWhite);
        }
        setAverageWhite(e) {
            this.averageWhite = e, this.setColorTransform(this.voiRange, e);
        }
        setCamera(e) {
            const { parallelScale: n, focalPoint: r } = e;
            if (n && (this.videoCamera.parallelScale = this.element.clientHeight / 2 / n), r !== void 0) {
                const i = this.worldToCanvas(r), a = [
                    this.element.clientWidth / 2,
                    this.element.clientHeight / 2
                ], o = [
                    (i[0] - a[0]) / this.videoCamera.parallelScale,
                    (i[1] - a[1]) / this.videoCamera.parallelScale
                ];
                this.videoCamera.panWorld = [
                    this.videoCamera.panWorld[0] - o[0],
                    this.videoCamera.panWorld[1] - o[1]
                ];
            }
            this.canvasContext.fillStyle = "rgba(0,0,0,1)", this.canvasContext.fillRect(0, 0, this.canvas.width, this.canvas.height), this.isPlaying || this.renderFrame();
        }
        getCurrentImageId(e = this.getCurrentImageIdIndex()) {
            return this.imageId.replace("/frames/1", `/frames/${e + 1}`);
        }
        getViewReferenceId(e = {}) {
            const { sliceIndex: n } = e;
            return n === void 0 ? `videoId:${this.getCurrentImageId()}` : Array.isArray(n) ? `videoId:${this.imageId.substring(0, this.imageId.length - 1)}${n[0] + 1}-${n[1] + 1}` : `videoId:${this.imageId.replace("/frames/1", `/frames/${1 + n}`)}`;
        }
        isReferenceViewable(e, n = {}) {
            let { imageURI: r } = n;
            const { referencedImageId: i, sliceIndex: a, multiSliceReference: o } = e;
            if (!super.isReferenceViewable(e)) return !1;
            const s = this.getCurrentImageId();
            if (!r) {
                const g = s.indexOf(":");
                r = s.substring(g + 1, s.length - 1);
            }
            if (n.withNavigation) return !0;
            const c = this.getSliceIndex();
            if (o) {
                const g = vh.imageIdToFrameEnd(o.referencedImageId);
                return c >= a && c <= g;
            }
            if (a !== void 0) return c === a;
            if (!i) return !1;
            const l = i.match(sp.frameRangeExtractor);
            if (!l || !l[2]) return !0;
            const f = l[2].split("-").map((g)=>Number(g)), u = c + 1;
            return f[0] <= u && u <= (f[1] ?? f[0]);
        }
        setViewReference(e) {
            typeof e.sliceIndex == "number" ? this.setFrameNumber(e.sliceIndex + 1) : Array.isArray(e.sliceIndex) && this.setFrameRange(e.sliceIndex);
        }
        getViewReference(e) {
            const n = e?.sliceIndex ?? (this.isPlaying ? this.frameRange[0] : this.getCurrentImageIdIndex()), r = e?.rangeEndSliceIndex ?? (this.isPlaying ? this.frameRange[1] - 1 : void 0), i = r > n ? {
                sliceIndex: r,
                referencedImageId: this.getCurrentImageId(r)
            } : void 0;
            return {
                ...super.getViewReference(e),
                referencedImageId: this.getViewReferenceId(e),
                sliceIndex: n,
                multiSliceReference: i
            };
        }
        getFrameNumber() {
            return 1 + this.getCurrentImageIdIndex();
        }
        getCurrentImageIdIndex() {
            return Math.round(this.videoElement.currentTime * this.fps);
        }
        getSliceIndex() {
            return this.getCurrentImageIdIndex() / this.scrollSpeed;
        }
        getCamera() {
            const { parallelScale: e } = this.videoCamera, n = [
                this.element.clientWidth / 2,
                this.element.clientHeight / 2
            ];
            return {
                parallelProjection: !0,
                focalPoint: this.canvasToWorld(n),
                position: [
                    0,
                    0,
                    0
                ],
                viewUp: [
                    0,
                    -1,
                    0
                ],
                parallelScale: this.element.clientHeight / 2 / e,
                viewPlaneNormal: [
                    0,
                    0,
                    1
                ]
            };
        }
        getFrameRate() {
            return this.fps;
        }
        getPan() {
            const e = this.videoCamera.panWorld;
            return [
                e[0],
                e[1]
            ];
        }
        refreshRenderValues() {
            let e = this.canvas.offsetWidth / this.videoWidth;
            this.videoHeight * e > this.canvas.height && (e = this.canvas.offsetHeight / this.videoHeight);
            const n = Math.floor(this.videoWidth * e), r = Math.floor(this.videoHeight * e), i = (this.canvas.offsetWidth - n) / 2, a = (this.canvas.offsetHeight - r) / 2, o = i / e, s = a / e;
            this.videoCamera.panWorld = [
                o,
                s
            ], this.videoCamera.parallelScale = e;
        }
        getWorldToCanvasRatio() {
            return this.videoCamera.parallelScale;
        }
        getCanvasToWorldRatio() {
            return 1 / this.videoCamera.parallelScale;
        }
        getTransform() {
            const e = this.videoCamera.panWorld, n = window.devicePixelRatio || 1, r = this.getWorldToCanvasRatio(), i = this.getCanvasToWorldRatio(), a = [
                this.canvas.offsetWidth / 2,
                this.canvas.offsetHeight / 2
            ], o = [
                a[0] * i,
                a[1] * i
            ], s = new df;
            return s.scale(n, n), s.translate(a[0], a[1]), s.scale(r, r), s.translate(e[0], e[1]), s.translate(-o[0], -o[1]), s;
        }
        updateCameraClippingPlanesAndRange() {}
        addImages(e) {
            const n = this.getActors();
            e.forEach((r)=>{
                const { imageId: i, ...a } = r, o = ot.getImage(i), s = this.createActorMapper(o), c = r.actorUID ?? Vn();
                s && (n.push({
                    uid: c,
                    actor: s,
                    referencedId: i,
                    ...a
                }), r.callback && r.callback({
                    imageActor: s,
                    imageId: i
                }));
            }), this.setActors(n);
        }
        createActorMapper(e) {
            return new OK(this, e);
        }
    };
    const IK = `
.DicomMicroscopyViewer {
  --ol-partial-background-color: rgba(127, 127, 127, 0.7);
  --ol-foreground-color: #000000;
  --ol-subtle-foreground-color: #000;
  --ol-subtle-background-color: rgba(78, 78, 78, 0.5);
}

.DicomMicroscopyViewer .ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.DicomMicroscopyViewer .ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.DicomMicroscopyViewer .ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.DicomMicroscopyViewer .ol-scale-bar-inner {
  display: flex;
}

.DicomMicroscopyViewer .ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.DicomMicroscopyViewer .ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow:
    -1.5px 0 var(--ol-partial-background-color),
    0 1.5px var(--ol-partial-background-color),
    1.5px 0 var(--ol-partial-background-color),
    0 -1.5px var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.DicomMicroscopyViewer .ol-unsupported {
  display: none;
}

.DicomMicroscopyViewer .ol-viewport,
.DicomMicroscopyViewer .ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.DicomMicroscopyViewer .ol-viewport canvas {
  all: unset;
}

.DicomMicroscopyViewer .ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.DicomMicroscopyViewer .ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.DicomMicroscopyViewer .ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.DicomMicroscopyViewer .ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.DicomMicroscopyViewer .ol-zoom {
  top: 0.5em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-rotate {
  top: 0.5em;
  right: 0.5em;
  transition:
    opacity 0.25s linear,
    visibility 0s linear;
}

.DicomMicroscopyViewer .ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition:
    opacity 0.25s linear,
    visibility 0s linear 0.25s;
}

.DicomMicroscopyViewer .ol-zoom-extent {
  top: 4.643em;
  left: 0.5em;
}

.DicomMicroscopyViewer .ol-full-screen {
  right: 0.5em;
  top: 0.5em;
}

.DicomMicroscopyViewer .ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: 0.4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.DicomMicroscopyViewer .ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.DicomMicroscopyViewer .ol-zoom-extent button {
  line-height: 1.4em;
}

.DicomMicroscopyViewer .ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.DicomMicroscopyViewer .ol-touch .ol-control button {
  font-size: 1.5em;
}

.DicomMicroscopyViewer .ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-control button:hover,
.DicomMicroscopyViewer .ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.DicomMicroscopyViewer .ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.DicomMicroscopyViewer .ol-attribution {
  text-align: right;
  bottom: 0.5em;
  right: 0.5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.DicomMicroscopyViewer .ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.DicomMicroscopyViewer .ol-attribution ul {
  margin: 0;
  padding: 1px 0.5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.DicomMicroscopyViewer .ol-attribution li {
  display: inline;
  list-style: none;
}

.DicomMicroscopyViewer .ol-attribution li:not(:last-child):after {
  content: ' ';
}

.DicomMicroscopyViewer .ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.DicomMicroscopyViewer .ol-attribution button {
  flex-shrink: 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-collapsed ul {
  display: none;
}

.DicomMicroscopyViewer .ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible img {
  margin-top: -0.2em;
  max-height: 1.6em;
}

.DicomMicroscopyViewer .ol-attribution.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-zoomslider {
  top: 4.5em;
  left: 0.5em;
  height: 200px;
}

.DicomMicroscopyViewer .ol-zoomslider button {
  position: relative;
  height: 10px;
}

.DicomMicroscopyViewer .ol-touch .ol-zoomslider {
  top: 5.5em;
}

.DicomMicroscopyViewer .ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap button {
  display: block;
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.DicomMicroscopyViewer .ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.DicomMicroscopyViewer .ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.DicomMicroscopyViewer .ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.DicomMicroscopyViewer .ol-overviewmap-box {
  border: 0.5px dotted var(--ol-subtle-foreground-color);
}

.DicomMicroscopyViewer .ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}

@layout-header-background: #007ea3;
@primary-color: #007ea3;
@processing-color: #8cb8c6;
@success-color: #3f9c35;
@warning-color: #eeaf30;
@error-color: #96172e;
@font-size-base: 14px;

.DicomMicroscopyViewer .ol-tooltip {
  font-size: 16px !important;
}
`;
    let Hf = null;
    const NC = Symbol.for("map"), AC = Symbol.for("affine"), MK = "postrender";
    cp = class extends uf {
        constructor(e){
            super({
                ...e,
                canvas: e.canvas || Zo(e.element)
            }), this.internalCamera = {
                rotation: 0,
                centerIndex: [
                    0,
                    0
                ],
                extent: [
                    0,
                    -2,
                    1,
                    -1
                ],
                xSpacing: 1,
                ySpacing: 1,
                resolution: 1,
                zoom: 1
            }, this.voiRange = {
                lower: 0,
                upper: 255
            }, this.getProperties = ()=>({
                    voiRange: {
                        ...this.voiRange
                    }
                }), this.resetCamera = ()=>!0, this.getNumberOfSlices = ()=>1, this.getFrameOfReferenceUID = ()=>this.frameOfReferenceUID, this.resize = ()=>{
                const r = this.canvas, { clientWidth: i, clientHeight: a } = r;
                (r.width !== i || r.height !== a) && (r.width = i, r.height = a), this.refreshRenderValues();
            }, this.canvasToWorld = (r)=>{
                if (!this.metadata) return;
                const i = this.canvasToIndex(r);
                return i[1] = -i[1], this.indexToWorld(i);
            }, this.worldToCanvas = (r)=>{
                if (!this.metadata) return;
                const i = this.worldToIndex(r);
                return i[1] = -i[1], this.indexToCanvas([
                    i[0],
                    i[1],
                    0
                ]);
            }, this.postrender = ()=>{
                this.refreshRenderValues(), We(this.element, Ge.IMAGE_RENDERED, {
                    element: this.element,
                    viewportId: this.id,
                    viewport: this,
                    renderingEngineId: this.renderingEngineId
                });
            }, this.getRotation = ()=>0, this.canvasToIndex = (r)=>{
                const i = this.getTransform();
                i.invert();
                const a = i.transformPoint(r.map((o)=>o * devicePixelRatio));
                return [
                    a[0],
                    a[1],
                    0
                ];
            }, this.indexToCanvas = (r)=>this.getTransform().transformPoint([
                    r[0],
                    r[1]
                ]).map((a)=>a / devicePixelRatio), this.customRenderViewportToCanvas = ()=>{}, this.getImageIds = ()=>[
                    this.imageIds[0]
                ], this.renderingEngineId = e.renderingEngineId, this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.element.style.position = "relative", this.microscopyElement = document.createElement("div"), this.microscopyElement.setAttribute("class", "DicomMicroscopyViewer"), this.microscopyElement.id = Vn(), this.microscopyElement.innerText = "Initial", this.microscopyElement.style.background = "grey", this.microscopyElement.style.width = "100%", this.microscopyElement.style.height = "100%", this.microscopyElement.style.position = "absolute", this.microscopyElement.style.left = "0", this.microscopyElement.style.top = "0";
            const n = this.element.firstElementChild;
            n.insertBefore(this.microscopyElement, n.childNodes[1]), this.addEventListeners(), this.addWidget("DicomMicroscopyViewer", {
                getEnabled: ()=>!!this.viewer,
                setEnabled: ()=>{
                    this.elementDisabledHandler();
                }
            }), this.resize();
        }
        static get useCustomRenderingPipeline() {
            return !0;
        }
        addEventListeners() {
            this.canvas.addEventListener(Ge.ELEMENT_DISABLED, this.elementDisabledHandler);
        }
        removeEventListeners() {
            this.canvas.removeEventListener(Ge.ELEMENT_DISABLED, this.elementDisabledHandler);
        }
        elementDisabledHandler() {
            this.removeEventListeners(), this.viewer?.cleanup(), this.viewer = null, this.element.firstElementChild.removeChild(this.microscopyElement), this.microscopyElement = null;
        }
        getImageDataMetadata(e = 0) {
            const n = this.metadataDicomweb.reduce((F, N)=>F?.NumberOfFrames < N.NumberOfFrames ? N : F), { TotalPixelMatrixColumns: r, TotalPixelMatrixRows: i, ImageOrientationSlide: a, ImagedVolumeWidth: o, ImagedVolumeHeight: s, ImagedVolumeDepth: c } = n, l = ct(Ia.IMAGE_PLANE, this.imageIds[e]);
            let f = a.slice(0, 3), u = a.slice(3, 6);
            (f == null || u == null) && (f = [
                1,
                0,
                0
            ], u = [
                0,
                1,
                0
            ]);
            const g = en(f[0], f[1], f[2]), h = en(u[0], u[1], u[2]), v = Xe();
            bn(v, g, h);
            const { XOffsetInSlideCoordinateSystem: m = 0, YOffsetInSlideCoordinateSystem: y = 0, ZOffsetInSlideCoordinateSystem: C = 0 } = n.TotalPixelMatrixOriginSequence?.[0] || {}, T = [
                m,
                y,
                C
            ], x = o / r, S = s / i, D = r, _ = i, M = c, P = 1;
            return this.hasPixelSpacing = !!(o && s), {
                bitsAllocated: 8,
                numberOfComponents: 3,
                origin: T,
                direction: [
                    ...g,
                    ...h,
                    ...v
                ],
                dimensions: [
                    D,
                    _,
                    P
                ],
                spacing: [
                    x,
                    S,
                    M
                ],
                hasPixelSpacing: this.hasPixelSpacing,
                numVoxels: D * _ * P,
                imagePlaneModule: l
            };
        }
        async setFrameNumber(e) {}
        setProperties(e) {
            e.voiRange && this.setVOI(e.voiRange);
        }
        resetProperties() {
            this.setProperties({
                voiRange: {
                    lower: 0,
                    upper: 255
                }
            });
        }
        setVOI(e) {
            this.voiRange = e;
            const n = this.setColorTransform(e, this.averageWhite);
            this.map.getViewport().querySelectorAll(".ol-layers canvas").forEach((i)=>{
                i.style.filter = n;
            });
        }
        setAverageWhite(e) {
            this.averageWhite = e, this.setColorTransform(this.voiRange, e);
        }
        getScalarData() {
            return null;
        }
        computeTransforms() {
            const e = xs(), n = xs();
            return Yd(e, this.metadata.origin), e[0] = this.metadata.direction[0], e[1] = this.metadata.direction[1], e[2] = this.metadata.direction[2], e[4] = this.metadata.direction[3], e[5] = this.metadata.direction[4], e[6] = this.metadata.direction[5], e[8] = this.metadata.direction[6], e[9] = this.metadata.direction[7], e[10] = this.metadata.direction[8], nc(e, e, this.metadata.spacing), Xr(n, e), {
                indexToWorld: e,
                worldToIndex: n
            };
        }
        getImageData() {
            const { metadata: e } = this;
            if (!e) return null;
            const { spacing: n } = e, r = {
                getDirection: ()=>e.direction,
                getDimensions: ()=>e.dimensions,
                getRange: ()=>[
                        0,
                        255
                    ],
                getScalarData: ()=>this.getScalarData(),
                getSpacing: ()=>e.spacing,
                worldToIndex: (a)=>this.worldToIndex(a),
                indexToWorld: (a)=>this.indexToWorld(a)
            };
            return {
                dimensions: e.dimensions,
                spacing: n,
                numberOfComponents: 3,
                origin: e.origin,
                direction: e.direction,
                metadata: {
                    Modality: this.modality,
                    FrameOfReferenceUID: this.frameOfReferenceUID
                },
                hasPixelSpacing: this.hasPixelSpacing,
                calibration: this.calibration,
                preScale: {
                    scaled: !1
                },
                scalarData: this.getScalarData(),
                imageData: r
            };
        }
        hasImageURI(e) {
            return !0;
        }
        setCamera(e) {
            const n = this.getCamera(), { parallelScale: r, focalPoint: i } = e, a = this.getView(), { xSpacing: o } = this.internalCamera;
            if (r) {
                const c = this.element.clientHeight / r, l = 1 / o / c;
                a.setResolution(l);
            }
            if (i) {
                const c = this.worldToCanvas(i), l = this.canvasToIndex(c);
                a.setCenter(l);
            }
            const s = this.getCamera();
            this.triggerCameraModifiedEventIfNecessary(n, s);
        }
        getCurrentImageId() {
            return this.imageIds[0];
        }
        getFrameNumber() {
            return 1;
        }
        getCamera() {
            this.refreshRenderValues();
            const { resolution: e, xSpacing: n, centerIndex: r } = this.internalCamera, i = e * n, a = this.indexToCanvas([
                r[0],
                r[1],
                0
            ]), o = this.canvasToWorld(a);
            return {
                parallelProjection: !0,
                focalPoint: o,
                position: o,
                viewUp: [
                    0,
                    -1,
                    0
                ],
                parallelScale: this.element.clientHeight * i,
                viewPlaneNormal: [
                    0,
                    0,
                    1
                ]
            };
        }
        static{
            this.getDicomMicroscopyViewer = async ()=>xb("dicom-microscopy-viewer");
        }
        worldToIndexWSI(e) {
            if (!Hf) return;
            const n = this.viewer[AC], r = Hf.applyInverseTransform({
                coordinate: [
                    e[0],
                    e[1]
                ],
                affine: n
            });
            return [
                r[0],
                r[1]
            ];
        }
        indexToWorldWSI(e) {
            if (!Hf) return;
            const n = Hf.applyTransform({
                coordinate: [
                    e[0],
                    e[1]
                ],
                affine: this.viewer[AC]
            });
            return [
                n[0],
                n[1],
                0
            ];
        }
        worldToIndex(e) {
            const { worldToIndex: n } = this.computeTransforms(), r = Xe();
            return pn(r, e, n), r;
        }
        indexToWorld(e) {
            const { indexToWorld: n } = this.computeTransforms(), r = Xe(), i = en(...e);
            return pn(r, i, n), [
                r[0],
                r[1],
                r[2]
            ];
        }
        setDataIds(e, n) {
            n?.miniNavigationOverlay !== !1 && cp.addMiniNavigationOverlayCss();
            const r = n?.webClient || ct(Ia.WADO_WEB_CLIENT, e[0]);
            if (!r) throw new Error(`To use setDataIds on WSI data, you must provide metaData.webClient for ${e[0]}`);
            return this.setWSI(e, r);
        }
        async setWSI(e, n) {
            this.microscopyElement.style.background = "black", this.microscopyElement.innerText = "Loading", this.imageIds = e;
            const r = await cp.getDicomMicroscopyViewer();
            Hf ||= r.utils, this.frameOfReferenceUID = null;
            const i = this.imageIds.map((s)=>{
                const c = n.getDICOMwebMetadata(s);
                Object.defineProperty(c, "isMultiframe", {
                    value: c.isMultiframe,
                    enumerable: !1
                }), Object.defineProperty(c, "frameNumber", {
                    value: void 0,
                    enumerable: !1
                });
                const l = c["00080008"]?.Value;
                l?.length === 1 && (c["00080008"].Value = l[0].split("\\"));
                const f = c["00200052"]?.Value?.[0];
                return this.frameOfReferenceUID ? f !== this.frameOfReferenceUID && (c["00200052"].Value = [
                    this.frameOfReferenceUID
                ]) : this.frameOfReferenceUID = f, c;
            }), a = [];
            i.forEach((s)=>{
                const c = new r.metadata.VLWholeSlideMicroscopyImage({
                    metadata: s
                }), l = c.ImageType[2];
                l === "VOLUME" || l === "THUMBNAIL" ? a.push(c) : console.log("Unknown image type", c.ImageType);
            }), this.metadataDicomweb = a;
            const o = new r.viewer.VolumeImageViewer({
                client: n,
                metadata: a,
                controls: [
                    "overview",
                    "position"
                ],
                retrieveRendered: !1,
                bindings: {}
            });
            o.render({
                container: this.microscopyElement
            }), this.metadata = this.getImageDataMetadata(), o.deactivateDragPanInteraction(), this.viewer = o, this.map = o[NC], this.map.on(MK, this.postrender), this.resize(), this.microscopyElement.innerText = "", Object.assign(this.microscopyElement.style, {
                "--ol-partial-background-color": "rgba(127, 127, 127, 0.7)",
                "--ol-foreground-color": "#000000",
                "--ol-subtle-foreground-color": "#000",
                "--ol-subtle-background-color": "rgba(78, 78, 78, 0.5)",
                background: "none"
            });
        }
        scroll(e) {
            const n = this.getCamera();
            this.setCamera({
                parallelScale: n.parallelScale * (1 + .1 * e)
            });
        }
        getSliceIndex() {
            return 0;
        }
        getView() {
            if (!this.viewer) return;
            const e = this.viewer[NC], n = window;
            return n.map = e, n.viewer = this.viewer, n.view = e?.getView(), n.wsi = this, e?.getView();
        }
        refreshRenderValues() {
            const e = this.getView();
            if (!e) return;
            const n = e.getResolution();
            if (!n || n < Jo) return;
            const r = e.getCenter(), i = e.getProjection().getExtent(), a = e.getRotation(), o = e.getZoom(), { metadata: { spacing: [s, c] } } = this, l = 1 / n / s;
            Object.assign(this.internalCamera, {
                extent: i,
                centerIndex: r,
                worldToCanvasRatio: l,
                xSpacing: s,
                ySpacing: c,
                resolution: n,
                rotation: a,
                zoom: o
            });
        }
        getZoom() {
            return this.getView()?.getZoom();
        }
        setZoom(e) {
            this.getView()?.setZoom(e);
        }
        getTransform() {
            this.refreshRenderValues();
            const { centerIndex: e, resolution: n, rotation: r } = this.internalCamera, i = [
                this.canvas.width / 2,
                this.canvas.height / 2
            ], a = new df;
            return a.translate(i[0], i[1]), a.rotate(r), a.scale(1 / n, -1 / n), a.translate(-e[0], -e[1]), a;
        }
        getViewReferenceId() {
            return `imageId:${this.getCurrentImageId()}`;
        }
        getCurrentImageIdIndex() {
            return 0;
        }
        static{
            this.overlayCssId = "overlayCss";
        }
        static addMiniNavigationOverlayCss() {
            if (document.getElementById(this.overlayCssId)) return;
            const e = document.createElement("style");
            e.innerText = IK, e.setAttribute("id", this.overlayCssId), document.getElementsByTagName("head")[0].append(e);
        }
    };
    const l_ = {
        [On.ORTHOGRAPHIC]: wi,
        [On.PERSPECTIVE]: wi,
        [On.STACK]: ua,
        [On.VOLUME_3D]: F4,
        [On.VIDEO]: sp,
        [On.WHOLE_SLIDE]: cp
    };
    function Xs(t) {
        return l_[t].useCustomRenderingPipeline;
    }
    const lp = 2;
    u_ = class {
        constructor(e){
            if (this._needsRender = new Set, this._animationFrameSet = !1, this._animationFrameHandle = null, this.renderFrameOfReference = (n)=>{
                const i = this._getViewportsAsArray().map((a)=>{
                    if (a.getFrameOfReferenceUID() === n) return a.id;
                });
                this.renderViewports(i);
            }, this.id = e || Vn(), this.useCPURendering = gd(), Rd.set(this), !Tb()) throw new Error("@cornerstonejs/core is not initialized, run init() first");
            this._viewports = new Map, this.hasBeenDestroyed = !1;
        }
        enableElement(e) {
            const n = this._normalizeViewportInputEntry(e);
            this._throwIfDestroyed();
            const { element: r, viewportId: i } = n;
            if (!r) throw new Error("No element provided");
            this.getViewport(i) && this.disableElement(i);
            const { type: o } = n, s = Xs(o);
            !this.useCPURendering && !s ? this.enableVTKjsDrivenViewport(n) : this.addCustomViewport(n);
            const c = Zo(r), { background: l } = n.defaultOptions;
            this.fillCanvasWithBackgroundColor(c, l);
        }
        disableElement(e) {
            this._throwIfDestroyed();
            const n = this.getViewport(e);
            if (!n) {
                console.warn(`viewport ${e} does not exist`);
                return;
            }
            this._resetViewport(n), !Xs(n.type) && !this.useCPURendering && this.offscreenMultiRenderWindow && this.offscreenMultiRenderWindow.removeRenderer(e), this._removeViewport(e), n.isDisabled = !0, this._needsRender.delete(e), this.getViewports().length || this._clearAnimationFrame();
        }
        setViewports(e) {
            const n = this._normalizeViewportInputEntries(e);
            this._throwIfDestroyed(), this._reset();
            const r = [], i = [];
            n.forEach((a)=>{
                !this.useCPURendering && !Xs(a.type) ? r.push(a) : i.push(a);
            }), this.setVtkjsDrivenViewports(r), this.setCustomViewports(i), n.forEach((a)=>{
                const o = Zo(a.element), { background: s } = a.defaultOptions;
                this.fillCanvasWithBackgroundColor(o, s);
            });
        }
        resize(e = !0, n = !0) {
            this._throwIfDestroyed();
            const r = this._getViewportsAsArray(), i = [], a = [];
            r.forEach((o)=>{
                Xs(o.type) ? a.push(o) : i.push(o);
            }), i.length && this._resizeVTKViewports(i, n, e), a.length && this._resizeUsingCustomResizeHandler(a, n, e);
        }
        getViewport(e) {
            return this._viewports?.get(e);
        }
        getViewports() {
            return this._throwIfDestroyed(), this._getViewportsAsArray();
        }
        getStackViewport(e) {
            this._throwIfDestroyed();
            const n = this.getViewport(e);
            if (!n) throw new Error(`Viewport with Id ${e} does not exist`);
            if (!(n instanceof ua)) throw new Error(`Viewport with Id ${e} is not a StackViewport.`);
            return n;
        }
        getStackViewports() {
            return this._throwIfDestroyed(), this.getViewports().filter((n)=>n instanceof ua);
        }
        getVolumeViewports() {
            this._throwIfDestroyed();
            const e = this.getViewports(), n = (r)=>r instanceof So;
            return e.filter(n);
        }
        render() {
            const n = this.getViewports().map((r)=>r.id);
            this._setViewportsToBeRenderedNextFrame(n);
        }
        renderViewports(e) {
            this._setViewportsToBeRenderedNextFrame(e);
        }
        renderViewport(e) {
            this._setViewportsToBeRenderedNextFrame([
                e
            ]);
        }
        destroy() {
            this.hasBeenDestroyed || (this.useCPURendering || (this._getViewportsAsArray().forEach((n)=>{
                this.offscreenMultiRenderWindow && this.offscreenMultiRenderWindow.removeRenderer(n.id);
            }), this.offscreenMultiRenderWindow && this.offscreenMultiRenderWindow.delete(), delete this.offscreenMultiRenderWindow), this._reset(), Rd.delete(this.id), this.hasBeenDestroyed = !0);
        }
        fillCanvasWithBackgroundColor(e, n) {
            const r = e.getContext("2d");
            let i;
            if (n) {
                const a = n.map((o)=>Math.floor(255 * o));
                i = `rgb(${a[0]}, ${a[1]}, ${a[2]})`;
            } else i = "black";
            r.fillStyle = i, r.fillRect(0, 0, e.width, e.height);
        }
        _normalizeViewportInputEntry(e) {
            const { type: n, defaultOptions: r } = e;
            let i = r;
            return (!i || Object.keys(i).length === 0) && (i = {
                background: [
                    0,
                    0,
                    0
                ],
                orientation: null,
                displayArea: null
            }, n === On.ORTHOGRAPHIC && (i = {
                ...i,
                orientation: kl.AXIAL
            })), {
                ...e,
                defaultOptions: i
            };
        }
        _normalizeViewportInputEntries(e) {
            const n = [];
            return e.forEach((r)=>{
                n.push(this._normalizeViewportInputEntry(r));
            }), n;
        }
        _resizeUsingCustomResizeHandler(e, n = !0, r = !0) {
            e.forEach((i)=>{
                typeof i.resize == "function" && i.resize();
            }), e.forEach((i)=>{
                const a = i.getCamera();
                i.resetCamera(), n && i.setCamera(a);
            }), r && this.render();
        }
        _removeViewport(e) {
            if (!this.getViewport(e)) {
                console.warn(`viewport ${e} does not exist`);
                return;
            }
            this._viewports.delete(e);
        }
        addCustomViewport(e) {
            const { element: n, viewportId: r, type: i, defaultOptions: a } = e;
            n.tabIndex = -1;
            const o = Zo(n), { clientWidth: s, clientHeight: c } = o;
            (o.width !== s || o.height !== c) && (o.width = s, o.height = c);
            const l = {
                id: r,
                renderingEngineId: this.id,
                element: n,
                type: i,
                canvas: o,
                sx: 0,
                sy: 0,
                sWidth: s,
                sHeight: c,
                defaultOptions: a || {}
            }, f = l_[i], u = new f(l);
            this._viewports.set(r, u);
            const g = {
                element: n,
                viewportId: r,
                renderingEngineId: this.id
            };
            We(Ke, Ge.ELEMENT_ENABLED, g);
        }
        getRenderer(e) {
            return this.offscreenMultiRenderWindow.getRenderer(e);
        }
        getOffscreenMultiRenderWindow(e) {
            if (this.useCPURendering) throw new Error("Offscreen multi render window is not available when using CPU rendering.");
            return this.offscreenMultiRenderWindow;
        }
        setCustomViewports(e) {
            e.forEach((n)=>{
                this.addCustomViewport(n);
            });
        }
        _getViewportsAsArray() {
            return Array.from(this._viewports.values());
        }
        _setViewportsToBeRenderedNextFrame(e) {
            e.forEach((n)=>{
                this._needsRender.add(n);
            }), this._render();
        }
        _render() {
            this._needsRender.size > 0 && !this._animationFrameSet && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports), this._animationFrameSet = !0);
        }
        _resetViewport(e) {
            const n = this.id, { element: r, canvas: i, id: a } = e, o = {
                element: r,
                viewportId: a,
                renderingEngineId: n
            };
            e.removeWidgets(), We(Ke, Ge.ELEMENT_DISABLED, o), r.removeAttribute("data-viewport-uid"), r.removeAttribute("data-rendering-engine-uid"), i.getContext("2d").clearRect(0, 0, i.width, i.height);
        }
        _clearAnimationFrame() {
            window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = !1, this._animationFrameHandle = null;
        }
        _reset() {
            this._getViewportsAsArray().forEach((n)=>{
                this._resetViewport(n);
            }), this._clearAnimationFrame(), this._viewports = new Map;
        }
        _throwIfDestroyed() {
            if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
        }
    };
    f_ = class extends u_ {
        constructor(e){
            super(e), this._renderFlaggedViewports = ()=>{
                this._throwIfDestroyed(), this.useCPURendering || this.performVtkDrawCall();
                const n = this._getViewportsAsArray(), r = [];
                for(let i = 0; i < n.length; i++){
                    const a = n[i];
                    if (this._needsRender.has(a.id)) {
                        const o = this.renderViewportUsingCustomOrVtkPipeline(a);
                        if (r.push(o), a.setRendered(), this._needsRender.delete(a.id), this._needsRender.size === 0) break;
                    }
                }
                this._animationFrameSet = !1, this._animationFrameHandle = null, r.forEach((i)=>{
                    i?.element && We(i.element, Ge.IMAGE_RENDERED, i);
                });
            }, this.useCPURendering || (this.offscreenMultiRenderWindow = pD.newInstance(), this.offScreenCanvasContainer = document.createElement("div"), this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer));
        }
        enableVTKjsDrivenViewport(e) {
            const r = this._getViewportsAsArray().filter((f)=>Xs(f.type) === !1), i = r.map((f)=>f.canvas), a = Zo(e.element);
            i.push(a);
            const { offScreenCanvasWidth: o, offScreenCanvasHeight: s } = this._resizeOffScreenCanvas(i), c = this._resize(r, o, s), l = {
                ...e,
                canvas: a
            };
            this.addVtkjsDrivenViewport(l, {
                offScreenCanvasWidth: o,
                offScreenCanvasHeight: s,
                xOffset: c
            });
        }
        addVtkjsDrivenViewport(e, n) {
            const { element: r, canvas: i, viewportId: a, type: o, defaultOptions: s } = e;
            r.tabIndex = -1;
            const { offScreenCanvasWidth: c, offScreenCanvasHeight: l, xOffset: f } = n, { sxStartDisplayCoords: u, syStartDisplayCoords: g, sxEndDisplayCoords: h, syEndDisplayCoords: v, sx: m, sy: y, sWidth: C, sHeight: T } = this._getViewportCoordsOnOffScreenCanvas(e, c, l, f);
            this.offscreenMultiRenderWindow.addRenderer({
                viewport: [
                    u,
                    g,
                    h,
                    v
                ],
                id: a,
                background: s.background ? s.background : [
                    0,
                    0,
                    0
                ]
            });
            const x = {
                id: a,
                element: r,
                renderingEngineId: this.id,
                type: o,
                canvas: i,
                sx: m,
                sy: y,
                sWidth: C,
                sHeight: T,
                defaultOptions: s || {}
            };
            let S;
            if (o === On.STACK) S = new ua(x);
            else if (o === On.ORTHOGRAPHIC || o === On.PERSPECTIVE) S = new wi(x);
            else if (o === On.VOLUME_3D) S = new F4(x);
            else throw new Error(`Viewport Type ${o} is not supported`);
            this._viewports.set(a, S);
            const D = {
                element: r,
                viewportId: a,
                renderingEngineId: this.id
            };
            S.suppressEvents || We(Ke, Ge.ELEMENT_ENABLED, D);
        }
        setVtkjsDrivenViewports(e) {
            if (e.length) {
                const n = e.map((o)=>Zo(o.element));
                n.forEach((o)=>{
                    const s = window.devicePixelRatio || 1, c = o.getBoundingClientRect();
                    o.width = c.width * s, o.height = c.height * s;
                });
                const { offScreenCanvasWidth: r, offScreenCanvasHeight: i } = this._resizeOffScreenCanvas(n);
                let a = 0;
                for(let o = 0; o < e.length; o++){
                    const s = e[o], c = n[o], l = {
                        ...s,
                        canvas: c
                    };
                    this.addVtkjsDrivenViewport(l, {
                        offScreenCanvasWidth: r,
                        offScreenCanvasHeight: i,
                        xOffset: a
                    }), a += c.width;
                }
            }
        }
        _resizeVTKViewports(e, n = !0, r = !0) {
            const i = e.map((a)=>Zo(a.element));
            if (i.forEach((a)=>{
                const o = window.devicePixelRatio || 1;
                a.width = a.clientWidth * o, a.height = a.clientHeight * o;
            }), i.length) {
                const { offScreenCanvasWidth: a, offScreenCanvasHeight: o } = this._resizeOffScreenCanvas(i);
                this._resize(e, a, o);
            }
            e.forEach((a)=>{
                const o = a.getCamera(), s = a.getRotation(), { flipHorizontal: c } = o;
                a.resetCameraForResize();
                const l = a.getDisplayArea();
                n && (l ? (c && a.setCamera({
                    flipHorizontal: c
                }), s && a.setViewPresentation({
                    rotation: s
                })) : a.setCamera(o));
            }), r && this.render();
        }
        performVtkDrawCall() {
            const { offscreenMultiRenderWindow: e } = this, n = e.getRenderWindow(), r = e.getRenderers();
            if (r.length) {
                for(let i = 0; i < r.length; i++){
                    const { renderer: a, id: o } = r[i];
                    this._needsRender.has(o) ? a.setDraw(!0) : a.setDraw(!1);
                }
                n.render();
                for(let i = 0; i < r.length; i++)r[i].renderer.setDraw(!1);
            }
        }
        renderViewportUsingCustomOrVtkPipeline(e) {
            let n;
            if (e.sWidth < lp || e.sHeight < lp) {
                console.warn("Viewport is too small", e.sWidth, e.sHeight);
                return;
            }
            if (Xs(e.type) === !0) n = e.customRenderViewportToCanvas();
            else {
                if (this.useCPURendering) throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
                const { offscreenMultiRenderWindow: r } = this, o = r.getOpenGLRenderWindow().get3DContext().canvas;
                n = this._renderViewportFromVtkCanvasToOnscreenCanvas(e, o);
            }
            return n;
        }
        _renderViewportFromVtkCanvasToOnscreenCanvas(e, n) {
            const { element: r, canvas: i, sx: a, sy: o, sWidth: s, sHeight: c, id: l, renderingEngineId: f, suppressEvents: u } = e, { width: g, height: h } = i;
            return i.getContext("2d").drawImage(n, a, o, s, c, 0, 0, g, h), {
                element: r,
                suppressEvents: u,
                viewportId: l,
                renderingEngineId: f,
                viewportStatus: e.viewportStatus
            };
        }
        _resizeOffScreenCanvas(e) {
            const { offScreenCanvasContainer: n, offscreenMultiRenderWindow: r } = this, i = Math.max(...e.map((o)=>o.height));
            let a = 0;
            return e.forEach((o)=>{
                a += o.width;
            }), n.width = a, n.height = i, r.resize(), {
                offScreenCanvasWidth: a,
                offScreenCanvasHeight: i
            };
        }
        _resize(e, n, r) {
            let i = 0;
            for(let a = 0; a < e.length; a++){
                const o = e[a], { sxStartDisplayCoords: s, syStartDisplayCoords: c, sxEndDisplayCoords: l, syEndDisplayCoords: f, sx: u, sy: g, sWidth: h, sHeight: v } = this._getViewportCoordsOnOffScreenCanvas(o, n, r, i);
                i += o.canvas.width, o.sx = u, o.sy = g, o.sWidth = h, o.sHeight = v, this.offscreenMultiRenderWindow.getRenderer(o.id).setViewport(s, c, l, f);
            }
            return i;
        }
        _getViewportCoordsOnOffScreenCanvas(e, n, r, i) {
            const { canvas: a } = e, { width: o, height: s } = a, c = i, l = 0, f = c / n, u = l + (r - s) / r, g = o / n, h = s / r;
            return {
                sxStartDisplayCoords: f,
                syStartDisplayCoords: u,
                sxEndDisplayCoords: f + g,
                syEndDisplayCoords: u + h,
                sx: c,
                sy: l,
                sWidth: o,
                sHeight: s
            };
        }
    };
    class bK {
        constructor(e){
            this.contexts = [], this.offScreenCanvasContainers = [], this.viewportToContext = new Map;
            for(let n = 0; n < e; n++){
                const r = pD.newInstance(), i = document.createElement("div");
                r.setContainer(i), this.contexts.push(r), this.offScreenCanvasContainers.push(i);
            }
        }
        getContextByIndex(e) {
            return e >= 0 && e < this.contexts.length ? {
                context: this.contexts[e],
                container: this.offScreenCanvasContainers[e]
            } : null;
        }
        assignViewportToContext(e, n) {
            this.viewportToContext.set(e, n);
        }
        getContextIndexForViewport(e) {
            return this.viewportToContext.get(e);
        }
        getAllContexts() {
            return this.contexts;
        }
        getContextCount() {
            return this.contexts.length;
        }
        destroy() {
            this.contexts.forEach((e)=>{
                e.delete();
            }), this.contexts = [], this.offScreenCanvasContainers = [], this.viewportToContext.clear();
        }
    }
    kC = class extends u_ {
        constructor(e){
            super(e), this._renderFlaggedViewports = ()=>{
                this._throwIfDestroyed();
                const a = this._getViewportsAsArray().filter((s)=>this._needsRender.has(s.id));
                if (a.length === 0) {
                    this._animationFrameSet = !1, this._animationFrameHandle = null;
                    return;
                }
                const o = a.map((s)=>{
                    const c = this.renderViewportUsingCustomOrVtkPipeline(s);
                    return s.setRendered(), this._needsRender.delete(s.id), c;
                });
                this._animationFrameSet = !1, this._animationFrameHandle = null, o.forEach((s)=>{
                    s?.element && We(s.element, Ge.IMAGE_RENDERED, s);
                });
            };
            const { rendering: n } = tf(), { webGlContextCount: r } = n;
            this.useCPURendering || (this.contextPool = new bK(r));
        }
        enableVTKjsDrivenViewport(e) {
            const i = this._getViewportsAsArray().filter((s)=>Xs(s.type) === !1).map((s)=>s.canvas), a = Zo(e.element);
            i.push(a);
            const o = {
                ...e,
                canvas: a
            };
            this.addVtkjsDrivenViewport(o);
        }
        addVtkjsDrivenViewport(e) {
            const { element: n, canvas: r, viewportId: i, type: a, defaultOptions: o } = e;
            n.tabIndex = -1;
            let s = 0;
            if (a === On.STACK) {
                const h = this.contextPool.getAllContexts();
                s = this._viewports.size % h.length;
            }
            this.contextPool.assignViewportToContext(i, s);
            const c = this.contextPool.getContextByIndex(s), { context: l } = c;
            l.addRenderer({
                viewport: [
                    0,
                    0,
                    1,
                    1
                ],
                id: i,
                background: o.background ? o.background : [
                    0,
                    0,
                    0
                ]
            });
            const f = {
                id: i,
                element: n,
                renderingEngineId: this.id,
                type: a,
                canvas: r,
                sx: 0,
                sy: 0,
                sWidth: r.width,
                sHeight: r.height,
                defaultOptions: o || {}
            };
            let u;
            if (a === On.STACK) u = new ua(f);
            else if (a === On.ORTHOGRAPHIC || a === On.PERSPECTIVE) u = new wi(f);
            else if (a === On.VOLUME_3D) u = new F4(f);
            else throw new Error(`Viewport Type ${a} is not supported`);
            this._viewports.set(i, u);
            const g = {
                element: n,
                viewportId: i,
                renderingEngineId: this.id
            };
            u.suppressEvents || We(Ke, Ge.ELEMENT_ENABLED, g);
        }
        setVtkjsDrivenViewports(e) {
            if (e.length) {
                const n = e.map((r)=>Zo(r.element));
                n.forEach((r)=>{
                    const i = window.devicePixelRatio || 1, a = r.getBoundingClientRect();
                    r.width = a.width * i, r.height = a.height * i;
                });
                for(let r = 0; r < e.length; r++){
                    const i = e[r], a = n[r], o = {
                        ...i,
                        canvas: a
                    };
                    this.addVtkjsDrivenViewport(o);
                }
            }
        }
        _resizeVTKViewports(e, n = !0, r = !0) {
            const i = e.map((a)=>Zo(a.element));
            i.forEach((a)=>{
                const o = window.devicePixelRatio || 1;
                a.width = a.clientWidth * o, a.height = a.clientHeight * o;
            }), i.length && this._resize(e), e.forEach((a)=>{
                const o = a.getCamera(), s = a.getRotation(), { flipHorizontal: c } = o;
                a.resetCameraForResize();
                const l = a.getDisplayArea();
                n && (l ? (c && a.setCamera({
                    flipHorizontal: c
                }), s && a.setViewPresentation({
                    rotation: s
                })) : a.setCamera(o));
            }), r && this.render();
        }
        renderViewportUsingCustomOrVtkPipeline(e) {
            if (Xs(e.type)) return e.customRenderViewportToCanvas();
            if (this.useCPURendering) throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
            const n = this.contextPool.getContextIndexForViewport(e.id), r = this.contextPool.getContextByIndex(n), { context: i, container: a } = r;
            return this._renderViewportWithContext(e, i, a);
        }
        _renderViewportWithContext(e, n, r) {
            if (e.sWidth < lp || e.sHeight < lp) {
                console.warn("Viewport is too small", e.sWidth, e.sHeight);
                return;
            }
            if (Xs(e.type)) return e.customRenderViewportToCanvas();
            if (this.useCPURendering) throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
            n.getRenderer(e.id) || n.addRenderer({
                viewport: [
                    0,
                    0,
                    1,
                    1
                ],
                id: e.id,
                background: e.defaultOptions?.background || [
                    0,
                    0,
                    0
                ]
            });
            const i = n.getRenderWindow();
            this._resizeOffScreenCanvasForViewport(e.canvas, r, n), n.getRenderer(e.id).setViewport(0, 0, 1, 1);
            const o = n.getRenderers();
            o.forEach(({ renderer: g, id: h })=>{
                g.setDraw(h === e.id);
            }), this.getWidgetRenderers().forEach((g, h)=>{
                h.setDraw(g === e.id);
            }), i.render(), o.forEach(({ renderer: g })=>g.setDraw(!1));
            const f = n.getOpenGLRenderWindow().get3DContext().canvas;
            return this._copyToOnscreenCanvas(e, f);
        }
        _renderViewportFromVtkCanvasToOnscreenCanvas(e, n) {
            return this._copyToOnscreenCanvas(e, n);
        }
        _resizeOffScreenCanvasForViewport(e, n, r) {
            const i = e.width, a = e.height;
            n.width = i, n.height = a, r.resize();
        }
        _copyToOnscreenCanvas(e, n) {
            const { element: r, canvas: i, id: a, renderingEngineId: o, suppressEvents: s } = e, { width: c, height: l } = i;
            return i.getContext("2d").drawImage(n, 0, 0, c, l, 0, 0, c, l), {
                element: r,
                suppressEvents: s,
                viewportId: a,
                renderingEngineId: o,
                viewportStatus: e.viewportStatus
            };
        }
        _resize(e) {
            for (const n of e){
                n.sx = 0, n.sy = 0, n.sWidth = n.canvas.width, n.sHeight = n.canvas.height;
                const r = this.contextPool.getContextIndexForViewport(n.id), i = this.contextPool.getContextByIndex(r), { context: a } = i;
                a.getRenderer(n.id).setViewport(0, 0, 1, 1);
            }
        }
        getWidgetRenderers() {
            const e = this._getViewportsAsArray(), n = new Map;
            return e.forEach((r)=>{
                (r.getWidgets ? r.getWidgets() : []).forEach((a)=>{
                    const o = a.getRenderer ? a.getRenderer() : null;
                    o && n.set(o, r.id);
                });
            }), n;
        }
        getRenderer(e) {
            const n = this.contextPool?.getContextIndexForViewport(e), r = this.contextPool.getContextByIndex(n), { context: i } = r;
            return i.getRenderer(e);
        }
        disableElement(e) {
            const n = this.getViewport(e);
            if (n && (super.disableElement(e), !Xs(n.type) && !this.useCPURendering)) {
                const r = this.contextPool.getContextIndexForViewport(e);
                if (r !== void 0) {
                    const i = this.contextPool.getContextByIndex(r);
                    if (i) {
                        const { context: a } = i;
                        a.removeRenderer(e);
                    }
                }
            }
        }
        destroy() {
            this.contextPool && this.contextPool.destroy(), super.destroy();
        }
        getOffscreenMultiRenderWindow(e) {
            if (this.useCPURendering) throw new Error("Offscreen multi render window is not available when using CPU rendering.");
            const n = this.contextPool.getContextIndexForViewport(e);
            return this.contextPool.getContextByIndex(n).context;
        }
    };
    LK = class {
        constructor(e){
            const r = tf()?.rendering?.renderingEngineMode;
            switch(r){
                case k0.Tiled:
                    this._implementation = new f_(e);
                    break;
                case k0.ContextPool:
                    this._implementation = new kC(e);
                    break;
                default:
                    console.warn(`RenderingEngine: Unknown rendering engine mode "${r}". Defaulting to Next rendering engine.`), this._implementation = new kC(e);
                    break;
            }
        }
        get id() {
            return this._implementation.id;
        }
        enableElement(e) {
            return this._implementation.enableElement(e);
        }
        disableElement(e) {
            return this._implementation.disableElement(e);
        }
        setViewports(e) {
            return this._implementation.setViewports(e);
        }
        resize(e = !0, n = !0) {
            return this._implementation.resize(e, n);
        }
        getViewport(e) {
            return this._implementation.getViewport(e);
        }
        getViewports() {
            return this._implementation.getViewports();
        }
        getStackViewport(e) {
            return this._implementation.getStackViewport(e);
        }
        getStackViewports() {
            return this._implementation.getStackViewports();
        }
        getVolumeViewports() {
            return this._implementation.getVolumeViewports();
        }
        getRenderer(e) {
            return this._implementation.getRenderer(e);
        }
        fillCanvasWithBackgroundColor(e, n) {
            return this._implementation.fillCanvasWithBackgroundColor(e, n);
        }
        render() {
            return this._implementation.render();
        }
        renderViewports(e) {
            return this._implementation.renderViewports(e);
        }
        renderViewport(e) {
            return this._implementation.renderViewport(e);
        }
        destroy() {
            return this._implementation.destroy();
        }
        getOffscreenMultiRenderWindow(e) {
            return this._implementation.getOffscreenMultiRenderWindow(e);
        }
    };
    var gs;
    (function(t) {
        t[t.None = 0] = "None", t[t.Capture = 1] = "Capture", t[t.Bubble = 2] = "Bubble";
    })(gs || (gs = {}));
    class Hp {
        constructor(e){
            this._eventListeners = new Map, this._children = new Map, this._target = e;
        }
        get isEmpty() {
            return this._eventListeners.size === 0 && this._children.size === 0;
        }
        addEventListener(e, n, r) {
            const i = e.indexOf(".");
            if (i !== -1) {
                const o = e.substring(0, i);
                let s = this._children.get(o);
                s || (s = new Hp(this._target), this._children.set(o, s)), e = e.substring(i + 1), s.addEventListener(e, n, r);
            } else this._addEventListener(e, n, r);
        }
        removeEventListener(e, n, r) {
            const i = e.indexOf(".");
            if (i !== -1) {
                const o = e.substring(0, i), s = this._children.get(o);
                if (!s) return;
                e = e.substring(i + 1), s.removeEventListener(e, n, r), s.isEmpty && this._children.delete(o);
            } else this._removeEventListener(e, n, r);
        }
        reset() {
            Array.from(this._children.entries()).forEach(([e, n])=>{
                if (n.reset(), n.isEmpty) this._children.delete(e);
                else throw new Error("Child is not empty and cannot be removed");
            }), this._unregisterAllEvents();
        }
        _addEventListener(e, n, r) {
            let i = this._eventListeners.get(e);
            i || (i = new Map, this._eventListeners.set(e, i));
            const o = r?.capture ?? !1 ? gs.Capture : gs.Bubble, s = i.get(n) ?? gs.None;
            if (s & o) {
                console.warn("A listener is already registered for this phase");
                return;
            }
            i.set(n, s | o), this._target.addEventListener(e, n, r);
        }
        _removeEventListener(e, n, r) {
            const a = r?.capture ?? !1 ? gs.Capture : gs.Bubble, o = this._eventListeners.get(e);
            if (!o) return;
            (n ? [
                n
            ] : Array.from(o.keys())).forEach((c)=>{
                const l = o.get(c) ?? gs.None;
                if (!!!(l & a)) return;
                this._target.removeEventListener(e, c, r);
                const u = l ^ a;
                u === gs.None ? o.delete(c) : o.set(c, u);
            }), o.size || this._eventListeners.delete(e);
        }
        _unregisterAllListeners(e, n) {
            Array.from(n.entries()).forEach(([r, i])=>{
                const a = gs.Capture;
                for(let o = a; i; o <<= 1){
                    if (!(i & o)) continue;
                    const s = o === gs.Capture;
                    this.removeEventListener(e, r, {
                        capture: s
                    }), i ^= o;
                }
            });
        }
        _unregisterAllEvents() {
            Array.from(this._eventListeners.entries()).forEach(([e, n])=>{
                this._unregisterAllListeners(e, n);
            });
        }
    }
    class PK {
        constructor(){
            this._targetsEventListeners = new Map;
        }
        addEventListener(e, n, r, i) {
            let a = this._targetsEventListeners.get(e);
            a || (a = new Hp(e), this._targetsEventListeners.set(e, a)), a.addEventListener(n, r, i);
        }
        removeEventListener(e, n, r, i) {
            const a = this._targetsEventListeners.get(e);
            a && (a.removeEventListener(n, r, i), a.isEmpty && this._targetsEventListeners.delete(e));
        }
        reset() {
            Array.from(this._targetsEventListeners.entries()).forEach(([e, n])=>{
                n.reset(), this._targetsEventListeners.delete(e);
            });
        }
    }
    const VK = Object.freeze(Object.defineProperty({
        __proto__: null,
        MultiTargetEventListenerManager: PK,
        TargetEventListeners: Hp
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function NK(t, e) {
        const n = t.getSize();
        for(let r = 0; r < n; r++){
            const i = [];
            t.getNodeValue(r, i), i[1] = i[1] * e, i[2] = i[2] * e, i[3] = i[3] * e, t.setNodeValue(r, i);
        }
    }
    function AK(t) {
        let e = t[0], n = t[0], r;
        const i = t.length;
        for(let a = 1; a < i; a++)r = t[a], e = Math.min(e, r), n = Math.max(n, r);
        return {
            min: e,
            max: n
        };
    }
    const kK = Symbol("LastRuntimeId"), UK = {}, FK = 4294967295, BK = "-";
    function d_(t, e, n) {
        return GK(t !== null && typeof t == "object" ? t : UK, kK, (typeof n == "number" && n > 0 ? n : FK) >>> 0).join(typeof e == "string" ? e : BK);
    }
    function GK(t, e, n) {
        let r = t[e];
        r instanceof Array || (r = [
            0
        ], Object.defineProperty(t, e, {
            value: r
        }));
        for(let i = !0, a = 0; i && a < r.length; ++a){
            let o = r[a] | 0;
            o < n ? (i = !1, o = o + 1) : (o = 0, a + 1 === r.length && r.push(0)), r[a] = o;
        }
        return r;
    }
    const UC = {}, WK = {
        add: (t, e)=>{
            const n = ur(t);
            UC[n] = e;
        },
        get: (t, e)=>{
            if (t === "calibratedPixelSpacing") {
                const n = ur(e);
                return UC[n];
            }
        }
    };
    function $K(t, e, n = 1e-5) {
        return Math.abs(t[0] + e[0]) < n && Math.abs(t[1] + e[1]) < n && Math.abs(t[2] + e[2]) < n;
    }
    function Mi(t, e) {
        return !(t[0] < 0 || t[0] >= e[0] || t[1] < 0 || t[1] >= e[1] || t[2] < 0 || t[2] >= e[2]);
    }
    function zK(t, e) {
        let n;
        e ? n = [
            ws(e)
        ] : n = Es();
        const r = [];
        return n.forEach((i)=>{
            const a = t.getActors(), o = i.getVolumeViewports();
            for (const s of o){
                const c = s.getActors();
                if (c.length !== a.length) continue;
                a.every(({ uid: f })=>c.find((u)=>f === u.uid)) && r.push(s);
            }
        }), r;
    }
    const g_ = (t)=>t.preScale.scaled && t.preScale.scalingParameters.suvbw;
    function h_(t, e, n = void 0, r = "_thumbnails", i = {
        displayArea: {
            imageArea: [
                1,
                1
            ]
        }
    }) {
        if (!t || !(t instanceof HTMLCanvasElement)) throw new Error("canvas element is required");
        const a = !e.imageId, o = !a && e, s = a && e, l = `renderGPUViewport-${o.imageId || s.volumeId}`, f = document.createElement("div"), u = window.devicePixelRatio || 1;
        i.displayArea || (i.displayArea = {
            imageArea: [
                1,
                1
            ]
        });
        const g = t.width, h = t.height;
        f.style.width = `${g / u + Cd}px`, f.style.height = `${h / u + Cd}px`, f.style.visibility = "hidden", f.style.position = "absolute", document.body.appendChild(f);
        const v = l.split(":").join("-");
        f.setAttribute("viewport-id-for-remove", v);
        const m = Zo(f), y = ws(r) || new f_(r);
        let C = y.getViewport(l);
        if (!C) {
            const T = {
                viewportId: l,
                type: a ? On.ORTHOGRAPHIC : On.STACK,
                element: f,
                defaultOptions: {
                    ...i,
                    suppressEvents: !0
                }
            };
            y.enableElement(T), C = y.getViewport(l);
        }
        return new Promise((T)=>{
            let x = !1, { viewReference: S } = i;
            const D = (_)=>{
                if (x) return;
                if (S) {
                    const H = S;
                    S = null, C.setViewReference(H), C.render();
                    return;
                }
                t.getContext("2d").drawImage(m, 0, 0, m.width, m.height, 0, 0, t.width, t.height);
                const P = C.canvasToWorld([
                    0,
                    0
                ]), F = C.canvasToWorld([
                    m.width / u,
                    0
                ]), N = C.canvasToWorld([
                    0,
                    m.height / u
                ]), B = In([
                    0,
                    0,
                    0
                ], C.canvasToWorld([
                    1 / u,
                    0
                ]), P), G = In([
                    0,
                    0,
                    0
                ], C.canvasToWorld([
                    0,
                    1 / u
                ]), P), Z = 1;
                x = !0, f.removeEventListener(Ge.IMAGE_RENDERED, D), setTimeout(()=>{
                    y.disableElement(l), document.querySelectorAll(`[viewport-id-for-remove="${v}"]`).forEach((ne)=>{
                        ne.remove();
                    });
                }, 0), T({
                    origin: P,
                    bottomLeft: N,
                    topRight: F,
                    thicknessMm: Z,
                    rightVector: B,
                    downVector: G
                });
            };
            f.addEventListener(Ge.IMAGE_RENDERED, D), a ? C.setVolumes([
                s
            ], !1, !0) : C.renderImageObject(e), C.resetCamera(), n === "PT" && !g_(o) && C.setProperties({
                voiRange: {
                    lower: o.minPixelValue,
                    upper: o.maxPixelValue
                }
            }), C.render();
        });
    }
    function p_(t, e, n, r, i) {
        if (e.volumeId) throw new Error("Unsupported volume rendering for CPU");
        const o = e, s = c_(t, o, n), c = {
            canvas: t,
            viewport: s,
            image: o,
            renderingTools: {}
        };
        c.transform = Ld(c);
        const l = !0;
        return new Promise((f, u)=>{
            a_(c, l), f(null);
        });
    }
    function jK(t) {
        const { canvas: e, imageId: n, viewReference: r, requestType: i = Gt.Thumbnail, priority: a = -5, renderingEngineId: o = "_thumbnails", useCPURendering: s = !1, thumbnail: c = !1, imageAspect: l = !1, viewportOptions: f } = t, u = r?.volumeId, g = u && !n, h = r && f ? {
            ...f,
            viewReference: r
        } : f, v = s ? p_ : h_;
        return new Promise((m, y)=>{
            function C(D, _) {
                const { modality: M } = ct("generalSeriesModule", _) || {}, P = !g && D, F = g && D;
                P && (P.isPreScaled = P.isPreScaled || P.preScale?.scaled), c && (e.height = 256, e.width = 256), l && P && (e.width = P && e.height * P.width / P.height), e.style.width = `${e.width / devicePixelRatio}px`, e.style.height = `${e.height / devicePixelRatio}px`, F && s && y(new Error("CPU rendering of volume not supported")), v(e, D, M, o, h).then(m);
            }
            function T(D, _) {
                console.error(D, _), y(D);
            }
            function x(D, _, M) {
                return $l(D, M).then((P)=>{
                    C.call(this, P, D);
                }, (P)=>{
                    T.call(this, P, D);
                });
            }
            const S = {
                useRGBA: !!s,
                requestType: i
            };
            if (u) {
                const D = ot.getVolume(u);
                D || y(new Error(`Volume id ${u} not found in cache`));
                const _ = D.imageIds[0];
                C(D, _);
            } else xo.addRequest(x.bind(null, n, null, S), i, {
                imageId: n
            }, a);
        });
    }
    function qv(t) {
        return Array.isArray(t) ? t : [
            t
        ];
    }
    const FC = {
        HISTORY_UNDO: "CORNERSTONE_TOOLS_HISTORY_UNDO",
        HISTORY_REDO: "CORNERSTONE_TOOLS_HISTORY_REDO"
    };
    class m_ {
        constructor(e = "Tools", n = 50){
            this.position = -1, this.redoAvailable = 0, this.undoAvailable = 0, this.ring = new Array, this.isRecordingGrouped = !1, this.label = e, this._size = n;
        }
        get size() {
            return this._size;
        }
        set size(e) {
            this.ring = new Array(e), this._size = e, this.position = -1, this.redoAvailable = 0, this.undoAvailable = 0;
        }
        undo(e = 1) {
            for(; e > 0 && this.undoAvailable > 0;){
                const n = this.ring[this.position];
                for (const r of qv(n).reverse())r.restoreMemo(!0), this.dispatchHistoryEvent({
                    item: r,
                    isUndo: !0
                });
                e--, this.redoAvailable++, this.undoAvailable--, this.position = (this.position - 1 + this.size) % this.size;
            }
        }
        undoIf(e) {
            return this.undoAvailable > 0 && e(this.ring[this.position]) ? (this.undo(), !0) : !1;
        }
        dispatchHistoryEvent({ item: e, isUndo: n }) {
            e.id && Ke.dispatchEvent(new CustomEvent(n ? FC.HISTORY_UNDO : FC.HISTORY_REDO, {
                detail: {
                    isUndo: n,
                    id: e.id,
                    operationType: e.operationType || "annotation",
                    memo: e
                }
            }));
        }
        redo(e = 1) {
            for(; e > 0 && this.redoAvailable > 0;){
                const n = (this.position + 1) % this.size, r = this.ring[n];
                for (const i of qv(r).reverse())i.restoreMemo(!1), this.dispatchHistoryEvent({
                    item: i,
                    isUndo: !1
                });
                e--, this.position = n, this.undoAvailable++, this.redoAvailable--;
            }
        }
        initializeGroupItem() {
            this.redoAvailable = 0, this.undoAvailable < this._size && this.undoAvailable++, this.position = (this.position + 1) % this._size, this.ring[this.position] = [];
        }
        startGroupRecording() {
            this.isRecordingGrouped = !0, this.initializeGroupItem();
        }
        rollbackUnusedGroupItem() {
            this.ring[this.position] = void 0, this.position = (this.position - 1) % this._size, this.undoAvailable--;
        }
        endGroupRecording() {
            this.isRecordingGrouped = !1;
            const e = this.ring[this.position];
            Array.isArray(e) && e.length === 0 && this.rollbackUnusedGroupItem();
        }
        pushGrouped(e) {
            const n = this.ring[this.position];
            if (Array.isArray(n)) return n.push(e), e;
            throw new Error("Last item should be an array for grouped memos.");
        }
        push(e) {
            if (!e) return;
            const n = e.restoreMemo ? e : e.createMemo?.();
            if (n) return this.isRecordingGrouped ? this.pushGrouped(n) : (this.redoAvailable = 0, this.undoAvailable < this._size && this.undoAvailable++, this.position = (this.position + 1) % this._size, this.ring[this.position] = n, n);
        }
    }
    const HK = new m_, B4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        DefaultHistoryMemo: HK,
        HistoryMemo: m_
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function KK(t, e) {
        const n = ct("imagePlaneModule", t);
        if (!n) throw new Error(`No imagePlaneModule found for imageId: ${t}`);
        const { columnCosines: r, rowCosines: i, imagePositionPatient: a } = n;
        let { columnPixelSpacing: o, rowPixelSpacing: s } = n;
        o ||= 1, s ||= 1;
        const c = Xe();
        $i(c, a, r, -o / 2), $i(c, c, i, -s / 2);
        const l = Xe();
        In(l, e, c);
        const f = xt(l, i), u = xt(l, r);
        return [
            f / s,
            u / o
        ];
    }
    function qK(t, e) {
        const n = ct("imagePlaneModule", t);
        if (!n) throw new Error(`No imagePlaneModule found for imageId: ${t}`);
        const { columnCosines: r, rowCosines: i, imagePositionPatient: a } = n;
        let { columnPixelSpacing: o, rowPixelSpacing: s } = n;
        o ||= 1, s ||= 1;
        const c = Xe();
        return $i(c, a, i, s * (e[0] - .5)), $i(c, c, r, o * (e[1] - .5)), Array.from(c);
    }
    function up(t) {
        const e = Es(), n = [];
        return e.forEach((r)=>{
            r.getViewports().forEach((a)=>{
                a.hasImageURI(t) && n.push(a);
            });
        }), n;
    }
    function v_(t, e) {
        const n = XK(t, e);
        return n ? n.index : null;
    }
    function XK(t, e) {
        const n = e.getImageIds(), r = e.getCurrentImageIdIndex();
        if (n.length === 0) return null;
        const i = (c)=>{
            const l = YK(c);
            if (!l) return null;
            const f = BD(l.planeNormal, l.imagePositionPatient);
            return b4(f, t);
        }, a = {
            distance: i(n[r]) ?? 1 / 0,
            index: r
        }, o = n.slice(r + 1);
        for(let c = 0; c < o.length; c++){
            const l = o[c], f = i(l);
            if (f !== null) if (f <= a.distance) a.distance = f, a.index = c + r + 1;
            else break;
        }
        const s = n.slice(0, r);
        for(let c = s.length - 1; c >= 0; c--){
            const l = s[c], f = i(l);
            if (!(f === null || f === a.distance)) if (f < a.distance) a.distance = f, a.index = c;
            else break;
        }
        return a.distance === 1 / 0 ? null : a;
    }
    function YK(t) {
        const e = ct("imagePlaneModule", t);
        if (!e || !(e.rowCosines instanceof Array && e.rowCosines.length === 3) || !(e.columnCosines instanceof Array && e.columnCosines.length === 3) || !(e.imagePositionPatient instanceof Array && e.imagePositionPatient.length === 3)) return null;
        const { rowCosines: n, columnCosines: r, imagePositionPatient: i } = e, a = Sn(Xe(), ...n), o = Sn(Xe(), ...r), s = bn(Xe(), a, o);
        return {
            rowCosines: n,
            columnCosines: r,
            imagePositionPatient: i,
            planeNormal: s
        };
    }
    function ZK(t) {
        const { width: e, height: n } = t.getCanvas(), { sliceToIndexMatrix: r, indexToSliceMatrix: i } = t.getSliceViewInfo(), a = Rl(t, [
            0,
            0
        ]), o = Rl(t, [
            e - 1,
            0
        ]), s = Rl(t, [
            0,
            n - 1
        ]), c = In(Xe(), o, a), l = In(Xe(), s, a), f = bn(Xe(), c, l);
        jn(c, c), jn(l, l), jn(f, f);
        const u = Math.max(Math.abs(c[0]), Math.abs(c[1]), Math.abs(c[2])), g = Math.max(Math.abs(l[0]), Math.abs(l[1]), Math.abs(l[2]));
        if (!Gh(1, u) || !Gh(1, g)) throw new Error("Livewire is not available for rotate/oblique viewports");
        const { voxelManager: h } = t.getImageData(), v = t.getSliceViewInfo(), m = h.getSliceData(v);
        return {
            width: v.width,
            height: v.height,
            scalarData: m,
            sliceToIndexMatrix: r,
            indexToSliceMatrix: i
        };
    }
    const C0 = {}, fp = {
        add: (t, e)=>{
            const [n, r] = t, i = `${n}_${r}`;
            C0[i] || (C0[i] = {}), C0[i] = e;
        },
        get: (t, e, n)=>{
            if (t !== "spatialRegistrationModule") return;
            const r = `${e}_${n}`;
            if (C0[r]) return C0[r];
            const i = `${n}_${e}`;
            if (C0[i]) return Xr(xs(), C0[i]);
        }
    };
    cf(fp.get.bind(fp));
    const JK = .05;
    function QK(t, e) {
        const n = t.getSliceIndex(), r = e.getSliceIndex(), i = ct("imagePlaneModule", n.toString()), a = ct("imagePlaneModule", r.toString());
        if (!i || !a) {
            console.log("Viewport spatial registration requires image plane module");
            return;
        }
        const { imageOrientationPatient: o } = a;
        if (!i.imageOrientationPatient.every((g, h)=>Math.abs(g - o[h]) < JK)) {
            console.log("Viewport spatial registration only supported for same orientation (hence translation only) for now", i?.imageOrientationPatient, a?.imageOrientationPatient);
            return;
        }
        const c = i.imagePositionPatient, l = a.imagePositionPatient, f = kr(Xe(), c, l), u = Yd(xs(), f);
        fp.add([
            t.id,
            e.id
        ], u);
    }
    function eq(t) {
        const { imageData: e, dimensions: n } = t.getImageData() || {};
        if (!e || !n) return [];
        const { canvas: r } = t, i = window.devicePixelRatio, a = [
            0,
            0
        ], o = [
            r.width / i,
            0
        ], s = [
            r.width / i,
            r.height / i
        ], c = [
            0,
            r.height / i
        ], l = t.canvasToWorld(a), f = t.canvasToWorld(o), u = t.canvasToWorld(s), g = t.canvasToWorld(c), h = e.worldToIndex(l), v = e.worldToIndex(f), m = e.worldToIndex(u), y = e.worldToIndex(g);
        return tq({
            dimensions: n,
            imageData: e,
            topLeftImage: h,
            topRightImage: v,
            bottomRightImage: m,
            bottomLeftImage: y,
            topLeftWorld: l,
            topRightWorld: f,
            bottomRightWorld: u,
            bottomLeftWorld: g
        });
    }
    function tq({ dimensions: t, imageData: e, topLeftImage: n, topRightImage: r, bottomRightImage: i, bottomLeftImage: a, topLeftWorld: o, topRightWorld: s, bottomRightWorld: c, bottomLeftWorld: l }) {
        const f = P1(n, t) ? o : e.indexToWorld([
            0,
            0,
            0
        ]), u = P1(r, t) ? s : e.indexToWorld([
            t[0] - 1,
            0,
            0
        ]), g = P1(i, t) ? c : e.indexToWorld([
            t[0] - 1,
            t[1] - 1,
            0
        ]), h = P1(a, t) ? l : e.indexToWorld([
            0,
            t[1] - 1,
            0
        ]);
        return [
            f,
            u,
            h,
            g
        ];
    }
    function P1(t, e) {
        return t[0] > 0 || t[0] < e[0] - 1 || t[1] > 0 || t[1] < e[1] - 1 || t[2] > 0 || t[2] < e[2] - 1;
    }
    Fe = function(t) {
        if (!t) return;
        const { viewportUid: e, renderingEngineUid: n } = t.dataset;
        return gf(e, n);
    };
    gf = function(t, e) {
        if (!e || !t) return;
        const n = ws(e);
        if (!n || n.hasBeenDestroyed) return;
        const r = n.getViewport(t);
        if (!r) return;
        const i = r.getFrameOfReferenceUID();
        return {
            viewport: r,
            renderingEngine: n,
            viewportId: t,
            renderingEngineId: e,
            FrameOfReferenceUID: i
        };
    };
    An = function(t) {
        const e = Es();
        for(let n = 0; n < e.length; n++){
            const r = e[n];
            if (r.getViewport(t)) return gf(t, r.id);
        }
    };
    nq = function() {
        const t = [];
        return Es().forEach((n)=>{
            n.getViewports().forEach(({ element: i })=>{
                t.push(Fe(i));
            });
        }), t;
    };
    function rq(t) {
        const e = Fe(t);
        if (!e) return;
        const { viewport: n } = e;
        if (!(n instanceof ua)) throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${n.type}`);
        return n.getCornerstoneImage();
    }
    function iq(t) {
        if (t.length <= 1) return !1;
        const e = t[0], { modality: n, seriesInstanceUID: r } = ct("generalSeriesModule", e), { imageOrientationPatient: i, pixelSpacing: a, frameOfReferenceUID: o, columns: s, rows: c, usingDefaultValues: l } = ct("imagePlaneModule", e);
        if (l) return !1;
        const f = {
            modality: n,
            imageOrientationPatient: i,
            pixelSpacing: a,
            columns: s,
            rows: c,
            seriesInstanceUID: r
        };
        let u = !0;
        for(let g = 0; g < t.length; g++){
            const h = t[g], { modality: v, seriesInstanceUID: m } = ct("generalSeriesModule", h), { imageOrientationPatient: y, pixelSpacing: C, columns: T, rows: x } = ct("imagePlaneModule", h);
            if (m !== f.seriesInstanceUID) {
                u = !1;
                break;
            }
            if (v !== f.modality) {
                u = !1;
                break;
            }
            if (T !== f.columns) {
                u = !1;
                break;
            }
            if (x !== f.rows) {
                u = !1;
                break;
            }
            if (!lr(y, f.imageOrientationPatient)) {
                u = !1;
                break;
            }
            if (!lr(C, f.pixelSpacing)) {
                u = !1;
                break;
            }
        }
        return u;
    }
    const aq = new Set([
        "1.2.840.10008.1.2.4.100",
        "1.2.840.10008.1.2.4.100.1",
        "1.2.840.10008.1.2.4.101",
        "1.2.840.10008.1.2.4.101.1",
        "1.2.840.10008.1.2.4.102",
        "1.2.840.10008.1.2.4.102.1",
        "1.2.840.10008.1.2.4.103",
        "1.2.840.10008.1.2.4.103.1",
        "1.2.840.10008.1.2.4.104",
        "1.2.840.10008.1.2.4.104.1",
        "1.2.840.10008.1.2.4.105",
        "1.2.840.10008.1.2.4.105.1",
        "1.2.840.10008.1.2.4.106",
        "1.2.840.10008.1.2.4.106.1",
        "1.2.840.10008.1.2.4.107",
        "1.2.840.10008.1.2.4.108"
    ]);
    function y_(t) {
        return t ? (Array.isArray(t) ? t : [
            t
        ]).find((n)=>aq.has(n)) : !1;
    }
    async function oq({ viewport: t, options: e = {} }) {
        const n = t.getRenderingEngine();
        let r = e.volumeId || `${Vn()}`;
        r.split(":").length === 0 && (r = `${kD()}:${r}`);
        const { id: i, element: a } = t, o = e.viewportId || i, s = t.getImageIds(), c = t.getViewPresentation(), l = t.getViewReference();
        n.enableElement({
            viewportId: o,
            type: On.ORTHOGRAPHIC,
            element: a,
            defaultOptions: {
                background: e.background,
                orientation: e.orientation
            }
        }), (await O4(r, {
            imageIds: s
        })).load();
        const u = n.getViewport(o);
        await SK(n, [
            {
                volumeId: r
            }
        ], [
            o
        ]);
        const g = ()=>{
            u.render(), a.removeEventListener(Ge.VOLUME_VIEWPORT_NEW_VOLUME, g);
        };
        return (()=>{
            a.addEventListener(Ge.VOLUME_VIEWPORT_NEW_VOLUME, g);
        })(), u.setViewPresentation(c), u.setViewReference(l), u.render(), u;
    }
    async function sq({ viewport: t, options: e }) {
        const n = t, { id: r, element: i } = n, a = t.getRenderingEngine(), { background: o } = e, s = e.viewportId || r, c = ot.getVolume(n.getVolumeId());
        if (!(c instanceof tg)) throw new Error("Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.");
        const l = {
            viewportId: s,
            type: On.STACK,
            element: i,
            defaultOptions: {
                background: o
            }
        }, f = n.getViewReference();
        a.enableElement(l);
        const u = a.getViewport(s);
        return await u.setStack(c.imageIds), u.setViewReference(f), u.render(), u;
    }
    function Rn(t, e = 2) {
        if (Array.isArray(t)) return t.map((i)=>Rn(i, e)).join(", ");
        if (t == null || t === "") return "NaN";
        t = Number(t);
        const n = Math.abs(t);
        if (n < 1e-4) return `${t}`;
        const r = n >= 100 ? e - 2 : n >= 10 ? e - 1 : n >= 1 ? e : n >= .1 ? e + 1 : n >= .01 ? e + 2 : n >= .001 ? e + 3 : e + 4;
        return t.toFixed(r);
    }
    function cq(t) {
        return Math.round(t / Jo) * Jo;
    }
    function lq(t, e, n) {
        const r = t.length === e * n * 4, i = t.length === e * n * 3;
        if (r || i) {
            const a = new Float32Array(e * n);
            let o = 0, s = 0;
            const c = r ? 4 : 3;
            for(let l = 0; l < e; l++)for(let f = 0; f < n; f++){
                const u = t[o], g = t[o + 1], h = t[o + 2];
                a[s] = (u + g + h) / 3, o += c, s++;
            }
            return a;
        } else return t;
    }
    function uq(t) {
        if (t instanceof wi) return ot.getVolume(t.getVolumeId()).imageIds;
        if (t.getImageIds) return t.getImageIds();
    }
    function G4(t, e) {
        const n = [
            ...t
        ];
        return e >= n.length ? (BC(n), n) : (BC(n), n.slice(0, e));
    }
    function BC(t) {
        for(let e = t.length - 1; e > 0; e--){
            const n = Math.floor(Math.random() * (e + 1));
            [t[e], t[n]] = [
                t[n],
                t[e]
            ];
        }
    }
    function M5(t) {
        const e = t.toString(16);
        return e.length == 1 ? "0" + e : e;
    }
    function fq(t, e, n) {
        return "#" + M5(t) + M5(e) + M5(n);
    }
    function dq(t) {
        const e = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
        return e ? {
            r: parseInt(e[1], 16),
            g: parseInt(e[2], 16),
            b: parseInt(e[3], 16)
        } : null;
    }
    const gq = Object.freeze(Object.defineProperty({
        __proto__: null,
        hexToRgb: dq,
        rgbToHex: fq
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function C_(t, e) {
        if (t === e) return !0;
        if (t == null || e == null) return !1;
        try {
            return JSON.stringify(t) === JSON.stringify(e);
        } catch (n) {
            return console.debug("Error in JSON.stringify during deep comparison:", n), t === e;
        }
    }
    function hq(t, e, n) {
        if (!n) throw new Error("getVolume is required, use the utilities export instead ");
        if (t.modality) return t.modality;
        if (t.setVolumes) return e = e ?? t.getVolumeId(), !e || !n ? void 0 : n(e).metadata.Modality;
        throw new Error("Invalid viewport type");
    }
    const pq = (t, e)=>t.reduce((n, r)=>((n[r[e]] = n[r[e]] || []).push(r), n), {});
    function mq(t) {
        const e = t.map((o)=>{
            const { imagePositionPatient: s } = ct("imagePlaneModule", o) || {};
            return {
                imageId: o,
                imagePositionPatient: s
            };
        });
        if (!e.every((o)=>o.imagePositionPatient)) return null;
        const n = pq(e, "imagePositionPatient"), r = Object.keys(n), i = n[r[0]].length;
        return i === 1 || !r.every((o)=>n[o].length === i) ? null : n;
    }
    function vq(t, e) {
        const n = {};
        let r = [];
        const i = Object.keys(t);
        for(let a = 0; a < i.length; a++){
            const o = new Set, s = t[i[a]];
            for(let c = 0; c < s.length; c++){
                const l = e(s[c].imageId) || 0;
                if (n[l] = n[l] || [], n[l].push({
                    imageId: s[c].imageId
                }), o.add(l), o.size - 1 < c) return;
            }
            if (a == 0) r = Array.from(o);
            else if (!Tq(r, o)) return;
        }
        return n;
    }
    function Kf(t, e) {
        const n = ct(e, t);
        try {
            return parseFloat(n);
        } catch  {
            return;
        }
    }
    function yq(t) {
        const e = ct("20011003", t);
        try {
            const { InlineBinary: n } = e;
            if (n) {
                const r = atob(n), i = new ArrayBuffer(r.length), a = new DataView(i);
                for(let o = 0; o < r.length; o++)a.setUint8(o, r.charCodeAt(o));
                return new Float32Array(i)[0];
            }
            return parseFloat(e);
        } catch  {
            return;
        }
    }
    function Cq(t) {
        let e = ct("0019100c", t) || ct("0019100C", t);
        try {
            const { InlineBinary: n } = e;
            return n && (e = atob(n)), parseFloat(e);
        } catch  {
            return;
        }
    }
    function wq(t) {
        let e = ct("00431039", t);
        try {
            const { InlineBinary: n } = e;
            return n && (e = atob(n).split("//")), parseFloat(e[0]) % 1e5;
        } catch  {
            return;
        }
    }
    function Tq(t, e) {
        if (t.length != e.size) return !1;
        for(let n = 0; n < t.length; n++)if (!e.has(t[n])) return !1;
        return !0;
    }
    function xq(t) {
        const e = ct("petImageModule", t);
        return e ? e.frameReferenceTime : 0;
    }
    w_ = function(t) {
        const e = mq(t);
        if (!e) return {
            imageIdGroups: [
                t
            ],
            splittingTag: null
        };
        const n = [
            "TemporalPositionIdentifier",
            "DiffusionBValue",
            "TriggerTime",
            "EchoTime",
            "EchoNumber",
            "PhilipsPrivateBValue",
            "SiemensPrivateBValue",
            "GEPrivateBValue",
            "PetFrameReferenceTime"
        ], r = [
            (i)=>Kf(i, n[0]),
            (i)=>Kf(i, n[1]),
            (i)=>Kf(i, n[2]),
            (i)=>Kf(i, n[3]),
            (i)=>Kf(i, n[4]),
            yq,
            Cq,
            wq,
            xq
        ];
        for(let i = 0; i < r.length; i++){
            const a = vq(e, r[i]);
            if (a) return {
                imageIdGroups: Object.keys(a).map(Number.parseFloat).sort((c, l)=>c - l).map((c)=>a[c].map((l)=>l.imageId)),
                splittingTag: n[i]
            };
        }
        return {
            imageIdGroups: [
                t
            ],
            splittingTag: null
        };
    };
    function Sq(t) {
        const { imageIdGroups: e, splittingTag: n } = w_(t);
        return {
            isDynamicVolume: e.length > 1,
            timePoints: e,
            splittingTag: n
        };
    }
    function Eq(t, e) {
        const n = t.length, { rescaleSlope: r, rescaleIntercept: i, suvbw: a } = e;
        if (e.modality === "PT" && typeof a == "number") for(let o = 0; o < n; o++)t[o] = a * (t[o] * r + i);
        else for(let o = 0; o < n; o++)t[o] = t[o] * r + i;
        return t;
    }
    function T_(t, e, n) {
        return Math.min(Math.max(e, t), n);
    }
    function dp(t, e) {
        if (!Fe(t.element)) throw new Error("Scroll::Viewport is not enabled (it might be disabled)");
        if (t instanceof ua && t.getImageIds().length === 0) throw new Error("Scroll::Stack Viewport has no images");
        const { volumeId: r, delta: i, scrollSlabs: a } = e;
        if (t instanceof wi) Dq(t, r, i, a);
        else {
            const o = t.getCurrentImageIdIndex();
            if (o + i > t.getImageIds().length - 1 || o + i < 0) {
                const s = {
                    imageIdIndex: o,
                    direction: i
                };
                We(Ke, Ge.STACK_SCROLL_OUT_OF_BOUNDS, s);
            }
            t.scroll(i, e.debounceLoading, e.loop);
        }
    }
    function Dq(t, e, n, r = !1) {
        const i = r, { numScrollSteps: a, currentStepIndex: o, sliceRangeInfo: s } = Gu(t, e, i);
        if (!s) return;
        const { sliceRange: c, spacingInNormalDirection: l, camera: f } = s, { focalPoint: u, viewPlaneNormal: g, position: h } = f, { newFocalPoint: v, newPosition: m } = Wu(u, h, c, g, l, n);
        t.setCamera({
            focalPoint: v,
            position: m
        }), t.render();
        const y = o + n, C = {
            volumeId: e,
            viewport: t,
            delta: n,
            desiredStepIndex: y,
            currentStepIndex: o,
            numScrollSteps: a,
            currentImageId: t.getCurrentImageId()
        };
        (y > a || y < 0) && t.getCurrentImageId() ? We(Ke, Ge.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, C) : We(Ke, Ge.VOLUME_VIEWPORT_SCROLL, C);
    }
    async function _q(t, e = {}) {
        const { imageIndex: n, debounceLoading: r, volumeId: i } = e, a = Fe(t);
        if (!a) throw new Error("Element has been disabled");
        const { viewport: o } = a, { imageIndex: s, numberOfSlices: c } = Rq(o, r), f = Oq(c, n) - s;
        dp(o, {
            delta: f,
            debounceLoading: r,
            volumeId: i
        });
    }
    function Rq(t, e) {
        return t instanceof ua ? {
            numberOfSlices: t.getImageIds().length,
            imageIndex: e ? t.getTargetImageIdIndex() : t.getCurrentImageIdIndex()
        } : {
            numberOfSlices: t.getNumberOfSlices(),
            imageIndex: t.getSliceIndex()
        };
    }
    function Oq(t, e) {
        const n = t - 1;
        return T_(e, 0, n);
    }
    function Iq(t, e, n = {}) {
        const r = ot.getVolume(t);
        if (!r) throw new Error(`Referenced volume with id ${t} does not exist.`);
        const { metadata: i, spacing: a, direction: o, dimensions: s } = r, { minX: c, maxX: l, minY: f, maxY: u, minZ: g, maxZ: h } = e, v = [
            Math.min(c, l),
            Math.min(f, u),
            Math.min(g, h)
        ], m = op(r.imageData, v), y = [
            Math.abs(l - c) + 1,
            Math.abs(u - f) + 1,
            Math.abs(h - g) + 1
        ], { targetBuffer: C } = n, T = {
            metadata: i,
            dimensions: y,
            spacing: a,
            origin: m,
            direction: o,
            targetBuffer: C,
            scalarData: C?.type === "Float32Array" ? new Float32Array(y[0] * y[1] * y[2]) : void 0
        }, x = I4(Vn(), T), S = x.voxelManager.getCompleteScalarDataArray(), D = y[0] * y[1], _ = s[0] * s[1], M = r.voxelManager.getCompleteScalarDataArray();
        for(let P = 0; P < y[2]; P++)for(let F = 0; F < y[1]; F++){
            const N = op(x.imageData, [
                0,
                F,
                P
            ]), B = Co(r.imageData, N), G = B[2] * _ + B[1] * s[0] + B[0], Z = M.slice(G, G + y[0]), H = P * D + F * y[0];
            S.set(Z, H);
        }
        return x.voxelManager.setCompleteScalarDataArray(S), x;
    }
    function Mq(t, e) {
        const { viewUp: n, viewPlaneNormal: r } = e, i = sh(t, [
            0,
            0,
            0
        ]), a = jc(Xe(), n), o = jc(Xe(), r), s = bn(Xe(), a, o), c = In(Xe(), sh(t, a), i), l = In(Xe(), sh(t, o), i);
        jn(c, c), jn(l, l);
        const f = bn(Xe(), c, l);
        return {
            worldVecRowDir: s,
            worldVecColDir: a,
            worldVecSliceDir: o,
            ijkVecRowDir: f,
            ijkVecColDir: c,
            ijkVecSliceDir: l
        };
    }
    function bq(t, e, n, r) {
        const [i, a, o] = e, s = i * a;
        let c = 0, l = 0, f = 0;
        const [u, g, h] = n.map(Math.round);
        for(let C = h - r; C <= h + r; C++)if (!(C < 0 || C >= o)) {
            for(let T = g - r; T <= g + r; T++)if (!(T < 0 || T >= a)) for(let x = u - r; x <= u + r; x++){
                if (x < 0 || x >= i) continue;
                const S = C * s + T * i + x, D = t[S];
                c += D, l += D * D, f++;
            }
        }
        if (f === 0) {
            const C = h * s + g * i + u;
            return C >= 0 && C < t.length ? {
                mean: t[C],
                stdDev: 0,
                count: 1
            } : {
                mean: 0,
                stdDev: 0,
                count: 0
            };
        }
        const v = c / f, m = l / f - v * v, y = Math.sqrt(Math.max(0, m));
        return {
            mean: v,
            stdDev: y,
            count: f
        };
    }
    const Lq = new Set([
        "1.2.840.10008.5.1.4.1.1.1",
        "1.2.840.10008.5.1.4.1.1.1.1",
        "1.2.840.10008.5.1.4.1.1.1.1.1",
        "1.2.840.10008.5.1.4.1.1.1.2",
        "1.2.840.10008.5.1.4.1.1.1.2.1",
        "1.2.840.10008.5.1.4.1.1.1.3",
        "1.2.840.10008.5.1.4.1.1.1.3.1",
        "1.2.840.10008.5.1.4.1.1.12.1",
        "1.2.840.10008.5.1.4.1.1.12.1.1",
        "1.2.840.10008.5.1.4.1.1.12.2",
        "1.2.840.10008.5.1.4.1.1.12.2.1",
        "1.2.840.10008.5.1.4.1.1.12.3"
    ]);
    function Pq(t) {
        const { PixelSpacing: e, ImagerPixelSpacing: n, EstimatedRadiographicMagnificationFactor: r, PixelSpacingCalibrationType: i, PixelSpacingCalibrationDescription: a } = t, o = !0;
        return n ? e ? lr(e, n) ? {
            PixelSpacing: e,
            type: Ks.PROJECTION,
            isProjection: o
        } : i || a ? {
            PixelSpacing: e,
            type: Ks.CALIBRATED,
            isProjection: o,
            PixelSpacingCalibrationType: i,
            PixelSpacingCalibrationDescription: a
        } : {
            PixelSpacing: e,
            type: Ks.UNKNOWN,
            isProjection: o
        } : r ? {
            PixelSpacing: n.map((c)=>c / r),
            type: Ks.ERMF,
            isProjection: o
        } : (console.warn("EstimatedRadiographicMagnificationFactor was not present. Unable to correct ImagerPixelSpacing."), {
            PixelSpacing: n,
            type: Ks.PROJECTION,
            isProjection: o
        }) : {
            PixelSpacing: e,
            type: Ks.UNKNOWN,
            isProjection: o
        };
    }
    function Vq(t) {
        const { SequenceOfUltrasoundRegions: e } = t, n = Array.isArray(e);
        if (n && e.length > 1) {
            console.warn("Sequence of Ultrasound Regions > one entry. This is not yet implemented, all measurements will be shown in pixels.");
            return;
        }
        const { PhysicalDeltaX: r, PhysicalDeltaY: i } = n ? e[0] : e;
        return {
            PixelSpacing: [
                Math.abs(r) * 10,
                Math.abs(i) * 10
            ]
        };
    }
    function Nq(t) {
        const { PixelSpacing: e, SOPClassUID: n, SequenceOfUltrasoundRegions: r } = t;
        return r ? Vq(t) : Lq.has(n) ? Pq(t) : {
            PixelSpacing: e,
            type: Ks.NOT_APPLICABLE,
            isProjection: !1
        };
    }
    let Aq;
    Aq = (t, e)=>hq(t, e, ot.getVolume);
    ga = Object.freeze(Object.defineProperty({
        __proto__: null,
        FrameRange: vh,
        HistoryMemo: B4,
        PointsManager: dh,
        ProgressiveIterator: rp,
        RLEVoxelMap: Ru,
        VoxelManager: $n,
        actorIsA: Ya,
        applyPreset: $D,
        asArray: qv,
        autoLoad: Gv,
        buildMetadata: ZD,
        calculateNeighborhoodStats: bq,
        calculateSpacingBetweenImageIds: DD,
        calculateViewportsSpatialRegistration: QK,
        calibratedPixelSpacingMetadataProvider: WK,
        clamp: Kv,
        clip: T_,
        color: gq,
        colormap: iN,
        convertStackToVolumeViewport: oq,
        convertToGrayscale: lq,
        convertVolumeToStackViewport: sq,
        createLinearRGBTransferFunction: e_,
        createSigmoidRGBTransferFunction: Y3,
        createSubVolume: Iq,
        decimate: ID,
        deepClone: ms,
        deepEqual: C_,
        deepMerge: Ma,
        eventListener: VK,
        fnv1aHash: wx,
        generateVolumePropsFromImageIds: D4,
        genericMetadataProvider: Vl,
        getBufferConfiguration: y4,
        getClosestImageId: Pd,
        getClosestStackImageIndexForPoint: v_,
        getCurrentVolumeViewportSlice: ZK,
        getDynamicVolumeInfo: Sq,
        getImageDataMetadata: JD,
        getImageLegacy: rq,
        getImageSliceDataForVolumeViewport: ip,
        getMinMax: AK,
        getPixelSpacingInformation: Nq,
        getRandomSampleFromArray: G4,
        getRuntimeId: d_,
        getScalingParameters: RD,
        getSliceRange: Wp,
        getSpacingInNormalDirection: ng,
        getTargetVolumeAndSpacingInNormalDir: rg,
        getViewportImageCornersInWorld: eq,
        getViewportImageIds: uq,
        getViewportModality: Aq,
        getViewportsWithImageURI: up,
        getViewportsWithVolumeId: Gp,
        getVoiFromSigmoidRGBTransferFunction: WD,
        getVolumeActorCorners: UD,
        getVolumeDirectionVectors: Mq,
        getVolumeId: lf,
        getVolumeSliceRangeInfo: GD,
        getVolumeViewportScrollInfo: Gu,
        getVolumeViewportsContainingSameVolumes: zK,
        hasFloatScalingParameters: E4,
        hasNaNValues: $v,
        imageIdToURI: ur,
        imageRetrieveMetadataProvider: Zu,
        imageToWorldCoords: qK,
        indexWithinDimensions: Mi,
        invertRgbTransferFunction: pd,
        isEqual: lr,
        isEqualAbs: tN,
        isEqualNegative: Sx,
        isImageActor: ps,
        isNumber: cr,
        isOpposite: $K,
        isPTPrescaledWithSUV: g_,
        isValidVolume: iq,
        isVideoTransferSyntax: y_,
        jumpToSlice: _q,
        loadImageToCanvas: jK,
        logger: bH,
        makeVolumeMetadata: ED,
        planar: Hj,
        pointInShapeCallback: _E,
        renderToCanvasCPU: p_,
        renderToCanvasGPU: h_,
        roundNumber: Rn,
        roundToPrecision: cq,
        scaleArray: Eq,
        scaleRgbTransferFunction: NK,
        scroll: dp,
        snapFocalPointToSlice: Wu,
        sortImageIdsAndGetSpacing: _D,
        spatialRegistrationMetadataProvider: fp,
        splitImageIdsBy4DTags: w_,
        transferFunctionUtils: oN,
        transformIndexToWorld: op,
        transformWorldToIndex: Co,
        transformWorldToIndexContinuous: sh,
        triggerEvent: We,
        updateVTKImageDataWithCornerstoneImage: zp,
        uuidv4: Vn,
        windowLevel: aN,
        worldToImageCoords: KK
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    ig = new d3("imageRetrievalPool");
    ig.setMaxSimultaneousRequests(Gt.Interaction, 200);
    ig.setMaxSimultaneousRequests(Gt.Thumbnail, 200);
    ig.setMaxSimultaneousRequests(Gt.Prefetch, 200);
    ig.grabDelay = 0;
    const GC = Symbol("DefaultSettings"), WC = Symbol("RuntimeSettings"), $C = Symbol("ObjectSettingsMap"), Pc = Symbol("Dictionary");
    sr = class {
        constructor(e){
            const n = Object.create(e instanceof sr && Pc in e ? e[Pc] : null);
            Object.seal(Object.defineProperty(this, Pc, {
                value: n
            }));
        }
        set(e, n) {
            return gp(this[Pc], e, n, null);
        }
        get(e) {
            return Fq(this[Pc], e);
        }
        unset(e) {
            return kq(this[Pc], e + "");
        }
        forEach(e) {
            zC(this[Pc], e);
        }
        extend() {
            return new sr(this);
        }
        import(e) {
            x_(e) && Object.keys(e).forEach((n)=>{
                gp(this[Pc], n, e[n], null);
            });
        }
        dump() {
            const e = {};
            return zC(this[Pc], (n, r)=>{
                typeof r < "u" && S_(e, n, r);
            }), e;
        }
        static assert(e) {
            return e instanceof sr ? e : sr.getRuntimeSettings();
        }
        static getDefaultSettings(e = null) {
            let n = sr[GC];
            if (n instanceof sr || (n = new sr, sr[GC] = n), e) {
                const r = {};
                return n.forEach((i)=>{
                    if (i.startsWith(e)) {
                        const a = i.split(`${e}.`)[1];
                        r[a] = n.get(i);
                    }
                }), r;
            }
            return n;
        }
        static getRuntimeSettings() {
            let e = sr[WC];
            return e instanceof sr || (e = new sr(sr.getDefaultSettings()), sr[WC] = e), e;
        }
        static getObjectSettings(e, n) {
            let r = null;
            if (e instanceof sr) r = e;
            else if (typeof e == "object" && e !== null) {
                let i = sr[$C];
                i instanceof WeakMap || (i = new WeakMap, sr[$C] = i), r = i.get(e), r instanceof sr || (r = new sr(sr.assert(sr.getObjectSettings(n))), i.set(e, r));
            }
            return r;
        }
        static extendRuntimeSettings() {
            return sr.getRuntimeSettings().extend();
        }
    };
    function kq(t, e) {
        if (e.endsWith(".")) {
            let n = 0;
            const r = e, i = r.slice(0, -1), a = i.length === 0;
            for(const o in t)Object.prototype.hasOwnProperty.call(t, o) && (a || o.startsWith(r) || o === i) && (delete t[o], ++n);
            return n > 0;
        }
        return delete t[e];
    }
    function zC(t, e) {
        for(const n in t)e(n, t[n]);
    }
    function Uq(t, e, n, r) {
        let i;
        if (r.has(n)) return gp(t, e, null, r);
        r.add(n), i = 0;
        for(const a in n)if (Object.prototype.hasOwnProperty.call(n, a)) {
            const o = a.length === 0 ? e : `${e}.${a}`;
            gp(t, o, n[a], r) || ++i;
        }
        return r.delete(n), i === 0;
    }
    function gp(t, e, n, r) {
        return Bq(e) ? x_(n) ? Uq(t, e, n, r instanceof WeakSet ? r : new WeakSet) : (t[e] = n, !0) : !1;
    }
    function Fq(t, e) {
        return t[e];
    }
    function Bq(t) {
        let e, n, r;
        if (typeof t != "string" || (e = t.length - 1) < 0) return !1;
        for(r = -1; (n = t.indexOf(".", r + 1)) >= 0;){
            if (n - r < 2 || n === e) return !1;
            r = n;
        }
        return !0;
    }
    function x_(t) {
        if (typeof t == "object" && t !== null) {
            const e = Object.getPrototypeOf(t);
            if (e === Object.prototype || e === null) return !0;
        }
        return !1;
    }
    function S_(t, e, n) {
        const r = e.indexOf(".");
        if (r >= 0) {
            const i = e.slice(0, r);
            let a = t[i];
            if (typeof a != "object" || a === null) {
                const o = a;
                a = {}, typeof o < "u" && (a[""] = o), t[i] = a;
            }
            S_(a, e.slice(r + 1, e.length), n);
        } else t[e] = n;
    }
    sr.getDefaultSettings().set("useCursors", !0);
    function Gq(t, e) {
        let n;
        if (e === void 0) for (const r of t)r != null && (n > r || n === void 0 && r >= r) && (n = r);
        else {
            let r = -1;
            for (let i of t)(i = e(i, ++r, t)) != null && (n > i || n === void 0 && i >= i) && (n = i);
        }
        return n;
    }
    function Wq(t) {
        if (!(a = t.length)) return [];
        for(var e = -1, n = Gq(t, $q), r = new Array(n); ++e < n;)for(var i = -1, a, o = r[e] = new Array(a); ++i < a;)o[i] = t[i][e];
        return r;
    }
    function $q(t) {
        return t.length;
    }
    function jC() {
        return Wq(arguments);
    }
    function zq(t, e, n, r, i) {
        var a = t * t, o = a * t;
        return ((1 - 3 * t + 3 * a - o) * e + (4 - 6 * a + 3 * o) * n + (1 + 3 * t + 3 * a - 3 * o) * r + o * i) / 6;
    }
    function b5(t) {
        var e = t.length - 1;
        return function(n) {
            var r = n <= 0 ? n = 0 : n >= 1 ? (n = 1, e - 1) : Math.floor(n * e), i = t[r], a = t[r + 1], o = r > 0 ? t[r - 1] : 2 * i - a, s = r < e - 1 ? t[r + 2] : 2 * a - i;
            return zq((n - r / e) * e, o, i, a, s);
        };
    }
    function qf(t, e) {
        for(var n = new Array(e), r = 0; r < e; ++r)n[r] = t(r / (e - 1));
        return n;
    }
    var zl;
    (function(t) {
        t[t.Primary = 1] = "Primary", t[t.Secondary = 2] = "Secondary", t[t.Primary_And_Secondary = 3] = "Primary_And_Secondary", t[t.Auxiliary = 4] = "Auxiliary", t[t.Primary_And_Auxiliary = 5] = "Primary_And_Auxiliary", t[t.Secondary_And_Auxiliary = 6] = "Secondary_And_Auxiliary", t[t.Primary_And_Secondary_And_Auxiliary = 7] = "Primary_And_Secondary_And_Auxiliary", t[t.Fourth_Button = 8] = "Fourth_Button", t[t.Fifth_Button = 16] = "Fifth_Button", t[t.Wheel = 524288] = "Wheel", t[t.Wheel_Primary = 524289] = "Wheel_Primary";
    })(zl || (zl = {}));
    var aa;
    (function(t) {
        t[t.Shift = 16] = "Shift", t[t.Ctrl = 17] = "Ctrl", t[t.Alt = 18] = "Alt", t[t.Meta = 91] = "Meta", t[t.ShiftCtrl = 1617] = "ShiftCtrl", t[t.ShiftAlt = 1618] = "ShiftAlt", t[t.ShiftMeta = 1691] = "ShiftMeta", t[t.CtrlAlt = 1718] = "CtrlAlt", t[t.CtrlMeta = 1791] = "CtrlMeta", t[t.AltMeta = 1891] = "AltMeta";
    })(aa || (aa = {}));
    var er;
    (function(t) {
        t.Active = "Active", t.Passive = "Passive", t.Enabled = "Enabled", t.Disabled = "Disabled";
    })(er || (er = {}));
    var Ol;
    (function(t) {
        t.Default = "", t.Highlighted = "Highlighted", t.Selected = "Selected", t.Locked = "Locked", t.AutoGenerated = "AutoGenerated";
    })(Ol || (Ol = {}));
    var z;
    (function(t) {
        t.TOOL_ACTIVATED = "CORNERSTONE_TOOLS_TOOL_ACTIVATED", t.TOOLGROUP_VIEWPORT_ADDED = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_ADDED", t.TOOLGROUP_VIEWPORT_REMOVED = "CORNERSTONE_TOOLS_TOOLGROUP_VIEWPORT_REMOVED", t.TOOL_MODE_CHANGED = "CORNERSTONE_TOOLS_TOOL_MODE_CHANGED", t.CROSSHAIR_TOOL_CENTER_CHANGED = "CORNERSTONE_TOOLS_CROSSHAIR_TOOL_CENTER_CHANGED", t.ANNOTATION_ADDED = "CORNERSTONE_TOOLS_ANNOTATION_ADDED", t.ANNOTATION_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_COMPLETED", t.ANNOTATION_MODIFIED = "CORNERSTONE_TOOLS_ANNOTATION_MODIFIED", t.ANNOTATION_REMOVED = "CORNERSTONE_TOOLS_ANNOTATION_REMOVED", t.ANNOTATION_SELECTION_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_SELECTION_CHANGE", t.ANNOTATION_LOCK_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_LOCK_CHANGE", t.ANNOTATION_VISIBILITY_CHANGE = "CORNERSTONE_TOOLS_ANNOTATION_VISIBILITY_CHANGE", t.ANNOTATION_RENDERED = "CORNERSTONE_TOOLS_ANNOTATION_RENDERED", t.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_CUT_MERGE_PROCESS_COMPLETED", t.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED = "CORNERSTONE_TOOLS_ANNOTATION_INTERPOLATION_PROCESS_COMPLETED", t.INTERPOLATED_ANNOTATIONS_REMOVED = "CORNERSTONE_TOOLS_INTERPOLATED_ANNOTATIONS_REMOVED", t.SEGMENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_MODIFIED", t.SEGMENTATION_RENDERED = "CORNERSTONE_TOOLS_SEGMENTATION_RENDERED", t.SEGMENTATION_REPRESENTATION_ADDED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_ADDED", t.SEGMENTATION_ADDED = "CORNERSTONE_TOOLS_SEGMENTATION_ADDED", t.SEGMENTATION_REPRESENTATION_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_MODIFIED", t.SEGMENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REMOVED", t.SEGMENTATION_REPRESENTATION_REMOVED = "CORNERSTONE_TOOLS_SEGMENTATION_REPRESENTATION_REMOVED", t.SEGMENTATION_DATA_MODIFIED = "CORNERSTONE_TOOLS_SEGMENTATION_DATA_MODIFIED", t.HISTORY_UNDO = "CORNERSTONE_TOOLS_HISTORY_UNDO", t.HISTORY_REDO = "CORNERSTONE_TOOLS_HISTORY_REDO", t.KEY_DOWN = "CORNERSTONE_TOOLS_KEY_DOWN", t.KEY_UP = "CORNERSTONE_TOOLS_KEY_UP", t.MOUSE_DOWN = "CORNERSTONE_TOOLS_MOUSE_DOWN", t.MOUSE_UP = "CORNERSTONE_TOOLS_MOUSE_UP", t.MOUSE_DOWN_ACTIVATE = "CORNERSTONE_TOOLS_MOUSE_DOWN_ACTIVATE", t.MOUSE_DRAG = "CORNERSTONE_TOOLS_MOUSE_DRAG", t.MOUSE_MOVE = "CORNERSTONE_TOOLS_MOUSE_MOVE", t.MOUSE_CLICK = "CORNERSTONE_TOOLS_MOUSE_CLICK", t.MOUSE_DOUBLE_CLICK = "CORNERSTONE_TOOLS_MOUSE_DOUBLE_CLICK", t.MOUSE_WHEEL = "CORNERSTONE_TOOLS_MOUSE_WHEEL", t.TOUCH_START = "CORNERSTONE_TOOLS_TOUCH_START", t.TOUCH_START_ACTIVATE = "CORNERSTONE_TOOLS_TOUCH_START_ACTIVATE", t.TOUCH_PRESS = "CORNERSTONE_TOOLS_TOUCH_PRESS", t.TOUCH_DRAG = "CORNERSTONE_TOOLS_TOUCH_DRAG", t.TOUCH_END = "CORNERSTONE_TOOLS_TOUCH_END", t.TOUCH_TAP = "CORNERSTONE_TOOLS_TAP", t.TOUCH_SWIPE = "CORNERSTONE_TOOLS_SWIPE";
    })(z || (z = {}));
    var Ft;
    (function(t) {
        t.Labelmap = "Labelmap", t.Contour = "Contour", t.Surface = "Surface";
    })(Ft || (Ft = {}));
    var bu;
    (function(t) {
        t.UP = "UP", t.DOWN = "DOWN", t.LEFT = "LEFT", t.RIGHT = "RIGHT";
    })(bu || (bu = {}));
    var Jt;
    (function(t) {
        t.Interaction = "Interaction", t.HandlesUpdated = "HandlesUpdated", t.StatsUpdated = "StatsUpdated", t.InitialSetup = "InitialSetup", t.Completed = "Completed", t.InterpolationUpdated = "InterpolationUpdated", t.History = "History", t.MetadataReferenceModified = "MetadataReferenceModified", t.LabelChange = "LabelChange";
    })(Jt || (Jt = {}));
    let jq = {}, nt = {
        isInteractingWithTool: !1,
        isMultiPartToolActive: !1,
        tools: {},
        toolGroups: [],
        synchronizers: [],
        svgNodeCache: jq,
        enabledElements: []
    };
    var L5, HC;
    function Hq() {
        if (HC) return L5;
        HC = 1;
        var t = "Expected a function", e = "__lodash_hash_undefined__", n = "[object Function]", r = "[object GeneratorFunction]", i = "[object Symbol]", a = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, o = /^\w*$/, s = /^\./, c = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, l = /[\\^$.*+?()[\]{}|]/g, f = /\\(\\)?/g, u = /^\[object .+?Constructor\]$/, g = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis, h = typeof self == "object" && self && self.Object === Object && self, v = g || h || Function("return this")();
        function m(De, ze) {
            return De?.[ze];
        }
        function y(De) {
            var ze = !1;
            if (De != null && typeof De.toString != "function") try {
                ze = !!(De + "");
            } catch  {}
            return ze;
        }
        var C = Array.prototype, T = Function.prototype, x = Object.prototype, S = v["__core-js_shared__"], D = function() {
            var De = /[^.]+$/.exec(S && S.keys && S.keys.IE_PROTO || "");
            return De ? "Symbol(src)_1." + De : "";
        }(), _ = T.toString, M = x.hasOwnProperty, P = x.toString, F = RegExp("^" + _.call(M).replace(l, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), N = v.Symbol, B = C.splice, G = Un(v, "Map"), Z = Un(Object, "create"), H = N ? N.prototype : void 0, ne = H ? H.toString : void 0;
        function ae(De) {
            var ze = -1, ft = De ? De.length : 0;
            for(this.clear(); ++ze < ft;){
                var nn = De[ze];
                this.set(nn[0], nn[1]);
            }
        }
        function ue() {
            this.__data__ = Z ? Z(null) : {};
        }
        function le(De) {
            return this.has(De) && delete this.__data__[De];
        }
        function oe(De) {
            var ze = this.__data__;
            if (Z) {
                var ft = ze[De];
                return ft === e ? void 0 : ft;
            }
            return M.call(ze, De) ? ze[De] : void 0;
        }
        function re(De) {
            var ze = this.__data__;
            return Z ? ze[De] !== void 0 : M.call(ze, De);
        }
        function X(De, ze) {
            var ft = this.__data__;
            return ft[De] = Z && ze === void 0 ? e : ze, this;
        }
        ae.prototype.clear = ue, ae.prototype.delete = le, ae.prototype.get = oe, ae.prototype.has = re, ae.prototype.set = X;
        function ie(De) {
            var ze = -1, ft = De ? De.length : 0;
            for(this.clear(); ++ze < ft;){
                var nn = De[ze];
                this.set(nn[0], nn[1]);
            }
        }
        function he() {
            this.__data__ = [];
        }
        function $e(De) {
            var ze = this.__data__, ft = Pe(ze, De);
            if (ft < 0) return !1;
            var nn = ze.length - 1;
            return ft == nn ? ze.pop() : B.call(ze, ft, 1), !0;
        }
        function je(De) {
            var ze = this.__data__, ft = Pe(ze, De);
            return ft < 0 ? void 0 : ze[ft][1];
        }
        function He(De) {
            return Pe(this.__data__, De) > -1;
        }
        function rt(De, ze) {
            var ft = this.__data__, nn = Pe(ft, De);
            return nn < 0 ? ft.push([
                De,
                ze
            ]) : ft[nn][1] = ze, this;
        }
        ie.prototype.clear = he, ie.prototype.delete = $e, ie.prototype.get = je, ie.prototype.has = He, ie.prototype.set = rt;
        function Qe(De) {
            var ze = -1, ft = De ? De.length : 0;
            for(this.clear(); ++ze < ft;){
                var nn = De[ze];
                this.set(nn[0], nn[1]);
            }
        }
        function et() {
            this.__data__ = {
                hash: new ae,
                map: new (G || ie),
                string: new ae
            };
        }
        function St(De) {
            return Hn(this, De).delete(De);
        }
        function Ln(De) {
            return Hn(this, De).get(De);
        }
        function Nn(De) {
            return Hn(this, De).has(De);
        }
        function zt(De, ze) {
            return Hn(this, De).set(De, ze), this;
        }
        Qe.prototype.clear = et, Qe.prototype.delete = St, Qe.prototype.get = Ln, Qe.prototype.has = Nn, Qe.prototype.set = zt;
        function Pe(De, ze) {
            for(var ft = De.length; ft--;)if (Mt(De[ft][0], ze)) return ft;
            return -1;
        }
        function Ct(De, ze) {
            ze = q(ze, De) ? [
                ze
            ] : ln(ze);
            for(var ft = 0, nn = ze.length; De != null && ft < nn;)De = De[Ce(ze[ft++])];
            return ft && ft == nn ? De : void 0;
        }
        function yt(De) {
            if (!tn(De) || me(De)) return !1;
            var ze = Cn(De) || y(De) ? F : u;
            return ze.test(Ue(De));
        }
        function En(De) {
            if (typeof De == "string") return De;
            if (Yt(De)) return ne ? ne.call(De) : "";
            var ze = De + "";
            return ze == "0" && 1 / De == -1 / 0 ? "-0" : ze;
        }
        function ln(De) {
            return jt(De) ? De : J(De);
        }
        function Hn(De, ze) {
            var ft = De.__data__;
            return Q(ze) ? ft[typeof ze == "string" ? "string" : "hash"] : ft.map;
        }
        function Un(De, ze) {
            var ft = m(De, ze);
            return yt(ft) ? ft : void 0;
        }
        function q(De, ze) {
            if (jt(De)) return !1;
            var ft = typeof De;
            return ft == "number" || ft == "symbol" || ft == "boolean" || De == null || Yt(De) ? !0 : o.test(De) || !a.test(De) || ze != null && De in Object(ze);
        }
        function Q(De) {
            var ze = typeof De;
            return ze == "string" || ze == "number" || ze == "symbol" || ze == "boolean" ? De !== "__proto__" : De === null;
        }
        function me(De) {
            return !!D && D in De;
        }
        var J = lt(function(De) {
            De = mn(De);
            var ze = [];
            return s.test(De) && ze.push(""), De.replace(c, function(ft, nn, Gr, ir) {
                ze.push(Gr ? ir.replace(f, "$1") : nn || ft);
            }), ze;
        });
        function Ce(De) {
            if (typeof De == "string" || Yt(De)) return De;
            var ze = De + "";
            return ze == "0" && 1 / De == -1 / 0 ? "-0" : ze;
        }
        function Ue(De) {
            if (De != null) {
                try {
                    return _.call(De);
                } catch  {}
                try {
                    return De + "";
                } catch  {}
            }
            return "";
        }
        function lt(De, ze) {
            if (typeof De != "function" || ze && typeof ze != "function") throw new TypeError(t);
            var ft = function() {
                var nn = arguments, Gr = ze ? ze.apply(this, nn) : nn[0], ir = ft.cache;
                if (ir.has(Gr)) return ir.get(Gr);
                var dr = De.apply(this, nn);
                return ft.cache = ir.set(Gr, dr), dr;
            };
            return ft.cache = new (lt.Cache || Qe), ft;
        }
        lt.Cache = Qe;
        function Mt(De, ze) {
            return De === ze || De !== De && ze !== ze;
        }
        var jt = Array.isArray;
        function Cn(De) {
            var ze = tn(De) ? P.call(De) : "";
            return ze == n || ze == r;
        }
        function tn(De) {
            var ze = typeof De;
            return !!De && (ze == "object" || ze == "function");
        }
        function Mr(De) {
            return !!De && typeof De == "object";
        }
        function Yt(De) {
            return typeof De == "symbol" || Mr(De) && P.call(De) == i;
        }
        function mn(De) {
            return De == null ? "" : En(De);
        }
        function Tn(De, ze, ft) {
            var nn = De == null ? void 0 : Ct(De, ze);
            return nn === void 0 ? ft : nn;
        }
        return L5 = Tn, L5;
    }
    var Kq = Hq();
    const qq = Qa(Kq), KC = Symbol("DefinedCursors"), E_ = new Set([
        "alias",
        "all-scroll",
        "auto",
        "cell",
        "col-resize",
        "context-menu",
        "copy",
        "crosshair",
        "default",
        "e-resize",
        "ew-resize",
        "grab",
        "grabbing",
        "help",
        "move",
        "ne-resize",
        "nesw-resize",
        "no-drop",
        "none",
        "not-allowed",
        "n-resize",
        "ns-resize",
        "nw-resize",
        "nwse-resize",
        "pointer",
        "progress",
        "row-resize",
        "se-resize",
        "s-resize",
        "sw-resize",
        "text",
        "vertical-text",
        "wait",
        "w-resize",
        "zoom-in",
        "zoom-out"
    ]);
    class yo {
        constructor(e, n){
            this.name = e + "", this.fallback = n;
        }
        getName() {
            return this.name + "";
        }
        addFallbackStyleProperty(e) {
            const { fallback: n } = this;
            return n instanceof yo ? `${e}, ${n.getStyleProperty()}` : e + "";
        }
        getStyleProperty() {
            return this.addFallbackStyleProperty(this.name) + "";
        }
        static getDefinedCursor(e) {
            const n = qC(yo, KC);
            let r = n.get(e);
            if (r instanceof yo) return r;
            if (E_.has(e)) return r = new yo(e), n.set(e, r), r;
        }
        static setDefinedCursor(e, n) {
            return n instanceof yo ? (qC(yo, KC).set(e, n), !0) : !1;
        }
    }
    function qC(t, e) {
        let n = t[e];
        return n instanceof Map || (n = new Map, Object.defineProperty(t, e, {
            value: n
        })), n;
    }
    const Xq = E_.values(), Yq = "image-cursor";
    class hp extends yo {
        constructor(e, n, r, i, a){
            super(i || hp.getUniqueInstanceName(Yq), a), this.url = e, this.x = Number(n) || 0, this.y = Number(r) || 0;
        }
        getStyleProperty() {
            const { url: e, x: n, y: r } = this;
            let i = `url('${e}')`;
            return n >= 0 && r >= 0 && (n > 0 || r > 0) && (i += ` ${n} ${r}`), this.addFallbackStyleProperty(i);
        }
        static getUniqueInstanceName(e) {
            return `${e}-${d_(hp)}`;
        }
    }
    const fn = {
        iconContent: "",
        iconSize: 16,
        viewBox: {
            x: 16,
            y: 16
        },
        mousePoint: {
            x: 8,
            y: 8
        },
        mousePointerGroupString: `
    <path stroke="{{color}}" d="M8 16L8 0"></path>
    <path stroke="{{color}}" d="M16 8L0 8"></path>
  `
    }, Ka = {
        x: 127,
        y: 60
    }, Cu = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
`, wl = `
<rect fill="{{color}}" x="80.19" y="25.03" width="47.14" height="15.85"/>
<rect fill="{{color}}" x="95.84" y="9.38" width="15.85" height="47.14"/>
`, V1 = '<path fill="{{color}}" d="M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z" transform="translate(-1.17 -0.96)"/>', wu = '<path fill="{{color}}" d="M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z" transform="translate(-8.86 -2.25)"/>', N1 = '<path fill="{{color}}" d="M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z" transform="translate(-8.86 -2.25)"/>', D_ = {
        Angle: dn(fn, {
            name: "Angle",
            iconContent: `<path fill="{{color}}" d="M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50
    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23
    10l50 50q10 10 10 23z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        ArrowAnnotate: dn(fn, {
            name: "ArrowAnnotate",
            iconContent: `<g id="arrowAnnotate-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="arrowAnnotate-arrow" d="M23,7 l-15,15 M7,17 l0,6 6,0" stroke-width="2" />
  </g>`,
            viewBox: {
                x: 24,
                y: 24
            }
        }),
        Bidirectional: dn(fn, {
            name: "Bidirectional",
            iconContent: `<g fill="{{color}}" stroke-width="3" stroke="{{color}}">
    <path d="M27.63 3.21L3.12 28.81"></path>
    <path d="M27.63 15.75L15.27 4.43"></path>
    <path d="M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z" ></path>
    <path d="M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z"></path>
    <path d="M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z"></path>
    <path d="M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z"></path>
  </g>`,
            viewBox: {
                x: 48,
                y: 48
            }
        }),
        CobbAngle: dn(fn, {
            name: "CobbAngle",
            iconContent: `<g stroke="{{color}}" stroke-width="3">
    <path d="M28.59 2.34L3.82 12.32"></path>
    <path d="M28.59 29.66L3.82 19.68"></path>
    <path stroke-dasharray="2" fill-opacity="0" d="M12.37
      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15
      9.33C13.11 9.24 13.02 9 12.88 8.63">
    </path>
  </g>`,
            viewBox: {
                x: 32,
                y: 32
            }
        }),
        CircleROI: dn(fn, {
            name: "CircleROI",
            iconContent: '<circle stroke="{{color}}" fill="none" stroke-width="3" cx="16" cy="16" r="14" />',
            viewBox: {
                x: 32,
                y: 32
            }
        }),
        EllipticalROI: dn(fn, {
            name: "EllipticalROI",
            iconContent: `<path stroke="{{color}}" fill="none" stroke-width="3" d="M30.74 15.76C30.74 20.99 24.14 25.23 16
    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14
    6.3 30.74 10.54 30.74 15.76Z" />`,
            viewBox: {
                x: 32,
                y: 32
            }
        }),
        FreehandROI: dn(fn, {
            name: "FreehandROI",
            iconContent: `<g fill="{{color}}" stroke="{{color}}" stroke-width="2">
    <ellipse ry="1" rx="1" id="svg_3" cy="4.240343" cx="14.306499"/>
    <line id="svg_4" y2="3.58462" x2="12.242186" y1="3.997482" x1="13.432202"/>
    <line id="svg_5" y2="3.268901" x2="10.857882" y1="3.608906" x1="12.387902"/>
    <line id="svg_6" y2="3.147471" x2="9.740724" y1="3.293187" x1="10.955026"/>
    <line id="svg_7" y2="3.147471" x2="8.089274" y1="3.196043" x1="9.983585"/>
    <line id="svg_8" y2="3.268901" x2="6.874972" y1="3.123185" x1="8.307848"/>
    <line id="svg_9" y2="3.657478" x2="5.587812" y1="3.220329" x1="7.020688"/>
    <line id="svg_10" y2="4.046054" x2="4.737801" y1="3.560334" x1="5.854959"/>
    <line id="svg_11" y2="4.337487" x2="4.300652" y1="3.997482" x1="4.834945"/>
    <line id="svg_12" y2="4.726063" x2="3.88779" y1="4.191771" x1="4.470655"/>
    <line id="svg_15" y2="5.3575" x2="3.377783" y1="4.604633" x1="3.960648"/>
    <line id="svg_16" y2="6.183226" x2="2.916348" y1="5.138926" x1="3.547785"/>
    <line id="svg_17" y2="6.960379" x2="2.770632" y1="5.867507" x1="3.037779"/>
    <line id="svg_18" y2="7.713246" x2="2.673488" y1="6.741804" x1="2.819204"/>
    <line id="svg_19" y2="8.684687" x2="2.697774" y1="7.616102" x1="2.673488"/>
    <line id="svg_20" y2="9.753273" x2="2.892062" y1="8.611829" x1="2.697774"/>
    <line id="svg_21" y2="10.724714" x2="3.134923" y1="9.534698" x1="2.84349"/>
    <line id="svg_23" y2="11.647583" x2="3.596357" y1="10.578998" x1="3.086351"/>
    <line id="svg_25" y2="12.521881" x2="4.276366" y1="11.501867" x1="3.499213"/>
    <line id="svg_26" y2="13.930471" x2="5.830673" y1="12.376165" x1="4.13065"/>
    <line id="svg_28" y2="14.707624" x2="7.263549" y1="13.881899" x1="5.733528"/>
    <line id="svg_29" y2="15.339061" x2="8.963571" y1="14.61048" x1="7.06926"/>
    <line id="svg_30" y2="15.581921" x2="10.882168" y1="15.314775" x1="8.817855"/>
    <line id="svg_31" y2="15.460491" x2="12.023612" y1="15.581921" x1="10.785024"/>
    <line id="svg_33" y2="15.120487" x2="13.092197" y1="15.484777" x1="11.877895"/>
    <line id="svg_34" y2="14.586194" x2="13.86935" y1="15.217631" x1="12.897909"/>
    <line id="svg_35" y2="13.833327" x2="14.597931" y1="14.756196" x1="13.699348"/>
    <line id="svg_37" y2="12.716169" x2="15.180796" y1="13.881899" x1="14.549359"/>
    <line id="svg_39" y2="11.429009" x2="15.520801" y1="12.813313" x1="15.15651"/>
    <ellipse ry="1" rx="1" id="svg_40" cy="10.967574" cx="15.520801"/>
  </g>`,
            viewBox: {
                x: 18,
                y: 18
            }
        }),
        FreehandROISculptor: dn(fn, {
            name: "FreehandROISculptor",
            iconContent: `<g id="icon-freehand-sculpt" fill="none" stroke-width="1.5" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <line id="svg_1" y2="2.559367" x2="10.184807" y1="4.467781" x1="8.81711"/>
    <line id="svg_4" y2="1.493836" x2="11.727442" y1="2.766112" x1="10.089386"/>
    <line id="svg_7" y2="1.080346" x2="13.047428" y1="1.748291" x1="11.345759"/>
    <line id="svg_8" y2="1.000829" x2="14.351511" y1="1.112153" x1="12.77707"/>
    <line id="svg_9" y2="1.350705" x2="15.242104" y1="0.905408" x1="13.969828"/>
    <line id="svg_10" y2="2.098167" x2="15.862339" y1="1.14396" x1="14.955842"/>
    <line id="svg_11" y2="3.195505" x2="16.41896" y1="1.939133" x1="15.766918"/>
    <line id="svg_12" y2="4.292843" x2="16.530284" y1="2.925147" x1="16.387153"/>
    <line id="svg_16" y2="5.644637" x2="16.196311" y1="3.831643" x1="16.593898"/>
    <line id="svg_18" y2="7.266789" x2="15.623787" y1="5.19934" x1="16.275829"/>
    <line id="svg_19" y2="10.813258" x2="14.526449" y1="6.726071" x1="15.766918"/>
    <line id="svg_20" y2="5.056209" x2="8.085552" y1="4.181519" x1="8.976145"/>
    <line id="svg_23" y2="5.326568" x2="7.481221" y1="4.78585" x1="8.403621"/>
    <line id="svg_24" y2="5.565119" x2="6.749662" y1="5.294761" x1="7.624352"/>
    <line id="svg_25" y2="5.994512" x2="5.429675" y1="5.533312" x1="6.956407"/>
    <line id="svg_27" y2="6.551133" x2="4.284627" y1="5.962706" x1="5.572807"/>
    <line id="svg_28" y2="7.584858" x2="3.044158" y1="6.392099" x1="4.427758"/>
    <line id="svg_29" y2="8.84123" x2="2.185372" y1="7.489437" x1="3.219096"/>
    <line id="svg_31" y2="10.606513" x2="1.644654" y1="8.602678" x1="2.280792"/>
    <line id="svg_32" y2="13.214679" x2="1.48562" y1="10.352058" x1="1.724171"/>
    <line id="svg_33" y2="14.375631" x2="1.676461" y1="12.992031" x1="1.453813"/>
    <line id="svg_34" y2="15.298031" x2="2.264889" y1="14.152983" x1="1.517427"/>
    <line id="svg_35" y2="16.172721" x2="3.521261" y1="14.948155" x1="1.915013"/>
    <line id="svg_36" y2="16.824762" x2="5.207027" y1="15.997783" x1="3.28271"/>
    <line id="svg_38" y2="17.063314" x2="7.035924" y1="16.745245" x1="4.968475"/>
    <line id="svg_39" y2="16.888376" x2="9.278311" y1="17.047411" x1="6.733758"/>
    <line id="svg_40" y2="16.284045" x2="10.661911" y1="16.983797" x1="8.992048"/>
    <line id="svg_41" y2="15.313934" x2="11.647925" y1="16.395369" x1="10.455166"/>
    <line id="svg_44" y2="13.898527" x2="12.82478" y1="15.425259" x1="11.504794"/>
    <line id="svg_45" y2="12.037824" x2="14.144766" y1="14.312017" x1="12.522614"/>
    <line id="svg_47" y2="10.59061" x2="14.605966" y1="12.228665" x1="13.953925"/>
    <ellipse ry="1" rx="1" id="svg_48" cy="3.982726" cx="13.460918"/>
  </g>`,
            viewBox: {
                x: 18,
                y: 18
            }
        }),
        Length: dn(fn, {
            name: "Length",
            iconContent: `<g id="length-group" fill="none" stroke-width="1" stroke="{{color}}" stroke-linecap="round" stroke-linejoin="round">
    <path id="length-dashes" d="m22.5,6 -16.5,16.5" stroke-width="3" stroke-dasharray="0.6666,5" />
  </g>`,
            viewBox: {
                x: 24,
                y: 24
            }
        }),
        Height: dn(fn, {
            name: "Height",
            iconContent: '<path d="m 6 22 l 8.5 0 v -16 h 8" stroke-width="3" fill="none" stroke="{{color}}" />',
            viewBox: {
                x: 24,
                y: 24
            }
        }),
        Probe: dn(fn, {
            name: "Probe",
            iconContent: `<path fill="{{color}}" d="M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75
    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73
    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5
    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5
    385.5-103 385.5 103 279.5 279.5 103 385.5z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        RectangleROI: dn(fn, {
            name: "RectangleROI",
            iconContent: `<path fill="{{color}}" d="M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47
    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0
    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119
    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        Label: dn(fn, {
            name: "Label",
            iconContent: `<path fill="{{color}}" d="M789 559l-170 450q33 0 136.5 2t160.5 2q19 0
    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29
    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15
    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5
    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0
    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11
    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0
    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58
    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        Crosshairs: dn(fn, {
            name: "Crosshairs",
            iconContent: `<path fill="{{color}}" d="M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26
    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45
    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26
    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5
    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32
    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5
    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26
    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26
    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161
    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161
    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        Eraser: dn(fn, {
            name: "Eraser",
            iconContent: `<path transform="translate(0,1792) scale(1,-1)" fill="{{color}}" d="M960 1408l336-384h-768l-336 384h768zm1013-1077q15
    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38
    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38
    0 69.5 20.5t47.5 54.5z" />`,
            viewBox: {
                x: 2048,
                y: 1792
            }
        }),
        Magnify: dn(fn, {
            name: "Magnify",
            iconContent: `<path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />`,
            viewBox: {
                x: 512,
                y: 512
            }
        }),
        Pan: dn(fn, {
            name: "Pan",
            iconContent: `<path fill="{{color}}" d="M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17
    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355
    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59
    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12
    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144
    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19
    45v448q0 42-39 59-13 5-25 5-26 0-45-19z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        Rotate: dn(fn, {
            name: "Rotate",
            iconContent: `<path fill="{{color}}" d="M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39
    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5
    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0
    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109
    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298
    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14
    39 17 39 59z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        StackScroll: dn(fn, {
            name: "StackScroll",
            iconContent: `<path fill="{{color}}" d="M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0
    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547
    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547
    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z" />`,
            viewBox: {
                x: 24,
                y: 28
            }
        }),
        WindowLevelRegion: dn(fn, {
            name: "WindowLevelRegion",
            iconContent: `<path fill="{{color}}" d="M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119
    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5
    84.5t84.5 203.5z" />`,
            viewBox: {
                x: 1792,
                y: 1792
            }
        }),
        WindowLevel: dn(fn, {
            name: "WindowLevel",
            iconContent: `
    <path fill="{{color}}" d="M14.5,3.5 a1 1 0 0 1 -11,11 Z" stroke="none" opacity="0.8" />
    <circle cx="9" cy="9" r="8" fill="none" stroke-width="2" stroke="{{color}}" />`,
            viewBox: {
                x: 18,
                y: 18
            }
        }),
        Zoom: dn(fn, {
            name: "Zoom",
            iconContent: `
  <path fill="{{color}}" d="M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395
    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5
    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17
    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208
    32s176 78.7 176 176-78.7 176-176 176z" />
  <path fill="{{color}}" transform="scale(0.22,0.22) translate(1400,0)" d="M1216
    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19
    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26
    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z" />`,
            viewBox: {
                x: 640,
                y: 512
            }
        }),
        SegmentationFreeHandEraseInside: dn(fn, {
            name: "SegmentationFreeHandEraseInside",
            iconContent: `${V1} ${Cu}`,
            viewBox: Ka
        }),
        SegmentationFreeHandFillInside: dn(fn, {
            name: "SegmentationFreeHandFillInside",
            iconContent: `${V1} ${wl}`,
            viewBox: Ka
        }),
        SegmentationFreeHandEraseOutside: dn(fn, {
            name: "SegmentationFreeHandEraseOutside",
            iconContent: `${V1} ${Cu}`,
            viewBox: Ka
        }),
        SegmentationFreeHandFillOutside: dn(fn, {
            name: "SegmentationFreeHandFillOutside",
            iconContent: `${V1} ${wl}`,
            viewBox: Ka
        }),
        SegmentationRectangleEraseInside: dn(fn, {
            name: "SegmentationRectangleEraseInside",
            iconContent: `${wu} ${Cu}`,
            viewBox: Ka
        }),
        RectangleScissor: dn(fn, {
            name: "RectangleScissor",
            iconContent: `${wu} ${wl}`,
            viewBox: Ka
        }),
        "RectangleScissor.FILL_INSIDE": dn(fn, {
            name: "RectangleScissor.FILL_INSIDE",
            iconContent: `${wu} ${wl}`,
            viewBox: Ka
        }),
        "RectangleScissor.FILL_OUTSIDE": dn(fn, {
            name: "RectangleScissor.FILL_OUTSIDE",
            iconContent: `${wu} ${wl}`,
            viewBox: Ka
        }),
        "RectangleScissor.ERASE_OUTSIDE": dn(fn, {
            name: "RectangleScissor.ERASE_OUTSIDE",
            iconContent: `${wu} ${Cu}`,
            viewBox: Ka
        }),
        "RectangleScissor.ERASE_INSIDE": dn(fn, {
            name: "RectangleScissor.ERASE_INSIDE",
            iconContent: `${wu} ${Cu}`,
            viewBox: Ka
        }),
        CircleScissor: dn(fn, {
            name: "CircleScissor",
            iconContent: `${N1} ${wl}`,
            viewBox: Ka
        }),
        "CircleScissor.FILL_INSIDE": dn(fn, {
            name: "CircleScissor.FILL_INSIDE",
            iconContent: `${N1} ${wl}`,
            viewBox: Ka
        }),
        "CircleScissor.ERASE_OUTSIDE": dn(fn, {
            name: "CircleScissor.ERASE_OUTSIDE",
            iconContent: `${N1} ${Cu}`,
            viewBox: Ka
        }),
        "CircleScissor.FILL_OUTSIDE": dn(fn, {
            name: "CircleScissor.FILL_OUTSIDE",
            iconContent: `${N1} ${wl}`,
            viewBox: Ka
        })
    };
    function dn(t, e) {
        return Object.assign(Object.create(t), {
            ...e,
            name: e.name || t.name
        });
    }
    function Zq(t) {
        return D_[t];
    }
    const Jq = Object.keys(D_);
    class Qq {
        constructor(){
            const e = {
                color: "rgb(255, 255, 0)",
                colorHighlighted: "rgb(0, 255, 0)",
                colorSelected: "rgb(0, 220, 0)",
                colorLocked: "rgb(209, 193, 90)",
                lineWidth: "1",
                lineDash: "",
                shadow: !0,
                textBoxVisibility: !0,
                textBoxFontFamily: "Helvetica Neue, Helvetica, Arial, sans-serif",
                textBoxFontSize: "14px",
                textBoxColor: "rgb(255, 255, 0)",
                textBoxColorHighlighted: "rgb(0, 255, 0)",
                textBoxColorSelected: "rgb(0, 255, 0)",
                textBoxColorLocked: "rgb(209, 193, 90)",
                textBoxBackground: "",
                textBoxLinkLineWidth: "1",
                textBoxLinkLineDash: "2,3",
                textBoxShadow: !0,
                markerSize: "10",
                angleArcLineDash: ""
            };
            this._initializeConfig(e);
        }
        getAnnotationToolStyles(e) {
            return this.config.annotations && this.config.annotations[e];
        }
        getViewportToolStyles(e) {
            return this.config.viewports && this.config.viewports[e];
        }
        getToolGroupToolStyles(e) {
            return this.config.toolGroups && this.config.toolGroups[e];
        }
        getDefaultToolStyles() {
            return this.config.default;
        }
        setAnnotationStyles(e, n) {
            let r = this.config.annotations;
            r || (this.config = {
                ...this.config,
                annotations: {}
            }, r = this.config.annotations), r[e] = n;
        }
        setViewportToolStyles(e, n) {
            let r = this.config.viewports;
            r || (this.config = {
                ...this.config,
                viewports: {}
            }, r = this.config.viewports), r[e] = n;
        }
        setToolGroupToolStyles(e, n) {
            let r = this.config.toolGroups;
            r || (this.config = {
                ...this.config,
                toolGroups: {}
            }, r = this.config.toolGroups), r[e] = n;
        }
        setDefaultToolStyles(e) {
            this.config.default = e;
        }
        getStyleProperty(e, n) {
            const { annotationUID: r, viewportId: i, toolGroupId: a, toolName: o } = n;
            return this._getToolStyle(e, r, i, a, o);
        }
        _getToolStyle(e, n, r, i, a) {
            if (n) {
                const s = this.getAnnotationToolStyles(n);
                if (s && s[e] !== void 0) return s[e];
            }
            if (r) {
                const s = this.getViewportToolStyles(r);
                if (s) {
                    if (s[a] && s[a][e] !== void 0) return s[a][e];
                    if (s.global && s.global[e] !== void 0) return s.global[e];
                }
            }
            if (i) {
                const s = this.getToolGroupToolStyles(i);
                if (s) {
                    if (s[a] && s[a][e] !== void 0) return s[a][e];
                    if (s.global && s.global[e] !== void 0) return s.global[e];
                }
            }
            const o = this.getDefaultToolStyles();
            if (o[a] && o[a][e] !== void 0) return o[a][e];
            if (o.global && o.global[e] !== void 0) return o.global[e];
        }
        _initializeConfig(e) {
            const n = {};
            for(const r in e)n[r] = e[r];
            this.config = {
                default: {
                    global: n
                }
            };
        }
    }
    const eX = new Qq;
    function tX(t, e, n) {
        const r = [
            `${t}`
        ];
        return e && r.push(`${r[0]}${e}`), n && r.push(`${r[r.length - 1]}${n}`), r;
    }
    function __(t, e, n, r) {
        const i = tX(t, n, r);
        for(let a = i.length - 1; a >= 0; --a){
            const o = eX.getStyleProperty(i[a], e);
            if (o !== void 0) return o;
        }
    }
    const nX = "color", rX = Ol.Highlighted, iX = er.Active;
    class yh extends hp {
        constructor(e, n, r, i, a){
            super(e, n, r, i, a);
        }
        static getDefinedCursor(e, n = !1, r) {
            r || (r = __(nX, {}, rX, iX));
            const i = aX(e, n, r);
            let a = super.getDefinedCursor(i);
            if (!a) {
                const o = Zq(e);
                o && (a = oX(o, i, n, r, super.getDefinedCursor("default")), super.setDefinedCursor(i, a));
            }
            return a;
        }
    }
    function R_(t, e) {
        const n = Object(e), r = Object.prototype.hasOwnProperty.bind(n);
        return (t + "").replace(/\{\{(\w+)\}\}/g, (i, a)=>r(a) ? n[a] + "" : "");
    }
    function aX(t, e, n) {
        return `${e ? "pointer" : "cursor"}:${t}/${n}`;
    }
    function oX(t, e, n, r, i) {
        const { x: a, y: o } = t.mousePoint;
        return new yh(sX(t, n, {
            color: r
        }), a, o, e, i);
    }
    function sX(t, e, n) {
        const r = cX(t, e, n);
        return `${URL.createObjectURL(r)}#${t.name || "unknown"}-${e ? "pointer" : "cursor"}`;
    }
    function cX(t, e, n) {
        const r = (e ? uX : lX)(t, n);
        return new Blob([
            r
        ], {
            type: "image/svg+xml"
        });
    }
    function lX(t, e) {
        const { iconContent: n, iconSize: r, viewBox: i } = t, a = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${r}" height="${r}" viewBox="0 0
      ${i.x} ${i.y}">
      ${n}
    </svg>`;
        return R_(a, e);
    }
    function uX(t, e) {
        const { iconContent: n, iconSize: r, viewBox: i, mousePointerGroupString: a } = t, o = r / Math.max(i.x, i.y, 1), s = 16 + r, c = `
    <svg data-icon="cursor" role="img" xmlns="http://www.w3.org/2000/svg"
      width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
      <g>${a}</g>
      <g transform="translate(16, 16) scale(${o})">${n}</g>
    </svg>`;
        return R_(c, e);
    }
    const XC = Symbol("ElementCursorsMap");
    function fX(t, e) {
        Vd(t)[0] = e, W4(t, e);
    }
    function W4(t, e) {
        const n = Vd(t);
        n[1] = n[0], n[0] = e, t.style.cursor = (e instanceof yo ? e : yo.getDefinedCursor("auto")).getStyleProperty();
    }
    function fr(t) {
        W4(t, Vd(t)[1]);
    }
    function Mn(t) {
        W4(t, yo.getDefinedCursor("none"));
    }
    function Vd(t) {
        let e = Vd[XC];
        e instanceof WeakMap || (e = new WeakMap, Object.defineProperty(Vd, XC, {
            value: e
        }));
        let n = e.get(t);
        return n || (n = [
            null,
            null
        ], e.set(t, n)), n;
    }
    [
        ...Jq,
        ...Xq
    ];
    function $4(t) {
        return nt.toolGroups.find((e)=>e.id === t);
    }
    const { Active: Xf, Passive: P5, Enabled: V5, Disabled: N5 } = er, dX = [
        {
            mouseButton: zl.Primary
        }
    ];
    class z4 {
        constructor(e){
            this.viewportsInfo = [], this.toolOptions = {}, this.currentActivePrimaryToolName = null, this.prevActivePrimaryToolName = null, this.restoreToolOptions = {}, this._toolInstances = {}, this.id = e;
        }
        getViewportIds() {
            return this.viewportsInfo.map(({ viewportId: e })=>e);
        }
        getViewportsInfo() {
            return this.viewportsInfo.slice();
        }
        getToolInstance(e) {
            const n = this._toolInstances[e];
            if (!n) {
                console.warn(`'${e}' is not registered with this toolGroup (${this.id}).`);
                return;
            }
            return n;
        }
        getToolInstances() {
            return this._toolInstances;
        }
        hasTool(e) {
            return !!this._toolInstances[e];
        }
        addTool(e, n = {}) {
            const r = nt.tools[e], i = typeof e < "u" && e !== "", a = this.toolOptions[e];
            if (!i) {
                console.warn("Tool with configuration did not produce a toolName: ", n);
                return;
            }
            if (!r) {
                console.warn(`'${e}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);
                return;
            }
            if (a) {
                console.warn(`'${e}' is already registered for ToolGroup ${this.id}.`);
                return;
            }
            const { toolClass: o } = r, s = {
                name: e,
                toolGroupId: this.id,
                configuration: n
            }, c = new o(s);
            this._toolInstances[e] = c;
        }
        addToolInstance(e, n, r = {}) {
            let i = nt.tools[e]?.toolClass;
            if (!i) {
                const a = nt.tools[n].toolClass;
                class o extends a {
                }
                o.toolName = e, i = o, nt.tools[e] = {
                    toolClass: o
                };
            }
            this.addTool(i.toolName, r);
        }
        addViewport(e, n) {
            if (typeof e != "string") throw new Error("viewportId must be defined and be a string");
            const r = this._findRenderingEngine(e, n);
            this.viewportsInfo.some(({ viewportId: o })=>o === e) || this.viewportsInfo.push({
                viewportId: e,
                renderingEngineId: r
            });
            const i = this.getActivePrimaryMouseButtonTool();
            this.setViewportsCursorByToolName(i);
            const a = {
                toolGroupId: this.id,
                viewportId: e,
                renderingEngineId: r
            };
            We(Ke, z.TOOLGROUP_VIEWPORT_ADDED, a);
        }
        removeViewports(e, n) {
            const r = [];
            if (this.viewportsInfo.forEach((a, o)=>{
                let s = !1;
                a.renderingEngineId === e && (s = !0, n && a.viewportId !== n && (s = !1)), s && r.push(o);
            }), r.length) for(let a = r.length - 1; a >= 0; a--)this.viewportsInfo.splice(r[a], 1);
            const i = {
                toolGroupId: this.id,
                viewportId: n,
                renderingEngineId: e
            };
            We(Ke, z.TOOLGROUP_VIEWPORT_REMOVED, i);
        }
        setActiveStrategy(e, n) {
            const r = this._toolInstances[e];
            if (r === void 0) {
                console.warn(`Tool ${e} not added to toolGroup, can't set tool configuration.`);
                return;
            }
            r.setActiveStrategy(n);
        }
        setToolMode(e, n, r = {}) {
            if (!e) {
                console.warn("setToolMode: toolName must be defined");
                return;
            }
            if (n === er.Active) {
                this.setToolActive(e, r || this.restoreToolOptions[e]);
                return;
            }
            if (n === er.Passive) {
                this.setToolPassive(e);
                return;
            }
            if (n === er.Enabled) {
                this.setToolEnabled(e);
                return;
            }
            if (n === er.Disabled) {
                this.setToolDisabled(e);
                return;
            }
            console.warn("setToolMode: mode must be defined");
        }
        setToolActive(e, n = {}) {
            const r = this._toolInstances[e];
            if (r === void 0) {
                console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
                return;
            }
            if (!r) {
                console.warn(`'${e}' instance ${r} is not registered with this toolGroup, can't set tool mode.`);
                return;
            }
            const i = this.toolOptions[e] ? this.toolOptions[e].bindings : [], a = n.bindings ? n.bindings : [], s = {
                bindings: [
                    ...i,
                    ...a
                ].reduce((l, f)=>{
                    const u = f.numTouchPoints !== void 0, g = f.mouseButton !== void 0;
                    return !l.some((h)=>A5(h, f)) && (u || g) && l.push(f), l;
                }, []),
                mode: Xf
            };
            if (this.toolOptions[e] = s, this._toolInstances[e].mode = Xf, this._hasMousePrimaryButtonBinding(n)) this.setViewportsCursorByToolName(e);
            else if (!this.getActivePrimaryMouseButtonTool()) {
                const f = yo.getDefinedCursor("default");
                this._setCursorForViewports(f);
            }
            this._hasMousePrimaryButtonBinding(n) && (this.prevActivePrimaryToolName === null ? this.prevActivePrimaryToolName = e : this.prevActivePrimaryToolName = this.currentActivePrimaryToolName, this.currentActivePrimaryToolName = e), typeof r.onSetToolActive == "function" && r.onSetToolActive(), this._renderViewports();
            const c = {
                toolGroupId: this.id,
                toolName: e,
                toolBindingsOptions: n
            };
            We(Ke, z.TOOL_ACTIVATED, c), this._triggerToolModeChangedEvent(e, Xf, n);
        }
        setToolPassive(e, n) {
            const r = this._toolInstances[e];
            if (r === void 0) {
                console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
                return;
            }
            const i = this.getToolOptions(e), a = Object.assign({
                bindings: i ? i.bindings : []
            }, i, {
                mode: P5
            }), o = Array.isArray(n?.removeAllBindings) ? n.removeAllBindings : this.getDefaultPrimaryBindings();
            a.bindings = a.bindings.filter((c)=>n?.removeAllBindings !== !0 && !o.some((l)=>A5(c, l)));
            let s = P5;
            a.bindings.length !== 0 && (s = Xf, a.mode = s), this.toolOptions[e] = a, r.mode = s, typeof r.onSetToolPassive == "function" && r.onSetToolPassive(), this._renderViewports(), this._triggerToolModeChangedEvent(e, P5);
        }
        setToolEnabled(e) {
            const n = this._toolInstances[e];
            if (n === void 0) {
                console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
                return;
            }
            const r = {
                bindings: [],
                mode: V5
            };
            this.toolOptions[e] = r, n.mode = V5, typeof n.onSetToolEnabled == "function" && n.onSetToolEnabled(), this._renderViewports(), this._triggerToolModeChangedEvent(e, V5);
        }
        setToolDisabled(e) {
            const n = this._toolInstances[e];
            if (n === void 0) {
                console.warn(`Tool ${e} not added to toolGroup, can't set tool mode.`);
                return;
            }
            const r = {
                bindings: [],
                mode: N5
            };
            this.restoreToolOptions[e] = this.toolOptions[e], this.toolOptions[e] = r, n.mode = N5, typeof n.onSetToolDisabled == "function" && n.onSetToolDisabled(), this._renderViewports(), this._triggerToolModeChangedEvent(e, N5);
        }
        getToolOptions(e) {
            const n = this.toolOptions[e];
            if (n !== void 0) return n;
        }
        getActivePrimaryMouseButtonTool() {
            return Object.keys(this.toolOptions).find((e)=>{
                const n = this.toolOptions[e];
                return n.mode === Xf && this._hasMousePrimaryButtonBinding(n);
            });
        }
        setViewportsCursorByToolName(e, n) {
            const r = this._getCursor(e, n);
            this._setCursorForViewports(r);
        }
        _getCursor(e, n) {
            let r, i;
            return n && (r = `${e}.${n}`, i = yh.getDefinedCursor(r, !0), i) || (r = `${e}`, i = yh.getDefinedCursor(r, !0), i) || (r = e, i = yh.getDefinedCursor(r, !0), i) ? i : yo.getDefinedCursor("default");
        }
        _setCursorForViewports(e) {
            sr.getRuntimeSettings().get("useCursors") && this.viewportsInfo.forEach(({ renderingEngineId: r, viewportId: i })=>{
                const a = gf(i, r);
                if (!a) return;
                const { viewport: o } = a;
                fX(o.element, e);
            });
        }
        setToolConfiguration(e, n, r) {
            const i = this._toolInstances[e];
            if (i === void 0) return console.warn(`Tool ${e} not present, can't set tool configuration.`), !1;
            let a;
            return r ? a = n : a = Object.assign(i.configuration, n), i.configuration = a, typeof i.onSetToolConfiguration == "function" && i.onSetToolConfiguration(), this._renderViewports(), !0;
        }
        getDefaultMousePrimary() {
            return zl.Primary;
        }
        getDefaultPrimaryBindings() {
            return dX;
        }
        getToolConfiguration(e, n) {
            if (this._toolInstances[e] === void 0) {
                console.warn(`Tool ${e} not present, can't set tool configuration.`);
                return;
            }
            const r = qq(this._toolInstances[e].configuration, n) || this._toolInstances[e].configuration;
            return ms(r);
        }
        getPrevActivePrimaryToolName() {
            return this.prevActivePrimaryToolName;
        }
        setActivePrimaryTool(e) {
            const n = this.getCurrentActivePrimaryToolName();
            this.setToolDisabled(n), this.setToolActive(e, {
                bindings: [
                    {
                        mouseButton: zl.Primary
                    }
                ]
            });
        }
        getCurrentActivePrimaryToolName() {
            return this.currentActivePrimaryToolName;
        }
        clone(e, n = null) {
            let r = $4(e);
            return r ? (console.debug(`ToolGroup ${e} already exists`), r) : (r = new z4(e), nt.toolGroups.push(r), n = n ?? (()=>!0), Object.keys(this._toolInstances).filter(n).forEach((i)=>{
                const a = this._toolInstances[i], o = this.toolOptions[i], s = a.mode;
                r.addTool(i), r.setToolMode(i, s, {
                    bindings: o.bindings ?? []
                });
            }), r);
        }
        _hasMousePrimaryButtonBinding(e) {
            const n = this.getDefaultPrimaryBindings();
            return e?.bindings?.some((r)=>n.some((i)=>A5(r, i)));
        }
        _renderViewports() {
            this.viewportsInfo.forEach(({ renderingEngineId: e, viewportId: n })=>{
                ws(e).renderViewport(n);
            });
        }
        _triggerToolModeChangedEvent(e, n, r) {
            const i = {
                toolGroupId: this.id,
                toolName: e,
                mode: n,
                toolBindingsOptions: r
            };
            We(Ke, z.TOOL_MODE_CHANGED, i);
        }
        _findRenderingEngine(e, n) {
            const r = Es();
            if (r?.length === 0) throw new Error("No rendering engines found.");
            if (n) return n;
            const i = r.filter((a)=>a.getViewport(e));
            if (i.length === 0) {
                if (r.length === 1) return r[0].id;
                throw new Error("No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.");
            }
            if (i.length > 1) throw new Error("Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.");
            return i[0].id;
        }
    }
    function A5(t, e) {
        return t.mouseButton !== e.mouseButton || t.numTouchPoints !== e.numTouchPoints ? !1 : t.modifierKey === e.modifierKey;
    }
    function gX(t) {
        if (nt.toolGroups.some((r)=>r.id === t)) {
            console.warn(`'${t}' already exists.`);
            return;
        }
        const n = new z4(t);
        return nt.toolGroups.push(n), n;
    }
    function YC(t) {
        const e = nt.toolGroups.findIndex((n)=>n.id === t);
        e > -1 && nt.toolGroups.splice(e, 1);
    }
    function ha(t, e) {
        e || (e = Es().find((r)=>r.getViewports().find((i)=>i.id === t))?.id);
        const n = nt.toolGroups.filter((r)=>r.viewportsInfo.some((i)=>i.renderingEngineId === e && (!i.viewportId || i.viewportId === t)));
        if (n.length) {
            if (n.length > 1) throw new Error(`Multiple tool groups found for renderingEngineId: ${e} and viewportId: ${t}. You should only
      have one tool group per viewport in a renderingEngine.`);
            return n[0];
        }
    }
    const hX = [
        er.Active,
        er.Passive,
        er.Enabled
    ];
    function pX(t) {
        return nt.toolGroups.filter(({ toolOptions: e })=>{
            const n = Object.keys(e);
            for(let r = 0; r < n.length; r++)if (t === n[r] && e[t] && hX.includes(e[t].mode)) return !0;
            return !1;
        });
    }
    function O_(t, e) {
        const n = Fe(e), { renderingEngine: r, viewportId: i } = n, a = z.ANNOTATION_ADDED, o = {
            annotation: t,
            viewportId: i,
            renderingEngineId: r.id
        };
        We(Ke, a, o);
    }
    function I_(t) {
        const { toolName: e } = t.metadata, n = pX(e);
        if (!n.length) return;
        const r = [];
        n.forEach((o)=>{
            o.viewportsInfo.forEach((s)=>{
                const { renderingEngineId: c, viewportId: l } = s, { FrameOfReferenceUID: f } = gf(l, c);
                t.metadata.FrameOfReferenceUID === f && r.push(s);
            });
        });
        const i = z.ANNOTATION_ADDED, a = {
            annotation: t
        };
        if (!r.length) {
            We(Ke, i, a);
            return;
        }
        r.forEach(({ renderingEngineId: o, viewportId: s })=>{
            a.viewportId = s, a.renderingEngineId = o, We(Ke, i, a);
        });
    }
    function Kp(t) {
        const e = z.ANNOTATION_REMOVED;
        We(Ke, e, t);
    }
    function yn(t, e, n = Jt.HandlesUpdated) {
        const r = e && Fe(e), { viewportId: i, renderingEngineId: a } = r || {}, o = z.ANNOTATION_MODIFIED;
        We(Ke, o, {
            annotation: t,
            viewportId: i,
            renderingEngineId: a,
            changeType: n
        });
    }
    function Ti(t) {
        M_({
            annotation: t
        });
    }
    function j4(t, e = !1) {
        M_({
            annotation: t,
            contourHoleProcessingEnabled: e
        });
    }
    function M_(t) {
        const e = z.ANNOTATION_COMPLETED;
        We(Ke, e, t);
    }
    const mX = Object.freeze(Object.defineProperty({
        __proto__: null,
        triggerAnnotationAddedForElement: O_,
        triggerAnnotationAddedForFOR: I_,
        triggerAnnotationCompleted: Ti,
        triggerAnnotationModified: yn,
        triggerAnnotationRemoved: Kp,
        triggerContourAnnotationCompleted: j4
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    let b_;
    function cc() {
        return b_;
    }
    function H4(t) {
        b_ = t;
    }
    function ba(t, e) {
        const n = cc(), r = n.getGroupKey(e);
        return n.getAnnotations(r, t);
    }
    function fa(t) {
        return cc().getAnnotation(t);
    }
    function L_() {
        return cc().getAllAnnotations();
    }
    function qp(t) {
        const { annotationUID: e, parentAnnotationUID: n } = t;
        if (!n) return;
        const r = fa(n), i = r.childAnnotationUIDs.indexOf(e);
        r.childAnnotationUIDs.splice(i, 1), t.parentAnnotationUID = void 0;
    }
    function ag(t, e) {
        const { annotationUID: n } = t, { annotationUID: r } = e;
        qp(e), t.childAnnotationUIDs || (t.childAnnotationUIDs = []), !t.childAnnotationUIDs.includes(r) && (t.childAnnotationUIDs.push(r), e.parentAnnotationUID = n);
    }
    function P_(t) {
        return t.parentAnnotationUID ? fa(t.parentAnnotationUID) : void 0;
    }
    function og(t) {
        return t.childAnnotationUIDs?.map((e)=>fa(e)) ?? [];
    }
    function nr(t, e) {
        t.annotationUID || (t.annotationUID = Vn());
        const n = cc();
        if (e instanceof HTMLDivElement) {
            const r = n.getGroupKey(e);
            n.addAnnotation(t, r), O_(t, e);
        } else n.addAnnotation(t, void 0), I_(t);
        return t.annotationUID;
    }
    function vX(t, e) {
        const n = cc(), r = n.getGroupKey(e);
        return n.getNumberOfAnnotations(r, t);
    }
    function Ir(t) {
        if (!t) return;
        const e = cc(), n = e.getAnnotation(t);
        n && (n.childAnnotationUIDs?.forEach((r)=>Ir(r)), e.removeAnnotation(t), Kp({
            annotation: n,
            annotationManagerUID: e.uid
        }));
    }
    function yX() {
        const t = cc(), e = t.removeAllAnnotations();
        for (const n of e)Kp({
            annotation: n,
            annotationManagerUID: t.uid
        });
    }
    function CX(t, e) {
        const n = cc(), r = n.getGroupKey(e), i = n.removeAnnotations(r, t);
        for (const a of i)Kp({
            annotation: a,
            annotationManagerUID: n.uid
        });
    }
    function V_(t) {
        let e = t;
        for(; e;)e.invalidated = !0, e = e.parentAnnotationUID ? fa(e.parentAnnotationUID) : void 0;
    }
    const wX = Object.freeze(Object.defineProperty({
        __proto__: null,
        addAnnotation: nr,
        addChildAnnotation: ag,
        clearParentAnnotation: qp,
        getAllAnnotations: L_,
        getAnnotation: fa,
        getAnnotationManager: cc,
        getAnnotations: ba,
        getChildAnnotations: og,
        getNumberOfAnnotations: vX,
        getParentAnnotation: P_,
        invalidateAnnotation: V_,
        removeAllAnnotations: yX,
        removeAnnotation: Ir,
        removeAnnotations: CX,
        setAnnotationManager: H4
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function N_(t) {
        const e = t.toolName;
        if (!e) throw new Error(`No Tool Found for the ToolClass ${t.name}`);
        nt.tools[e] || (nt.tools[e] = {
            toolClass: t
        });
    }
    function Xp(t) {
        return !!(t && nt.tools[t]);
    }
    function j0(t, e) {
        const n = e || t.currentTarget, { viewport: r } = Fe(n) || {};
        if (!r) return;
        const i = SX(t), a = xX(t), o = TX(n, a), s = r.canvasToWorld(o);
        return {
            page: a,
            client: i,
            canvas: o,
            world: s
        };
    }
    function TX(t, e) {
        const n = t.getBoundingClientRect();
        return [
            e[0] - n.left - window.pageXOffset,
            e[1] - n.top - window.pageYOffset
        ];
    }
    function xX(t) {
        return [
            t.pageX,
            t.pageY
        ];
    }
    function SX(t) {
        return [
            t.clientX,
            t.clientY
        ];
    }
    function A_(t) {
        const e = t.currentTarget, { viewportId: n, renderingEngineId: r } = Fe(e), i = j0(t, e), a = {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        }, o = {
            event: t,
            eventName: z.MOUSE_DOUBLE_CLICK,
            viewportId: n,
            renderingEngineId: r,
            camera: {},
            element: e,
            startPoints: i,
            lastPoints: i,
            currentPoints: i,
            deltaPoints: a
        };
        !We(e, z.MOUSE_DOUBLE_CLICK, o) && (t.stopImmediatePropagation(), t.preventDefault());
    }
    const ZC = z.MOUSE_MOVE;
    function sg(t) {
        const e = t.currentTarget, n = Fe(e);
        if (!n) return;
        const { renderingEngineId: r, viewportId: i } = n, a = j0(t);
        !We(e, ZC, {
            renderingEngineId: r,
            viewportId: i,
            camera: {},
            element: e,
            currentPoints: a,
            eventName: ZC,
            event: t
        }) && (t.stopImmediatePropagation(), t.preventDefault());
    }
    const { MOUSE_DOWN: JC, MOUSE_DOWN_ACTIVATE: EX, MOUSE_CLICK: DX, MOUSE_UP: _X, MOUSE_DRAG: QC } = z, RX = 400, OX = 150, IX = 3, MX = {
        mouseButton: void 0,
        element: null,
        renderingEngineId: void 0,
        viewportId: void 0,
        isClickEvent: !0,
        clickDelay: 200,
        preventClickTimeout: null,
        startPoints: {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        },
        lastPoints: {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        }
    };
    let Pt = {
        mouseButton: void 0,
        renderingEngineId: void 0,
        viewportId: void 0,
        isClickEvent: !0,
        clickDelay: 200,
        element: null,
        preventClickTimeout: null,
        startPoints: {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        },
        lastPoints: {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        }
    };
    const oi = {
        doubleClickTimeout: null,
        mouseDownEvent: null,
        mouseUpEvent: null,
        ignoreDoubleClick: !1
    };
    function k_(t) {
        if (oi.doubleClickTimeout) {
            if (t.buttons === oi.mouseDownEvent.buttons) return;
            oi.mouseDownEvent = t, pp();
            return;
        }
        oi.doubleClickTimeout = setTimeout(pp, t.buttons === 1 ? RX : OX), oi.mouseDownEvent = t, oi.ignoreDoubleClick = !1, Pt.element = t.currentTarget, Pt.mouseButton = t.buttons;
        const e = Fe(Pt.element), { renderingEngineId: n, viewportId: r } = e;
        Pt.renderingEngineId = n, Pt.viewportId = r, Pt.preventClickTimeout = setTimeout(LX, Pt.clickDelay), Pt.element.removeEventListener("mousemove", sg);
        const i = j0(t, Pt.element);
        Pt.startPoints = Ul(i), Pt.lastPoints = Ul(i), document.addEventListener("mouseup", K4), document.addEventListener("mousemove", U_);
    }
    function bX(t) {
        const e = Yp(Pt.startPoints, Pt.startPoints), n = {
            event: t,
            eventName: JC,
            element: Pt.element,
            mouseButton: Pt.mouseButton,
            renderingEngineId: Pt.renderingEngineId,
            viewportId: Pt.viewportId,
            camera: {},
            startPoints: Pt.startPoints,
            lastPoints: Pt.startPoints,
            currentPoints: Pt.startPoints,
            deltaPoints: e
        };
        Pt.lastPoints = Ul(n.lastPoints), We(n.element, JC, n) && We(n.element, EX, n);
    }
    function U_(t) {
        if (!Fe(Pt.element)?.viewport) return;
        const n = j0(t, Pt.element), r = W_(Pt.element, Pt.lastPoints), i = Yp(n, r);
        if (oi.doubleClickTimeout) if (B_(i.canvas)) pp();
        else return;
        const a = {
            event: t,
            eventName: QC,
            mouseButton: Pt.mouseButton,
            renderingEngineId: Pt.renderingEngineId,
            viewportId: Pt.viewportId,
            camera: {},
            element: Pt.element,
            startPoints: Ul(Pt.startPoints),
            lastPoints: Ul(r),
            currentPoints: n,
            deltaPoints: i
        };
        !We(Pt.element, QC, a) && (t.stopImmediatePropagation(), t.preventDefault()), Pt.lastPoints = Ul(n);
    }
    function K4(t) {
        if (clearTimeout(Pt.preventClickTimeout), oi.doubleClickTimeout) oi.mouseUpEvent ? Xv() : (oi.mouseUpEvent = t, Pt.element.addEventListener("mousemove", F_));
        else {
            const e = Pt.isClickEvent ? DX : _X, n = j0(t, Pt.element), r = Yp(n, Pt.lastPoints), i = {
                event: t,
                eventName: e,
                mouseButton: Pt.mouseButton,
                element: Pt.element,
                renderingEngineId: Pt.renderingEngineId,
                viewportId: Pt.viewportId,
                camera: {},
                startPoints: Ul(Pt.startPoints),
                lastPoints: Ul(Pt.lastPoints),
                currentPoints: n,
                deltaPoints: r
            };
            We(i.element, e, i), Xv();
        }
        document.removeEventListener("mousemove", U_);
    }
    function F_(t) {
        const e = j0(t, Pt.element), n = W_(Pt.element, Pt.lastPoints), r = Yp(e, n);
        B_(r.canvas) && (pp(), sg(t));
    }
    function B_(t) {
        return Math.abs(t[0]) + Math.abs(t[1]) > IX;
    }
    function LX() {
        Pt.isClickEvent = !1;
    }
    function pp() {
        oi.ignoreDoubleClick = !0;
        const t = oi.mouseDownEvent, e = oi.mouseUpEvent;
        G_(), bX(t), e && K4(e);
    }
    function G_() {
        oi.doubleClickTimeout && (clearTimeout(oi.doubleClickTimeout), oi.doubleClickTimeout = null), oi.mouseDownEvent = null, oi.mouseUpEvent = null;
    }
    function Xv() {
        document.removeEventListener("mouseup", K4), Pt.element?.removeEventListener("mousemove", F_), Pt.element?.addEventListener("mousemove", sg), G_(), Pt = JSON.parse(JSON.stringify(MX));
    }
    function Ul(t) {
        return JSON.parse(JSON.stringify(t));
    }
    function W_(t, e) {
        const { viewport: n } = Fe(t) || {};
        if (!n) return e;
        const r = n.canvasToWorld(e.canvas);
        return {
            page: e.page,
            client: e.client,
            canvas: e.canvas,
            world: r
        };
    }
    function Yp(t, e) {
        return !t || !e ? {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        } : {
            page: k5(t.page, e.page),
            client: k5(t.client, e.client),
            canvas: k5(t.canvas, e.canvas),
            world: PX(t.world, e.world)
        };
    }
    function k5(t, e) {
        return [
            t[0] - e[0],
            t[1] - e[1]
        ];
    }
    function PX(t, e) {
        return [
            t[0] - e[0],
            t[1] - e[1],
            t[2] - e[2]
        ];
    }
    function VX() {
        return Pt.mouseButton;
    }
    function $_(t) {
        oi.ignoreDoubleClick ? (oi.ignoreDoubleClick = !1, t.stopImmediatePropagation(), t.preventDefault()) : Xv();
    }
    function z_(t) {
        t.removeEventListener("dblclick", A_), t.removeEventListener("mousedown", k_), t.removeEventListener("mousemove", sg), t.removeEventListener("dblclick", $_, {
            capture: !0
        });
    }
    function NX(t) {
        z_(t), t.addEventListener("dblclick", A_), t.addEventListener("mousedown", k_), t.addEventListener("mousemove", sg), t.addEventListener("dblclick", $_, {
            capture: !0
        });
    }
    const j_ = {
        enable: NX,
        disable: z_
    }, AX = 2e3, Ju = {
        mouse: 0,
        touch: 1
    };
    let ew, tw;
    function H_(t, e) {
        const n = Date.now();
        if (t !== ew) {
            if (n - tw <= AX) return e.preventDefault(), e.stopPropagation(), e.stopImmediatePropagation(), !1;
            ew = t;
        }
        tw = n;
    }
    const K_ = H_.bind(null, Ju.mouse), q_ = H_.bind(null, Ju.touch);
    function nw(t, e, n) {
        const r = n ? K_ : q_;
        e.forEach(function(i) {
            t.addEventListener(i, r, {
                passive: !1
            });
        });
    }
    function rw(t, e, n) {
        const r = n ? K_ : q_;
        e.forEach(function(i) {
            t.removeEventListener(i, r);
        });
    }
    const X_ = [
        "mousedown",
        "mouseup",
        "mousemove"
    ], Y_ = [
        "touchstart",
        "touchend"
    ];
    function Z_(t) {
        rw(t, X_, Ju.mouse), rw(t, Y_, Ju.touch);
    }
    function kX(t) {
        Z_(t), nw(t, X_, Ju.mouse), nw(t, Y_, Ju.touch);
    }
    const J_ = {
        enable: kX,
        disable: Z_
    };
    function Zp(t, e) {
        const n = e || t.currentTarget, r = t.type === "touchend" ? t.changedTouches : t.touches;
        return Object.keys(r).map((i)=>{
            const a = BX(r[i]), o = FX(r[i]), s = UX(n, o), { viewport: c } = Fe(n), l = c.canvasToWorld(s);
            return {
                page: o,
                client: a,
                canvas: s,
                world: l,
                touch: {
                    identifier: i,
                    radiusX: r[i].radiusX,
                    radiusY: r[i].radiusY,
                    force: r[i].force,
                    rotationAngle: r[i].rotationAngle
                }
            };
        });
    }
    function UX(t, e) {
        const n = t.getBoundingClientRect();
        return [
            e[0] - n.left - window.pageXOffset,
            e[1] - n.top - window.pageYOffset
        ];
    }
    function FX(t) {
        return [
            t.pageX,
            t.pageY
        ];
    }
    function BX(t) {
        return [
            t.clientX,
            t.clientY
        ];
    }
    function Yv(t, e) {
        const n = mp(t), r = mp(e);
        return {
            page: U5(n.page, r.page),
            client: U5(n.client, r.client),
            canvas: U5(n.canvas, r.canvas),
            world: GX(n.world, r.world)
        };
    }
    function Q_(t, e) {
        const n = mp(t), r = mp(e);
        return {
            page: $u(n.page, r.page),
            client: $u(n.client, r.client),
            canvas: $u(n.canvas, r.canvas),
            world: eR(n.world, r.world)
        };
    }
    function Zv(t, e) {
        const n = aw(t), r = aw(e);
        return {
            page: n.page - r.page,
            client: n.client - r.client,
            canvas: n.canvas - r.canvas,
            world: n.world - r.world
        };
    }
    function qc(t) {
        return JSON.parse(JSON.stringify(t));
    }
    function iw(t) {
        return JSON.parse(JSON.stringify(t));
    }
    function mp(t) {
        return t.reduce((e, n)=>({
                page: [
                    e.page[0] + n.page[0] / t.length,
                    e.page[1] + n.page[1] / t.length
                ],
                client: [
                    e.client[0] + n.client[0] / t.length,
                    e.client[1] + n.client[1] / t.length
                ],
                canvas: [
                    e.canvas[0] + n.canvas[0] / t.length,
                    e.canvas[1] + n.canvas[1] / t.length
                ],
                world: [
                    e.world[0] + n.world[0] / t.length,
                    e.world[1] + n.world[1] / t.length,
                    e.world[2] + n.world[2] / t.length
                ]
            }), {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ]
        });
    }
    function Js(t) {
        return t.reduce((e, n)=>({
                page: [
                    e.page[0] + n.page[0] / t.length,
                    e.page[1] + n.page[1] / t.length
                ],
                client: [
                    e.client[0] + n.client[0] / t.length,
                    e.client[1] + n.client[1] / t.length
                ],
                canvas: [
                    e.canvas[0] + n.canvas[0] / t.length,
                    e.canvas[1] + n.canvas[1] / t.length
                ],
                world: [
                    e.world[0] + n.world[0] / t.length,
                    e.world[1] + n.world[1] / t.length,
                    e.world[2] + n.world[2] / t.length
                ],
                touch: {
                    identifier: null,
                    radiusX: e.touch.radiusX + n.touch.radiusX / t.length,
                    radiusY: e.touch.radiusY + n.touch.radiusY / t.length,
                    force: e.touch.force + n.touch.force / t.length,
                    rotationAngle: e.touch.rotationAngle + n.touch.rotationAngle / t.length
                }
            }), {
            page: [
                0,
                0
            ],
            client: [
                0,
                0
            ],
            canvas: [
                0,
                0
            ],
            world: [
                0,
                0,
                0
            ],
            touch: {
                identifier: null,
                radiusX: 0,
                radiusY: 0,
                force: 0,
                rotationAngle: 0
            }
        });
    }
    function U5(t, e) {
        return [
            t[0] - e[0],
            t[1] - e[1]
        ];
    }
    function GX(t, e) {
        return [
            t[0] - e[0],
            t[1] - e[1],
            t[2] - e[2]
        ];
    }
    function aw(t) {
        const e = [];
        for(let n = 0; n < t.length; n++)for(let r = 0; r < t.length; r++)n < r && e.push({
            page: $u(t[n].page, t[r].page),
            client: $u(t[n].client, t[r].client),
            canvas: $u(t[n].canvas, t[r].canvas),
            world: eR(t[n].world, t[r].world)
        });
        return e.reduce((n, r)=>({
                page: n.page + r.page / e.length,
                client: n.client + r.client / e.length,
                canvas: n.canvas + r.canvas / e.length,
                world: n.world + r.world / e.length
            }), {
            page: 0,
            client: 0,
            canvas: 0,
            world: 0
        });
    }
    function $u(t, e) {
        return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2));
    }
    function eR(t, e) {
        return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2));
    }
    sr.getRuntimeSettings();
    const { TOUCH_START: ow, TOUCH_START_ACTIVATE: WX, TOUCH_PRESS: sw, TOUCH_DRAG: cw, TOUCH_END: lw, TOUCH_TAP: uw, TOUCH_SWIPE: F5 } = z, Nd = {
        page: [
            0,
            0
        ],
        client: [
            0,
            0
        ],
        canvas: [
            0,
            0
        ],
        world: [
            0,
            0,
            0
        ]
    }, vp = {
        page: 0,
        client: 0,
        canvas: 0,
        world: 0
    }, tR = {
        renderingEngineId: void 0,
        viewportId: void 0,
        element: null,
        startPointsList: [
            {
                ...Nd,
                touch: null
            }
        ],
        lastPointsList: [
            {
                ...Nd,
                touch: null
            }
        ],
        isTouchStart: !1,
        startTime: null,
        pressTimeout: null,
        pressDelay: 700,
        pressMaxDistance: 5,
        accumulatedDistance: vp,
        swipeDistanceThreshold: 48,
        swiped: !1,
        swipeToleranceMs: 300
    }, nR = {
        renderingEngineId: void 0,
        viewportId: void 0,
        element: null,
        startPointsList: [
            {
                ...Nd,
                touch: null
            }
        ],
        taps: 0,
        tapTimeout: null,
        tapMaxDistance: 24,
        tapToleranceMs: 300
    };
    let ht = JSON.parse(JSON.stringify(tR)), Ar = JSON.parse(JSON.stringify(nR));
    function jl(t, e, n) {
        return We(t, e, n);
    }
    function rR(t) {
        ht.element = t.currentTarget;
        const e = Fe(ht.element), { renderingEngineId: n, viewportId: r } = e;
        ht.renderingEngineId = n, ht.viewportId = r, !ht.isTouchStart && (clearTimeout(ht.pressTimeout), ht.pressTimeout = setTimeout(()=>$X(t), ht.pressDelay), zX(t), document.addEventListener("touchmove", iR), document.addEventListener("touchend", aR));
    }
    function $X(t) {
        if (ht.accumulatedDistance.canvas > ht.pressMaxDistance) return;
        const n = {
            event: t,
            eventName: sw,
            renderingEngineId: ht.renderingEngineId,
            viewportId: ht.viewportId,
            camera: {},
            element: ht.element,
            startPointsList: qc(ht.startPointsList),
            lastPointsList: qc(ht.lastPointsList),
            startPoints: iw(Js(ht.startPointsList)),
            lastPoints: iw(Js(ht.lastPointsList))
        };
        jl(n.element, sw, n);
    }
    function zX(t) {
        ht.isTouchStart = !0, ht.startTime = new Date;
        const e = Zp(t, ht.element), n = Js(e), r = Nd, i = vp, a = {
            event: t,
            eventName: ow,
            element: ht.element,
            renderingEngineId: ht.renderingEngineId,
            viewportId: ht.viewportId,
            camera: {},
            startPointsList: e,
            lastPointsList: e,
            currentPointsList: e,
            startPoints: n,
            lastPoints: n,
            currentPoints: n,
            deltaPoints: r,
            deltaDistance: i
        };
        ht.startPointsList = qc(a.startPointsList), ht.lastPointsList = qc(a.lastPointsList), jl(a.element, ow, a) && jl(a.element, WX, a);
    }
    function iR(t) {
        const e = Zp(t, ht.element), n = oR(ht.element, ht.lastPointsList), r = e.length === n.length ? Yv(e, n) : Nd, i = e.length === n.length ? Zv(e, n) : vp, a = e.length === n.length ? Q_(e, ht.lastPointsList) : vp;
        ht.accumulatedDistance = {
            page: ht.accumulatedDistance.page + a.page,
            client: ht.accumulatedDistance.client + a.client,
            canvas: ht.accumulatedDistance.canvas + a.canvas,
            world: ht.accumulatedDistance.world + a.world
        };
        const o = {
            event: t,
            eventName: cw,
            renderingEngineId: ht.renderingEngineId,
            viewportId: ht.viewportId,
            camera: {},
            element: ht.element,
            startPoints: Js(ht.startPointsList),
            lastPoints: Js(n),
            currentPoints: Js(e),
            startPointsList: qc(ht.startPointsList),
            lastPointsList: qc(n),
            currentPointsList: e,
            deltaPoints: r,
            deltaDistance: i
        };
        jl(ht.element, cw, o), HX(t, r), ht.lastPointsList = qc(e);
    }
    function aR(t) {
        clearTimeout(ht.pressTimeout);
        const e = Zp(t, ht.element), n = oR(ht.element, ht.lastPointsList), r = e.length === n.length ? Yv(e, n) : Yv(e, e), i = e.length === n.length ? Zv(e, n) : Zv(e, e), a = {
            event: t,
            eventName: lw,
            element: ht.element,
            renderingEngineId: ht.renderingEngineId,
            viewportId: ht.viewportId,
            camera: {},
            startPointsList: qc(ht.startPointsList),
            lastPointsList: qc(n),
            currentPointsList: e,
            startPoints: Js(ht.startPointsList),
            lastPoints: Js(n),
            currentPoints: Js(e),
            deltaPoints: r,
            deltaDistance: i
        };
        jl(a.element, lw, a), jX(t), ht = JSON.parse(JSON.stringify(tR)), document.removeEventListener("touchmove", iR), document.removeEventListener("touchend", aR);
    }
    function jX(t) {
        const e = new Date().getTime(), n = ht.startTime.getTime();
        if (e - n > Ar.tapToleranceMs || (Ar.taps === 0 && (Ar.element = ht.element, Ar.renderingEngineId = ht.renderingEngineId, Ar.viewportId = ht.viewportId, Ar.startPointsList = ht.startPointsList), Ar.taps > 0 && !(Ar.element == ht.element && Ar.renderingEngineId == ht.renderingEngineId && Ar.viewportId == ht.viewportId))) return;
        const r = Zp(t, Ar.element);
        Q_(r, Ar.startPointsList).canvas > Ar.tapMaxDistance || (clearTimeout(Ar.tapTimeout), Ar.taps += 1, Ar.tapTimeout = setTimeout(()=>{
            const a = {
                event: t,
                eventName: uw,
                element: Ar.element,
                renderingEngineId: Ar.renderingEngineId,
                viewportId: Ar.viewportId,
                camera: {},
                currentPointsList: r,
                currentPoints: Js(r),
                taps: Ar.taps
            };
            jl(a.element, uw, a), Ar = JSON.parse(JSON.stringify(nR));
        }, Ar.tapToleranceMs));
    }
    function HX(t, e) {
        const n = new Date().getTime(), r = ht.startTime.getTime();
        if (ht.swiped || n - r > ht.swipeToleranceMs) return;
        const [i, a] = e.canvas, o = {
            event: t,
            eventName: F5,
            renderingEngineId: ht.renderingEngineId,
            viewportId: ht.viewportId,
            camera: {},
            element: ht.element,
            swipe: null
        };
        Math.abs(i) > ht.swipeDistanceThreshold && (o.swipe = i > 0 ? bu.RIGHT : bu.LEFT, jl(o.element, F5, o), ht.swiped = !0), Math.abs(a) > ht.swipeDistanceThreshold && (o.swipe = a > 0 ? bu.DOWN : bu.UP, jl(o.element, F5, o), ht.swiped = !0);
    }
    function oR(t, e) {
        const { viewport: n } = Fe(t);
        return e.map((r)=>{
            const i = n.canvasToWorld(r.canvas);
            return {
                page: r.page,
                client: r.client,
                canvas: r.canvas,
                world: i,
                touch: r.touch
            };
        });
    }
    function sR(t) {
        J_.disable(t), t.removeEventListener("touchstart", rR);
    }
    function KX(t) {
        sR(t), J_.enable(t), t.addEventListener("touchstart", rR, {
            passive: !1
        });
    }
    const cR = {
        enable: KX,
        disable: sR
    }, fw = 10, dw = 40, gw = 800;
    function qX(t) {
        let e = 0, n = 0, r = 0, i = 0;
        return "detail" in t && (n = t.detail), "wheelDelta" in t && (n = -t.wheelDelta / 120), "wheelDeltaY" in t && (n = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), r = e * fw, i = n * fw, "deltaY" in t && (i = t.deltaY), "deltaX" in t && (r = t.deltaX), (r || i) && t.deltaMode && (t.deltaMode === 1 ? (r *= dw, i *= dw) : (r *= gw, i *= gw)), r && !e && (e = r < 1 ? -1 : 1), i && !n && (n = i < 1 ? -1 : 1), {
            spinX: e,
            spinY: n,
            pixelX: r,
            pixelY: i
        };
    }
    function lR(t) {
        const e = t.currentTarget, n = Fe(e), { renderingEngineId: r, viewportId: i } = n;
        if (t.deltaY > -1 && t.deltaY < 1) return;
        t.preventDefault();
        const { spinX: a, spinY: o, pixelX: s, pixelY: c } = qX(t), l = o < 0 ? -1 : 1, f = {
            event: t,
            eventName: z.MOUSE_WHEEL,
            renderingEngineId: r,
            viewportId: i,
            element: e,
            camera: {},
            detail: t,
            wheel: {
                spinX: a,
                spinY: o,
                pixelX: s,
                pixelY: c,
                direction: l
            },
            points: j0(t)
        };
        We(e, z.MOUSE_WHEEL, f);
    }
    function XX(t) {
        uR(t), t.addEventListener("wheel", lR, {
            passive: !1
        });
    }
    function uR(t) {
        t.removeEventListener("wheel", lR);
    }
    const fR = {
        enable: XX,
        disable: uR
    }, YX = {
        renderingEngineId: void 0,
        viewportId: void 0,
        key: void 0,
        keyCode: void 0,
        element: null
    };
    let Kr = {
        renderingEngineId: void 0,
        viewportId: void 0,
        key: void 0,
        keyCode: void 0,
        element: null
    };
    function Jp(t) {
        Kr.element = t.currentTarget;
        const e = Fe(Kr.element), { renderingEngineId: n, viewportId: r } = e;
        Kr.renderingEngineId = n, Kr.viewportId = r, Kr.key = t.key, Kr.keyCode = t.keyCode, t.preventDefault();
        const i = {
            renderingEngineId: Kr.renderingEngineId,
            viewportId: Kr.viewportId,
            element: Kr.element,
            key: Kr.key,
            keyCode: Kr.keyCode
        };
        We(i.element, z.KEY_DOWN, i), document.addEventListener("keyup", dR), document.addEventListener("visibilitychange", q4), Kr.element.removeEventListener("keydown", Jp);
    }
    function q4() {
        document.removeEventListener("visibilitychange", q4), document.visibilityState === "hidden" && gR();
    }
    function dR(t) {
        const e = {
            renderingEngineId: Kr.renderingEngineId,
            viewportId: Kr.viewportId,
            element: Kr.element,
            key: Kr.key,
            keyCode: Kr.keyCode
        };
        document.removeEventListener("keyup", dR), document.removeEventListener("visibilitychange", q4), Kr.element.addEventListener("keydown", Jp), Kr = structuredClone(YX), We(e.element, z.KEY_UP, e);
    }
    function ZX() {
        return Kr.keyCode;
    }
    function gR() {
        Kr.keyCode = void 0;
    }
    function JX(t) {
        hR(t), t.addEventListener("keydown", Jp);
    }
    function hR(t) {
        t.removeEventListener("keydown", Jp);
    }
    const hf = {
        enable: JX,
        disable: hR,
        getModifierKey: ZX
    }, X4 = new Map, QX = (t)=>{
        const e = X4.get(t);
        e && (e.isDirty = !0);
    }, eY = (t)=>{
        const e = X4.get(t);
        return e && !e.isDirty ? e.indices : null;
    }, tY = (t, e)=>{
        X4.set(t, {
            indices: e,
            isDirty: !1
        });
    };
    function Qp(t, e, n) {
        const r = {
            segmentationId: t,
            modifiedSlicesToUse: e,
            segmentIndex: n
        };
        QX(t), We(Ke, z.SEGMENTATION_DATA_MODIFIED, r);
    }
    function e2(t) {
        const e = {
            segmentationId: t
        };
        We(Ke, z.SEGMENTATION_MODIFIED, e);
    }
    function nY(t) {
        const e = {
            segmentationId: t
        };
        We(Ke, z.SEGMENTATION_REMOVED, e);
    }
    function A1(t, e, n) {
        const r = {
            segmentationId: e,
            type: n,
            viewportId: t
        };
        We(Ke, z.SEGMENTATION_REPRESENTATION_MODIFIED, r);
    }
    function hw(t, e, n) {
        const r = {
            viewportId: t,
            segmentationId: e,
            type: n
        };
        We(Ke, z.SEGMENTATION_REPRESENTATION_REMOVED, r);
    }
    const rY = {
        renderOutline: !0,
        outlineWidthAutoGenerated: 3,
        outlineWidth: 1,
        outlineWidthInactive: 1,
        outlineOpacity: 1,
        outlineOpacityInactive: .85,
        outlineDash: void 0,
        outlineDashInactive: void 0,
        outlineDashAutoGenerated: "5,3",
        activeSegmentOutlineWidthDelta: 0,
        renderFill: !0,
        fillAlpha: .5,
        fillAlphaInactive: .3,
        fillAlphaAutoGenerated: .3
    };
    function iY() {
        return rY;
    }
    const aY = {
        renderOutline: !0,
        renderOutlineInactive: !0,
        outlineWidth: 3,
        outlineWidthInactive: 2,
        activeSegmentOutlineWidthDelta: 0,
        renderFill: !0,
        renderFillInactive: !0,
        fillAlpha: .5,
        fillAlphaInactive: .4,
        outlineOpacity: 1,
        outlineOpacityInactive: .85
    };
    function oY() {
        return aY;
    }
    class sY {
        constructor(){
            this.config = {
                global: {},
                segmentations: {},
                viewportsStyle: {}
            };
        }
        setStyle(e, n) {
            const { viewportId: r, segmentationId: i, type: a, segmentIndex: o } = e, s = this.getStyle(e);
            let c;
            if (!r && !i ? c = {
                ...s,
                ...n
            } : c = this.copyActiveToInactiveIfNotProvided({
                ...s,
                ...n
            }, a), !a) throw new Error("Type is required to set a style");
            if (r) {
                this.config.viewportsStyle[r] || (this.config.viewportsStyle[r] = {
                    renderInactiveSegmentations: !1,
                    representations: {}
                });
                const l = this.config.viewportsStyle[r].representations;
                if (i) {
                    l[i] || (l[i] = {}), l[i][a] || (l[i][a] = {});
                    const f = l[i][a];
                    o !== void 0 ? (f.perSegment || (f.perSegment = {}), f.perSegment[o] = c) : f.allSegments = c;
                } else {
                    const f = "__allSegmentations__";
                    l[f] || (l[f] = {}), l[f][a] || (l[f][a] = {}), l[f][a].allSegments = c;
                }
            } else if (i) {
                this.config.segmentations[i] || (this.config.segmentations[i] = {}), this.config.segmentations[i][a] || (this.config.segmentations[i][a] = {});
                const l = this.config.segmentations[i][a];
                o !== void 0 ? (l.perSegment || (l.perSegment = {}), l.perSegment[o] = c) : l.allSegments = c;
            } else this.config.global[a] = c;
        }
        copyActiveToInactiveIfNotProvided(e, n) {
            const r = {
                ...e
            };
            if (n === Ft.Labelmap) {
                const i = r;
                i.renderOutlineInactive ??= i.renderOutline, i.outlineWidthInactive ??= i.outlineWidth, i.renderFillInactive ??= i.renderFill, i.fillAlphaInactive ??= i.fillAlpha, i.outlineOpacityInactive ??= i.outlineOpacity;
            } else if (n === Ft.Contour) {
                const i = r;
                i.outlineWidthInactive ??= i.outlineWidth, i.outlineOpacityInactive ??= i.outlineOpacity, i.outlineDashInactive ??= i.outlineDash, i.renderOutlineInactive ??= i.renderOutline, i.renderFillInactive ??= i.renderFill, i.fillAlphaInactive ??= i.fillAlpha;
            }
            return r;
        }
        getStyle(e) {
            const { viewportId: n, segmentationId: r, type: i, segmentIndex: a } = e;
            let o = this.getDefaultStyle(i);
            if (this.config.global[i] && (o = {
                ...o,
                ...this.config.global[i]
            }), this.config.segmentations[r]?.[i] && (o = {
                ...o,
                ...this.config.segmentations[r][i].allSegments
            }, a !== void 0 && this.config.segmentations[r][i].perSegment?.[a] && (o = {
                ...o,
                ...this.config.segmentations[r][i].perSegment[a]
            })), n && this.config.viewportsStyle[n]) {
                this.config.viewportsStyle[n].renderInactiveSegmentations;
                const s = "__allSegmentations__";
                this.config.viewportsStyle[n].representations[s]?.[i] && (o = {
                    ...o,
                    ...this.config.viewportsStyle[n].representations[s][i].allSegments
                }), r && this.config.viewportsStyle[n].representations[r]?.[i] && (o = {
                    ...o,
                    ...this.config.viewportsStyle[n].representations[r][i].allSegments
                }, a !== void 0 && this.config.viewportsStyle[n].representations[r][i].perSegment?.[a] && (o = {
                    ...o,
                    ...this.config.viewportsStyle[n].representations[r][i].perSegment[a]
                }));
            }
            return o;
        }
        getRenderInactiveSegmentations(e) {
            return this.config.viewportsStyle[e]?.renderInactiveSegmentations;
        }
        setRenderInactiveSegmentations(e, n) {
            this.config.viewportsStyle[e] || (this.config.viewportsStyle[e] = {
                renderInactiveSegmentations: !1,
                representations: {}
            }), this.config.viewportsStyle[e].renderInactiveSegmentations = n;
        }
        getDefaultStyle(e) {
            switch(e){
                case Ft.Labelmap:
                    return oY();
                case Ft.Contour:
                    return iY();
                case Ft.Surface:
                    return {};
                default:
                    throw new Error(`Unknown representation type: ${e}`);
            }
        }
        clearSegmentationStyle(e) {
            this.config.segmentations[e] && delete this.config.segmentations[e];
        }
        clearAllSegmentationStyles() {
            this.config.segmentations = {};
        }
        clearViewportStyle(e) {
            this.config.viewportsStyle[e] && delete this.config.viewportsStyle[e];
        }
        clearAllViewportStyles() {
            for(const e in this.config.viewportsStyle){
                const r = this.config.viewportsStyle[e].renderInactiveSegmentations;
                this.config.viewportsStyle[e] = {
                    renderInactiveSegmentations: r,
                    representations: {}
                };
            }
        }
        resetToGlobalStyle() {
            this.clearAllSegmentationStyles(), this.clearAllViewportStyles();
        }
        hasCustomStyle(e) {
            const { type: n } = e, r = this.getStyle(e), i = this.getDefaultStyle(n);
            return !C_(r, i);
        }
    }
    const zu = new sY;
    function cY(t) {
        const e = {
            segmentationId: t
        };
        We(Ke, z.SEGMENTATION_ADDED, e);
    }
    const pw = {
        colorLUT: [],
        segmentations: [],
        viewportSegRepresentations: {}
    };
    class lY {
        constructor(e){
            this._stackLabelmapImageIdReferenceMap = new Map, this._labelmapImageIdReferenceMap = new Map, e ||= Vn(), this.state = Object.freeze(ms(pw)), this.uid = e;
        }
        getState() {
            return this.state;
        }
        updateState(e) {
            const n = ms(this.state);
            e(n), this.state = Object.freeze(n);
        }
        getColorLUT(e) {
            return this.state.colorLUT[e];
        }
        getNextColorLUTIndex() {
            return this.state.colorLUT.length;
        }
        resetState() {
            this._stackLabelmapImageIdReferenceMap.clear(), this._labelmapImageIdReferenceMap.clear(), this.state = Object.freeze(ms(pw));
        }
        getSegmentation(e) {
            return this.state.segmentations.find((n)=>n.segmentationId === e);
        }
        updateSegmentation(e, n) {
            this.updateState((r)=>{
                const i = r.segmentations.find((a)=>a.segmentationId === e);
                if (!i) {
                    console.warn(`Segmentation with id ${e} not found. Update aborted.`);
                    return;
                }
                Object.assign(i, n);
            }), e2(e);
        }
        addSegmentation(e) {
            if (this.getSegmentation(e.segmentationId)) throw new Error(`Segmentation with id ${e.segmentationId} already exists`);
            this.updateState((n)=>{
                const r = ms(e);
                if (r.representationData.Labelmap && "volumeId" in r.representationData.Labelmap && !("imageIds" in r.representationData.Labelmap)) {
                    const i = this.getLabelmapImageIds(r.representationData);
                    r.representationData.Labelmap.imageIds = i;
                }
                n.segmentations.push(r);
            }), cY(e.segmentationId);
        }
        removeSegmentation(e) {
            this.updateState((n)=>{
                const r = n.segmentations.filter((i)=>i.segmentationId !== e);
                n.segmentations.splice(0, n.segmentations.length, ...r);
            }), nY(e);
        }
        addSegmentationRepresentation(e, n, r, i) {
            if (!An(e)) return;
            if (this.getSegmentationRepresentations(e, {
                type: r,
                segmentationId: n
            }).length > 0) {
                console.debug("A segmentation representation of type", r, "already exists in viewport", e, "for segmentation", n);
                return;
            }
            this.updateState((s)=>{
                s.viewportSegRepresentations[e] || (s.viewportSegRepresentations[e] = [], zu.setRenderInactiveSegmentations(e, !0)), r !== Ft.Labelmap ? this.addDefaultSegmentationRepresentation(s, e, n, r, i) : this.addLabelmapRepresentation(s, e, n, i);
            }), A1(e, n, r);
        }
        addDefaultSegmentationRepresentation(e, n, r, i, a) {
            const o = e.segmentations.find((c)=>c.segmentationId === r);
            if (!o) return;
            const s = {};
            Object.keys(o.segments).forEach((c)=>{
                s[Number(c)] = {
                    visible: !0
                };
            }), e.viewportSegRepresentations[n].push({
                segmentationId: r,
                type: i,
                active: !0,
                visible: !0,
                colorLUTIndex: a?.colorLUTIndex || 0,
                segments: s,
                config: {
                    ...mw(i),
                    ...a
                }
            }), this._setActiveSegmentation(e, n, r);
        }
        addLabelmapRepresentation(e, n, r, i = mw(Ft.Labelmap)) {
            if (!An(n)) return;
            const o = this.getSegmentation(r);
            if (!o) return;
            const { representationData: s } = o;
            if (!s.Labelmap) return this.addDefaultSegmentationRepresentation(e, n, r, Ft.Labelmap, i);
            this.processLabelmapRepresentationAddition(n, r), this.addDefaultSegmentationRepresentation(e, n, r, Ft.Labelmap, i);
        }
        async processLabelmapRepresentationAddition(e, n) {
            const r = An(e);
            if (!r) return;
            const i = this.getSegmentation(n);
            if (!i) return;
            const a = r.viewport instanceof So, { representationData: o } = i, s = "volumeId" in o.Labelmap;
            r.viewport, !a && !s && this.updateLabelmapSegmentationImageReferences(e, i.segmentationId);
        }
        _updateLabelmapSegmentationReferences(e, n, r, i) {
            const a = n.getCurrentImageId();
            let o = !1;
            for (const s of r)n.isReferenceViewable({
                referencedImageId: s
            }, {
                asOverlay: !0
            }) && (o = !0, this._stackLabelmapImageIdReferenceMap.get(e).set(a, s), this._updateLabelmapImageIdReferenceMap({
                segmentationId: e,
                referenceImageId: a,
                labelmapImageId: s
            }));
            return i && i(n, e, r), o ? this._stackLabelmapImageIdReferenceMap.get(e).get(a) : void 0;
        }
        updateLabelmapSegmentationImageReferences(e, n) {
            const r = this.getSegmentation(n);
            if (!r) return;
            this._stackLabelmapImageIdReferenceMap.has(n) || this._stackLabelmapImageIdReferenceMap.set(n, new Map);
            const { representationData: i } = r;
            if (!i.Labelmap) return;
            const a = this.getLabelmapImageIds(i), s = An(e).viewport;
            return this._updateLabelmapSegmentationReferences(n, s, a, null);
        }
        _updateAllLabelmapSegmentationImageReferences(e, n) {
            const r = this.getSegmentation(n);
            if (!r) return;
            this._stackLabelmapImageIdReferenceMap.has(n) || this._stackLabelmapImageIdReferenceMap.set(n, new Map);
            const { representationData: i } = r;
            if (!i.Labelmap) return;
            const a = this.getLabelmapImageIds(i), s = An(e).viewport;
            this._updateLabelmapSegmentationReferences(n, s, a, (c, l, f)=>{
                c.getImageIds().forEach((g, h)=>{
                    for (const v of f)c.isReferenceViewable({
                        referencedImageId: v,
                        sliceIndex: h
                    }, {
                        asOverlay: !0,
                        withNavigation: !0
                    }) && (this._stackLabelmapImageIdReferenceMap.get(l).set(g, v), this._updateLabelmapImageIdReferenceMap({
                        segmentationId: l,
                        referenceImageId: g,
                        labelmapImageId: v
                    }));
                });
            });
        }
        getLabelmapImageIds(e) {
            const n = e.Labelmap;
            let r;
            if (n.imageIds) r = n.imageIds;
            else if (!r && n.volumeId) {
                const i = n.volumeId;
                r = ot.getVolume(i).imageIds;
            }
            return r;
        }
        getLabelmapImageIdsForImageId(e, n) {
            const r = this._generateMapKey({
                segmentationId: n,
                referenceImageId: e
            });
            return this._labelmapImageIdReferenceMap.get(r);
        }
        getCurrentLabelmapImageIdsForViewport(e, n) {
            const r = An(e);
            if (!r) return;
            const a = r.viewport.getCurrentImageId();
            return this.getLabelmapImageIdsForImageId(a, n);
        }
        getCurrentLabelmapImageIdForViewport(e, n) {
            const r = An(e);
            if (!r || !this._stackLabelmapImageIdReferenceMap.has(n)) return;
            const a = r.viewport.getCurrentImageId();
            return this._stackLabelmapImageIdReferenceMap.get(n).get(a);
        }
        getStackSegmentationImageIdsForViewport(e, n) {
            if (!this.getSegmentation(n)) return [];
            this._updateAllLabelmapSegmentationImageReferences(e, n);
            const { viewport: i } = An(e), a = i.getImageIds(), o = this._stackLabelmapImageIdReferenceMap.get(n);
            return a.map((s)=>o.get(s));
        }
        removeSegmentationRepresentationsInternal(e, n) {
            const r = [];
            return this.updateState((i)=>{
                if (!i.viewportSegRepresentations[e]) return;
                const a = i.viewportSegRepresentations[e];
                let o = !1;
                if (!n || Object.values(n).every((s)=>s === void 0)) r.push(...a), delete i.viewportSegRepresentations[e];
                else {
                    const { segmentationId: s, type: c } = n;
                    i.viewportSegRepresentations[e] = a.filter((l)=>{
                        const f = s && c && l.segmentationId === s && l.type === c || s && !c && l.segmentationId === s || !s && c && l.type === c;
                        return f && (r.push(l), l.active && (o = !0)), !f;
                    }), i.viewportSegRepresentations[e].length === 0 ? delete i.viewportSegRepresentations[e] : o && (i.viewportSegRepresentations[e][0].active = !0);
                }
            }), r;
        }
        removeSegmentationRepresentations(e, n) {
            const r = this.removeSegmentationRepresentationsInternal(e, n);
            r.forEach((a)=>{
                hw(e, a.segmentationId, a.type);
            });
            const i = this.getSegmentationRepresentations(e);
            return i.length > 0 && i[0].active && A1(e, i[0].segmentationId, i[0].type), r;
        }
        removeSegmentationRepresentation(e, n, r) {
            const i = this.removeSegmentationRepresentationsInternal(e, n);
            return r || i.forEach(({ segmentationId: a, type: o })=>{
                hw(e, a, o);
            }), i;
        }
        _updateLabelmapImageIdReferenceMap({ segmentationId: e, referenceImageId: n, labelmapImageId: r }) {
            const i = this._generateMapKey({
                segmentationId: e,
                referenceImageId: n
            });
            if (!this._labelmapImageIdReferenceMap.has(i)) {
                this._labelmapImageIdReferenceMap.set(i, [
                    r
                ]);
                return;
            }
            const a = this._labelmapImageIdReferenceMap.get(i), o = Array.from(new Set([
                ...a,
                r
            ]));
            this._labelmapImageIdReferenceMap.set(i, o);
        }
        _setActiveSegmentation(e, n, r) {
            const i = e.viewportSegRepresentations[n];
            i && i.forEach((a)=>{
                a.active = a.segmentationId === r;
            });
        }
        setActiveSegmentation(e, n) {
            this.updateState((r)=>{
                const i = r.viewportSegRepresentations[e];
                i && i.forEach((a)=>{
                    a.active = a.segmentationId === n;
                });
            }), A1(e, n);
        }
        getActiveSegmentation(e) {
            if (!this.state.viewportSegRepresentations[e]) return;
            const n = this.state.viewportSegRepresentations[e].find((r)=>r.active);
            if (n) return this.getSegmentation(n.segmentationId);
        }
        getSegmentationRepresentations(e, n = {}) {
            const r = this.state.viewportSegRepresentations[e];
            return r ? !n.type && !n.segmentationId ? r : r.filter((i)=>{
                const a = n.type ? i.type === n.type : !0, o = n.segmentationId ? i.segmentationId === n.segmentationId : !0;
                return a && o;
            }) : [];
        }
        getSegmentationRepresentation(e, n) {
            return this.getSegmentationRepresentations(e, n)[0];
        }
        getSegmentationRepresentationVisibility(e, n) {
            return this.getSegmentationRepresentation(e, n)?.visible;
        }
        setSegmentationRepresentationVisibility(e, n, r) {
            this.updateState((i)=>{
                const a = this.getSegmentationRepresentations(e, n);
                a && a.forEach((o)=>{
                    o.visible = r, Object.entries(o.segments).forEach(([s, c])=>{
                        c.visible = r;
                    });
                });
            }), A1(e, n.segmentationId, n.type);
        }
        addColorLUT(e, n) {
            this.updateState((r)=>{
                r.colorLUT[n] && console.warn("Color LUT table already exists, overwriting"), r.colorLUT[n] = ms(e);
            });
        }
        removeColorLUT(e) {
            this.updateState((n)=>{
                delete n.colorLUT[e];
            });
        }
        _getStackIdForImageIds(e) {
            return e.map((n)=>n.slice(-Math.round(n.length * .15))).join("_");
        }
        getAllViewportSegmentationRepresentations() {
            return Object.entries(this.state.viewportSegRepresentations).map(([e, n])=>({
                    viewportId: e,
                    representations: n
                }));
        }
        getSegmentationRepresentationsBySegmentationId(e) {
            const n = [];
            return Object.entries(this.state.viewportSegRepresentations).forEach(([r, i])=>{
                const a = i.filter((o)=>o.segmentationId === e);
                a.length > 0 && n.push({
                    viewportId: r,
                    representations: a
                });
            }), n;
        }
        _generateMapKey({ segmentationId: e, referenceImageId: n }) {
            return `${e}-${n}`;
        }
    }
    function mw(t) {
        const e = Jc.newInstance(), n = B0.newInstance();
        return n.addPoint(0, 0), t === Ft.Labelmap ? {
            cfun: e,
            ofun: n
        } : {};
    }
    const lc = new lY("DEFAULT");
    function P0(t, e = {}) {
        return lc.getSegmentationRepresentations(t, e);
    }
    function uY(t, e) {
        const n = lc;
        if (!e.segmentationId || !e.type) throw new Error("getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them");
        return n.getSegmentationRepresentations(t, e)?.[0];
    }
    function fY(t, e) {
        const n = Fe(t), { viewport: r } = n, a = r.getActors().filter((o)=>o.representationUID && typeof o.representationUID == "string" && o.representationUID.startsWith(e));
        r.removeActors(a.map((o)=>o.uid));
    }
    function pR(t, e, n) {
        const r = An(t);
        if (!r) return;
        const { renderingEngine: i, viewport: a } = r;
        if (!i || !a) return;
        const s = a.getActors().filter(n);
        return s.length > 0 ? s[0] : void 0;
    }
    function dY(t, e) {
        const n = An(t);
        if (!n) return;
        const { renderingEngine: r, viewport: i } = n;
        if (!r || !i) return;
        const o = i.getActors().filter(e);
        return o.length > 0 ? o : void 0;
    }
    function gY(t, e) {
        return hY(t, e)?.uid;
    }
    function Td(t, e) {
        return dY(t, (n)=>n.representationUID?.startsWith(`${e}-${Ft.Labelmap}`));
    }
    function hY(t, e) {
        return pR(t, e, (n)=>n.representationUID?.startsWith(`${e}-${Ft.Labelmap}`));
    }
    function pY(t, e, n) {
        return pR(t, e, (r)=>r.representationUID === mR(e, n));
    }
    function mR(t, e) {
        return `${t}-${Ft.Surface}-${e}`;
    }
    function mY(t, e, n) {
        const r = Fe(t), { viewport: i } = r, o = pY(i.id, n, e.segmentIndex)?.actor, s = e.visible;
        if (o) {
            if (o.setVisibility(s), !s) return;
            const C = o.getMapper(), T = C.getInputData(), x = e.points, S = e.polys, D = T.getPoints().getData(), _ = T.getPolys().getData();
            if (x.length === D.length && S.length === _.length) return;
            const M = Hc.newInstance();
            M.getPoints().setData(x, 3);
            const P = W0.newInstance({
                values: Float32Array.from(S)
            });
            M.setPolys(P), C.setInputData(M), C.modified(), i.getRenderer().resetCameraClippingRange();
            return;
        }
        const c = e.points, l = e.polys, f = e.color, u = Hc.newInstance();
        u.getPoints().setData(c, 3);
        const g = W0.newInstance({
            values: Float32Array.from(l)
        });
        u.setPolys(g);
        const h = ZE.newInstance({});
        let v;
        h.setInputData(u);
        const m = kz.newInstance();
        m.setMapper(h), m.getProperty().setColor(f[0] / 255, f[1] / 255, f[2] / 255), m.getProperty().setLineWidth(2);
        const y = mR(n, e.segmentIndex);
        i.addActor({
            uid: Vn(),
            actor: m,
            clippingFilter: v,
            representationUID: y
        }), i.resetCamera(), i.getRenderer().resetCameraClippingRange(), i.render();
    }
    function eo(t) {
        return lc.getSegmentation(t);
    }
    function Y4(t) {
        return lc.getColorLUT(t);
    }
    let Jv = {};
    function vY(t) {
        Jv = t;
    }
    let vw = !1;
    function Xc() {
        if (!Jv.addons?.polySeg) return console.warn("PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } })."), null;
        const t = Jv.addons.polySeg;
        return vw || (t.init(), vw = !0), t;
    }
    function yY({ segmentationId: t, type: e, data: n }) {
        const r = eo(t);
        if (!r) throw new Error(`Segmentation ${t} not found`);
        switch(r.representationData[e] && console.warn(`Representation data of type ${e} already exists for segmentation ${t}, overwriting it.`), e){
            case Ft.Labelmap:
                n && (r.representationData[e] = n);
                break;
            case Ft.Contour:
                n && (r.representationData[e] = n);
                break;
            case Ft.Surface:
                n && (r.representationData[e] = n);
                break;
            default:
                throw new Error(`Invalid representation type ${e}`);
        }
    }
    function vR(t) {
        const e = typeof t;
        return t !== null && (e === "object" || e === "function");
    }
    function yR(t, e, n) {
        let r, i, a, o, s, c, l = 0, f = !1, u = !1, g = !0;
        const h = !e && e !== 0 && typeof window.requestAnimationFrame == "function";
        if (typeof t != "function") throw new TypeError("Expected a function");
        e = Number(e) || 0, vR(n) && (f = !!n.leading, u = "maxWait" in n, a = u ? Math.max(Number(n.maxWait) || 0, e) : a, g = "trailing" in n ? !!n.trailing : g);
        function v(N) {
            const B = r, G = i;
            return r = i = void 0, l = N, o = t.apply(G, B), o;
        }
        function m(N, B) {
            return h ? window.requestAnimationFrame(N) : setTimeout(N, B);
        }
        function y(N) {
            if (h) return window.cancelAnimationFrame(N);
            clearTimeout(N);
        }
        function C(N) {
            return l = N, s = m(S, e), f ? v(N) : o;
        }
        function T(N) {
            const B = N - c, G = N - l, Z = e - B;
            return u ? Math.min(Z, a - G) : Z;
        }
        function x(N) {
            const B = N - c, G = N - l;
            return c === void 0 || B >= e || B < 0 || u && G >= a;
        }
        function S() {
            const N = Date.now();
            if (x(N)) return D(N);
            s = m(S, T(N));
        }
        function D(N) {
            return s = void 0, g && r ? v(N) : (r = i = void 0, o);
        }
        function _() {
            s !== void 0 && y(s), l = 0, r = c = i = s = void 0;
        }
        function M() {
            return s === void 0 ? o : D(Date.now());
        }
        function P() {
            return s !== void 0;
        }
        function F(...N) {
            const B = Date.now(), G = x(B);
            if (r = N, i = this, c = B, G) {
                if (s === void 0) return C(c);
                if (u) return s = m(S, e), v(c);
            }
            return s === void 0 && (s = m(S, e)), o;
        }
        return F.cancel = _, F.flush = M, F.pending = P, F;
    }
    const Ch = new Map;
    async function Z4(t, e, n, r, i) {
        const a = await n();
        yY({
            segmentationId: t,
            type: e,
            data: a
        }), i?.(), Ch.has(t) || Ch.set(t, []);
        const o = Ch.get(t);
        return o.includes(e) || o.push(e), CY(r), e2(t), a;
    }
    function CY(t) {
        const e = (n)=>{
            wY(n, t);
        };
        t._debouncedUpdateFunction = e, Ke.removeEventListener(z.SEGMENTATION_DATA_MODIFIED, t._debouncedUpdateFunction), Ke.addEventListener(z.SEGMENTATION_DATA_MODIFIED, t._debouncedUpdateFunction);
    }
    const wY = yR((t, e)=>{
        const n = t.detail.segmentationId, r = Ch.get(n);
        !r || !r.length || (e(n), r.length && e2(n));
    }, 300);
    function J4(t, e) {
        const n = uY(t, e);
        return n ? Object.entries(n.segments).reduce((i, [a, o])=>(o.visible || i.add(Number(a)), i), new Set) : new Set;
    }
    function TY(t, e, n = !1) {
        const r = An(t);
        if (!r) return;
        const { viewport: i } = r;
        fY(i.element, e), n && i.render();
    }
    async function xY(t, e) {
        const { segmentationId: n, type: r } = e, i = eo(n);
        if (!i) return;
        let a = i.representationData[Ft.Surface];
        if (!a && Xc()?.canComputeRequestedRepresentation(n, Ft.Surface)) {
            const l = Xc();
            if (a = await Z4(n, Ft.Surface, ()=>l.computeSurfaceData(n, {
                    viewport: t
                }), ()=>l.updateSurfaceData(n, {
                    viewport: t
                })), !a) throw new Error(`No Surface data found for segmentationId ${n} even we tried to compute it`);
        } else !a && !Xc() && console.debug(`No surface data found for segmentationId ${n} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
        if (!a) {
            console.warn(`No Surface data found for segmentationId ${n}. Skipping render.`);
            return;
        }
        const { geometryIds: o } = a;
        o?.size || console.warn(`No Surfaces found for segmentationId ${n}. Skipping render.`);
        const { colorLUTIndex: s } = e, c = Y4(s);
        o.forEach((l)=>{
            const f = ot.getGeometry(l);
            if (!f?.data) {
                console.warn(`No Surfaces found for geometryId ${l}. Skipping render.`);
                return;
            }
            const { segmentIndex: u } = f.data, h = J4(t.id, {
                segmentationId: n,
                type: r
            }).has(u), v = f.data, m = c[u];
            v.color = m.slice(0, 3), v.visible = !h, mY(t.element, v, n);
        }), t.render();
    }
    const SY = {
        render: xY,
        removeRepresentation: TY
    };
    function EY(t, e, n) {
        const r = t.getImageIds();
        if (!r || !r.length) return;
        const i = r.map((a)=>{
            const { imagePositionPatient: o } = ct("imagePlaneModule", a), s = DY(e, o, n);
            return {
                imageId: a,
                distance: s
            };
        });
        return i.sort((a, o)=>a.distance - o.distance), i[0].imageId;
    }
    function DY(t, e, n) {
        const r = Xe();
        In(r, t, e);
        const i = xt(r, n);
        return Math.abs(i);
    }
    function _Y(t, e) {
        const { segmentation: n } = t.data, { segmentation: r } = e.data;
        return n.segmentationId === r.segmentationId && n.segmentIndex === r.segmentIndex;
    }
    class RY {
        constructor(e){
            this.getGroupKey = (n)=>{
                if (typeof n == "string") return n;
                const i = Fe(n);
                if (!i) throw new Error("Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID");
                return i.FrameOfReferenceUID;
            }, this._imageVolumeModifiedHandler = (n)=>{
                const r = n.detail, { FrameOfReferenceUID: i } = r, o = this.annotations[i];
                o && Object.keys(o).forEach((s)=>{
                    o[s].forEach((l)=>{
                        l.invalidated !== void 0 && (l.invalidated = !0);
                    });
                });
            }, this.getFramesOfReference = ()=>Object.keys(this.annotations), this.getAnnotations = (n, r)=>{
                const i = this.annotations;
                return i[n] ? r ? i[n][r] ? i[n][r] : [] : i[n] : [];
            }, this.getAnnotation = (n)=>{
                const r = this.annotations;
                for(const i in r){
                    const a = r[i];
                    for(const o in a){
                        const s = a[o];
                        for (const c of s)if (n === c.annotationUID) return c;
                    }
                }
            }, this.getNumberOfAnnotations = (n, r)=>{
                const i = this.getAnnotations(n, r);
                if (!i.length) return 0;
                if (r) return i.length;
                let a = 0;
                for(const o in i)a += i[o].length;
                return a;
            }, this.addAnnotation = (n, r)=>{
                const { metadata: i } = n, { FrameOfReferenceUID: a, toolName: o } = i;
                r = r || a;
                const s = this.annotations;
                let c = s[r];
                c || (s[r] = {}, c = s[r]);
                let l = c[o];
                l || (c[o] = [], l = c[o]), this.preprocessingFn && (n = this.preprocessingFn(n)), l.push(n);
            }, this.removeAnnotation = (n)=>{
                const { annotations: r } = this;
                for(const i in r){
                    const a = r[i];
                    for(const o in a){
                        const s = a[o], c = s.findIndex((l)=>l.annotationUID === n);
                        c !== -1 && (s.splice(c, 1), s.length === 0 && delete a[o]);
                    }
                    Object.keys(a).length === 0 && delete r[i];
                }
            }, this.removeAnnotations = (n, r)=>{
                const i = this.annotations, a = [];
                if (!i[n]) return a;
                if (r) {
                    const o = i[n][r];
                    for (const s of o)this.removeAnnotation(s.annotationUID), a.push(s);
                } else for(const o in i[n]){
                    const s = i[n][o];
                    for (const c of s)this.removeAnnotation(c.annotationUID), a.push(c);
                }
                return a;
            }, this.saveAnnotations = (n, r)=>{
                const i = this.annotations;
                if (n && r) {
                    const a = i[n];
                    if (!a) return;
                    const o = a[r];
                    return structuredClone(o);
                } else if (n) {
                    const a = i[n];
                    return structuredClone(a);
                }
                return structuredClone(i);
            }, this.restoreAnnotations = (n, r, i)=>{
                const a = this.annotations;
                if (r && i) {
                    let o = a[r];
                    o || (a[r] = {}, o = a[r]), o[i] = n;
                } else r ? a[r] = n : this.annotations = structuredClone(n);
            }, this.getAllAnnotations = ()=>Object.values(this.annotations).map((n)=>Object.values(n)).flat(2), this.getNumberOfAllAnnotations = ()=>{
                let n = 0;
                const r = this.annotations;
                for(const i in r){
                    const a = r[i];
                    for(const o in a){
                        const s = a[o];
                        n += s.length;
                    }
                }
                return n;
            }, this.removeAllAnnotations = ()=>{
                const n = [];
                for (const r of this.getAllAnnotations())this.removeAnnotation(r.annotationUID), n.push(r);
                return n;
            }, e || (e = Vn()), this.annotations = {}, this.uid = e, Ke.addEventListener(Ge.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);
        }
        setPreprocessingFn(e) {
            this.preprocessingFn = e;
        }
    }
    const OY = new RY("DEFAULT"), wh = new Set;
    function IY(t, e = !0) {
        const n = bY();
        t && (e ? LY(t, wh, n) : PY(t, wh, n)), VY(n, wh);
    }
    function Ja(t) {
        return wh.has(t);
    }
    function MY(t) {
        const e = Ja(t);
        return IY(t, e), e;
    }
    function bY() {
        return Object.freeze({
            added: [],
            removed: [],
            locked: []
        });
    }
    function LY(t, e, n) {
        if (!e.has(t)) {
            e.add(t), n.added.push(t);
            const r = fa(t);
            r && (r.isLocked = !0);
        }
    }
    function PY(t, e, n) {
        if (e.delete(t)) {
            n.removed.push(t);
            const r = fa(t);
            r && (r.isLocked = !1);
        }
    }
    function VY(t, e) {
        (t.added.length > 0 || t.removed.length > 0) && (e.forEach((n)=>void t.locked.push(n)), We(Ke, z.ANNOTATION_LOCK_CHANGE, t));
    }
    const Nl = new Set;
    function Qs(t, e = !0, n = !1) {
        e ? NY(t, n) : CR(t);
    }
    function NY(t, e = !1) {
        const n = wR();
        if (!e) {
            TR(Nl, n);
            const r = fa(t);
            r && (r.isSelected = !0);
        }
        if (t && !Nl.has(t)) {
            Nl.add(t), n.added.push(t);
            const r = fa(t);
            r && (r.isSelected = !0);
        }
        xR(n, Nl);
    }
    function CR(t) {
        const e = wR();
        if (t) {
            if (Nl.delete(t)) {
                e.removed.push(t);
                const n = fa(t);
                n.isSelected = !1;
            }
        } else TR(Nl, e);
        xR(e, Nl);
    }
    function t2(t) {
        return Nl.has(t);
    }
    function wR() {
        return Object.freeze({
            added: [],
            removed: [],
            selection: []
        });
    }
    function TR(t, e) {
        t.forEach((n)=>{
            if (t.delete(n)) {
                e.removed.push(n);
                const r = fa(n);
                r && (r.isSelected = !1);
            }
        });
    }
    function xR(t, e) {
        (t.added.length > 0 || t.removed.length > 0) && (e.forEach((n)=>void t.selection.push(n)), We(Ke, z.ANNOTATION_SELECTION_CHANGE, t));
    }
    const AY = (t)=>(t.data || (t.data = {}), t.data.handles || (t.data.handles = {}), t.data.handles.textBox || (t.data.handles.textBox = {}), t), kY = (t)=>(t.data || (t.data = {}), t.data.cachedStats || (t.data.cachedStats = {}), t), Ad = new Set;
    function UY(t, e = !0) {
        const n = FY();
        t && (e ? BY(t, Ad, n) : GY(t, Ad, n)), WY(n);
    }
    function Eo(t) {
        if (fa(t)) return !Ad.has(t);
    }
    function FY() {
        return Object.freeze({
            lastVisible: [],
            lastHidden: [],
            hidden: []
        });
    }
    function BY(t, e, n) {
        if (e.delete(t)) {
            n.lastVisible.push(t);
            const r = fa(t);
            r.isVisible = !0;
        }
    }
    function GY(t, e, n) {
        e.has(t) || (e.add(t), t2(t) && CR(t), n.lastHidden.push(t));
    }
    function WY(t) {
        (t.lastHidden.length > 0 || t.lastVisible.length > 0) && (Ad.forEach((e)=>void t.hidden.push(e)), We(Ke, z.ANNOTATION_VISIBILITY_CHANGE, t));
    }
    function $Y(t) {
        const e = !Ad.has(t);
        return UY(t, e), e;
    }
    const Q4 = OY, zY = (t)=>{
        t = AY(t), t = kY(t);
        const e = t.annotationUID, n = MY(e);
        t.isLocked = n;
        const r = $Y(e);
        return t.isVisible = r, t;
    };
    Q4.setPreprocessingFn(zY);
    H4(Q4);
    function jY() {
        H4(Q4);
    }
    function Hl(t) {
        if (!t.data.segmentation) throw new Error("removeContourSegmentationAnnotation: annotation does not have a segmentation data");
        const { segmentationId: e, segmentIndex: n } = t.data.segmentation, r = eo(e), { annotationUIDsMap: i } = r?.representationData.Contour || {}, a = i?.get(n);
        a && (a.delete(t.annotationUID), a.size || i.delete(n));
    }
    function Kl(t) {
        if (t.parentAnnotationUID) return;
        if (!t.data.segmentation) throw new Error("addContourSegmentationAnnotation: annotation does not have a segmentation data");
        const { segmentationId: e, segmentIndex: n } = t.data.segmentation, r = eo(e);
        r.representationData.Contour || (r.representationData.Contour = {
            annotationUIDsMap: new Map
        });
        let { annotationUIDsMap: i } = r.representationData.Contour;
        i || (i = new Map);
        let a = i?.get(n);
        a || (a = new Set, i.set(n, a)), i.set(n, a.add(t.annotationUID));
    }
    const HY = "PlanarFreehandContourSegmentationTool";
    function KY(t) {
        const { polyline: e } = t.data?.contour || {};
        if (!e || e.length < 3) {
            console.warn("Skipping creation of new annotation due to invalid polyline:", e);
            return;
        }
        Ir(t.annotationUID), Hl(t);
        const n = e[0], r = e[e.length - 1], i = {
            metadata: {
                ...t.metadata,
                toolName: HY,
                originalToolName: t.metadata.originalToolName || t.metadata.toolName
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [
                        n,
                        r
                    ],
                    textBox: t.data.handles.textBox ? {
                        ...t.data.handles.textBox
                    } : void 0
                },
                contour: {
                    ...t.data.contour
                },
                spline: t.data.spline,
                segmentation: {
                    ...t.data.segmentation
                }
            },
            annotationUID: Vn(),
            highlighted: !0,
            invalidated: !0,
            isLocked: !1,
            isVisible: void 0,
            interpolationUID: t.interpolationUID,
            interpolationCompleted: t.interpolationCompleted
        };
        return nr(i, t.metadata.FrameOfReferenceUID), Kl(i), i;
    }
    function SR(t) {
        const r = lc.getState().viewportSegRepresentations;
        return Object.entries(r).filter(([, a])=>a.some((o)=>o.segmentationId === t)).map(([a])=>a);
    }
    var Za;
    (function(t) {
        t[t.CounterClockwise = -1] = "CounterClockwise", t[t.Unknown = 0] = "Unknown", t[t.Clockwise = 1] = "Clockwise";
    })(Za || (Za = {}));
    function qY(t, e) {
        return t.minX <= e.maxX && t.maxX >= e.minX && t.minY <= e.maxY && t.maxY >= e.minY;
    }
    function yw(t, e) {
        const n = t.maxX - t.minX, r = t.maxY - t.minY, i = [
            n,
            r
        ], a = [
            t.minX + n / 2,
            t.minY + r / 2
        ], o = [
            Math.abs(e[0] - a[0]),
            Math.abs(e[1] - a[1])
        ], s = o[0] - i[0] * .5, c = o[1] - i[1] * .5;
        if (s > 0 && c > 0) return s * s + c * c;
        const l = Math.max(s, 0) + Math.max(c, 0);
        return l * l;
    }
    class XY {
    }
    const { PointsManager: YY } = ga;
    function Qv(t) {
        return {
            max: [
                -1 / 0
            ],
            min: [
                1 / 0
            ],
            sum: [
                0
            ],
            count: 0,
            maxIJK: null,
            maxLPS: null,
            minIJK: null,
            minLPS: null,
            runMean: [
                0
            ],
            m2: [
                0
            ],
            m3: [
                0
            ],
            m4: [
                0
            ],
            allValues: [
                []
            ],
            pointsInShape: t ? YY.create3(1024) : null,
            sumLPS: [
                0,
                0,
                0
            ]
        };
    }
    function ZY(t, e, n = null, r = null) {
        Array.isArray(e) && e.length > 1 && t.max.length === 1 && (t.max.push(t.max[0], t.max[0]), t.min.push(t.min[0], t.min[0]), t.sum.push(t.sum[0], t.sum[0]), t.runMean.push(0, 0), t.m2.push(t.m2[0], t.m2[0]), t.m3.push(t.m3[0], t.m3[0]), t.m4.push(t.m4[0], t.m4[0]), t.allValues.push([], [])), t?.pointsInShape && n && t.pointsInShape.push(n);
        const i = Array.isArray(e) ? e : [
            e
        ];
        t.count += 1, n && (t.sumLPS[0] += n[0], t.sumLPS[1] += n[1], t.sumLPS[2] += n[2]), t.max.forEach((a, o)=>{
            const s = i[o];
            t.allValues[o].push(s);
            const c = t.count, l = s - t.runMean[o], f = l / c, u = l * f * (c - 1);
            t.sum[o] += s, t.runMean[o] += f, t.m4[o] += u * f * f * (c * c - 3 * c + 3) + 6 * f * f * t.m2[o] - 4 * f * t.m3[o], t.m3[o] += u * f * (c - 2) - 3 * f * t.m2[o], t.m2[o] += u, s < t.min[o] && (t.min[o] = s, o === 0 && (t.minIJK = r ? [
                ...r
            ] : null, t.minLPS = n ? [
                ...n
            ] : null)), s > t.max[o] && (t.max[o] = s, o === 0 && (t.maxIJK = r ? [
                ...r
            ] : null, t.maxLPS = n ? [
                ...n
            ] : null));
        });
    }
    function JY(t) {
        if (t.length === 0) return 0;
        const e = [
            ...t
        ].sort((r, i)=>r - i), n = Math.floor(e.length / 2);
        return e.length % 2 === 0 ? (e[n - 1] + e[n]) / 2 : e[n];
    }
    function QY(t, e) {
        const n = t.sum.map((u)=>u / t.count), r = t.m2.map((u)=>Math.sqrt(u / t.count)), i = t.sumLPS.map((u)=>u / t.count), a = t.m3.map((u, g)=>{
            const h = t.m2[g] / t.count;
            return h === 0 ? 0 : u / (t.count * Math.pow(h, 1.5));
        }), o = t.m4.map((u, g)=>{
            const h = t.m2[g] / t.count;
            return h === 0 ? 0 : u / (t.count * h * h) - 3;
        }), s = t.allValues.map((u)=>JY(u)), c = {
            max: {
                name: "max",
                label: "Max Pixel",
                value: t.max.length === 1 ? t.max[0] : t.max,
                unit: e,
                pointIJK: t.maxIJK ? [
                    ...t.maxIJK
                ] : null,
                pointLPS: t.maxLPS ? [
                    ...t.maxLPS
                ] : null
            },
            min: {
                name: "min",
                label: "Min Pixel",
                value: t.min.length === 1 ? t.min[0] : t.min,
                unit: e,
                pointIJK: t.minIJK ? [
                    ...t.minIJK
                ] : null,
                pointLPS: t.minLPS ? [
                    ...t.minLPS
                ] : null
            },
            mean: {
                name: "mean",
                label: "Mean Pixel",
                value: n.length === 1 ? n[0] : n,
                unit: e
            },
            stdDev: {
                name: "stdDev",
                label: "Standard Deviation",
                value: r.length === 1 ? r[0] : r,
                unit: e
            },
            count: {
                name: "count",
                label: "Voxel Count",
                value: t.count,
                unit: null
            },
            median: {
                name: "median",
                label: "Median",
                value: s.length === 1 ? s[0] : s,
                unit: e
            },
            skewness: {
                name: "skewness",
                label: "Skewness",
                value: a.length === 1 ? a[0] : a,
                unit: null
            },
            kurtosis: {
                name: "kurtosis",
                label: "Kurtosis",
                value: o.length === 1 ? o[0] : o,
                unit: null
            },
            maxLPS: {
                name: "maxLPS",
                label: "Max LPS",
                value: t.maxLPS ? Array.from(t.maxLPS) : null,
                unit: null
            },
            minLPS: {
                name: "minLPS",
                label: "Min LPS",
                value: t.minLPS ? Array.from(t.minLPS) : null,
                unit: null
            },
            pointsInShape: t.pointsInShape,
            center: {
                name: "center",
                label: "Center",
                value: i ? [
                    ...i
                ] : null,
                unit: null
            },
            array: []
        };
        c.array.push(c.min, c.max, c.mean, c.stdDev, c.median, c.skewness, c.kurtosis, c.count, c.maxLPS, c.minLPS), c.center.value && c.array.push(c.center);
        const l = t.pointsInShape !== null, f = Qv(l);
        return t.max = f.max, t.min = f.min, t.sum = f.sum, t.count = f.count, t.maxIJK = f.maxIJK, t.maxLPS = f.maxLPS, t.minIJK = f.minIJK, t.minLPS = f.minLPS, t.runMean = f.runMean, t.m2 = f.m2, t.m3 = f.m3, t.m4 = f.m4, t.allValues = f.allValues, t.pointsInShape = f.pointsInShape, t.sumLPS = f.sumLPS, c;
    }
    class n2 extends XY {
        static{
            this.state = Qv(!0);
        }
        static statsInit(e) {
            e.storePointData || (this.state.pointsInShape = null), this.state = Qv(e.storePointData);
        }
        static{
            this.statsCallback = ({ value: e, pointLPS: n = null, pointIJK: r = null })=>{
                ZY(this.state, e, n, r);
            };
        }
        static{
            this.getStatistics = (e)=>QY(this.state, e?.unit);
        }
    }
    function $0(t, e) {
        if (t.length !== e.length) throw Error("Both points should have the same dimensionality");
        const [n, r, i = 0] = t, [a, o, s = 0] = e, c = a - n, l = o - r, f = s - i;
        return c * c + l * l + f * f;
    }
    function cg(t, e) {
        return Math.sqrt($0(t, e));
    }
    function Cw(t, e) {
        const [n, r] = t, [i, a] = e, o = 2 * i - n, s = 2 * a - r;
        return [
            o,
            s
        ];
    }
    function B5(t) {
        const [e, n] = t;
        return cg(e, n);
    }
    function ww(t) {
        const [e, n] = t, r = cg(e, n), i = [
            e[0] - r,
            e[1] - r
        ], a = [
            e[0] + r,
            e[1] + r
        ];
        return [
            i,
            a
        ];
    }
    function ER(t, e, n = {}) {
        return n.precalculated || eZ(t, n), n.precalculated(e);
    }
    const eZ = (t, e = {})=>{
        const { xRadius: n, yRadius: r, zRadius: i } = t;
        (e.invXRadiusSq === void 0 || e.invYRadiusSq === void 0 || e.invZRadiusSq === void 0) && (e.invXRadiusSq = n !== 0 ? 1 / n ** 2 : 0, e.invYRadiusSq = r !== 0 ? 1 / r ** 2 : 0, e.invZRadiusSq = i !== 0 ? 1 / i ** 2 : 0);
        const { invXRadiusSq: a, invYRadiusSq: o, invZRadiusSq: s } = e, { center: c } = t, [l, f, u] = c;
        return e.precalculated = (g)=>{
            const h = g[0] - l;
            let v = h * h * a;
            if (v > 1) return !1;
            const m = g[1] - f;
            if (v += m * m * o, v > 1) return !1;
            const y = g[2] - u;
            return v += y * y * s, v <= 1;
        }, e;
    };
    function Tw(t) {
        const [e, n, r, i] = t, a = [
            r[0],
            n[1]
        ], o = [
            i[0],
            e[1]
        ];
        return [
            a,
            o
        ];
    }
    function e3(t, e, n) {
        let r;
        const i = $0(t, e);
        if (t[0] === e[0] && t[1] === e[1] && (r = t), !r) {
            const a = ((n[0] - t[0]) * (e[0] - t[0]) + (n[1] - t[1]) * (e[1] - t[1])) / i;
            a < 0 ? r = t : a > 1 ? r = e : r = [
                t[0] + a * (e[0] - t[0]),
                t[1] + a * (e[1] - t[1])
            ];
        }
        return {
            point: [
                ...r
            ],
            distanceSquared: $0(n, r)
        };
    }
    function ey(t, e, n) {
        return e3(t, e, n).distanceSquared;
    }
    function Cs(t, e, n) {
        if (t.length !== 2 || e.length !== 2 || n.length !== 2) throw Error("lineStart, lineEnd, and point should have 2 elements of [x, y]");
        return Math.sqrt(ey(t, e, n));
    }
    function k1(t) {
        return typeof t == "number" ? t ? t < 0 ? -1 : 1 : t === t ? 0 : NaN : NaN;
    }
    function xw(t, e, n, r, i = !1) {
        const [a, o] = t, [s, c] = e, [l, f] = n, [u, g] = r;
        if (i) {
            const G = (a - s) * (f - g) - (o - c) * (l - u);
            if (Math.abs(G) < 1e-10) return;
            const Z = ((a - l) * (f - g) - (o - f) * (l - u)) / G, H = a + Z * (s - a), ne = o + Z * (c - o);
            return [
                H,
                ne
            ];
        }
        const h = c - o, v = a - s, m = s * o - a * c, y = h * l + v * f + m, C = h * u + v * g + m;
        if (y !== 0 && C !== 0 && k1(y) === k1(C)) return;
        const T = g - f, x = l - u, S = u * f - l * g, D = T * a + x * o + S, _ = T * s + x * c + S;
        if (D !== 0 && _ !== 0 && k1(D) === k1(_)) return;
        const M = h * x - T * v;
        let P;
        P = v * S - x * m;
        const F = P / M;
        P = T * m - h * S;
        const N = P / M;
        return [
            F,
            N
        ];
    }
    const Yf = .01;
    function G5(t, e, n) {
        const r = t[0] <= e[0] ? t[0] : e[0], i = t[0] >= e[0] ? t[0] : e[0], a = t[1] <= e[1] ? t[1] : e[1], o = t[1] >= e[1] ? t[1] : e[1];
        if (!(n[0] >= r - Yf && n[0] <= i + Yf && n[1] >= a - Yf && n[1] <= o + Yf)) return !1;
        const c = (e[1] - t[1]) * (n[0] - e[0]) - (e[0] - t[0]) * (n[1] - e[1]);
        return (c >= 0 ? c : -c) <= Yf;
    }
    function DR(t) {
        if (t.length < 3) return !1;
        const e = t.length, n = t[0], r = t[e - 1], i = $0(n, r);
        return Gh(0, i);
    }
    function Ra(t, e, n = {
        closed: void 0
    }) {
        if (t.length < 3) return !1;
        const r = t.length;
        let i = 0;
        const { closed: a, holes: o } = n;
        if (o?.length) {
            for (const l of o)if (Ra(l, e)) return !1;
        }
        const s = !(a === void 0 ? DR(t) : a), c = t.length - (s ? 1 : 2);
        for(let l = 0; l <= c; l++){
            const f = t[l], u = l === r - 1 ? 0 : l + 1, g = t[u], h = f[0] >= g[0] ? f[0] : g[0], v = f[1] >= g[1] ? f[1] : g[1], m = f[1] <= g[1] ? f[1] : g[1];
            if (e[0] <= h && e[1] >= m && e[1] < v) {
                let T = f[0] === g[0];
                if (!T) {
                    const x = (e[1] - f[1]) * (g[0] - f[0]) / (g[1] - f[1]) + f[0];
                    T = e[0] <= x;
                }
                i += T ? 1 : 0;
            }
        }
        return !!(i % 2);
    }
    function lg(t, e) {
        for(let n = 0, r = e.length; n < r; n++)if (!Ra(t, e[n])) return !1;
        return !0;
    }
    function kd(t, e) {
        let n = t;
        const r = e?.numDimensions || 2, i = r === 3;
        if (!Array.isArray(t[0])) {
            const u = t, g = u.length / r;
            n = new Array(u.length / r);
            for(let h = 0, v = g; h < v; h++)n[h] = [
                u[h * r],
                u[h * r + 1]
            ], i && n[h].push(u[h * r + 2]);
        }
        let a = 1 / 0, o = 1 / 0, s = -1 / 0, c = -1 / 0, l = 1 / 0, f = -1 / 0;
        n = n;
        for(let u = 0, g = n.length; u < g; u++){
            const [h, v, m] = n[u];
            a = a < h ? a : h, o = o < v ? o : v, s = s > h ? s : h, c = c > v ? c : v, i && (l = l < m ? l : m, f = f > m ? f : m);
        }
        return i ? {
            minX: a,
            maxX: s,
            minY: o,
            maxY: c,
            minZ: l,
            maxZ: f
        } : {
            minX: a,
            maxX: s,
            minY: o,
            maxY: c
        };
    }
    function r2(t) {
        const e = t.length;
        let n = 0, r = e - 1;
        for(let i = 0; i < e; i++)n += (t[r][0] + t[i][0]) * (t[r][1] - t[i][1]), r = i;
        return Math.abs(n / 2);
    }
    function Fl(t) {
        if (t.length < 3) return 0;
        const e = t[0];
        let n = 0;
        for(let r = 0, i = t.length; r < i; r++){
            const a = t[r], o = r === i - 1 ? 0 : r + 1, s = t[o], c = a[0] - e[0], l = a[1] - e[1], f = s[0] - e[0], u = s[1] - e[1];
            n += c * u - l * f;
        }
        return n *= .5, n;
    }
    function Th(t) {
        return Fl(t) >= 0 ? 1 : -1;
    }
    function tZ(t) {
        const e = Xe(), n = t[0];
        for(let r = 0, i = t.length; r < i; r++){
            const a = t[r], o = r === i - 1 ? 0 : r + 1, s = t[o], c = a[0] - n[0], l = a[1] - n[1], f = a[2] - n[2], u = s[0] - n[0], g = s[1] - n[1], h = s[2] - n[2];
            e[0] += l * h - f * g, e[1] += f * u - c * h, e[2] += c * g - l * u;
        }
        return Ys(e, e, .5), e;
    }
    function nZ(t) {
        const e = tZ(t);
        return jn(e, e);
    }
    function t3(t) {
        const e = Fl(t);
        return [
            0,
            0,
            e / Math.abs(e)
        ];
    }
    const ai = 1e-7;
    function W5(t, e) {
        return t[0] * e[1] - t[1] * e[0];
    }
    function _r(t, e) {
        return lr(t, e, ai);
    }
    function _R(t, e, n, r) {
        const i = yi(sn(), e, t), a = yi(sn(), r, n), o = W5(i, a), s = yi(sn(), n, t), c = W5(s, i);
        if (Math.abs(o) < ai) {
            if (Math.abs(c) < ai) {
                const u = kc(i, i), g = kc(a, a);
                if (u < ai || g < ai) return _r(t, n) || _r(t, r) ? t : _r(e, n) || _r(e, r) ? e : null;
                const h = kc(yi(sn(), n, t), i) / u, v = kc(yi(sn(), r, t), i) / u, m = kc(yi(sn(), t, n), a) / g, y = kc(yi(sn(), e, n), a) / g, C = (T)=>T >= -ai && T <= 1 + ai;
                if (C(h)) {
                    const T = id(sn(), t, i, h);
                    if (_r(n, T)) return n;
                }
                if (C(v)) {
                    const T = id(sn(), t, i, v);
                    if (_r(r, T)) return r;
                }
                if (C(m)) {
                    const T = id(sn(), n, a, m);
                    if (_r(t, T)) return t;
                }
                if (C(y)) {
                    const T = id(sn(), n, a, y);
                    if (_r(e, T)) return e;
                }
            }
            return null;
        }
        const l = W5(s, a) / o, f = c / o;
        return l >= -ai && l <= 1 + ai && f >= -ai && f <= 1 + ai ? [
            t[0] + l * i[0],
            t[1] + l * i[1]
        ] : null;
    }
    var Gc;
    (function(t) {
        t[t.Vertex = 0] = "Vertex", t[t.Intersection = 1] = "Intersection";
    })(Gc || (Gc = {}));
    var ia;
    (function(t) {
        t[t.Entering = 0] = "Entering", t[t.Exiting = 1] = "Exiting", t[t.Unknown = 2] = "Unknown";
    })(ia || (ia = {}));
    function RR(t, e) {
        if (t.length !== e.length) return !1;
        const n = t.length;
        if (n === 0) return !0;
        let r = !0;
        for(let a = 0; a < n; a++)if (!_r(t[a], e[a])) {
            r = !1;
            break;
        }
        if (r) return !0;
        let i = !0;
        for(let a = 0; a < n; a++)if (!_r(t[a], e[n - 1 - a])) {
            i = !1;
            break;
        }
        if (i) return !0;
        for(let a = 1; a < n; a++){
            let o = !0;
            for(let c = 0; c < n; c++)if (!_r(t[c], e[(c + a) % n])) {
                o = !1;
                break;
            }
            if (o) return !0;
            let s = !0;
            for(let c = 0; c < n; c++)if (!_r(t[c], e[(n - 1 - c + a) % n])) {
                s = !1;
                break;
            }
            if (s) return !0;
        }
        return !1;
    }
    function ty(t, e) {
        if (t.length < 3) return [];
        if (e.length < 3) return [
            t.slice()
        ];
        const n = e.slice();
        if (RR(t, e)) return [];
        const r = Fl(t), i = Fl(n);
        Math.sign(r) === Math.sign(i) && Math.abs(i) > ai && n.reverse();
        const a = [];
        for(let f = 0; f < t.length; f++){
            const u = t[f], g = t[(f + 1) % t.length];
            for(let h = 0; h < n.length; h++){
                const v = n[h], m = n[(h + 1) % n.length], y = _R(u, g, v, m);
                if (y) {
                    const C = Math.sqrt(Pl(u, g)), T = Math.sqrt(Pl(v, m));
                    a.push({
                        coord: y,
                        seg1Idx: f,
                        seg2Idx: h,
                        alpha1: C < ai ? 0 : Math.sqrt(Pl(u, y)) / C,
                        alpha2: T < ai ? 0 : Math.sqrt(Pl(v, y)) / T
                    });
                }
            }
        }
        const o = (f, u, g)=>{
            const h = [];
            let v = 0;
            for(let y = 0; y < f.length; y++){
                const C = f[y];
                h.push({
                    id: `${u}_v${v++}`,
                    coordinates: C,
                    type: Gc.Vertex,
                    originalPolyIndex: u,
                    originalVertexIndex: y,
                    next: null,
                    prev: null,
                    isIntersection: !1,
                    visited: !1
                });
                const T = g.filter((x)=>(u === 0 ? x.seg1Idx : x.seg2Idx) === y).sort((x, S)=>(u === 0 ? x.alpha1 : x.alpha2) - (u === 0 ? S.alpha1 : S.alpha2));
                for (const x of T){
                    if (h.length > 0 && _r(h[h.length - 1].coordinates, x.coord)) {
                        h[h.length - 1].isIntersection || (h[h.length - 1].isIntersection = !0, h[h.length - 1].intersectionInfo = x, h[h.length - 1].alpha = u === 0 ? x.alpha1 : x.alpha2);
                        continue;
                    }
                    h.push({
                        id: `${u}_i${v++}`,
                        coordinates: x.coord,
                        type: Gc.Intersection,
                        originalPolyIndex: u,
                        next: null,
                        prev: null,
                        isIntersection: !0,
                        visited: !1,
                        alpha: u === 0 ? x.alpha1 : x.alpha2,
                        intersectionInfo: x
                    });
                }
            }
            const m = [];
            if (h.length > 0) {
                m.push(h[0]);
                for(let y = 1; y < h.length; y++)_r(h[y].coordinates, m[m.length - 1].coordinates) ? h[y].isIntersection && (m[m.length - 1].isIntersection = !0, m[m.length - 1].intersectionInfo = h[y].intersectionInfo, m[m.length - 1].alpha = h[y].alpha) : m.push(h[y]);
            }
            if (m.length > 0) for(let y = 0; y < m.length; y++)m[y].next = m[(y + 1) % m.length], m[y].prev = m[(y - 1 + m.length) % m.length];
            return m;
        }, s = o(t, 0, a), c = o(n, 1, a);
        s.forEach((f)=>{
            if (f.isIntersection) {
                const u = f.intersectionInfo, g = c.find((h)=>h.isIntersection && _r(h.coordinates, f.coordinates) && h.intersectionInfo.seg1Idx === u.seg1Idx && h.intersectionInfo.seg2Idx === u.seg2Idx);
                if (g) {
                    f.partnerNode = g, g.partnerNode = f;
                    const h = f.prev.coordinates, v = f.coordinates, m = g.next.coordinates;
                    yi(sn(), v, h), yi(sn(), m, v);
                    const y = [
                        (f.prev.coordinates[0] + f.coordinates[0]) / 2,
                        (f.prev.coordinates[1] + f.coordinates[1]) / 2
                    ];
                    Ra(e, y) ? f.intersectionDir = ia.Exiting : f.intersectionDir = ia.Entering;
                } else f.isIntersection = !1;
            }
        }), s.forEach((f)=>delete f.intersectionInfo), c.forEach((f)=>delete f.intersectionInfo);
        const l = [];
        for(let f = 0; f < s.length; f++){
            const u = s[f];
            if (u.visited || u.isIntersection || Ra(e, u.coordinates)) continue;
            const g = [];
            let h = u, v = !0, m = 0;
            const y = (s.length + c.length) * 2;
            do {
                if (m++ > y) {
                    console.warn("Subtraction: Max iterations reached, possible infinite loop.");
                    break;
                }
                h.visited = !0, (g.length === 0 || !_r(g[g.length - 1], h.coordinates)) && g.push(h.coordinates), h.isIntersection && (v ? h.intersectionDir === ia.Entering && h.partnerNode && (h = h.partnerNode, v = !1) : h.partnerNode ? (h = h.partnerNode, v = !0) : console.warn("Subtraction: Intersection on source without partner.")), h = h.next;
            }while (h !== u || !v);
            g.length >= 3 && (_r(g[0], g[g.length - 1]) && g.pop(), g.length >= 3 && l.push(g));
        }
        return l;
    }
    function rZ(t, e) {
        if (t.length < 3 || e.length < 3) return [];
        let n = e.slice();
        const r = Fl(t), i = Fl(n);
        if (Math.abs(r) < ai || Math.abs(i) < ai) return [];
        r < 0 && (t = t.slice().reverse()), i < 0 && (n = n.slice().reverse());
        const a = n, o = [];
        for(let u = 0; u < t.length; u++){
            const g = t[u], h = t[(u + 1) % t.length];
            for(let v = 0; v < n.length; v++){
                const m = n[v], y = n[(v + 1) % n.length], C = _R(g, h, m, y);
                if (C) {
                    const T = Math.sqrt(Pl(g, h)), x = Math.sqrt(Pl(m, y));
                    o.push({
                        coord: [
                            ...C
                        ],
                        seg1Idx: u,
                        seg2Idx: v,
                        alpha1: T < ai ? 0 : Math.sqrt(Pl(g, C)) / T,
                        alpha2: x < ai ? 0 : Math.sqrt(Pl(m, C)) / x
                    });
                }
            }
        }
        if (o.length === 0) return Ra(a, t[0]) && t.every((u)=>Ra(a, u)) ? [
            [
                ...t.map((u)=>[
                        ...u
                    ])
            ]
        ] : Ra(t, n[0]) && n.every((u)=>Ra(t, u)) ? [
            [
                ...n.map((u)=>[
                        ...u
                    ])
            ]
        ] : [];
        const s = (u, g, h)=>{
            const v = [];
            let m = 0;
            for(let C = 0; C < u.length; C++){
                const T = u[C];
                v.push({
                    id: `${g}_v${m++}`,
                    coordinates: [
                        ...T
                    ],
                    type: Gc.Vertex,
                    originalPolyIndex: g,
                    originalVertexIndex: C,
                    next: null,
                    prev: null,
                    isIntersection: !1,
                    visited: !1,
                    processedInPath: !1,
                    intersectionDir: ia.Unknown
                });
                const x = h.filter((S)=>(g === 0 ? S.seg1Idx : S.seg2Idx) === C).sort((S, D)=>(g === 0 ? S.alpha1 : S.alpha2) - (g === 0 ? D.alpha1 : D.alpha2));
                for (const S of x){
                    if (v.length > 0 && _r(v[v.length - 1].coordinates, S.coord)) {
                        const D = v[v.length - 1];
                        D.isIntersection || (D.isIntersection = !0, D.intersectionInfo = S, D.alpha = g === 0 ? S.alpha1 : S.alpha2, D.type = Gc.Intersection);
                        continue;
                    }
                    v.push({
                        id: `${g}_i${m++}`,
                        coordinates: [
                            ...S.coord
                        ],
                        type: Gc.Intersection,
                        originalPolyIndex: g,
                        next: null,
                        prev: null,
                        isIntersection: !0,
                        visited: !1,
                        processedInPath: !1,
                        alpha: g === 0 ? S.alpha1 : S.alpha2,
                        intersectionInfo: S,
                        intersectionDir: ia.Unknown
                    });
                }
            }
            const y = [];
            if (v.length > 0) {
                y.push(v[0]);
                for(let C = 1; C < v.length; C++)if (!_r(v[C].coordinates, y[y.length - 1].coordinates)) y.push(v[C]);
                else {
                    const T = y[y.length - 1];
                    v[C].isIntersection && v[C].intersectionInfo && (T.isIntersection = !0, T.intersectionInfo = v[C].intersectionInfo, T.alpha = v[C].alpha, T.type = Gc.Intersection);
                }
            }
            if (y.length > 1 && _r(y[0].coordinates, y[y.length - 1].coordinates)) {
                const C = y[0], T = y.pop();
                T.isIntersection && !C.isIntersection && T.intersectionInfo && (C.isIntersection = !0, C.intersectionInfo = T.intersectionInfo, C.alpha = T.alpha, C.type = Gc.Intersection);
            }
            if (y.length > 0) for(let C = 0; C < y.length; C++)y[C].next = y[(C + 1) % y.length], y[C].prev = y[(C - 1 + y.length) % y.length];
            return y;
        }, c = s(t, 0, o), l = s(n, 1, o);
        if (c.length === 0 || l.length === 0) return [];
        c.forEach((u)=>{
            if (u.isIntersection && u.intersectionInfo) {
                const g = u.intersectionInfo, h = l.find((v)=>v.isIntersection && v.intersectionInfo && _r(v.coordinates, u.coordinates) && v.intersectionInfo.seg1Idx === g.seg1Idx && v.intersectionInfo.seg2Idx === g.seg2Idx);
                if (h) {
                    u.partnerNode = h, h.partnerNode = u;
                    const v = yi(sn(), u.coordinates, u.prev.coordinates), m = yi(sn(), h.next.coordinates, h.coordinates), y = v[0] * m[1] - v[1] * m[0];
                    if (y > ai) u.intersectionDir = ia.Entering, h.intersectionDir = ia.Exiting;
                    else if (y < -ai) u.intersectionDir = ia.Exiting, h.intersectionDir = ia.Entering;
                    else {
                        const C = [
                            (u.prev.coordinates[0] + u.coordinates[0]) / 2,
                            (u.prev.coordinates[1] + u.coordinates[1]) / 2
                        ];
                        Ra(a, C) ? (u.intersectionDir = ia.Exiting, h.intersectionDir = ia.Entering) : (u.intersectionDir = ia.Entering, h.intersectionDir = ia.Exiting);
                    }
                } else u.isIntersection = !1, u.intersectionInfo = void 0;
            }
        });
        const f = [];
        for (const u of c){
            if (!u.isIntersection || u.visited || u.intersectionDir !== ia.Entering) continue;
            let g = [], h = u, v = !0;
            const m = u;
            let y = 0;
            const C = (c.length + l.length) * 2;
            c.forEach((T)=>T.processedInPath = !1), l.forEach((T)=>T.processedInPath = !1);
            do {
                if (y++ > C) {
                    console.warn("Intersection: Max iterations in path tracing.", m.id, h.id), g = [];
                    break;
                }
                if (h.processedInPath && h !== m) {
                    console.warn("Intersection: Path processing loop detected, discarding path segment.", m.id, h.id), g = [];
                    break;
                }
                h.processedInPath = !0, h.visited = !0, (g.length === 0 || !_r(g[g.length - 1], h.coordinates)) && g.push([
                    ...h.coordinates
                ]);
                let T = !1;
                h.isIntersection && h.partnerNode && (v ? (h = h.partnerNode, v = !1, T = !0) : (h = h.partnerNode, v = !0, T = !0)), h = h.next;
            }while (h !== m || v && h.originalPolyIndex !== 0 || !v && h.originalPolyIndex !== 1);
            if (y > C || g.length === 0 || g.length > 0 && _r(g[0], g[g.length - 1]) && g.pop(), g.length >= 3) {
                const T = Fl(g);
                (r > 0 && T < 0 || r < 0 && T > 0) && g.reverse(), f.push(g.map((x)=>[
                        ...x
                    ]));
            }
        }
        return f;
    }
    function ny(t, e, n, r) {
        let i = !1;
        const a = t[0] < e[0] ? t[0] : e[0], o = t[1] < e[1] ? t[1] : e[1], s = t[0] > e[0] ? t[0] : e[0], c = t[1] > e[1] ? t[1] : e[1], l = n[0] < r[0] ? n[0] : r[0], f = n[1] < r[1] ? n[1] : r[1], u = n[0] > r[0] ? n[0] : r[0], g = n[1] > r[1] ? n[1] : r[1];
        if (a > u || s < l || o > g || c < f) return !1;
        const h = [
            U1(t, e, n),
            U1(t, e, r),
            U1(n, r, t),
            U1(n, r, e)
        ];
        return h[0] !== h[1] && h[2] !== h[3] ? !0 : ((h[0] === 0 && F1(t, n, e) || h[1] === 0 && F1(t, r, e) || h[2] === 0 && F1(n, t, r) || h[3] === 0 && F1(n, e, r)) && (i = !0), i);
    }
    function U1(t, e, n) {
        const r = (e[1] - t[1]) * (n[0] - e[0]) - (e[0] - t[0]) * (n[1] - e[1]);
        return r === 0 ? 0 : r > 0 ? 1 : 2;
    }
    function F1(t, e, n) {
        return e[0] <= Math.max(t[0], n[0]) && e[0] >= Math.min(t[0], n[0]) && e[1] <= Math.max(t[1], n[1]) && e[1] >= Math.min(t[1], n[1]);
    }
    function ry(t, e, n, r = !0) {
        const i = [], a = t.length, o = a - (r ? 1 : 2);
        for(let s = 0; s <= o; s++){
            const c = t[s], l = s === a - 1 ? 0 : s + 1, f = t[l];
            ny(e, n, c, f) && i.push([
                s,
                l
            ]);
        }
        return i;
    }
    function OR(t, e, n, r = !0) {
        let i, a;
        r ? (a = t.length - 1, i = 0) : (a = 0, i = 1);
        for(let o = i; o < t.length; o++){
            const s = t[a], c = t[o];
            if (ny(e, n, s, c)) return [
                a,
                o
            ];
            a = o;
        }
    }
    function iy(t, e) {
        for(let n = 0, r = t.length; n < r; n++){
            const i = t[n], a = n === r - 1 ? 0 : n + 1, o = t[a];
            if (OR(e, i, o)?.length === 2) return !0;
        }
        return !1;
    }
    const iZ = .01;
    function IR(t, e, n, r) {
        const i = [
            e[0] - t[0],
            e[1] - t[1]
        ], a = [
            r[0] - n[0],
            r[1] - n[1]
        ], o = a[1] * i[0] - a[0] * i[1];
        if ((o >= 0 ? o : -o) < iZ) {
            const v = [
                t[0] < e[0] ? t[0] : e[0],
                t[0] > e[0] ? t[0] : e[0],
                t[1] < e[1] ? t[1] : e[1],
                t[1] > e[1] ? t[1] : e[1]
            ], m = [
                n[0] < r[0] ? n[0] : r[0],
                n[0] > r[0] ? n[0] : r[0],
                n[1] < r[1] ? n[1] : r[1],
                n[1] > r[1] ? n[1] : r[1]
            ];
            if (!(v[0] <= m[1] && v[1] >= m[0] && v[2] <= m[3] && v[3] >= m[2]) || !(G5(t, e, n) || G5(t, e, r) || G5(n, r, t))) return;
            const T = v[0] > m[0] ? v[0] : m[0], x = v[1] < m[1] ? v[1] : m[1], S = v[2] > m[2] ? v[2] : m[2], D = v[3] < m[3] ? v[3] : m[3], _ = (T + x) * .5, M = (S + D) * .5;
            return [
                _,
                M
            ];
        }
        let c = t[1] - n[1], l = t[0] - n[0];
        const f = a[0] * c - a[1] * l, u = i[0] * c - i[1] * l;
        c = f / o, l = u / o;
        const g = t[0] + c * i[0], h = t[1] + c * i[1];
        return [
            g,
            h
        ];
    }
    var V0;
    (function(t) {
        t[t.Vertex = 0] = "Vertex", t[t.Intersection = 1] = "Intersection";
    })(V0 || (V0 = {}));
    var N0;
    (function(t) {
        t[t.Outside = -1] = "Outside", t[t.Edge = 0] = "Edge", t[t.Inside = 1] = "Inside";
    })(N0 || (N0 = {}));
    var Lu;
    (function(t) {
        t[t.Exiting = -1] = "Exiting", t[t.Unknown = 0] = "Unknown", t[t.Entering = 1] = "Entering";
    })(Lu || (Lu = {}));
    function Sw(t) {
        for(let e = 0, n = t.length; e < n; e++){
            const r = t[e];
            r.next || (r.next = t[e === n - 1 ? 0 : e + 1]);
        }
    }
    function aZ(t, e) {
        const n = [], r = [], i = new Map;
        let o = Ra(e, t[0]) ? Lu.Exiting : Lu.Entering;
        for(let s = 0, c = t.length; s < c; s++){
            const l = t[s], f = Ra(e, l), u = {
                type: V0.Vertex,
                coordinates: l,
                position: f ? N0.Inside : N0.Outside,
                visited: !1,
                next: null
            };
            n.push(u);
            const g = t[s === c - 1 ? 0 : s + 1], h = ry(e, l, g).map((v)=>{
                const m = v[0], y = e[v[0]], C = e[v[1]], T = IR(l, g, y, C), x = $0(l, T);
                return {
                    sourceLineSegmentId: m,
                    coordinate: T,
                    targetStartPointDistSquared: x
                };
            });
            h.sort((v, m)=>v.targetStartPointDistSquared - m.targetStartPointDistSquared), h.forEach((v)=>{
                const { sourceLineSegmentId: m, coordinate: y } = v, C = {
                    type: V0.Intersection,
                    coordinates: y,
                    position: N0.Edge,
                    direction: o,
                    visited: !1,
                    next: null
                }, T = {
                    ...C,
                    direction: Lu.Unknown,
                    cloned: !0
                };
                o === Lu.Entering ? C.next = T : T.next = C;
                let x = i.get(m);
                x || (x = [], i.set(m, x)), n.push(C), x.push(T), o *= -1;
            });
        }
        for(let s = 0, c = e.length; s < c; s++){
            const l = s, f = e[s], u = {
                type: V0.Vertex,
                coordinates: f,
                visited: !1,
                next: null
            };
            r.push(u);
            const g = i.get(l);
            g?.length && g.map((h)=>({
                    intersectionPoint: h,
                    lineSegStartDistSquared: $0(f, h.coordinates)
                })).sort((h, v)=>h.lineSegStartDistSquared - v.lineSegStartDistSquared).map(({ intersectionPoint: h })=>h).forEach((h)=>r.push(h));
        }
        return Sw(n), Sw(r), {
            targetPolylinePoints: n,
            sourcePolylinePoints: r
        };
    }
    function oZ(t) {
        for(let e = 0, n = t.length; e < n; e++){
            const r = t[e];
            if (!r.visited && r.position === N0.Outside && r.type === V0.Vertex) return r;
        }
        for(let e = 0, n = t.length; e < n; e++){
            const r = t[e];
            if (!r.visited && r.position === N0.Outside) return r;
        }
    }
    function ay(t, e) {
        const n = t3(t), r = t3(e), i = xt(r, n);
        if (Gh(1, i) || (e = e.slice().reverse()), !iy(e, t) && lg(e, t)) return e.slice();
        const { targetPolylinePoints: s } = aZ(t, e), c = oZ(s);
        if (!c) return t.slice();
        const l = [
            c.coordinates
        ];
        let f = c.next, u = 0;
        const g = t.length + e.length + 1e3;
        for(; f !== c && u < g;){
            if (u++, f.type === V0.Intersection && f.cloned) {
                f = f.next;
                continue;
            }
            if (l.push(f.coordinates), f = f.next, !f) {
                console.warn("Broken linked list detected in mergePolylines, breaking loop");
                break;
            }
        }
        return u >= g && console.warn("Maximum iterations reached in mergePolylines, possible infinite loop detected"), l;
    }
    const sZ = .1;
    function MR(t, e = sZ) {
        const n = t.length;
        if (n < 3) return t;
        const r = e * e, i = [
            [
                0,
                n - 1
            ]
        ], a = new Array(n).fill(!1);
        let o = 2;
        for(a[0] = !0, a[n - 1] = !0; i.length;){
            const [c, l] = i.pop();
            if (l - c === 1) continue;
            const f = t[c], u = t[l];
            let g = -1 / 0, h = -1;
            for(let v = c + 1; v < l; v++){
                const m = t[v], y = ey(f, u, m);
                y > g && (g = y, h = v);
            }
            g < r || (a[h] = !0, o++, i.push([
                h,
                l
            ]), i.push([
                c,
                h
            ]));
        }
        const s = new Array(o);
        for(let c = 0, l = 0; c < n; c++)a[c] && (s[l++] = t[c]);
        return s;
    }
    function bR(t, e, n, r = !0) {
        const i = [], a = ry(t, e, n, r);
        for(let o = 0; o < a.length; o++){
            const s = t[a[o][0]], c = t[a[o][1]], l = IR(e, n, s, c);
            i.push(l);
        }
        return i;
    }
    function cZ(t, e, n, r = !0) {
        let i, a;
        r ? (a = t.length - 1, i = 0) : (a = 0, i = 1);
        const o = [];
        for(let f = i; f < t.length; f++){
            const u = t[a], g = t[f];
            ny(e, n, u, g) && o.push([
                a,
                f
            ]), a = f;
        }
        if (o.length === 0) return;
        const s = [];
        o.forEach((f)=>{
            const u = [
                t[f[0]],
                t[f[1]]
            ], g = [
                (u[0][0] + u[1][0]) / 2,
                (u[0][1] + u[1][1]) / 2
            ];
            s.push(Or(g, e));
        });
        const c = Math.min(...s), l = s.indexOf(c);
        return {
            segment: o[l],
            distance: c
        };
    }
    const Tu = .001, lZ = (t, e)=>{
        let n, r, i;
        if (t instanceof ua) {
            const o = t.getImageData();
            if (!o) return;
            r = o.direction.slice(0, 3), i = o.direction.slice(3, 6), n = o.spacing;
        } else {
            const o = t.getImageData(), { direction: s, spacing: c } = o, { viewPlaneNormal: l, viewUp: f } = t.getCamera(), u = s.slice(0, 3), g = s.slice(3, 6), h = s.slice(6, 9), v = Xe();
            bn(v, f, l);
            const m = Math.abs(xt(v, u)), y = Math.abs(xt(v, g)), C = Math.abs(xt(v, h));
            let T;
            if (Math.abs(1 - m) < Tu) T = c[0], r = u;
            else if (Math.abs(1 - y) < Tu) T = c[1], r = g;
            else if (Math.abs(1 - C) < Tu) T = c[2], r = h;
            else throw new Error("No support yet for oblique plane planar contours");
            const x = Math.abs(xt(f, u)), S = Math.abs(xt(f, g)), D = Math.abs(xt(f, h));
            let _;
            if (Math.abs(1 - x) < Tu) _ = c[0], i = u;
            else if (Math.abs(1 - S) < Tu) _ = c[1], i = g;
            else if (Math.abs(1 - D) < Tu) _ = c[2], i = h;
            else throw new Error("No support yet for oblique plane planar contours");
            n = [
                T,
                _
            ];
        }
        return {
            spacing: [
                n[0] / e,
                n[1] / e
            ],
            xDir: r,
            yDir: i
        };
    }, uZ = (t, e, n)=>z3(t, e) < n, fZ = (t, e, n, r)=>{
        const { xDir: i, yDir: a, spacing: o } = r, s = Fe(t), { viewport: c } = s;
        if (!e.length) return e.push(n), console.log(">>>>> !canvasPoints. :: RETURN"), 1;
        const l = c.canvasToWorld(e[e.length - 1]), f = c.canvasToWorld(n), u = Xe();
        kr(u, f, l);
        const g = Math.abs(xt(u, i)), h = Math.abs(xt(u, a)), v = Math.max(Math.floor(g / o[0]), Math.floor(h / o[0]));
        if (v > 1) {
            const m = e[e.length - 1], y = z3(m, n), C = sn();
            yi(C, n, m), qo(C, C[0] / y, C[1] / y);
            const T = y / v;
            for(let x = 1; x <= v; x++)e.push([
                m[0] + T * C[0] * x,
                m[1] + T * C[1] * x
            ]);
        } else e.push(n);
        return v;
    }, dZ = (t, e, n, r)=>{
        const i = [
            t[0] - e[0],
            t[1] - e[1]
        ], a = [
            n[0] - e[0],
            n[1] - e[1]
        ], o = i[0] * a[0] + i[1] * a[1];
        if (o < 0) return !1;
        const s = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
        if (s === 0) return !1;
        const c = o / s, l = [
            a[0] / s,
            a[1] / s
        ], f = [
            l[0] * c,
            l[1] * c
        ], u = [
            e[0] + f[0],
            e[1] + f[1]
        ];
        return !(Or(t, u) > r || Or(e, u) > Or(e, n));
    }, gZ = 1e-6;
    function LR(t) {
        let e;
        const n = G4(t, 50);
        for(let o = 0; o < 3; o++)if (n.every((s, c, l)=>Math.abs(s[o] - l[0][o]) < gZ)) {
            e = o;
            break;
        }
        if (e === void 0) throw new Error("Cannot find a shared dimension index for polyline, probably oblique plane");
        const r = [], i = (e + 1) % 3, a = (e + 2) % 3;
        for(let o = 0; o < t.length; o++)r.push([
            t[o][i],
            t[o][a]
        ]);
        return {
            sharedDimensionIndex: e,
            projectedPolyline: r
        };
    }
    function hZ(t, e, n = {}) {
        const { sharedDimensionIndex: r, projectedPolyline: i } = LR(e), { holes: a } = n, o = [];
        if (a) for(let c = 0; c < a.length; c++){
            const l = a[c], f = [];
            for(let u = 0; u < l.length; u++)f.push([
                l[u][(r + 1) % 3],
                l[u][(r + 2) % 3]
            ]);
            o.push(f);
        }
        const s = [
            t[(r + 1) % 3],
            t[(r + 2) % 3]
        ];
        return Ra(i, s, {
            holes: o
        });
    }
    function pZ(t) {
        if (t.length < 3) return t.slice();
        const e = t.map((a)=>[
                a[0],
                a[1]
            ]).sort((a, o)=>a[0] === o[0] ? a[1] - o[1] : a[0] - o[0]);
        function n(a, o, s) {
            return (o[0] - a[0]) * (s[1] - a[1]) - (o[1] - a[1]) * (s[0] - a[0]);
        }
        const r = [];
        for (const a of e){
            for(; r.length >= 2 && n(r[r.length - 2], r[r.length - 1], a) <= 0;)r.pop();
            r.push(a);
        }
        const i = [];
        for(let a = e.length - 1; a >= 0; a--){
            const o = e[a];
            for(; i.length >= 2 && n(i[i.length - 2], i[i.length - 1], o) <= 0;)i.pop();
            i.push(o);
        }
        return r.pop(), i.pop(), r.concat(i);
    }
    const H0 = Object.freeze(Object.defineProperty({
        __proto__: null,
        addCanvasPointsToArray: fZ,
        arePolylinesIdentical: RR,
        containsPoint: Ra,
        containsPoints: lg,
        convexHull: pZ,
        decimate: MR,
        getAABB: kd,
        getArea: r2,
        getClosestLineSegmentIntersection: cZ,
        getFirstLineSegmentIntersectionIndexes: OR,
        getLineSegmentIntersectionsCoordinates: bR,
        getLineSegmentIntersectionsIndexes: ry,
        getNormal2: t3,
        getNormal3: nZ,
        getSignedArea: Fl,
        getSubPixelSpacingAndXYDirections: lZ,
        getWindingDirection: Th,
        intersectPolyline: iy,
        intersectPolylines: rZ,
        isClosed: DR,
        isPointInsidePolyline3D: hZ,
        mergePolylines: ay,
        pointCanProjectOnLine: dZ,
        pointsAreWithinCloseContourProximity: uZ,
        projectTo2D: LR,
        subtractPolylines: ty
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function mZ(t, e, n, r) {
        const i = [
            t,
            e
        ], a = [
            t + n,
            e
        ], o = [
            t + n,
            e
        ], s = [
            t + n,
            e + r
        ], c = [
            t + n,
            e + r
        ], l = [
            t,
            e + r
        ], f = [
            t,
            e + r
        ];
        return {
            top: [
                i,
                a
            ],
            right: [
                o,
                s
            ],
            bottom: [
                c,
                l
            ],
            left: [
                f,
                [
                    t,
                    e
                ]
            ]
        };
    }
    function vZ(t, e) {
        if (t.length !== 4 || e.length !== 2) throw Error("rectangle:[left, top, width, height] or point: [x,y] not defined correctly");
        const [n, r, i, a] = t;
        let o = 655535;
        const s = mZ(n, r, i, a);
        return Object.keys(s).forEach((c)=>{
            const [l, f] = s[c], u = Cs(l, f, e);
            u < o && (o = u);
        }), o;
    }
    function Ew(t, e) {
        let n = [
            0,
            0
        ], r = Number.MAX_SAFE_INTEGER;
        return t.forEach(function(i) {
            const a = yZ(e, i);
            a < r && (r = a, n = [
                ...i
            ]);
        }), n;
    }
    function yZ(t, e) {
        const [n, r] = t, [i, a] = e;
        return Math.sqrt(Math.pow(n - i, 2) + Math.pow(r - a, 2));
    }
    function CZ(t, e) {
        const [n, r] = t, [i, a] = e, o = In(Xe(), r, n), s = In(Xe(), i, a), c = xt(o, s), l = Xa(o), f = Xa(s), u = c / (l * f);
        return Math.acos(u) * 180 / Math.PI;
    }
    function wZ(t, e) {
        const [n, r] = t, [i, a] = e, o = Yu(sn(), r, n), s = Yu(sn(), i, a), c = kc(o, s), l = Rv(o), f = Rv(s), u = c / (l * f);
        return Math.acos(u) * (180 / Math.PI);
    }
    function xh(t, e) {
        return t[0].length === 3 ? CZ(t, e) : wZ(t, e);
    }
    function uc(t, e, n, r) {
        const { canvasToWorld: i, worldToCanvas: a } = n, { data: o } = t, { targetWindingDirection: s } = e;
        let { points: c } = e, l = Th(c);
        r?.decimate?.enabled && (c = MR(e.points, r?.decimate?.epsilon));
        let { closed: f } = e;
        const u = c.length, g = new Array(u);
        Th(c);
        const h = P_(t);
        if (f === void 0) {
            let v = !1;
            if (c.length > 3) {
                const m = $0(c[0], c[u - 1]);
                v = lr(0, m);
            }
            f = v;
        }
        if (r?.updateWindingDirection !== !1) {
            let v = h ? h.data.contour.windingDirection * -1 : s;
            v === void 0 && (v = l), v !== l && c.reverse();
            const m = (o.handles?.points ?? []).map(a);
            m.length > 2 && Th(m) !== v && o.handles.points.reverse(), l = v;
        }
        for(let v = 0; v < u; v++)g[v] = i(c[v]);
        o.contour.polyline = g, o.contour.closed = f, o.contour.windingDirection = l, V_(t);
    }
    const TZ = "viewport-element";
    function xZ(t) {
        const e = Fe(t), { viewportId: n, renderingEngineId: r } = e, i = `${n}:${r}`, a = SZ(t);
        return Object.keys(nt.svgNodeCache[i]).forEach((o)=>{
            nt.svgNodeCache[i][o].touched = !1;
        }), {
            svgLayerElement: a,
            svgNodeCacheForCanvas: nt.svgNodeCache,
            getSvgNode: EZ.bind(this, i),
            appendNode: DZ.bind(this, a, i),
            setNodeTouched: _Z.bind(this, i),
            clearUntouched: RZ.bind(this, a, i)
        };
    }
    function SZ(t) {
        const e = `.${TZ}`;
        return t.querySelector(e)?.querySelector(":scope > .svg-layer");
    }
    function EZ(t, e) {
        if (nt.svgNodeCache[t] && nt.svgNodeCache[t][e]) return nt.svgNodeCache[t][e].domRef;
    }
    function DZ(t, e, n, r) {
        if (!nt.svgNodeCache[e]) return null;
        nt.svgNodeCache[e][r] = {
            touched: !0,
            domRef: n
        }, t.appendChild(n);
    }
    function _Z(t, e) {
        nt.svgNodeCache[t] && nt.svgNodeCache[t][e] && (nt.svgNodeCache[t][e].touched = !0);
    }
    function RZ(t, e) {
        nt.svgNodeCache[e] && Object.keys(nt.svgNodeCache[e]).forEach((n)=>{
            const r = nt.svgNodeCache[e][n];
            !r.touched && r.domRef && (t.removeChild(r.domRef), delete nt.svgNodeCache[e][n]);
        });
    }
    function OZ(t, e) {
        const n = xZ(t);
        e(n), n.clearUntouched();
    }
    function Zl(t, e, n) {
        return `${t}::${e}::${n}`;
    }
    function ac(t, e) {
        Object.keys(t).forEach((n)=>{
            const r = e.getAttribute(n), i = t[n];
            i === void 0 || i === "" ? e.removeAttribute(n) : r !== i && e.setAttribute(n, i);
        });
    }
    function K0(t, e) {
        Object.keys(t).forEach((n)=>{
            const r = t[n];
            r !== void 0 && r !== "" && e.setAttribute(n, r);
        });
    }
    function n3(t, e, n, r, i, a = {}, o = "") {
        const { color: s, fill: c, width: l, lineWidth: f, lineDash: u, fillOpacity: g, strokeOpacity: h } = Object.assign({
            color: "rgb(0, 255, 0)",
            fill: "transparent",
            width: "2",
            lineDash: void 0,
            lineWidth: void 0,
            strokeOpacity: 1,
            fillOpacity: 1
        }, a), v = f || l, m = "http://www.w3.org/2000/svg", y = Zl(e, "circle", n), C = t.getSvgNode(y), T = {
            cx: `${r[0]}`,
            cy: `${r[1]}`,
            r: `${i}`,
            stroke: s,
            fill: c,
            "stroke-width": v,
            "stroke-dasharray": u,
            "fill-opacity": g,
            "stroke-opacity": h
        };
        if (C) ac(T, C), t.setNodeTouched(y);
        else {
            const x = document.createElementNS(m, "circle");
            o !== "" && x.setAttribute("data-id", o), K0(T, x), t.appendNode(x, y);
        }
    }
    function IZ(t, e, n, r, i = {}, a = "") {
        const { color: o, width: s, lineWidth: c, lineDash: l } = Object.assign({
            color: "rgb(0, 255, 0)",
            width: "2",
            lineWidth: void 0,
            lineDash: void 0
        }, i), f = c || s, u = "http://www.w3.org/2000/svg", g = Zl(e, "ellipse", n), h = t.getSvgNode(g), [v, m, y, C] = r, T = Math.hypot(y[0] - C[0], y[1] - C[1]), x = Math.hypot(m[0] - v[0], m[1] - v[1]), S = Math.atan2(y[1] - C[1], y[0] - C[0]) * 180 / Math.PI, D = [
            (y[0] + C[0]) / 2,
            (m[1] + v[1]) / 2
        ], _ = T / 2, M = x / 2, P = {
            cx: `${D[0]}`,
            cy: `${D[1]}`,
            rx: `${_}`,
            ry: `${M}`,
            stroke: o,
            fill: "transparent",
            transform: `rotate(${S} ${D[0]} ${D[1]})`,
            "stroke-width": f,
            "stroke-dasharray": l
        };
        if (h) ac(P, h), t.setNodeTouched(g);
        else {
            const F = document.createElementNS(u, "ellipse");
            a !== "" && F.setAttribute("data-id", a), K0(P, F), t.appendNode(F, g);
        }
    }
    function MZ(t, e, n, r, i = {}, a) {
        const { color: o, handleRadius: s, width: c, lineWidth: l, fill: f, type: u, opacity: g } = Object.assign({
            color: "rgb(0, 255, 0)",
            handleRadius: "6",
            width: "2",
            lineWidth: void 0,
            fill: "transparent",
            type: "circle",
            opacity: 1
        }, i), h = l || c, v = "http://www.w3.org/2000/svg", m = Zl(e, "handle", `hg-${n}-index-${a}`);
        let y;
        if (u === "circle") y = {
            cx: `${r[0]}`,
            cy: `${r[1]}`,
            r: s,
            stroke: o,
            fill: f,
            "stroke-width": h,
            opacity: g
        };
        else if (u === "rect") {
            const x = parseFloat(s) * 1.5, S = r[0] - x * .5, D = r[1] - x * .5;
            y = {
                x: `${S}`,
                y: `${D}`,
                width: `${x}`,
                height: `${x}`,
                stroke: o,
                fill: f,
                "stroke-width": h,
                rx: `${x * .1}`,
                opacity: g
            };
        } else throw new Error(`Unsupported handle type: ${u}`);
        const C = t.getSvgNode(m);
        if (C) ac(y, C), t.setNodeTouched(m);
        else {
            const T = document.createElementNS(v, u);
            K0(y, T), t.appendNode(T, m);
        }
    }
    function Do(t, e, n, r, i = {}) {
        r.forEach((a, o)=>{
            MZ(t, e, n, a, i, o);
        });
    }
    function Oa(t, e, n, r, i, a = {}, o = "") {
        if (isNaN(r[0]) || isNaN(r[1]) || isNaN(i[0]) || isNaN(i[1])) return;
        const { color: s = "rgb(0, 255, 0)", width: c = 10, lineWidth: l, lineDash: f, markerStartId: u = null, markerEndId: g = null, shadow: h = !1, strokeOpacity: v = 1 } = a, m = l || c, y = "http://www.w3.org/2000/svg", C = Zl(e, "line", n), T = t.getSvgNode(C), x = t.svgLayerElement.id, S = h ? `filter:url(#shadow-${x});` : "", D = {
            x1: `${r[0]}`,
            y1: `${r[1]}`,
            x2: `${i[0]}`,
            y2: `${i[1]}`,
            stroke: s,
            style: S,
            "stroke-width": m,
            "stroke-dasharray": f,
            "marker-start": u ? `url(#${u})` : "",
            "marker-end": g ? `url(#${g})` : "",
            "stroke-opacity": v
        };
        if (T) ac(D, T), t.setNodeTouched(C);
        else {
            const _ = document.createElementNS(y, "line");
            o !== "" && _.setAttribute("data-id", o), K0(D, _), t.appendNode(_, C);
        }
    }
    function Yc(t, e, n, r, i) {
        if (r.length < 2) return;
        const { color: a = "rgb(0, 255, 0)", width: o = 10, fillColor: s = "none", fillOpacity: c = 0, lineWidth: l, lineDash: f, closePath: u = !1, markerStartId: g = null, markerEndId: h = null } = i, v = l || o, m = "http://www.w3.org/2000/svg", y = Zl(e, "polyline", n), C = t.getSvgNode(y);
        let T = "";
        for (const S of r)T += `${S[0].toFixed(1)}, ${S[1].toFixed(1)} `;
        if (u) {
            const S = r[0];
            T += `${S[0]}, ${S[1]}`;
        }
        const x = {
            points: T,
            stroke: a,
            fill: s,
            "fill-opacity": c,
            "stroke-width": v,
            "stroke-dasharray": f,
            "marker-start": g ? `url(#${g})` : "",
            "marker-end": h ? `url(#${h})` : ""
        };
        if (C) ac(x, C), t.setNodeTouched(y);
        else {
            const S = document.createElementNS(m, "polyline");
            K0(x, S), t.appendNode(S, y);
        }
    }
    function A0(t, e, n, r, i) {
        const o = r.length && r[0].length && Array.isArray(r[0][0]) ? r : [
            r
        ], { color: s = "rgb(0, 255, 0)", width: c = 10, fillColor: l = "none", fillOpacity: f = 0, lineWidth: u, lineDash: g, closePath: h = !1 } = i, v = u || c, m = "http://www.w3.org/2000/svg", y = Zl(e, "path", n), C = t.getSvgNode(y);
        let T = "";
        for(let S = 0, D = o.length; S < D; S++){
            const _ = o[S], M = _.length;
            if (!(M < 2)) {
                for(let P = 0; P < M; P++){
                    const F = _[P];
                    T += `${P ? "L" : "M"} ${F[0].toFixed(1)}, ${F[1].toFixed(1)} `;
                }
                h && (T += "Z ");
            }
        }
        if (!T) return;
        const x = {
            d: T,
            stroke: s,
            fill: l,
            "fill-opacity": f,
            "stroke-width": v,
            "stroke-dasharray": g
        };
        if (C) ac(x, C), t.setNodeTouched(y);
        else {
            const S = document.createElementNS(m, "path");
            K0(x, S), t.appendNode(S, y);
        }
    }
    function yp(t, e, n, r, i, a = {}) {
        const o = Object.assign({
            fontFamily: "Helvetica, Arial, sans-serif",
            fontSize: "14px",
            color: "rgb(255, 255, 0)",
            background: "",
            padding: 25,
            centerX: !1,
            centerY: !0
        }, a);
        return bZ(t, e, n, r, i, o);
    }
    function bZ(t, e, n, r = [
        ""
    ], i, a) {
        const { padding: o, color: s, fontFamily: c, fontSize: l, background: f } = a;
        let u;
        const [g, h] = [
            i[0] + o,
            i[1] + o
        ], v = "http://www.w3.org/2000/svg", m = Zl(e, "text", n), y = t.getSvgNode(m);
        if (y) {
            const C = y.querySelector("text"), T = Array.from(C.children);
            for(let D = 0; D < T.length; D++){
                const _ = T[D], M = r[D] || "";
                _.textContent = M;
            }
            if (r.length > T.length) {
                for(let D = 0; D < r.length - T.length; D++){
                    const _ = r[D + T.length], M = Dw(_);
                    C.appendChild(M);
                }
                y.appendChild(C), t.appendNode(y, m);
            }
            const x = {
                fill: s,
                "font-size": l,
                "font-family": c
            }, S = {
                transform: `translate(${g} ${h})`
            };
            ac(x, C), ac(S, y), y.setAttribute("data-annotation-uid", e), u = _w(y, f), t.setNodeTouched(m);
        } else {
            const C = document.createElementNS(v, "g");
            C.setAttribute("data-annotation-uid", e), C.setAttribute("transform", `translate(${g} ${h})`);
            const T = LZ(t, a);
            for(let x = 0; x < r.length; x++){
                const S = r[x], D = Dw(S);
                T.appendChild(D);
            }
            C.appendChild(T), t.appendNode(C, m), u = _w(C, f);
        }
        return Object.assign({}, u, {
            x: g,
            y: h,
            height: u.height + o,
            width: u.width + o
        });
    }
    function LZ(t, e) {
        const { color: n, fontFamily: r, fontSize: i } = e, o = document.createElementNS("http://www.w3.org/2000/svg", "text"), s = "user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);", c = `filter:url(#shadow-${t.svgLayerElement.id});`, l = `${s}${c}`;
        return o.setAttribute("x", "0"), o.setAttribute("y", "0"), o.setAttribute("fill", n), o.setAttribute("font-family", r), o.setAttribute("font-size", i), o.setAttribute("style", l), o.setAttribute("pointer-events", "visible"), o;
    }
    function Dw(t) {
        const n = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        return n.setAttribute("x", "0"), n.setAttribute("dy", "1.2em"), n.textContent = t, n;
    }
    function _w(t, e) {
        let n = t.querySelector("rect.background");
        if (!e) return n && t.removeChild(n), t.getBBox();
        n || (n = document.createElementNS("http://www.w3.org/2000/svg", "rect"), n.setAttribute("class", "background"), t.insertBefore(n, t.firstChild));
        const r = t.getBBox(), i = {
            x: `${r.x}`,
            y: `${r.y}`,
            width: `${r.width}`,
            height: `${r.height}`,
            fill: e
        };
        return ac(i, n), r;
    }
    function PZ(t, e, n, r, i, a, o = {}) {
        const s = r.length > 0 ? Ew(r, i) : i, c = VZ(a), l = Ew(c, s), f = Object.assign({
            color: "rgb(255, 255, 0)",
            lineWidth: "1",
            lineDash: "2,3"
        }, o);
        Oa(t, e, `link-${n}`, s, l, f);
    }
    function VZ(t) {
        const { x: e, y: n, height: r, width: i } = t, a = i / 2, o = r / 2, s = [
            e + a,
            n
        ], c = [
            e,
            n + o
        ], l = [
            e + a,
            n + r
        ], f = [
            e + i,
            n + o
        ];
        return [
            s,
            c,
            l,
            f
        ];
    }
    function fc(t, e, n, r, i, a, o, s = {}) {
        const c = Object.assign({
            handleRadius: "6",
            centering: {
                x: !1,
                y: !0
            }
        }, s), l = yp(t, e, n, r, i, c);
        return PZ(t, e, n, a, i, l, c), l;
    }
    function NZ(t, e, n, r, i = {}, a = "") {
        const { color: o, width: s, lineWidth: c, lineDash: l } = Object.assign({
            color: "rgb(0, 255, 0)",
            width: "2",
            lineWidth: void 0,
            lineDash: void 0
        }, i), f = c || s, u = "http://www.w3.org/2000/svg", g = Zl(e, "rect", n), h = t.getSvgNode(g), [v, m, y, C] = r, T = Math.hypot(v[0] - m[0], v[1] - m[1]), x = Math.hypot(v[0] - y[0], v[1] - y[1]), S = [
            (C[0] + v[0]) / 2,
            (C[1] + v[1]) / 2
        ], D = [
            (y[0] + v[0]) / 2,
            (y[1] + v[1]) / 2
        ], _ = Math.atan2(S[1] - D[1], S[0] - D[0]) * 180 / Math.PI, M = {
            x: `${S[0] - T / 2}`,
            y: `${S[1] - x / 2}`,
            width: `${T}`,
            height: `${x}`,
            stroke: o,
            fill: "transparent",
            transform: `rotate(${_} ${S[0]} ${S[1]})`,
            "stroke-width": f,
            "stroke-dasharray": l
        };
        if (h) ac(M, h), t.setNodeTouched(g);
        else {
            const P = document.createElementNS(u, "rect");
            a !== "" && P.setAttribute("data-id", a), K0(M, P), t.appendNode(P, g);
        }
    }
    const Rw = "http://www.w3.org/2000/svg";
    function Ow(t, e, n, r, i, a = {}) {
        if (isNaN(r[0]) || isNaN(r[1]) || isNaN(i[0]) || isNaN(i[1])) return;
        const { viaMarker: o = !1, color: s = "rgb(0, 255, 0)", markerSize: c = 10 } = a;
        if (!o) {
            AZ(t, e, n, r, i, a);
            return;
        }
        const l = t.svgLayerElement.id, u = `${`arrow-${e}`}-${l}`, g = t.svgLayerElement.querySelector("defs");
        let h = g.querySelector(`#${u}`);
        if (h) {
            h.setAttribute("markerWidth", `${c}`), h.setAttribute("markerHeight", `${c}`);
            const v = h.querySelector("path");
            v && v.setAttribute("fill", s);
        } else {
            h = document.createElementNS(Rw, "marker"), h.setAttribute("id", u), h.setAttribute("viewBox", "0 0 10 10"), h.setAttribute("refX", "8"), h.setAttribute("refY", "5"), h.setAttribute("markerWidth", `${c}`), h.setAttribute("markerHeight", `${c}`), h.setAttribute("orient", "auto");
            const v = document.createElementNS(Rw, "path");
            v.setAttribute("d", "M 0 0 L 10 5 L 0 10 z"), v.setAttribute("fill", s), h.appendChild(v), g.appendChild(h);
        }
        a.markerEndId = u, Oa(t, e, n, r, i, a);
    }
    function AZ(t, e, n, r, i, a = {}) {
        const { color: o = "rgb(0, 255, 0)", width: s = 2, lineWidth: c, lineDash: l } = a, f = 10, u = Math.atan2(i[1] - r[1], i[0] - r[0]), g = {
            start: [
                i[0] - f * Math.cos(u - Math.PI / 7),
                i[1] - f * Math.sin(u - Math.PI / 7)
            ],
            end: i
        }, h = {
            start: [
                i[0] - f * Math.cos(u + Math.PI / 7),
                i[1] - f * Math.sin(u + Math.PI / 7)
            ],
            end: i
        };
        Oa(t, e, n, r, i, {
            color: o,
            width: s,
            lineWidth: c,
            lineDash: l
        }), Oa(t, e, "2", g.start, g.end, {
            color: o,
            width: s,
            lineWidth: c,
            lineDash: l
        }), Oa(t, e, "3", h.start, h.end, {
            color: o,
            width: s,
            lineWidth: c,
            lineDash: l
        });
    }
    function kZ(t, e) {
        const n = Fe(t), { renderingEngineId: r, viewportId: i } = n, a = ha(i, r);
        if (!a) return [];
        const o = [], s = Object.keys(a.toolOptions);
        for(let c = 0; c < s.length; c++){
            const l = s[c], f = a.toolOptions[l];
            if (f && e.includes(f.mode)) {
                const u = a.getToolInstance(l);
                o.push(u);
            }
        }
        return o;
    }
    const { Active: UZ, Passive: FZ, Enabled: BZ } = er;
    class GZ {
        constructor(){
            this._needsRender = new Set, this._animationFrameSet = !1, this._animationFrameHandle = null, this._renderFlaggedViewports = ()=>{
                this._throwIfDestroyed();
                const e = Array.from(this._viewportElements.values());
                for(let n = 0; n < e.length; n++){
                    const r = e[n];
                    if (this._needsRender.has(r) && (this._triggerRender(r), this._needsRender.delete(r), this._needsRender.size === 0)) break;
                }
                this._animationFrameSet = !1, this._animationFrameHandle = null, this._render();
            }, this._viewportElements = new Map;
        }
        addViewportElement(e, n) {
            this._viewportElements.set(e, n);
        }
        removeViewportElement(e, n) {
            this._viewportElements.delete(e), this._needsRender.delete(n), this._reset();
        }
        renderViewport(e) {
            this._setViewportsToBeRenderedNextFrame([
                e
            ]);
        }
        _throwIfDestroyed() {
            if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
        }
        _setAllViewportsToBeRenderedNextFrame() {
            [
                ...this._viewportElements.values()
            ].forEach((n)=>{
                this._needsRender.add(n);
            }), this._renderFlaggedViewports();
        }
        _setViewportsToBeRenderedNextFrame(e) {
            const n = [
                ...this._viewportElements.values()
            ];
            e.forEach((r)=>{
                n.indexOf(r) !== -1 && this._needsRender.add(r);
            }), this._render();
        }
        _render() {
            this._needsRender.size > 0 && this._animationFrameSet === !1 && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports), this._animationFrameSet = !0);
        }
        _triggerRender(e) {
            const n = Fe(e);
            if (!n) return;
            if (!ws(n.renderingEngineId)) {
                console.warn("rendering Engine has been destroyed");
                return;
            }
            const i = kZ(e, [
                UZ,
                FZ,
                BZ
            ]), { renderingEngineId: a, viewportId: o } = n, s = {
                element: e,
                renderingEngineId: a,
                viewportId: o
            };
            OZ(e, (c)=>{
                let l = !1;
                const f = (u)=>{
                    if (u.renderAnnotation) {
                        const g = u.renderAnnotation(n, c);
                        l = l || g;
                    }
                };
                i.forEach(f), l && We(e, z.ANNOTATION_RENDERED, {
                    ...s
                });
            });
        }
        _reset() {
            window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = !1, this._animationFrameHandle = null, this._setAllViewportsToBeRenderedNextFrame();
        }
    }
    const oy = new GZ;
    function ug(t) {
        oy.renderViewport(t);
    }
    function it(t) {
        t.length && t.forEach((e)=>{
            const n = An(e);
            if (!n) {
                console.warn(`Viewport not available for ${e}`);
                return;
            }
            const { viewport: r } = n;
            if (!r) {
                console.warn(`Viewport not available for ${e}`);
                return;
            }
            const i = r.element;
            ug(i);
        });
    }
    function WZ(t, e) {
        const n = t.length, r = [];
        for(let i = 0; i < n; i++){
            const a = t[i];
            a.getFrameOfReferenceUID() === e && r.push(a);
        }
        return r;
    }
    const { Active: $Z, Passive: zZ, Enabled: jZ } = er;
    function HZ(t, e) {
        const n = t.length, r = [];
        for(let i = 0; i < n; i++){
            const a = t[i], o = ha(a.id, a.renderingEngineId);
            if (!o) continue;
            KZ(o, e) && r.push(a);
        }
        return r;
    }
    function KZ(t, e) {
        const { toolOptions: n } = t, r = n[e];
        if (!r) return !1;
        const i = r.mode;
        return i === $Z || i === zZ || i === jZ;
    }
    function qZ(t, e, n = .999) {
        return t.filter((r)=>{
            const i = r.getCamera();
            return Math.abs(xt(i.viewPlaneNormal, e.viewPlaneNormal)) > n;
        });
    }
    function rn(t, e, n = !0) {
        const r = Fe(t), { renderingEngine: i, FrameOfReferenceUID: a } = r;
        let o = i.getViewports();
        o = WZ(o, a), o = HZ(o, e);
        const s = i.getViewport(r.viewportId);
        return n && (o = qZ(o, s.getCamera())), o.map((l)=>l.id);
    }
    const Cp = "PlanarFreehandContourSegmentationTool";
    function sy(t, e) {
        const n = t.length, r = new Array(n);
        for(let i = 0; i < n; i++)r[i] = e.worldToCanvas(t[i]);
        return r;
    }
    function XZ(t, e) {
        return og(e).map((n)=>{
            const r = n, i = sy(r.data.contour.polyline, t);
            return {
                annotation: r,
                polyline: i
            };
        });
    }
    function PR(t, e, n) {
        ag(e, n), Hl(n);
        const { contour: r } = n.data, i = sy(r.polyline, t);
        uc(n, {
            points: i,
            closed: r.closed,
            targetWindingDirection: e.data.contour.windingDirection === Za.Clockwise ? Za.CounterClockwise : Za.Clockwise
        }, t);
        const { element: a } = t;
        VR(t, [
            e,
            n
        ]);
    }
    function YZ(t, e, n, r, i) {
        if (!Xp(Cp)) {
            console.warn(`${Cp} is not registered in cornerstone. Cannot combine polylines.`);
            return;
        }
        const a = i[0], o = Ra(n, a), s = XZ(t, e), c = new Set(s), l = new Map, f = (T, x)=>{
            let S = l.get(T);
            S || (S = [], l.set(T, S)), S.push(x), c.delete(x);
        }, u = [];
        if (o) {
            const T = ay(n, i);
            u.push(T), Array.from(c.keys()).forEach((x)=>f(T, x));
        } else ty(n, i).forEach((x)=>{
            u.push(x), Array.from(c.keys()).forEach((S)=>{
                lg(x, S.polyline) && f(x, S);
            });
        });
        Array.from(l.values()).forEach((T)=>T.forEach((x)=>qp(x.annotation)));
        const { element: g } = t, { metadata: h, data: v } = e, { handles: m, segmentation: y } = v, { textBox: C } = m;
        Ir(r.annotationUID), Ir(e.annotationUID), Hl(r), Hl(e);
        for(let T = 0; T < u.length; T++){
            const x = u[T];
            if (!x || x.length < 3) {
                console.warn("Skipping creation of new annotation due to invalid polyline:", x);
                continue;
            }
            const S = ZZ(t, e, x);
            nr(S, g), Kl(S), yn(S, t.element), l.get(x)?.forEach((D)=>ag(S, D.annotation));
        }
        VR(t, [
            e,
            r
        ]);
    }
    function ZZ(t, e, n) {
        const r = t.canvasToWorld(n[0]), i = t.canvasToWorld(n[n.length - 1]), a = {
            metadata: {
                ...e.metadata,
                toolName: Cp,
                originalToolName: e.metadata.originalToolName || e.metadata.toolName
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [
                        r,
                        i
                    ],
                    textBox: e.data.handles.textBox ? {
                        ...e.data.handles.textBox
                    } : void 0
                },
                contour: {
                    polyline: [],
                    closed: !0
                },
                spline: e.data.spline,
                segmentation: {
                    ...e.data.segmentation
                }
            },
            annotationUID: Vn(),
            highlighted: !0,
            invalidated: !0,
            isLocked: !1,
            isVisible: void 0,
            interpolationUID: e.interpolationUID,
            interpolationCompleted: e.interpolationCompleted
        };
        return uc(a, {
            points: n,
            closed: !0,
            targetWindingDirection: Za.Clockwise
        }, t), a;
    }
    function VR(t, e) {
        const { element: n } = t, r = new Set([
            Cp
        ]);
        e.forEach((i)=>{
            r.add(i.metadata.toolName);
        });
        for (const i of r.values())if (Xp(i)) {
            const a = rn(n, i);
            it(a);
        }
    }
    function i2(t) {
        return !!t.data?.segmentation;
    }
    function JZ(t, e, n) {
        const r = [], i = kd(e);
        for(let a = 0; a < n.length; a++){
            const o = n[a], s = QZ(o.data.contour.polyline, t), c = kd(s);
            if (!qY(i, c)) continue;
            const f = iy(e, s), u = !f && lg(s, e);
            (f || u) && r.push({
                targetAnnotation: o,
                targetPolyline: s,
                isContourHole: u
            });
        }
        return r;
    }
    function QZ(t, e) {
        const n = t.length, r = new Array(n);
        for(let i = 0; i < n; i++)r[i] = e.worldToCanvas(t[i]);
        return r;
    }
    const wp = "PlanarFreehandContourSegmentationTool";
    function eJ(t, e, n, r) {
        const i = r.filter((o)=>o.isContourHole), a = r.filter((o)=>!o.isContourHole);
        if (i.length > 0) {
            const o = i[0];
            aJ(t, o.targetAnnotation, e), NR(t, [
                e,
                o.targetAnnotation
            ]);
            return;
        }
        if (a.length !== 0) {
            if (!Xp(wp)) {
                console.warn(`${wp} is not registered in cornerstone. Cannot process multiple intersections.`);
                return;
            }
            tJ(t, e, n, a);
        }
    }
    function tJ(t, e, n, r) {
        const { element: i } = t, a = [
            e
        ], o = [], s = [];
        r.forEach(({ targetAnnotation: g })=>{
            const h = iJ(t, g);
            s.push(...h), a.push(g);
        });
        const c = n[0];
        if (r.some(({ targetPolyline: g })=>Ra(g, c))) {
            let g = n;
            r.forEach(({ targetPolyline: h })=>{
                g = ay(g, h);
            }), o.push(g);
        } else r.forEach(({ targetPolyline: g })=>{
            const h = ty(g, n);
            o.push(...h);
        });
        a.forEach((g)=>{
            Ir(g.annotationUID), Hl(g);
        }), s.forEach((g)=>qp(g.annotation));
        const f = r[0].targetAnnotation, u = [];
        o.forEach((g)=>{
            if (!g || g.length < 3) {
                console.warn("Skipping creation of new annotation due to invalid polyline:", g);
                return;
            }
            const h = nJ(t, f, g);
            nr(h, i), Kl(h), yn(h, t.element), u.push(h);
        }), rJ(t, s, u), NR(t, a);
    }
    function nJ(t, e, n) {
        const r = t.canvasToWorld(n[0]), i = t.canvasToWorld(n[n.length - 1]), a = {
            metadata: {
                ...e.metadata,
                toolName: wp,
                originalToolName: e.metadata.originalToolName || e.metadata.toolName
            },
            data: {
                cachedStats: {},
                handles: {
                    points: [
                        r,
                        i
                    ],
                    textBox: e.data.handles.textBox ? {
                        ...e.data.handles.textBox
                    } : void 0
                },
                contour: {
                    polyline: [],
                    closed: !0
                },
                spline: e.data.spline,
                segmentation: {
                    ...e.data.segmentation
                }
            },
            annotationUID: Vn(),
            highlighted: !0,
            invalidated: !0,
            isLocked: !1,
            isVisible: void 0,
            interpolationUID: e.interpolationUID,
            interpolationCompleted: e.interpolationCompleted
        };
        return uc(a, {
            points: n,
            closed: !0,
            targetWindingDirection: Za.Clockwise
        }, t), a;
    }
    function rJ(t, e, n) {
        e.forEach((r)=>{
            const i = n.find((a)=>{
                const o = cy(a.data.contour.polyline, t);
                return lg(o, r.polyline);
            });
            i && ag(i, r.annotation);
        });
    }
    function iJ(t, e) {
        return og(e).map((n)=>{
            const r = n, i = cy(r.data.contour.polyline, t);
            return {
                annotation: r,
                polyline: i
            };
        });
    }
    function aJ(t, e, n) {
        ag(e, n), Hl(n);
        const { contour: r } = n.data, i = cy(r.polyline, t);
        uc(n, {
            points: i,
            closed: r.closed,
            targetWindingDirection: e.data.contour.windingDirection === Za.Clockwise ? Za.CounterClockwise : Za.Clockwise
        }, t);
    }
    function cy(t, e) {
        const n = t.length, r = new Array(n);
        for(let i = 0; i < n; i++)r[i] = e.worldToCanvas(t[i]);
        return r;
    }
    function NR(t, e) {
        const { element: n } = t, r = new Set([
            wp
        ]);
        e.forEach((i)=>{
            r.add(i.metadata.toolName);
        });
        for (const i of r.values())if (Xp(i)) {
            const a = rn(n, i);
            it(a);
        }
    }
    const { isEqual: Iw } = ga;
    function AR(t) {
        const { metadata: e } = t;
        return nq().filter((n)=>{
            if (n.FrameOfReferenceUID === e.FrameOfReferenceUID) {
                const r = n.viewport, { viewPlaneNormal: i, viewUp: a } = r.getCamera();
                return Iw(i, e.viewPlaneNormal) && (!e.viewUp || Iw(a, e.viewUp));
            }
        }).map((n)=>n.viewport);
    }
    function oJ(t) {
        if (!t) throw new Error(`No contours found for geometryId ${t.id}`);
        const e = t.id;
        if (t.type !== Ih.CONTOUR) throw new Error(`Geometry type ${t.type} not supported for rendering.`);
        if (!t.data) {
            console.warn(`No contours found for geometryId ${e}. Skipping render.`);
            return;
        }
    }
    function sJ(t, e, n, r) {
        n.size ? t.render() : cJ(t, e, r);
    }
    function cJ(t, e, n) {
        const { segmentationId: r } = n, i = new Map;
        e.forEach((a)=>{
            const o = ot.getGeometry(a);
            if (!o) {
                console.warn(`No geometry found for geometryId ${a}. Skipping render.`);
                return;
            }
            const s = o.data.segmentIndex;
            oJ(o);
            const c = zu.getStyle({
                viewportId: t.id,
                segmentationId: r,
                type: Ft.Contour,
                segmentIndex: s
            }), l = o.data, f = t.getCamera().viewPlaneNormal;
            l.contours.forEach((u)=>{
                const { points: g, color: h, id: v } = u, m = EY(t, g[0], f), y = {
                    annotationUID: Vn(),
                    data: {
                        contour: {
                            closed: !0,
                            polyline: g
                        },
                        segmentation: {
                            segmentationId: r,
                            segmentIndex: s,
                            color: h,
                            id: v
                        },
                        handles: {}
                    },
                    handles: {},
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !0,
                    isVisible: !0,
                    metadata: {
                        referencedImageId: m,
                        toolName: "PlanarFreehandContourSegmentationTool",
                        FrameOfReferenceUID: t.getFrameOfReferenceUID(),
                        viewPlaneNormal: t.getCamera().viewPlaneNormal
                    }
                }, C = t.element;
                nr(y, C), Kl(y);
            }), c && i.set(s, c);
        }), t.render();
    }
    function lJ(t, e, n = !1) {
        const r = eo(e), { annotationUIDsMap: i } = r.representationData.Contour;
        i.forEach((a)=>{
            a.forEach((o)=>{
                Ir(o);
            });
        });
    }
    function uJ(t) {
        const e = eY(t);
        if (e) return e;
        const n = eo(t);
        if (!n) throw new Error(`No segmentation found for segmentationId ${t}`);
        let r;
        if (n.representationData.Labelmap) r = fJ(n, t);
        else if (n.representationData.Contour) r = hJ(n);
        else if (n.representationData.Surface) r = pJ(n);
        else throw new Error(`Unsupported segmentation type: ${n.representationData}`);
        return tY(t, r), r;
    }
    function fJ(t, e) {
        const n = t.representationData[Ft.Labelmap], r = new Set;
        return n.imageIds ? gJ(r, n.imageIds) : dJ(r, e), Array.from(r).map(Number).sort((i, a)=>i - a);
    }
    function dJ(t, e) {
        ot.getVolume(e).voxelManager.forEach(({ value: r })=>{
            r !== 0 && t.add(r);
        });
    }
    function gJ(t, e) {
        e.forEach((n)=>{
            ot.getImage(n).voxelManager.getScalarData().forEach((a)=>{
                a !== 0 && t.add(a);
            });
        });
    }
    function hJ(t) {
        const { annotationUIDsMap: e, geometryIds: n } = t.representationData.Contour || {};
        if (!n) throw new Error(`No geometryIds found for segmentationId ${t.segmentationId}`);
        const r = new Set([
            ...e.keys()
        ]);
        return n.forEach((i)=>{
            const a = ot.getGeometry(i);
            r.add(a.data.segmentIndex);
        }), Array.from(r).sort((i, a)=>i - a);
    }
    function pJ(t) {
        const e = t.representationData.Surface?.geometryIds ?? [];
        return Array.from(e.keys()).map(Number).sort((n, r)=>n - r);
    }
    const xu = new Map, Mw = new Map;
    function mJ(t, e, n = !1) {
        const r = An(t);
        if (!r) return;
        const { viewport: i } = r;
        lJ(t, e), n && i.render();
    }
    async function vJ(t, e) {
        const { segmentationId: n } = e, r = eo(n);
        if (!r) return;
        let i = r.representationData[Ft.Contour];
        const a = Xc();
        if (!i && Xc()?.canComputeRequestedRepresentation(n, Ft.Contour) && !xu.get(t.id) ? (xu.set(t.id, !0), i = await Z4(n, Ft.Contour, ()=>a.computeContourData(n, {
                viewport: t
            }), ()=>{}), xu.set(t.id, !1)) : !i && !Xc() && console.debug(`No contour data found for segmentationId ${n} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`), !i || !i.geometryIds?.length) return;
        let o = !1;
        const s = t.getCamera().viewPlaneNormal;
        i.annotationUIDsMap && (o = !CJ(i.annotationUIDsMap, s)), i.geometryIds.length > 0 && (o = !yJ(i.geometryIds, s));
        const c = Mw.get(t.id) || new Set;
        if (o && !xu.get(t.id) && !c.has(n) && t.viewportStatus === sa.RENDERED) {
            xu.set(t.id, !0);
            const l = uJ(n), u = (await a.computeSurfaceData(n, {
                segmentIndices: l,
                viewport: t
            })).geometryIds, g = [];
            for (const y of u.values()){
                const T = ot.getGeometry(y).data;
                g.push({
                    points: T.points,
                    polys: T.polys,
                    segmentIndex: T.segmentIndex,
                    id: T.segmentIndex
                });
            }
            const h = await a.clipAndCacheSurfacesForViewport(g, t), v = a.extractContourData(h), m = a.createAndAddContourSegmentationsFromClippedSurfaces(v, t, n);
            i.annotationUIDsMap = new Map([
                ...i.annotationUIDsMap,
                ...m
            ]), c.add(n), Mw.set(t.id, c), xu.set(t.id, !1);
        }
        sJ(t, i.geometryIds, i.annotationUIDsMap, e);
    }
    function yJ(t, e) {
        let n = null, r = null;
        for (const u of t){
            const g = ot.getGeometry(u);
            if (!g) continue;
            const h = g.data;
            if (h.contours?.[0]?.points?.length >= 3) {
                n = g, r = h;
                break;
            }
        }
        if (!n || !r) return !1;
        const a = r.contours[0].points, o = a[0], s = a[1], c = a[2];
        let l = bn(Xe(), In(Xe(), s, o), In(Xe(), c, o));
        l = jn(Xe(), l);
        const f = xt(l, e);
        return Math.abs(f) > .9;
    }
    function CJ(t, e) {
        const n = Array.from(t.values()).flat().map((i)=>Array.from(i)).flat(), r = G4(n, 3);
        for (const i of r){
            const a = fa(i);
            if (a?.metadata) {
                if (!a.metadata.viewPlaneNormal) continue;
                const o = a.metadata.viewPlaneNormal, s = Math.abs(e[0] * o[0] + e[1] * o[1] + e[2] * o[2]);
                if (Math.abs(s - 1) > .01) return !1;
            }
        }
        return !0;
    }
    const wJ = {
        render: vJ,
        removeRepresentation: mJ
    };
    function Ud(t, e) {
        return lc.getCurrentLabelmapImageIdsForViewport(t, e);
    }
    const bw = new Map, TJ = ({ cfun: t, ofun: e, actor: n })=>{
        n.getProperty().setRGBTransferFunction(1, t), n.getProperty().setScalarOpacity(1, e);
    };
    async function xJ({ viewport: t, volumeInputs: e, segmentationId: n }) {
        const r = t.getDefaultActor(), { actor: i } = r, { uid: a, callback: o } = r, s = t.getVolumeId();
        if (bw.get(a)?.added) return {
            uid: a,
            actor: i
        };
        const c = e, l = ot.getVolume(c[0].volumeId);
        if (!l) throw new Error(`imageVolume with id: ${l.volumeId} does not exist`);
        const { volumeId: f } = c[0], u = await R4(f);
        if (!u) throw new Error(`segImageVolume with id: ${u.volumeId} does not exist`);
        const h = u.voxelManager.getCompleteScalarDataArray(), { imageData: v } = u, m = ot.getVolume(s), C = m.voxelManager.getCompleteScalarDataArray(), T = 2, x = new Float32Array(T * m.voxelManager.getScalarDataLength()), S = v.getDimensions();
        for(let F = 0; F < S[2]; ++F)for(let N = 0; N < S[1]; ++N)for(let B = 0; B < S[0]; ++B){
            const G = B + S[0] * (N + S[1] * F);
            x[G * T + 0] = C[G], x[G * T + 1] = h[G];
        }
        t.removeActors([
            a
        ]);
        const D = i.getMapper(), _ = Mj(D);
        i.setMapper(_), _.setBlendMode(Al.LABELMAP_EDGE_PROJECTION_BLEND);
        const M = _.getInputData().getPointData().getArray(0);
        M.setData(x), M.setNumberOfComponents(2), i.getProperty().setColorMixPreset(1), i.getProperty().setForceNearestInterpolation(1, !0), i.getProperty().setIndependentComponents(!0), t.addActor({
            actor: i,
            uid: a,
            callback: o,
            referencedId: s,
            representationUID: `${n}-${Ft.Labelmap}`
        }), bw.set(a, {
            added: !0,
            segmentationRepresentationUID: `${n}`,
            originalBlendMode: t.getBlendMode()
        }), i.set({
            preLoad: TJ
        });
        function P(F) {
            const { segmentationId: N } = F.detail, { representationData: B } = eo(N), { volumeId: G } = B.Labelmap;
            if (G !== u.volumeId) return;
            const H = ot.getVolume(G).voxelManager, ne = _.getInputData(), ae = ne.getPointData().getArray(0), ue = ae.getData(), le = 2, oe = v.getDimensions(), re = Array.from({
                length: oe[2]
            }, (X, ie)=>ie);
            for (const X of re)for(let ie = 0; ie < oe[1]; ++ie)for(let he = 0; he < oe[0]; ++he){
                const $e = he + oe[0] * (ie + oe[1] * X);
                ue[$e * le + 1] = H.getAtIndex($e);
            }
            ae.setData(ue), ne.modified(), t.render();
        }
        return Ke.addEventListenerDebounced(z.SEGMENTATION_DATA_MODIFIED, P, 200), Ke.addEventListener(z.SEGMENTATION_REPRESENTATION_REMOVED, async (F)=>{
            Ke.removeEventListener(z.SEGMENTATION_DATA_MODIFIED, P);
            const N = t.getActor(a), { element: B, id: G } = t;
            t.removeActors([
                a
            ]);
            const Z = await Wv({
                volumeId: a,
                blendMode: Al.MAXIMUM_INTENSITY_BLEND,
                callback: ({ volumeActor: H })=>{
                    N.callback && N.callback({
                        volumeActor: H,
                        volumeId: f
                    });
                }
            }, B, G);
            t.addActor({
                actor: Z,
                uid: a
            }), t.render();
        }), {
            uid: a,
            actor: i
        };
    }
    const { uuidv4: kR } = ga;
    async function SJ(t, e, n, r) {
        const i = Fe(t), { renderingEngine: a, viewport: o } = i, { id: s } = o, c = !0, l = !1, f = !0;
        if (o instanceof So) {
            const g = EJ(e, n);
            ot.getVolume(g) || await DJ(e);
            let h = r?.blendMode ?? Al.MAXIMUM_INTENSITY_BLEND, v = h === Al.LABELMAP_EDGE_PROJECTION_BLEND;
            if (v) {
                const y = o.getVolumeId(), C = ot.getVolume(y), x = ot.getVolume(g).dimensions, S = C.dimensions;
                (x[0] !== S[0] || x[1] !== S[1] || x[2] !== S[2]) && (v = !1, h = Al.MAXIMUM_INTENSITY_BLEND, console.debug("Dimensions mismatch - falling back to regular volume addition"));
            }
            const m = [
                {
                    volumeId: g,
                    visibility: c,
                    representationUID: `${n}-${Ft.Labelmap}`,
                    useIndependentComponents: v,
                    blendMode: h
                }
            ];
            if (!m[0].useIndependentComponents) await EK(a, m, [
                s
            ], l, f);
            else return await xJ({
                viewport: o,
                volumeInputs: m,
                segmentationId: n
            });
        } else {
            const g = Ud(o.id, n).map((h)=>({
                    imageId: h,
                    representationUID: `${n}-${Ft.Labelmap}-${h}`
                }));
            DK(a, g, [
                s
            ]);
        }
        Qp(n);
    }
    function EJ(t, e) {
        let { volumeId: n } = t;
        if (!n) {
            n = kR();
            const r = eo(e);
            r.representationData.Labelmap = {
                ...r.representationData.Labelmap,
                volumeId: n
            }, t.volumeId = n, e2(e);
        }
        return n;
    }
    async function DJ(t) {
        const e = t;
        if (!(e.imageIds.length > 0)) throw new Error("cannot create labelmap, no imageIds found for the volume labelmap");
        return await VD(t.volumeId || kR(), e.imageIds);
    }
    function _J(t, e) {
        const n = Fe(t), { viewport: r } = n;
        r.removeActors([
            gY(r.id, e)
        ]);
    }
    function ly(t) {
        return lc.getActiveSegmentation(t);
    }
    function RJ(t) {
        return ly(t);
    }
    function uy(t) {
        const e = eo(t);
        if (e) {
            const n = Object.keys(e.segments).find((r)=>e.segments[r].active);
            return n ? Number(n) : void 0;
        }
    }
    const $5 = 255, xd = new Map;
    let z5 = !1;
    function OJ(t, e, n = !1) {
        const r = An(t);
        if (xd.forEach((a, o)=>{
            o.includes(e) && xd.delete(o);
        }), !r) return;
        const { viewport: i } = r;
        _J(i.element, e), n && i.render();
    }
    async function IJ(t, e) {
        const { segmentationId: n, config: r } = e, i = eo(n);
        if (!i) {
            console.warn("No segmentation found for segmentationId: ", n);
            return;
        }
        let a = i.representationData[Ft.Labelmap], o = Td(t.id, n);
        if (!a && Xc()?.canComputeRequestedRepresentation(n, Ft.Labelmap) && !z5) {
            z5 = !0;
            const s = Xc();
            if (a = await Z4(n, Ft.Labelmap, ()=>s.computeLabelmapData(n, {
                    viewport: t
                }), ()=>null, ()=>{
                lc.processLabelmapRepresentationAddition(t.id, n), setTimeout(()=>{
                    Qp(n);
                }, 0);
            }), !a) throw new Error(`No labelmap data found for segmentationId ${n}.`);
            z5 = !1;
        } else !a && !Xc() && console.debug(`No labelmap data found for segmentationId ${n} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);
        if (a) {
            if (t instanceof wi) o?.length || await Pw(t, a, n, r), o = Td(t.id, n);
            else {
                if (!Ud(t.id, n)?.length) return;
                o || await Pw(t, a, n, r), o = Td(t.id, n);
            }
            if (o?.length) for (const s of o)MJ(t.id, s, e);
        }
    }
    function MJ(t, e, n) {
        const { segmentationId: r } = n, { cfun: i, ofun: a } = n.config, { colorLUTIndex: o } = n, c = RJ(t)?.segmentationId === r, l = zu.getStyle({
            viewportId: t,
            type: Ft.Labelmap,
            segmentationId: r
        }), f = zu.getRenderInactiveSegmentations(t), u = Y4(o), g = Math.min(256, u.length), { outlineWidth: h, renderOutline: v, outlineOpacity: m, activeSegmentOutlineWidthDelta: y } = Lw(l, c), C = J4(t, {
            segmentationId: r,
            type: Ft.Labelmap
        });
        for(let D = 0; D < g; D++){
            const _ = D, M = u[_], F = zu.getStyle({
                viewportId: t,
                type: Ft.Labelmap,
                segmentationId: r,
                segmentIndex: _
            }), { fillAlpha: N, outlineWidth: B, renderFill: G, renderOutline: Z } = Lw(l, c, F), { forceOpacityUpdate: H, forceColorUpdate: ne } = bJ(t, r, _, {
                fillAlpha: N,
                renderFill: G,
                renderOutline: Z,
                segmentColor: M,
                outlineWidth: B,
                segmentsHidden: C,
                cfun: i,
                ofun: a
            });
            if (ne && i.addRGBPoint(_, M[0] / $5, M[1] / $5, M[2] / $5), H) if (G) {
                const ae = C.has(_) ? 0 : M[3] / 255 * N;
                a.removePoint(_), a.addPointLong(_, ae, .5, 1);
            } else a.addPointLong(_, .01, .5, 1);
        }
        a.setClamping(!1);
        const T = e.actor, { preLoad: x } = T.get?.("preLoad") || {
            preLoad: null
        };
        if (x ? x({
            cfun: i,
            ofun: a,
            actor: T
        }) : (T.getProperty().setRGBTransferFunction(0, i), T.getProperty().setScalarOpacity(0, a), T.getProperty().setInterpolationTypeToNearest()), v) {
            T.getProperty().setUseLabelOutline(v), T.getProperty().setLabelOutlineOpacity(m);
            const D = uy(n.segmentationId), _ = new Array(g - 1);
            for(let M = 1; M < g; M++){
                if (C.has(M)) {
                    _[M - 1] = 0;
                    continue;
                }
                _[M - 1] = M === D ? h + y : h;
            }
            T.getProperty().setLabelOutlineThickness(_), T.modified(), T.getProperty().modified(), T.getMapper().modified();
        } else T.getProperty().setLabelOutlineThickness(new Array(g - 1).fill(0));
        const S = c || f;
        T.setVisibility(S);
    }
    function Lw(t, e, n) {
        const i = {
            ...t,
            ...n || {}
        }, a = e ? i.fillAlpha : i.fillAlphaInactive, o = e ? i.outlineWidth : i.outlineWidthInactive, s = e ? i.renderFill : i.renderFillInactive, c = e ? i.renderOutline : i.renderOutlineInactive, l = e ? i.outlineOpacity : i.outlineOpacityInactive, f = i.activeSegmentOutlineWidthDelta;
        return {
            fillAlpha: a,
            outlineWidth: o,
            renderFill: s,
            renderOutline: c,
            outlineOpacity: l,
            activeSegmentOutlineWidthDelta: f
        };
    }
    function bJ(t, e, n, { fillAlpha: r, renderFill: i, renderOutline: a, segmentColor: o, outlineWidth: s, segmentsHidden: c, cfun: l, ofun: f }) {
        const u = `${t}-${e}-${n}`, g = xd.get(u);
        if (!g) return xd.set(u, {
            fillAlpha: r,
            renderFill: i,
            renderOutline: a,
            outlineWidth: s,
            segmentColor: o.slice(),
            segmentsHidden: new Set(c),
            cfunMTime: l.getMTime(),
            ofunMTime: f.getMTime()
        }), {
            forceOpacityUpdate: !0,
            forceColorUpdate: !0
        };
        const { fillAlpha: h, renderFill: v, renderOutline: m, outlineWidth: y, segmentColor: C, segmentsHidden: T, cfunMTime: x, ofunMTime: S } = g, D = C[0] !== o[0] || C[1] !== o[1] || C[2] !== o[2], _ = C[3] !== o[3] || h !== r || v !== i || m !== a || y !== s || T !== c;
        return (_ || D) && xd.set(u, {
            fillAlpha: r,
            renderFill: i,
            renderOutline: a,
            outlineWidth: s,
            segmentColor: o.slice(),
            segmentsHidden: new Set(c),
            cfunMTime: l.getMTime(),
            ofunMTime: f.getMTime()
        }), {
            forceOpacityUpdate: _,
            forceColorUpdate: D
        };
    }
    async function Pw(t, e, n, r) {
        return await SJ(t.element, e, n, r) || void 0;
    }
    const LJ = {
        render: IJ,
        removeRepresentation: OJ
    }, { DefaultHistoryMemo: Su } = B4;
    class oc {
        static{
            this.defaults = {
                configuration: {
                    strategies: {},
                    defaultStrategy: void 0,
                    activeStrategy: void 0,
                    strategyOptions: {}
                }
            };
        }
        constructor(e, n){
            const r = oc.mergeDefaultProps(oc.defaults, n), i = Ma(r, e), { configuration: a = {}, supportedInteractionTypes: o, toolGroupId: s } = i;
            this.toolGroupId = s, this.supportedInteractionTypes = o || [], this.configuration = Object.assign({}, a), this.mode = er.Disabled;
        }
        static mergeDefaultProps(e = {}, n) {
            return n ? Ma(e, n) : e;
        }
        get toolName() {
            return this.getToolName();
        }
        getToolName() {
            return this.constructor.toolName;
        }
        applyActiveStrategy(e, n) {
            const { strategies: r, activeStrategy: i } = this.configuration;
            return r[i]?.call(this, e, n);
        }
        applyActiveStrategyCallback(e, n, r, ...i) {
            const { strategies: a, activeStrategy: o } = this.configuration;
            if (!a[o]) throw new Error(`applyActiveStrategyCallback: active strategy ${o} not found, check tool configuration or spellings`);
            return a[o][r]?.call(this, e, n, ...i);
        }
        setConfiguration(e) {
            this.configuration = Ma(this.configuration, e);
        }
        setActiveStrategy(e) {
            this.setConfiguration({
                activeStrategy: e
            });
        }
        getTargetImageData(e) {
            if (e.startsWith("imageId:")) {
                const n = e.split("imageId:")[1], r = ur(n);
                let i = up(r);
                return !i || !i.length || (i = i.filter((a)=>a.getCurrentImageId() === n), !i || !i.length) ? void 0 : i[0].getImageData();
            } else if (e.startsWith("volumeId:")) {
                const n = lf(e), r = Gp(n);
                return !r || !r.length ? void 0 : r[0].getImageData();
            } else if (e.startsWith("videoId:")) {
                const n = ur(e), r = up(n);
                return !r || !r.length ? void 0 : r[0].getImageData();
            } else throw new Error('getTargetIdImage: targetId must start with "imageId:" or "volumeId:"');
        }
        getTargetId(e) {
            const n = e.getViewReferenceId?.();
            if (n) return n;
            throw new Error("getTargetId: viewport must have a getViewReferenceId method");
        }
        undo() {
            this.doneEditMemo(), Su.undo();
        }
        redo() {
            Su.redo();
        }
        static createZoomPanMemo(e) {
            const n = {
                pan: e.getPan(),
                zoom: e.getZoom()
            }, r = {
                restoreMemo: ()=>{
                    const i = e.getPan(), a = e.getZoom();
                    e.setZoom(n.zoom), e.setPan(n.pan), e.render(), n.pan = i, n.zoom = a;
                }
            };
            return Su.push(r), r;
        }
        doneEditMemo() {
            this.memo?.commitMemo?.() && Su.push(this.memo), this.memo = null;
        }
        static startGroupRecording() {
            Su.startGroupRecording();
        }
        static endGroupRecording() {
            Su.endGroupRecording();
        }
    }
    oc.toolName = "BaseTool";
    const { isEqual: PJ } = ga, { EPSILON: VJ } = u3, NJ = 1 - VJ;
    function AJ(t, e, n) {
        const { viewPlaneNormal: r } = e, i = t.filter((c)=>{
            let l = c.metadata.viewPlaneNormal;
            if (!c.metadata.referencedImageId && !l && c.metadata.FrameOfReferenceUID) {
                for (const u of c.data.handles.points){
                    const g = In(Xe(), u, e.focalPoint), h = xt(g, e.viewPlaneNormal);
                    if (!PJ(h, 0)) return !1;
                }
                return c.metadata.viewPlaneNormal = e.viewPlaneNormal, c.metadata.cameraFocalPoint = e.focalPoint, !0;
            }
            if (!l) {
                const { referencedImageId: u } = c.metadata, { imageOrientationPatient: g } = ct("imagePlaneModule", u), h = en(g[0], g[1], g[2]), v = en(g[3], g[4], g[5]);
                l = Xe(), bn(l, h, v), c.metadata.viewPlaneNormal = l;
            }
            const f = Math.abs(xt(r, l)) > NJ;
            return l && f;
        });
        if (!i.length) return [];
        const a = n / 2, { focalPoint: o } = e, s = [];
        for (const c of i){
            const l = c.data, f = l.handles.points[0] || l.contour?.polyline[0];
            if (!c.isVisible) continue;
            const u = Xe();
            if (!f) {
                s.push(c);
                continue;
            }
            In(u, o, f);
            const g = xt(u, r);
            Math.abs(g) < a && s.push(c);
        }
        return s;
    }
    function UR(t, e, n = {}) {
        if (t instanceof wi) {
            const r = t.getCamera(), { spacingInNormalDirection: i } = rg(t, r);
            return AJ(e, r, i);
        }
        if (t instanceof ua) {
            const r = t.getCurrentImageId();
            if (!r) return [];
            const i = r.indexOf(":");
            n.imageURI = r.substring(i + 1);
        }
        return e.filter((r)=>r.isVisible ? r.data.isCanvasAnnotation ? !0 : t.isReferenceViewable(r.metadata, n) : !1);
    }
    function kJ(t) {
        if (t) {
            if (t.data && t.highlighted) return Ol.Highlighted;
            if (t2(t.annotationUID)) return Ol.Selected;
            if (Ja(t.annotationUID)) return Ol.Locked;
            if (t.data && t.autoGenerated) return Ol.AutoGenerated;
        }
        return Ol.Default;
    }
    class FR extends oc {
        constructor(){
            super(...arguments), this.onImageSpacingCalibrated = (e)=>{
                const { element: n, imageId: r } = e.detail, i = ur(r), a = cc();
                a.getFramesOfReference().forEach((s)=>{
                    const l = a.getAnnotations(s)[this.getToolName()];
                    !l || !l.length || (l.forEach((f)=>{
                        if (!f.metadata?.referencedImageId) return;
                        ur(f.metadata.referencedImageId) === i && (f.invalidated = !0, f.data.cachedStats = {});
                    }), ug(n));
                });
            };
        }
        filterInteractableAnnotationsForElement(e, n) {
            if (!n?.length) return [];
            const r = Fe(e), { viewport: i } = r;
            return UR(i, n);
        }
        createAnnotation(e) {
            const n = e.detail, { currentPoints: r, element: i } = n, { world: a } = r, o = Fe(i), { viewport: s } = o, c = s.getCamera(), { viewPlaneNormal: l, viewUp: f, position: u } = c, g = this.getReferencedImageId(s, a, l, f), h = s.getViewReference({
                points: [
                    a
                ]
            });
            return {
                highlighted: !0,
                invalidated: !0,
                metadata: {
                    toolName: this.getToolName(),
                    ...h,
                    referencedImageId: g,
                    viewUp: f,
                    cameraPosition: u
                },
                data: {
                    cachedStats: {},
                    handles: {
                        points: [],
                        activeHandleIndex: null,
                        textBox: {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        }
                    }
                }
            };
        }
        getReferencedImageId(e, n, r, i) {
            const a = this.getTargetId(e);
            let o = a.split(/^[a-zA-Z]+:/)[1];
            if (e instanceof So) {
                const s = lf(a), c = ot.getVolume(s);
                o = Pd(c, n, r);
            }
            return o;
        }
        getStyle(e, n, r) {
            return __(e, n, kJ(r), this.mode);
        }
    }
    FR.toolName = "AnnotationDisplayTool";
    const { DefaultHistoryMemo: UJ } = B4, { PointsManager: FJ } = ga;
    class ji extends FR {
        static createAnnotation(...e) {
            let n = {
                annotationUID: null,
                highlighted: !0,
                invalidated: !0,
                metadata: {
                    toolName: this.toolName
                },
                data: {
                    text: "",
                    handles: {
                        points: new Array,
                        textBox: {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        }
                    },
                    label: ""
                }
            };
            for (const r of e)n = Ma(n, r);
            return n;
        }
        static createAnnotationForViewport(e, ...n) {
            return this.createAnnotation({
                metadata: e.getViewReference()
            }, ...n);
        }
        static createAndAddAnnotation(e, ...n) {
            const r = this.createAnnotationForViewport(e, ...n);
            nr(r, e.element), yn(r, e.element);
        }
        constructor(e, n){
            super(e, n), this.mouseMoveCallback = (r, i)=>{
                if (!i) return !1;
                const { element: a, currentPoints: o } = r.detail, s = o.canvas;
                let c = !1;
                for (const l of i){
                    if (Ja(l.annotationUID) || !Eo(l.annotationUID)) continue;
                    const { data: f } = l, u = f.handles ? f.handles.activeHandleIndex : void 0, g = this._imagePointNearToolOrHandle(a, l, s, 6), h = g && !l.highlighted, v = !g && l.highlighted;
                    h || v ? (l.highlighted = !l.highlighted, c = !0) : f.handles && f.handles.activeHandleIndex !== u && (c = !0);
                }
                return c;
            }, this.isSuvScaled = ji.isSuvScaled, e.configuration?.getTextLines && (this.configuration.getTextLines = e.configuration.getTextLines), e.configuration?.statsCalculator && (this.configuration.statsCalculator = e.configuration.statsCalculator);
        }
        getHandleNearImagePoint(e, n, r, i) {
            const a = Fe(e), { viewport: o } = a, { data: s } = n, { isCanvasAnnotation: c } = s, { points: l, textBox: f } = s.handles;
            if (f) {
                const { worldBoundingBox: u } = f;
                if (u) {
                    const g = {
                        topLeft: o.worldToCanvas(u.topLeft),
                        topRight: o.worldToCanvas(u.topRight),
                        bottomLeft: o.worldToCanvas(u.bottomLeft),
                        bottomRight: o.worldToCanvas(u.bottomRight)
                    };
                    if (r[0] >= g.topLeft[0] && r[0] <= g.bottomRight[0] && r[1] >= g.topLeft[1] && r[1] <= g.bottomRight[1]) return s.handles.activeHandleIndex = null, f;
                }
            }
            for(let u = 0; u < l?.length; u++){
                const g = l[u], h = c ? g.slice(0, 2) : o.worldToCanvas(g);
                if (Or(r, h) < i === !0) return s.handles.activeHandleIndex = u, g;
            }
            s.handles.activeHandleIndex = null;
        }
        getLinkedTextBoxStyle(e, n) {
            return {
                visibility: this.getStyle("textBoxVisibility", e, n),
                fontFamily: this.getStyle("textBoxFontFamily", e, n),
                fontSize: this.getStyle("textBoxFontSize", e, n),
                color: this.getStyle("textBoxColor", e, n),
                shadow: this.getStyle("textBoxShadow", e, n),
                background: this.getStyle("textBoxBackground", e, n),
                lineWidth: this.getStyle("textBoxLinkLineWidth", e, n),
                lineDash: this.getStyle("textBoxLinkLineDash", e, n)
            };
        }
        static isSuvScaled(e, n, r) {
            if (e instanceof So) {
                const a = lf(n);
                return ot.getVolume(a)?.scaling?.PT !== void 0;
            }
            return typeof (r && ct("scalingModule", r))?.suvbw == "number";
        }
        getAnnotationStyle(e) {
            const { annotation: n, styleSpecifier: r } = e, i = (m)=>this.getStyle(m, r, n), { annotationUID: a } = n, o = Eo(a), s = Ja(a), c = i("lineWidth"), l = i("lineDash"), f = i("angleArcLineDash"), u = i("color"), g = i("markerSize"), h = i("shadow"), v = this.getLinkedTextBoxStyle(r, n);
            return {
                visibility: o,
                locked: s,
                color: u,
                lineWidth: c,
                lineDash: l,
                lineOpacity: 1,
                fillColor: u,
                fillOpacity: 0,
                shadow: h,
                textbox: v,
                markerSize: g,
                angleArcLineDash: f
            };
        }
        _imagePointNearToolOrHandle(e, n, r, i) {
            if (this.getHandleNearImagePoint(e, n, r, i) || this.isPointNearTool(e, n, r, i, "mouse")) return !0;
        }
        static createAnnotationState(e, n) {
            const { data: r, annotationUID: i } = e, a = {
                ...r,
                cachedStats: {}
            };
            delete a.contour, delete a.spline;
            const o = {
                annotationUID: i,
                data: structuredClone(a),
                deleting: n
            }, s = r.contour;
            return s && (o.data.contour = {
                ...s,
                polyline: null,
                pointsManager: FJ.create3(s.polyline.length, s.polyline)
            }), o;
        }
        static createAnnotationMemo(e, n, r) {
            if (!n) return;
            const { newAnnotation: i, deleting: a = i ? !1 : void 0 } = r || {}, { annotationUID: o } = n, s = ji.createAnnotationState(n, a), c = {
                restoreMemo: ()=>{
                    const l = ji.createAnnotationState(n, a), { viewport: f } = Fe(e) || {};
                    if (f?.setViewReference(n.metadata), s.deleting === !0) {
                        if (s.deleting = !1, Object.assign(n.data, s.data), n.data.contour) {
                            const g = n.data;
                            g.contour.polyline = s.data.contour.pointsManager.points, delete s.data.contour.pointsManager, g.segmentation && Kl(n);
                        }
                        s.data = l.data, nr(n, e), Qs(n.annotationUID, !0), f?.render();
                        return;
                    }
                    if (s.deleting === !1) {
                        s.deleting = !0, s.data = l.data, Qs(n.annotationUID), Ir(n.annotationUID), f?.render();
                        return;
                    }
                    const u = fa(o);
                    if (!u) {
                        console.warn("No current annotation");
                        return;
                    }
                    Object.assign(u.data, s.data), u.data.contour && (u.data.contour.polyline = s.data.contour.pointsManager.points), s.data = l.data, u.invalidated = !0, yn(u, e, Jt.History);
                },
                id: o,
                operationType: "annotation"
            };
            return UJ.push(c), c;
        }
        createMemo(e, n, r) {
            this.memo ||= ji.createAnnotationMemo(e, n, r);
        }
        static hydrateBase(e, n, r, i = {}) {
            if (!n) return null;
            const { viewport: a } = n, o = a.getFrameOfReferenceUID(), s = a.getCamera(), c = i.viewplaneNormal ?? s.viewPlaneNormal, l = i.viewUp ?? s.viewUp, f = i.toolInstance || new e;
            let u, g = c, h = l;
            if (i.referencedImageId) u = i.referencedImageId, g = void 0, h = void 0;
            else if (a instanceof ua) {
                const v = v_(r[0], a);
                v !== void 0 && (u = a.getImageIds()[v]);
            } else if (a instanceof So) u = f.getReferencedImageId(a, r[0], c, l);
            else throw new Error("Unsupported viewport type");
            return {
                FrameOfReferenceUID: o,
                referencedImageId: u,
                viewPlaneNormal: g,
                viewUp: h,
                instance: f,
                viewport: a
            };
        }
    }
    ji.toolName = "AnnotationTool";
    const { CalibrationTypes: w0 } = sc, T0 = "px", B1 = "voxels", BR = [
        1,
        2,
        3,
        4
    ], BJ = [
        "3,3",
        "4,7"
    ], GJ = [
        "4,3",
        "4,7"
    ], r3 = {
        0: "px",
        1: "percent",
        2: "dB",
        3: "cm",
        4: "seconds",
        5: "hertz",
        6: "dB/seconds",
        7: "cm/sec",
        8: "cm²",
        9: "cm²/s",
        12: "degrees"
    }, WJ = .001, Zf = "²", ql = (t, e)=>{
        const { calibration: n, hasPixelSpacing: r } = t;
        let i = r ? "mm" : T0;
        const a = r ? "mm³" : B1;
        let o = i + Zf, s = 1, c = "";
        if (!n || !n.type && !n.sequenceOfUltrasoundRegions) return {
            unit: i,
            areaUnit: o,
            scale: s,
            volumeUnit: a
        };
        if (n.type === w0.UNCALIBRATED) return {
            unit: T0,
            areaUnit: T0 + Zf,
            scale: s,
            volumeUnit: B1
        };
        if (n.sequenceOfUltrasoundRegions) {
            let f, u;
            if (Array.isArray(e) && e.length === 2) [f, u] = e;
            else if (typeof e == "function") {
                const C = e();
                f = C[0], u = C[1];
            }
            let g = n.sequenceOfUltrasoundRegions.filter((C)=>f[0] >= C.regionLocationMinX0 && f[0] <= C.regionLocationMaxX1 && f[1] >= C.regionLocationMinY0 && f[1] <= C.regionLocationMaxY1 && u[0] >= C.regionLocationMinX0 && u[0] <= C.regionLocationMaxX1 && u[1] >= C.regionLocationMinY0 && u[1] <= C.regionLocationMaxY1);
            if (!g?.length) return {
                unit: i,
                areaUnit: o,
                scale: s,
                volumeUnit: a
            };
            if (g = g.filter((C)=>BR.includes(C.regionDataType) && BJ.includes(`${C.physicalUnitsXDirection},${C.physicalUnitsYDirection}`)), !g.length) return {
                unit: T0,
                areaUnit: T0 + Zf,
                scale: s,
                volumeUnit: B1
            };
            const h = g[0], v = Math.abs(h.physicalDeltaX), m = Math.abs(h.physicalDeltaY);
            if (lr(v, m, WJ)) s = 1 / v, c = "US Region", i = r3[h.physicalUnitsXDirection] || "unknown", o = i + Zf;
            else return {
                unit: T0,
                areaUnit: T0 + Zf,
                scale: s,
                volumeUnit: B1
            };
        } else n.scale && (s = n.scale);
        return [
            w0.ERMF,
            w0.USER,
            w0.ERROR,
            w0.PROJECTION,
            w0.CALIBRATED,
            w0.UNKNOWN
        ].includes(n?.type) && (c = n.type), {
            unit: i + (c ? ` ${c}` : ""),
            areaUnit: o + (c ? ` ${c}` : ""),
            scale: s,
            volumeUnit: a + (c ? ` ${c}` : "")
        };
    }, $J = (t, e)=>{
        const [n] = e, { calibration: r } = t;
        let i = [
            "raw"
        ], a = [
            null
        ], o = "";
        if (!r || !r.type && !r.sequenceOfUltrasoundRegions) return {
            units: i,
            values: a
        };
        if (r.sequenceOfUltrasoundRegions) {
            const s = r.sequenceOfUltrasoundRegions.filter((m)=>BR.includes(m.regionDataType) && GJ.includes(`${m.physicalUnitsXDirection},${m.physicalUnitsYDirection}`));
            if (!s?.length) return {
                units: i,
                values: a
            };
            const c = s.find((m)=>n[0] >= m.regionLocationMinX0 && n[0] <= m.regionLocationMaxX1 && n[1] >= m.regionLocationMinY0 && n[1] <= m.regionLocationMaxY1);
            if (!c) return {
                units: i,
                values: a
            };
            const { referencePixelX0: l = 0, referencePixelY0: f = 0 } = c, { physicalDeltaX: u, physicalDeltaY: g } = c, h = (n[1] - c.regionLocationMinY0 - f) * g, v = (n[0] - c.regionLocationMinX0 - l) * u;
            o = "US Region", a = [
                v,
                h
            ], i = [
                r3[c.physicalUnitsXDirection],
                r3[c.physicalUnitsYDirection]
            ];
        }
        return {
            units: i,
            values: a,
            calibrationType: o
        };
    }, zJ = (t)=>t.calibration?.aspect || 1;
    function jJ(t, e, n, r) {
        const i = Xe();
        bn(i, e, t);
        const a = en(...n), o = en(...r), s = Xe();
        kr(s, a, o);
        const c = Xa(s);
        if (c < 1e-4) return {
            worldWidth: 0,
            worldHeight: 0
        };
        const l = xt(s, i) / (c * Xa(i)), u = Math.sqrt(1 - l * l) * c, g = l * c;
        return {
            worldWidth: u,
            worldHeight: g
        };
    }
    function GR(t, e, n, r) {
        const i = Xe();
        bn(i, e, t);
        const a = en(...n), o = en(...r), s = Xe();
        kr(s, a, o);
        const c = Xa(s);
        if (c < 1e-4) return {
            worldWidth: 0,
            worldHeight: 0
        };
        const l = xt(s, i) / (c * Xa(i)), u = Math.sqrt(1 - l * l) * c, g = l * c;
        return {
            worldWidth: u,
            worldHeight: g
        };
    }
    function tl(t, e, n) {
        let r = !0, i = !0;
        if (typeof t != "function") throw new TypeError("Expected a function");
        return vR(n) && (r = "leading" in n ? !!n.leading : r, i = "trailing" in n ? !!n.trailing : i), yR(t, e, {
            leading: r,
            trailing: i,
            maxWait: e
        });
    }
    function HJ(t) {
        return t[0]?.length === 3;
    }
    function KJ(t, e) {
        if (!e || e.length === 0 || e.length === t.length) return t;
        const n = e[e.length - 1] - e[0] + 1, r = b5(e.map((a)=>t[a][0])), i = b5(e.map((a)=>t[a][1]));
        if (HJ(t)) {
            const a = b5(e.map((o)=>t[o][2]));
            return jC(qf(r, n), qf(i, n), qf(a, n));
        } else return jC(qf(r, n), qf(i, n));
    }
    function qJ(t, e) {
        const n = [], [r, i] = e, a = i - r + 1, o = Math.floor(a / t);
        let s = 0, c = Math.round((a - 1) / (o - 1) * s) + r;
        for(; c <= i;)n.push(c), s++, c = Math.round((a - 1) / (o - 1) * s) + r;
        return n;
    }
    function XJ(t, e, n, r) {
        const i = n - e + 1, a = Math.floor(r / 100 * i) ?? 1, o = Math.floor(i / a) ?? 1;
        if (isNaN(i) || !i || !o || i / o < 2) return t;
        const s = Math.max(0, e), c = Math.min(t.length - 1, n), l = t.slice(0, s), f = t.slice(c + 1, t.length), u = qJ(o, [
            s,
            c
        ]), g = KJ(t, u);
        return [
            ...l,
            ...g,
            ...f
        ];
    }
    function a2(t, e) {
        return e?.autoGenerated ? !1 : t?.smoothing?.smoothOnAdd === !0 || t?.smoothing?.smoothOnEdit === !0;
    }
    function YJ(t, e) {
        return cg(t, e) < .001;
    }
    function ZJ(t, e) {
        return cg(t, e) === 0;
    }
    function JJ(t, e) {
        for(let n = 0; n < t.length; n++)for(let r = 0; r < e.length; r++)if (ZJ(t[n], e[r])) return [
            n,
            r
        ];
    }
    function Pu(t, e, n) {
        return (t + e + n) % e;
    }
    function Vw(t, e, n, r) {
        const [, i, a] = t, [, o, s] = e, c = a.length, l = s.length;
        let f = t[0], u = e[0];
        if (!a[f] || !s[u] || !a[i] || !s[o]) return [
            void 0,
            void 0
        ];
        for(; f !== i && u !== o;){
            if (n(s[u], a[f])) return [
                f,
                u
            ];
            f = Pu(f, c, r), u = Pu(u, l, r);
        }
        return [
            void 0,
            void 0
        ];
    }
    function QJ(t, e) {
        const [n, r] = JJ(t, e) || [], i = (c, l)=>YJ(c, l) === !1, [a, o] = Vw([
            Pu(n, t.length, 1),
            n,
            t
        ], [
            Pu(r, e.length, 1),
            r,
            e
        ], i, 1), [s] = Vw([
            Pu(a, t.length, -1),
            a,
            t
        ], [
            Pu(o, e.length, -1),
            o,
            e
        ], i, -1);
        return [
            a,
            s
        ];
    }
    function o2(t, e, n) {
        const { interpolation: r, smoothing: i } = t, a = e;
        if (r) {
            const { knotsRatioPercentageOnAdd: o, knotsRatioPercentageOnEdit: s, smoothOnAdd: c = !1, smoothOnEdit: l = !1 } = i, f = n ? s : o;
            if (n ? l : c) {
                const [g, h] = n ? QJ(e, n) : [
                    0,
                    e.length - 1
                ];
                return !e[g] || !e[h] ? e : XJ(e, g, h, f);
            }
        }
        return a;
    }
    const fg = (t)=>{
        if (t.shiftKey) return t.ctrlKey ? aa.ShiftCtrl : t.altKey ? aa.ShiftAlt : t.metaKey ? aa.ShiftMeta : aa.Shift;
        if (t.ctrlKey) return t.altKey ? aa.CtrlAlt : t.metaKey ? aa.CtrlMeta : aa.Ctrl;
        if (t.altKey) return t.metaKey && aa.AltMeta || aa.Alt;
        if (t.metaKey) return aa.Meta;
    };
    function fy(t, e) {
        const n = t[0], r = t[t.length - 1], i = sn();
        qo(i, r[0] - n[0], r[1] - n[1]), Ou(i, i);
        const a = sn(), o = sn();
        qo(a, -i[1], i[0]), qo(o, i[1], -i[0]);
        const s = [
            (n[0] + r[0]) / 2,
            (n[1] + r[1]) / 2
        ], c = {
            dist: 0,
            index: null
        };
        for(let u = 0; u < t.length; u++){
            const g = t[u], h = z3(g, s);
            h > c.dist && (c.dist = h, c.index = u);
        }
        return [
            t[c.index],
            s
        ].map(e.canvasToWorld);
    }
    function eQ(t, e) {
        const { viewport: n } = t, r = e.data.contour.polyline.map(n.worldToCanvas);
        return fy(r, n);
    }
    const { addCanvasPointsToArray: dy, pointsAreWithinCloseContourProximity: WR, getFirstLineSegmentIntersectionIndexes: $R, getSubPixelSpacingAndXYDirections: tQ } = H0;
    function nQ(t, e, n) {
        this.isDrawing = !0;
        const r = t.detail, { currentPoints: i, element: a } = r, o = i.canvas, s = Fe(a), { viewport: c } = s, l = fg(t.detail.event) === this.configuration.contourHoleAdditionModifierKey, { spacing: f, xDir: u, yDir: g } = tQ(c, this.configuration.subPixelResolution) || {};
        !f || !u || !g || (this.drawData = {
            canvasPoints: [
                o
            ],
            polylineIndex: 0,
            contourHoleProcessingEnabled: l,
            newAnnotation: !0
        }, this.commonData = {
            annotation: e,
            viewportIdsToRender: n,
            spacing: f,
            xDir: u,
            yDir: g,
            movingTextBox: !1
        }, nt.isInteractingWithTool = !0, a.addEventListener(z.MOUSE_UP, this.mouseUpDrawCallback), a.addEventListener(z.MOUSE_DRAG, this.mouseDragDrawCallback), a.addEventListener(z.MOUSE_CLICK, this.mouseUpDrawCallback), a.addEventListener(z.TOUCH_END, this.mouseUpDrawCallback), a.addEventListener(z.TOUCH_DRAG, this.mouseDragDrawCallback), a.addEventListener(z.TOUCH_TAP, this.mouseUpDrawCallback), Mn(a));
    }
    function rQ(t) {
        nt.isInteractingWithTool = !1, t.removeEventListener(z.MOUSE_UP, this.mouseUpDrawCallback), t.removeEventListener(z.MOUSE_DRAG, this.mouseDragDrawCallback), t.removeEventListener(z.MOUSE_CLICK, this.mouseUpDrawCallback), t.removeEventListener(z.TOUCH_END, this.mouseUpDrawCallback), t.removeEventListener(z.TOUCH_DRAG, this.mouseDragDrawCallback), t.removeEventListener(z.TOUCH_TAP, this.mouseUpDrawCallback), fr(t);
    }
    function iQ(t) {
        const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, o = Fe(r), { viewport: s } = o, { annotation: c, viewportIdsToRender: l, xDir: f, yDir: u, spacing: g, movingTextBox: h } = this.commonData, { polylineIndex: v, canvasPoints: m, newAnnotation: y } = this.drawData;
        this.createMemo(r, c, {
            newAnnotation: y
        });
        const C = m[m.length - 1], T = s.canvasToWorld(C), x = Xe();
        kr(x, i, T);
        const S = Math.abs(xt(x, f)), D = Math.abs(xt(x, u));
        if (!(S <= g[0] && D <= g[1])) {
            if (h) {
                this.isDrawing = !1;
                const { deltaPoints: _ } = e, M = _.world, { textBox: P } = c.data.handles, { worldPosition: F } = P;
                F[0] += M[0], F[1] += M[1], F[2] += M[2], P.hasMoved = !0;
            } else {
                const _ = this.findCrossingIndexDuringCreate(t);
                if (_ !== void 0) this.applyCreateOnCross(t, _);
                else {
                    const M = dy(r, m, a, this.commonData);
                    this.drawData.polylineIndex = v + M;
                }
                c.invalidated = !0;
            }
            it(l), c.invalidated && yn(c, r, Jt.HandlesUpdated);
        }
    }
    function aQ(t) {
        const { allowOpenContours: e } = this.configuration, { canvasPoints: n, contourHoleProcessingEnabled: r } = this.drawData, i = n[0], a = n[n.length - 1], o = t.detail, { element: s } = o;
        this.doneEditMemo(), this.drawData.newAnnotation = !1, e && !WR(i, a, this.configuration.closeContourProximity) ? this.completeDrawOpenContour(s, {
            contourHoleProcessingEnabled: r
        }) : this.completeDrawClosedContour(s, {
            contourHoleProcessingEnabled: r
        });
    }
    function oQ(t, e) {
        this.removeCrossedLinesOnCompleteDraw();
        const { canvasPoints: n } = this.drawData, { contourHoleProcessingEnabled: r, minPointsToSave: i } = e ?? {};
        if (i && n.length < i || this.haltDrawing(t, n)) return !1;
        const { annotation: a, viewportIdsToRender: o } = this.commonData, s = Fe(t), { viewport: c, renderingEngine: l } = s;
        dy(t, n, n[0], this.commonData), n.pop();
        const f = a2(this.configuration, a) ? o2(this.configuration, n) : n;
        this.updateContourPolyline(a, {
            points: f,
            closed: !0,
            targetWindingDirection: Za.Clockwise
        }, c);
        const { textBox: u } = a.data.handles;
        return u?.hasMoved || j4(a, r), this.isDrawing = !1, this.drawData = void 0, this.commonData = void 0, it(o), this.deactivateDraw(t), !0;
    }
    function sQ() {
        const { canvasPoints: t } = this.drawData, e = t.length, n = [
            t[0],
            t[e - 1]
        ], r = t.slice(0, -1).slice(1), i = $R(r, n[0], n[1], !1);
        if (i) {
            const a = i[1];
            a === 1 ? this.drawData.canvasPoints = t.splice(1) : this.drawData.canvasPoints = t.splice(0, a);
        }
    }
    function cQ(t, e) {
        const { canvasPoints: n } = this.drawData, { contourHoleProcessingEnabled: r } = e ?? {};
        if (this.haltDrawing(t, n)) return !1;
        const { annotation: i, viewportIdsToRender: a } = this.commonData, o = Fe(t), { viewport: s, renderingEngine: c } = o, l = a2(this.configuration, i) ? o2(this.configuration, n) : n;
        this.updateContourPolyline(i, {
            points: l,
            closed: !1
        }, s);
        const { textBox: f } = i.data.handles, u = i.data.contour.polyline;
        return i.data.handles.points = [
            u[0],
            u[u.length - 1]
        ], i.data.isOpenUShapeContour && (i.data.openUShapeContourVectorToPeak = fy(n, s)), f.hasMoved || j4(i, r), this.isDrawing = !1, this.drawData = void 0, this.commonData = void 0, it(a), this.deactivateDraw(t), !0;
    }
    function lQ(t) {
        const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { canvasPoints: o } = this.drawData, s = o.slice(0, -1), c = $R(s, i, a, !1);
        return c === void 0 ? void 0 : c[0];
    }
    function uQ(t, e) {
        const n = t.detail, { element: r } = n, { canvasPoints: i, contourHoleProcessingEnabled: a } = this.drawData, { annotation: o, viewportIdsToRender: s } = this.commonData;
        dy(r, i, i[e], this.commonData), i.pop();
        const c = i.slice(e), l = r2(c);
        if (lr(l, 0)) {
            i.splice(e + 1);
            return;
        }
        i.splice(0, e);
        const f = {
            contourHoleProcessingEnabled: a,
            minPointsToSave: 3
        };
        this.completeDrawClosedContour(r, f) && this.activateClosedContourEdit(t, o, s);
    }
    function fQ(t) {
        const { allowOpenContours: e } = this.configuration, { canvasPoints: n, contourHoleProcessingEnabled: r } = this.drawData, i = n[0], a = n[n.length - 1];
        e && !WR(i, a, this.configuration.closeContourProximity) ? this.completeDrawOpenContour(t, {
            contourHoleProcessingEnabled: r
        }) : this.completeDrawClosedContour(t, {
            contourHoleProcessingEnabled: r
        });
    }
    function dQ(t, e) {
        const n = Math.max(e * 3, 3);
        return t.length < n;
    }
    function gQ(t, e) {
        const { subPixelResolution: n } = this.configuration;
        if (dQ(e, n)) {
            const { annotation: r, viewportIdsToRender: i } = this.commonData, a = Fe(t), { renderingEngine: o } = a;
            return Ir(r.annotationUID), this.isDrawing = !1, this.drawData = void 0, this.commonData = void 0, it(i), this.deactivateDraw(t), !0;
        }
        return !1;
    }
    function hQ(t) {
        t.activateDraw = nQ.bind(t), t.deactivateDraw = rQ.bind(t), t.applyCreateOnCross = uQ.bind(t), t.findCrossingIndexDuringCreate = lQ.bind(t), t.completeDrawOpenContour = cQ.bind(t), t.removeCrossedLinesOnCompleteDraw = sQ.bind(t), t.mouseDragDrawCallback = iQ.bind(t), t.mouseUpDrawCallback = aQ.bind(t), t.completeDrawClosedContour = oQ.bind(t), t.cancelDrawing = fQ.bind(t), t.haltDrawing = gQ.bind(t);
    }
    const { addCanvasPointsToArray: pQ, getFirstLineSegmentIntersectionIndexes: z0 } = H0;
    function mQ(t, e) {
        const n = t.detail, { element: r, currentPoints: i, lastPoints: a } = n, o = i.canvas, s = a.canvas, { editCanvasPoints: c, prevCanvasPoints: l } = this.editData, f = z0(l, o, s, e);
        if (f) this.editData.startCrossingIndex = f[0], this.removePointsUpUntilFirstCrossing(e);
        else if (l.length >= 2) if (c.length > this.configuration.checkCanvasEditFallbackProximity) {
            const u = c[0], g = [];
            for(let m = 0; m < l.length; m++){
                const y = l[m], C = Or(y, u);
                g.push({
                    distance: C,
                    index: m
                });
            }
            g.sort((m, y)=>m.distance - y.distance);
            const h = [
                g[0],
                g[1]
            ], v = Math.min(h[0].index, h[1].index);
            this.editData.startCrossingIndex = v;
        } else {
            const u = sn();
            yi(u, c[1], c[0]), Ou(u, u);
            const g = 6, h = [
                c[0][0] - u[0] * g,
                c[0][1] - u[1] * g
            ], v = z0(l, h, c[0], e);
            if (v) {
                const m = [
                    h
                ];
                pQ(r, m, c[0], this.commonData), c.unshift(...m), this.removePointsUpUntilFirstCrossing(e), this.editData.editIndex = c.length - 1, this.editData.startCrossingIndex = v[0];
            }
        }
    }
    function vQ(t) {
        const { editCanvasPoints: e, prevCanvasPoints: n } = this.editData;
        let r = 0;
        for(let i = 0; i < e.length - 1; i++){
            const a = [
                e[i],
                e[i + 1]
            ], o = !!z0(n, a[0], a[1], t);
            if (r++, o) break;
        }
        e.splice(0, r), this.editData.editIndex = e.length - 1;
    }
    function yQ(t, e) {
        const n = t.detail, { currentPoints: r, lastPoints: i } = n, a = r.canvas, o = i.canvas, { prevCanvasPoints: s } = this.editData;
        return !!z0(s, a, o, e);
    }
    function CQ(t) {
        const { prevCanvasPoints: e, editCanvasPoints: n } = this.editData;
        for(let r = n.length - 1; r > 0; r--){
            const i = [
                n[r],
                n[r - 1]
            ], a = !!z0(e, i[0], i[1], t);
            if (n.pop(), a) break;
        }
    }
    function wQ() {
        const { editCanvasPoints: t, prevCanvasPoints: e, startCrossingIndex: n } = this.editData;
        if (n === void 0) return;
        const r = t[t.length - 1], i = [];
        for(let o = 0; o < e.length; o++){
            const s = e[o], c = Or(s, r);
            i.push({
                distance: c,
                index: o
            });
        }
        i.sort((o, s)=>o.distance - s.distance);
        const a = t.slice(0, -1);
        for(let o = 0; o < i.length; o++){
            const { index: s } = i[o], c = e[s], l = t[t.length - 1];
            if (!z0(a, c, l, !1)) return s;
        }
        return -1;
    }
    function TQ(t) {
        const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { editCanvasPoints: o } = this.editData, s = o.slice(0, -2), c = z0(s, i, a, !1);
        if (!c) return;
        const l = c[0], f = o.length - l;
        for(let u = 0; u < f; u++)o.pop();
    }
    function xQ(t) {
        t.checkForFirstCrossing = mQ.bind(t), t.removePointsUpUntilFirstCrossing = vQ.bind(t), t.checkForSecondCrossing = yQ.bind(t), t.findSnapIndex = wQ.bind(t), t.removePointsAfterSecondCrossing = CQ.bind(t), t.checkAndRemoveCrossesOnEditLine = TQ.bind(t);
    }
    const { getSubPixelSpacingAndXYDirections: SQ, addCanvasPointsToArray: zR, getArea: Nw } = H0;
    function EQ(t, e, n) {
        this.isEditingClosed = !0;
        const r = t.detail, { currentPoints: i, element: a } = r, o = i.canvas, s = Fe(a);
        if (!s) return;
        const { viewport: c } = s, l = e.data.contour.polyline.map(c.worldToCanvas), { spacing: f, xDir: u, yDir: g } = SQ(c, this.configuration.subPixelResolution);
        this.editData = {
            prevCanvasPoints: l,
            editCanvasPoints: [
                o
            ],
            startCrossingIndex: void 0,
            editIndex: 0,
            annotation: e
        }, this.commonData = {
            annotation: e,
            viewportIdsToRender: n,
            spacing: f,
            xDir: u,
            yDir: g,
            movingTextBox: !1
        }, nt.isInteractingWithTool = !0, a.addEventListener(z.MOUSE_UP, this.mouseUpClosedContourEditCallback), a.addEventListener(z.MOUSE_DRAG, this.mouseDragClosedContourEditCallback), a.addEventListener(z.MOUSE_CLICK, this.mouseUpClosedContourEditCallback), a.addEventListener(z.TOUCH_END, this.mouseUpClosedContourEditCallback), a.addEventListener(z.TOUCH_DRAG, this.mouseDragClosedContourEditCallback), a.addEventListener(z.TOUCH_TAP, this.mouseUpClosedContourEditCallback), Mn(a);
    }
    function DQ(t) {
        nt.isInteractingWithTool = !1, t.removeEventListener(z.MOUSE_UP, this.mouseUpClosedContourEditCallback), t.removeEventListener(z.MOUSE_DRAG, this.mouseDragClosedContourEditCallback), t.removeEventListener(z.MOUSE_CLICK, this.mouseUpClosedContourEditCallback), t.removeEventListener(z.TOUCH_END, this.mouseUpClosedContourEditCallback), t.removeEventListener(z.TOUCH_DRAG, this.mouseDragClosedContourEditCallback), t.removeEventListener(z.TOUCH_TAP, this.mouseUpClosedContourEditCallback), fr(t);
    }
    function _Q(t) {
        const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, o = Fe(r), { viewport: s } = o, { viewportIdsToRender: c, xDir: l, yDir: f, spacing: u } = this.commonData, { editIndex: g, editCanvasPoints: h, startCrossingIndex: v, annotation: m } = this.editData;
        this.createMemo(r, m);
        const y = h[h.length - 1], C = s.canvasToWorld(y), T = Xe();
        kr(T, i, C);
        const x = Math.abs(xt(T, l)), S = Math.abs(xt(T, f));
        if (x <= u[0] && S <= u[1]) return;
        v !== void 0 && this.checkAndRemoveCrossesOnEditLine(t);
        const D = zR(r, h, a, this.commonData), _ = g + D;
        if (this.editData.editIndex = _, v === void 0 && h.length > 1 && this.checkForFirstCrossing(t, !0), this.editData.snapIndex = this.findSnapIndex(), this.editData.snapIndex === -1) {
            this.finishEditAndStartNewEdit(t);
            return;
        }
        this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(t), v !== void 0 && this.checkForSecondCrossing(t, !0) && (this.removePointsAfterSecondCrossing(!0), this.finishEditAndStartNewEdit(t)), it(c);
    }
    function RQ(t) {
        const e = t.detail, { element: n } = e, r = Fe(n), { viewport: i, renderingEngine: a } = r, { annotation: o, viewportIdsToRender: s } = this.commonData, { fusedCanvasPoints: c, editCanvasPoints: l } = this.editData;
        uc(o, {
            points: c,
            closed: !0,
            targetWindingDirection: Za.Clockwise
        }, i), o.autoGenerated && (o.autoGenerated = !1), yn(o, n);
        const f = l.pop();
        this.editData = {
            prevCanvasPoints: c,
            editCanvasPoints: [
                f
            ],
            startCrossingIndex: void 0,
            editIndex: 0,
            snapIndex: void 0,
            annotation: o
        }, it(s);
    }
    function OQ(t) {
        const { prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r, snapIndex: i } = this.editData;
        if (r === void 0 || i === void 0) return;
        const a = t.detail, { element: o } = a, s = [
            ...n
        ];
        zR(o, s, e[i], this.commonData), s.length > n.length && s.pop();
        let c, l;
        r > i ? (c = i, l = r) : (c = r, l = i);
        const f = Or(e[c], s[0]), u = Or(e[c], s[s.length - 1]), g = Or(e[l], s[0]), h = Or(e[l], s[s.length - 1]), v = [];
        for(let D = 0; D < c; D++){
            const _ = e[D];
            v.push([
                _[0],
                _[1]
            ]);
        }
        let m = f + h, y = u + g;
        if (m < y) for(let D = 0; D < s.length; D++){
            const _ = s[D];
            v.push([
                _[0],
                _[1]
            ]);
        }
        else for(let D = s.length - 1; D >= 0; D--){
            const _ = s[D];
            v.push([
                _[0],
                _[1]
            ]);
        }
        for(let D = l; D < e.length; D++){
            const _ = e[D];
            v.push([
                _[0],
                _[1]
            ]);
        }
        const C = [];
        for(let D = c; D < l; D++){
            const _ = e[D];
            C.push([
                _[0],
                _[1]
            ]);
        }
        if (m = g + u, y = h + f, m < y) for(let D = 0; D < s.length; D++){
            const _ = s[D];
            C.push([
                _[0],
                _[1]
            ]);
        }
        else for(let D = s.length - 1; D >= 0; D--){
            const _ = s[D];
            C.push([
                _[0],
                _[1]
            ]);
        }
        const T = Nw(v), x = Nw(C);
        return T > x ? v : C;
    }
    function IQ(t) {
        const e = t.detail, { element: n } = e;
        this.completeClosedContourEdit(n);
    }
    function MQ(t) {
        const e = Fe(t), { viewport: n } = e, { annotation: r, viewportIdsToRender: i } = this.commonData;
        this.doneEditMemo();
        const { fusedCanvasPoints: a, prevCanvasPoints: o } = this.editData;
        if (a) {
            const s = a2(this.configuration, r) ? o2(this.configuration, a, o) : a, c = this.configuration?.decimate || {};
            uc(r, {
                points: s,
                closed: !0,
                targetWindingDirection: Za.Clockwise
            }, n, {
                decimate: {
                    enabled: !!c.enabled,
                    epsilon: c.epsilon
                }
            }), r.autoGenerated && (r.autoGenerated = !1), yn(r, t);
        }
        this.isEditingClosed = !1, this.editData = void 0, this.commonData = void 0, it(i), this.deactivateClosedContourEdit(t);
    }
    function bQ(t) {
        this.completeClosedContourEdit(t);
    }
    function LQ(t) {
        t.activateClosedContourEdit = EQ.bind(t), t.deactivateClosedContourEdit = DQ.bind(t), t.mouseDragClosedContourEditCallback = _Q.bind(t), t.mouseUpClosedContourEditCallback = IQ.bind(t), t.finishEditAndStartNewEdit = RQ.bind(t), t.fuseEditPointsWithClosedContour = OQ.bind(t), t.cancelClosedContourEdit = bQ.bind(t), t.completeClosedContourEdit = MQ.bind(t);
    }
    const { addCanvasPointsToArray: jR, getSubPixelSpacingAndXYDirections: PQ } = H0;
    function VQ(t, e, n) {
        this.isEditingOpen = !0;
        const r = t.detail, { currentPoints: i, element: a } = r, o = i.canvas, s = Fe(a), { viewport: c } = s;
        this.doneEditMemo();
        const l = e.data.contour.polyline.map(c.worldToCanvas), { spacing: f, xDir: u, yDir: g } = PQ(c, this.configuration.subPixelResolution);
        this.editData = {
            prevCanvasPoints: l,
            editCanvasPoints: [
                o
            ],
            startCrossingIndex: void 0,
            editIndex: 0
        }, this.commonData = {
            annotation: e,
            viewportIdsToRender: n,
            spacing: f,
            xDir: u,
            yDir: g,
            movingTextBox: !1
        }, nt.isInteractingWithTool = !0, a.addEventListener(z.MOUSE_UP, this.mouseUpOpenContourEditCallback), a.addEventListener(z.MOUSE_DRAG, this.mouseDragOpenContourEditCallback), a.addEventListener(z.MOUSE_CLICK, this.mouseUpOpenContourEditCallback), a.addEventListener(z.TOUCH_END, this.mouseUpOpenContourEditCallback), a.addEventListener(z.TOUCH_DRAG, this.mouseDragOpenContourEditCallback), a.addEventListener(z.TOUCH_TAP, this.mouseUpOpenContourEditCallback), Mn(a);
    }
    function NQ(t) {
        nt.isInteractingWithTool = !1, t.removeEventListener(z.MOUSE_UP, this.mouseUpOpenContourEditCallback), t.removeEventListener(z.MOUSE_DRAG, this.mouseDragOpenContourEditCallback), t.removeEventListener(z.MOUSE_CLICK, this.mouseUpOpenContourEditCallback), t.removeEventListener(z.TOUCH_END, this.mouseUpOpenContourEditCallback), t.removeEventListener(z.TOUCH_DRAG, this.mouseDragOpenContourEditCallback), t.removeEventListener(z.TOUCH_TAP, this.mouseUpOpenContourEditCallback), fr(t);
    }
    function AQ(t) {
        const e = t.detail, { currentPoints: n, element: r } = e, i = n.world, a = n.canvas, o = Fe(r), { viewport: s } = o, { viewportIdsToRender: c, xDir: l, yDir: f, spacing: u } = this.commonData, { editIndex: g, editCanvasPoints: h, startCrossingIndex: v } = this.editData, m = h[h.length - 1], y = s.canvasToWorld(m), C = Xe();
        this.createMemo(r, this.commonData.annotation), kr(C, i, y);
        const T = Math.abs(xt(C, l)), x = Math.abs(xt(C, f));
        if (T <= u[0] && x <= u[1]) return;
        v !== void 0 && this.checkAndRemoveCrossesOnEditLine(t);
        const S = jR(r, h, a, this.commonData), D = g + S;
        this.editData.editIndex = D, v === void 0 && h.length > 1 && this.checkForFirstCrossing(t, !1), this.editData.snapIndex = this.findSnapIndex(), this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(t), v !== void 0 && this.checkForSecondCrossing(t, !1) ? (this.removePointsAfterSecondCrossing(!1), this.finishEditOpenOnSecondCrossing(t)) : this.checkIfShouldOverwriteAnEnd(t) && this.openContourEditOverwriteEnd(t), it(c);
    }
    function kQ(t) {
        const e = t.detail, { element: n } = e, r = Fe(n), { viewport: i } = r, { annotation: a, viewportIdsToRender: o } = this.commonData, s = this.fuseEditPointsForOpenContourEndEdit();
        uc(a, {
            points: s,
            closed: !1
        }, i);
        const c = a.data.contour.polyline;
        a.data.handles.points = [
            c[0],
            c[c.length - 1]
        ], a.data.handles.activeHandleIndex = 1, yn(a, n), this.isEditingOpen = !1, this.editData = void 0, this.commonData = void 0, this.doneEditMemo(), this.deactivateOpenContourEdit(n), this.activateOpenContourEndEdit(t, a, o, null);
    }
    function UQ(t) {
        const e = t.detail, { currentPoints: n, lastPoints: r } = e, i = n.canvas, a = r.canvas, { snapIndex: o, prevCanvasPoints: s, startCrossingIndex: c } = this.editData;
        if (c === void 0 || o === void 0) return !1;
        if (o === -1) return !0;
        if (o !== 0 && o !== s.length - 1) return !1;
        const l = i, f = a, u = s[o], g = sn(), h = sn();
        qo(g, l[0] - f[0], l[1] - f[1]), qo(h, l[0] - u[0], l[1] - u[1]);
        const v = kc(g, h), m = Math.sqrt(g[0] * g[0] + g[1] * g[1]), y = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
        return Math.acos(v / (m * y)) < Math.PI / 2;
    }
    function FQ() {
        const { snapIndex: t, prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r } = this.editData, i = [];
        if (t === 0) for(let s = e.length - 1; s >= r; s--){
            const c = e[s];
            i.push([
                c[0],
                c[1]
            ]);
        }
        else for(let s = 0; s < r; s++){
            const c = e[s];
            i.push([
                c[0],
                c[1]
            ]);
        }
        const a = Or(e[r], n[0]), o = Or(e[r], n[n.length - 1]);
        if (a < o) for(let s = 0; s < n.length; s++){
            const c = n[s];
            i.push([
                c[0],
                c[1]
            ]);
        }
        else for(let s = n.length - 1; s >= 0; s--){
            const c = n[s];
            i.push([
                c[0],
                c[1]
            ]);
        }
        return i;
    }
    function BQ(t) {
        const { prevCanvasPoints: e, editCanvasPoints: n, startCrossingIndex: r, snapIndex: i } = this.editData;
        if (r === void 0 || i === void 0) return;
        const a = t.detail, { element: o } = a, s = [
            ...n
        ];
        jR(o, s, e[i], this.commonData), s.length > n.length && s.pop();
        let c, l;
        r > i ? (c = i, l = r) : (c = r, l = i);
        const f = Or(e[c], s[0]), u = Or(e[c], s[s.length - 1]), g = Or(e[l], s[0]), h = Or(e[l], s[s.length - 1]), v = [];
        for(let C = 0; C < c; C++){
            const T = e[C];
            v.push([
                T[0],
                T[1]
            ]);
        }
        const m = f + h, y = u + g;
        if (m < y) for(let C = 0; C < s.length; C++){
            const T = s[C];
            v.push([
                T[0],
                T[1]
            ]);
        }
        else for(let C = s.length - 1; C >= 0; C--){
            const T = s[C];
            v.push([
                T[0],
                T[1]
            ]);
        }
        for(let C = l; C < e.length; C++){
            const T = e[C];
            v.push([
                T[0],
                T[1]
            ]);
        }
        return v;
    }
    function GQ(t) {
        const e = t.detail, { element: n } = e, r = Fe(n), { viewport: i, renderingEngine: a } = r, { annotation: o, viewportIdsToRender: s } = this.commonData, { fusedCanvasPoints: c, editCanvasPoints: l } = this.editData;
        uc(o, {
            points: c,
            closed: !1
        }, i);
        const f = o.data.contour.polyline;
        o.data.handles.points = [
            f[0],
            f[f.length - 1]
        ], yn(o, n);
        const u = l.pop();
        this.editData = {
            prevCanvasPoints: c,
            editCanvasPoints: [
                u
            ],
            startCrossingIndex: void 0,
            editIndex: 0
        }, it(s);
    }
    function WQ(t) {
        const e = t.detail, { element: n } = e;
        this.completeOpenContourEdit(n);
    }
    function $Q(t) {
        const e = Fe(t), { viewport: n } = e, { annotation: r, viewportIdsToRender: i } = this.commonData;
        this.doneEditMemo();
        const { fusedCanvasPoints: a, prevCanvasPoints: o } = this.editData;
        if (a) {
            const s = a2(this.configuration) ? o2(this.configuration, a, o) : a, c = this.configuration?.decimate || {};
            uc(r, {
                points: s,
                closed: !1
            }, n, {
                decimate: {
                    enabled: !!c.enabled,
                    epsilon: c.epsilon
                }
            });
            const l = r.data.contour.polyline;
            r.data.handles.points = [
                l[0],
                l[l.length - 1]
            ], r.data.isOpenUShapeContour && (r.data.openUShapeContourVectorToPeak = fy(a, n)), yn(r, t);
        }
        this.isEditingOpen = !1, this.editData = void 0, this.commonData = void 0, it(i), this.deactivateOpenContourEdit(t);
    }
    function zQ(t) {
        this.completeOpenContourEdit(t);
    }
    function jQ(t) {
        t.activateOpenContourEdit = VQ.bind(t), t.deactivateOpenContourEdit = NQ.bind(t), t.mouseDragOpenContourEditCallback = AQ.bind(t), t.mouseUpOpenContourEditCallback = WQ.bind(t), t.fuseEditPointsWithOpenContour = BQ.bind(t), t.finishEditOpenOnSecondCrossing = GQ.bind(t), t.checkIfShouldOverwriteAnEnd = UQ.bind(t), t.fuseEditPointsForOpenContourEndEdit = FQ.bind(t), t.openContourEditOverwriteEnd = kQ.bind(t), t.cancelOpenContourEdit = zQ.bind(t), t.completeOpenContourEdit = $Q.bind(t);
    }
    const { getSubPixelSpacingAndXYDirections: HQ } = H0;
    function KQ(t, e, n, r) {
        this.isDrawing = !0;
        const i = t.detail, { element: a } = i, o = Fe(a), { viewport: s } = o, { spacing: c, xDir: l, yDir: f } = HQ(s, this.configuration.subPixelResolution), u = e.data.contour.polyline.map(s.worldToCanvas);
        e.data.handles.activeHandleIndex === 0 && u.reverse();
        let h = !1;
        r?.worldPosition && (h = !0), this.drawData = {
            canvasPoints: u,
            polylineIndex: u.length - 1
        }, this.commonData = {
            annotation: e,
            viewportIdsToRender: n,
            spacing: c,
            xDir: l,
            yDir: f,
            movingTextBox: h
        }, nt.isInteractingWithTool = !0, a.addEventListener(z.MOUSE_UP, this.mouseUpDrawCallback), a.addEventListener(z.MOUSE_DRAG, this.mouseDragDrawCallback), a.addEventListener(z.MOUSE_CLICK, this.mouseUpDrawCallback), a.addEventListener(z.TOUCH_END, this.mouseUpDrawCallback), a.addEventListener(z.TOUCH_DRAG, this.mouseDragDrawCallback), a.addEventListener(z.TOUCH_TAP, this.mouseUpDrawCallback), Mn(a);
    }
    function qQ(t) {
        t.activateOpenContourEndEdit = KQ.bind(t);
    }
    function XQ(t) {
        return (t.childAnnotationUIDs ?? []).map((n)=>fa(n).data.contour.polyline);
    }
    function s2(t, e) {
        const n = XQ(t), r = [];
        return n.forEach((i)=>{
            const a = i.length, o = new Array(a);
            for(let s = 0; s < a; s++)o[s] = e.worldToCanvas(i[s]);
            r.push(o);
        }), r;
    }
    const { pointsAreWithinCloseContourProximity: YQ } = H0;
    function ZQ(t, e) {
        const n = {
            toolGroupId: this.toolGroupId,
            toolName: this.getToolName(),
            viewportId: t.viewport.id,
            annotationUID: e.annotationUID
        }, { lineWidth: r, lineDash: i, color: a, fillColor: o, fillOpacity: s } = this.getAnnotationStyle({
            annotation: e,
            styleSpecifier: n
        }), { closed: c } = e.data.contour;
        return {
            color: a,
            width: r,
            lineDash: i,
            fillColor: o,
            fillOpacity: s,
            closePath: c
        };
    }
    function JQ(t, e, n) {
        t?.viewport?.getImageData() && (n.data.contour.closed ? this.renderClosedContour(t, e, n) : n.data.isOpenUShapeContour ? (QQ(t, n), this.renderOpenUShapedContour(t, e, n)) : this.renderOpenContour(t, e, n));
    }
    function QQ(t, e) {
        e.data.openUShapeContourVectorToPeak || (e.data.openUShapeContourVectorToPeak = eQ(t, e));
    }
    function eee(t, e, n) {
        if (n.parentAnnotationUID) return;
        const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((l)=>r.worldToCanvas(l)), o = s2(n, r), s = [
            a,
            ...o
        ];
        A0(e, n.annotationUID, "1", s, i);
    }
    function tee(t, e, n) {
        const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((c)=>r.worldToCanvas(c));
        Yc(e, n.annotationUID, "1", a, i);
        const s = n.data.handles.activeHandleIndex;
        if (this.configuration.alwaysRenderOpenContourHandles?.enabled === !0) {
            const c = this.configuration.alwaysRenderOpenContourHandles.radius, l = "0", f = [
                a[0],
                a[a.length - 1]
            ];
            s === 0 ? f.shift() : s === 1 && f.pop(), Do(e, n.annotationUID, l, f, {
                color: i.color,
                handleRadius: c
            });
        }
        if (s !== null) {
            const c = "1", l = s === 0 ? 0 : a.length - 1, f = a[l];
            Do(e, n.annotationUID, c, [
                f
            ], {
                color: i.color
            });
        }
    }
    function nee(t, e, n) {
        const { viewport: r } = t, { openUShapeContourVectorToPeak: i } = n.data, { polyline: a } = n.data.contour;
        if (this.renderOpenContour(t, e, n), !i) return;
        const o = r.worldToCanvas(a[0]), s = r.worldToCanvas(a[a.length - 1]), c = [
            r.worldToCanvas(i[0]),
            r.worldToCanvas(i[1])
        ], l = this._getRenderingOptions(t, n);
        Yc(e, n.annotationUID, "first-to-last", [
            o,
            s
        ], {
            color: l.color,
            width: l.width,
            closePath: !1,
            lineDash: "2,2"
        }), Yc(e, n.annotationUID, "midpoint-to-open-contour", [
            c[0],
            c[1]
        ], {
            color: l.color,
            width: l.width,
            closePath: !1,
            lineDash: "2,2"
        });
    }
    function ree(t, e, n) {
        const r = this._getRenderingOptions(t, n), { allowOpenContours: i } = this.configuration, { canvasPoints: a } = this.drawData;
        if (r.closePath = !1, Yc(e, n.annotationUID, "1", a, r), i) {
            const o = a[0], s = a[a.length - 1];
            YQ(o, s, this.configuration.closeContourProximity) ? Yc(e, n.annotationUID, "2", [
                s,
                o
            ], r) : Do(e, n.annotationUID, "0", [
                o
            ], {
                color: r.color,
                handleRadius: 2
            });
        }
    }
    function iee(t, e, n) {
        const { viewport: r } = t, { fusedCanvasPoints: i } = this.editData;
        if (i === void 0) {
            this.renderClosedContour(t, e, n);
            return;
        }
        const a = s2(n, r), o = [
            i,
            ...a
        ], s = this._getRenderingOptions(t, n), c = "preview-1";
        n.parentAnnotationUID && s.fillOpacity && (s.fillOpacity = 0), A0(e, n.annotationUID, c, o, s);
    }
    function aee(t, e, n) {
        const { fusedCanvasPoints: r } = this.editData;
        if (r === void 0) {
            this.renderOpenContour(t, e, n);
            return;
        }
        const i = this._getRenderingOptions(t, n);
        Yc(e, n.annotationUID, "preview-1", r, i);
    }
    function oee(t, e, n) {
        if (n.parentAnnotationUID) return;
        const { viewport: r } = t, i = this._getRenderingOptions(t, n), a = n.data.contour.polyline.map((v)=>r.worldToCanvas(v)), o = s2(n, r), s = "1", c = a[0], l = 6, f = 100, u = [];
        for(let v = 0; v < f; v++){
            const m = v / f * 2 * Math.PI, y = c[0] + l * Math.cos(m), C = c[1] + l * Math.sin(m);
            u.push([
                y,
                C
            ]);
        }
        const g = [
            [
                c[0] - l * 2,
                c[1]
            ],
            [
                c[0] + l * 2,
                c[1]
            ],
            [
                c[0],
                c[1] - l * 2
            ],
            [
                c[0],
                c[1] + l * 2
            ]
        ];
        A0(e, n.annotationUID, s + "-crosshair_v", [
            g[0],
            g[1]
        ], i), A0(e, n.annotationUID, s + "-crosshair_h", [
            g[2],
            g[3]
        ], i);
        const h = [
            u,
            ...o
        ];
        A0(e, n.annotationUID, s, h, i);
    }
    function see(t) {
        t.renderContour = JQ.bind(t), t.renderClosedContour = eee.bind(t), t.renderOpenContour = tee.bind(t), t.renderPointContourWithMarker = oee.bind(t), t.renderOpenUShapedContour = nee.bind(t), t.renderContourBeingDrawn = ree.bind(t), t.renderClosedContourBeingEdited = iee.bind(t), t.renderOpenContourBeingEdited = aee.bind(t), t._getRenderingOptions = ZQ.bind(t);
    }
    function Jl(t) {
        const e = cee(t), n = (e.top[1] + e.bottom[1]) / 2;
        return [
            e.right[0],
            n
        ];
    }
    function cee(t) {
        const e = [
            t[0],
            t[1]
        ].sort(o), n = [
            t[0],
            t[1]
        ].sort(s), r = e[e.length - 1], i = n[0], a = n[n.length - 1];
        return {
            top: i,
            bottom: a,
            right: r
        };
        function o(c, l) {
            return c[0] < l[0] ? -1 : 1;
        }
        function s(c, l) {
            return c[1] < l[1] ? -1 : 1;
        }
    }
    function dg(t, e) {
        if (t instanceof So) {
            const n = lf(e), r = ot.getVolume(n);
            return !!r?.scaling && Object.keys(r.scaling).length > 0;
        } else if (t instanceof ua) {
            const { preScale: n } = t.getImageData() || {};
            return !!n?.scaled;
        } else return !1;
    }
    function Aw(t, e) {
        let n = 0;
        for(let r = 0; r < t.length - 1; r++){
            const i = t[r], a = t[r + 1];
            n += Math.sqrt(Math.pow(a[0] - i[0], 2) + Math.pow(a[1] - i[1], 2));
        }
        if (e) {
            const r = t[0], i = t[t.length - 1];
            n += Math.sqrt(Math.pow(i[0] - r[0], 2) + Math.pow(i[1] - r[1], 2));
        }
        return n;
    }
    class lee extends ji {
        constructor(e, n){
            super(e, n);
        }
        renderAnnotation(e, n) {
            let r = !1;
            const { viewport: i } = e, { element: a } = i;
            if (!i.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), r;
            let o = ba(this.getToolName(), a);
            if (!o?.length || (o = this.filterInteractableAnnotationsForElement(a, o), !o?.length)) return r;
            const s = this.getTargetId(i), c = {
                toolGroupId: this.toolGroupId,
                toolName: this.getToolName(),
                viewportId: e.viewport.id
            };
            for(let l = 0; l < o.length; l++){
                const f = o[l];
                c.annotationUID = f.annotationUID;
                const u = this.getAnnotationStyle({
                    annotation: f,
                    styleSpecifier: c
                });
                if (!u.visibility) continue;
                const g = this.renderAnnotationInstance({
                    enabledElement: e,
                    targetId: s,
                    annotation: f,
                    annotationStyle: u,
                    svgDrawingHelper: n
                });
                r ||= g, f.invalidated = !1;
            }
            return r;
        }
        createAnnotation(e) {
            const n = super.createAnnotation(e);
            return Object.assign(n.data, {
                contour: {
                    polyline: [],
                    closed: !1
                }
            }), Object.assign(n, {
                interpolationUID: "",
                autoGenerated: !1
            }), n;
        }
        addAnnotation(e, n) {
            return nr(e, n);
        }
        cancelAnnotation(e) {}
        moveAnnotation(e, n) {
            const { points: r } = e.data.handles;
            for(let i = 0, a = r.length; i < a; i++){
                const o = r[i];
                o[0] += n[0], o[1] += n[1], o[2] += n[2];
            }
            e.invalidated = !0, og(e).forEach((i)=>this.moveAnnotation(i, n));
        }
        updateContourPolyline(e, n, r, i) {
            const a = this.configuration?.decimate || {};
            uc(e, n, r, {
                decimate: {
                    enabled: !!a.enabled,
                    epsilon: a.epsilon
                },
                updateWindingDirection: i?.updateWindingDirection
            });
        }
        getPolylinePoints(e) {
            return e.data.contour?.polyline ?? e.data.polyline;
        }
        renderAnnotationInstance(e) {
            const { enabledElement: n, annotationStyle: r, svgDrawingHelper: i } = e, a = e.annotation;
            if (a.parentAnnotationUID) return;
            const { annotationUID: o } = a, { viewport: s } = n, { worldToCanvas: c } = s, l = this.getPolylinePoints(a).map((C)=>c(C)), { lineWidth: f, lineDash: u, color: g, fillColor: h, fillOpacity: v } = r, m = s2(a, s), y = [
                l,
                ...m
            ];
            return A0(i, o, "contourPolyline", y, {
                color: g,
                lineDash: u,
                lineWidth: Math.max(.1, f),
                fillColor: h,
                fillOpacity: v
            }), !0;
        }
    }
    const Xl = {
        ...wX,
        ...mX,
        resetAnnotationManager: jY
    }, kw = "PlanarFreehandContourSegmentationTool";
    function gy(t, e = []) {
        const { viewport: n, sliceData: r, annotation: i } = t, a = new Map, { toolName: o, originalToolName: s } = i.metadata, c = s || o, l = (ba(c, n.element) || []).filter((f)=>!f.metadata.originalToolName || f.metadata.originalToolName === c);
        if (c !== kw) {
            const f = ba(kw, n.element);
            f?.length && f.forEach((u)=>{
                const { metadata: g } = u;
                g.originalToolName === c && g.originalToolName !== g.toolName && l.push(u);
            });
        }
        if (!l?.length) return a;
        for(let f = 0; f < r.numberOfSlices; f++){
            const u = l.filter((h)=>h.metadata.sliceIndex === f);
            if (!u?.length) continue;
            const g = u.filter((h)=>e.every((v)=>{
                    const y = (v.parentKey ? v.parentKey(h) : h)?.[v.key];
                    return Array.isArray(y) ? y.every((C, T)=>C === v.value[T]) : y === v.value;
                }));
            g.length && a.set(f, g);
        }
        return a;
    }
    function uee(t, e) {
        const n = gy(t, e), r = [];
        if (!n?.size) return r;
        for (const i of n.values())i.forEach((a)=>{
            r.push(a);
        });
        return r;
    }
    function HR(t, e, n) {
        const r = Ma({
            data: {},
            metadata: {}
        }, n);
        return Object.assign(r, {
            highlighted: !1,
            invalidated: !0,
            autoGenerated: !0,
            annotationUID: void 0,
            cachedStats: {},
            childAnnotationUIDs: [],
            parentAnnotationUID: void 0
        }), Object.assign(r.data, {
            handles: {
                points: e.points || e || [],
                interpolationSources: e.sources,
                activeHandleIndex: null,
                textBox: {
                    hasMoved: !1,
                    worldPosition: [
                        0,
                        0,
                        0
                    ],
                    worldBoundingBox: {
                        topLeft: [
                            0,
                            0,
                            0
                        ],
                        topRight: [
                            0,
                            0,
                            0
                        ],
                        bottomLeft: [
                            0,
                            0,
                            0
                        ],
                        bottomRight: [
                            0,
                            0,
                            0
                        ]
                    }
                }
            },
            contour: {
                ...n.data.contour,
                polyline: t
            }
        }), r;
    }
    function fee(t, e) {
        const n = gy(e, [
            {
                key: "interpolationUID",
                value: e.interpolationUID
            }
        ]), r = dee(n);
        if (!r) {
            console.warn("No annotations found to interpolate", n);
            return;
        }
        const i = gee(n, t.annotationUID), a = [];
        for(let o = r[0] + 1; o < r[1]; o++)if (hee(n, o)) {
            const s = mee(o, r, n);
            (s?.[0] === i || s?.[1] === i) && pee(s, a, o);
        }
        return {
            interpolationData: n,
            interpolationList: a
        };
    }
    function dee(t) {
        let e = 1 / 0, n = -1 / 0, r = !1;
        for (const [i, a] of t.entries())a.length && (e = Math.min(i, e), n = Math.max(i, n), r = !0);
        if (r) return [
            e,
            n
        ];
    }
    function gee(t, e) {
        for (const [n, r] of t)for(let i = 0; i < r.length; i++)if (r[i].annotationUID === e) return n;
    }
    function hee(t, e) {
        const n = t.get(e);
        return !n?.length || n.length === 1 && n[0].autoGenerated;
    }
    function pee(t, e, n) {
        const [r] = t;
        e[r] ||= {
            pair: t,
            list: []
        }, e[r].list.push(n);
    }
    function mee(t, e, n) {
        const r = [];
        let i = !0;
        for(let a = t - 1; a >= e[0]; a--){
            const o = n.get(a);
            if (o?.length) {
                if (o[0].autoGenerated) continue;
                o.length > 1 && (i = !1), r.push(a);
                break;
            }
        }
        if (!(!i || !r.length)) {
            for(let a = t + 1; a <= e[1]; a++){
                const o = n.get(a);
                if (o?.length) {
                    if (o[0].autoGenerated) continue;
                    o.length > 1 && (i = !1), r.push(a);
                    break;
                }
            }
            if (!(!i || r.length < 2)) return r;
        }
    }
    const { PointsManager: Uw } = ga;
    function vee(t, e = 12) {
        const n = Uw.create3(e);
        n.sources = [];
        const { sources: r } = n, { length: i, sources: a = [] } = t, o = 5;
        if (i < o * 3) return t.subselect(e);
        const s = Math.floor(Math.max(2 * i / e, o * 2));
        a.forEach(()=>r.push(Uw.create3(e)));
        const c = yee(t, o), l = Cee(c, e), f = [];
        if (l?.length > 2) {
            let u = -1;
            const g = s / 3;
            l.forEach((m)=>{
                const [y, , C] = m, T = Math.ceil((y + C) / 2);
                C - u < g || (T - y > 2 * g ? (Eu(f, u, y, s, i), u = Eu(f, y, T, s, i)) : u = Eu(f, u, T, s, i), C - u > g && (u = Eu(f, u, C, s, i)));
            });
            const h = f[0];
            i3(h + i - u, i) > 2 * g && Eu(f, u, h - g, s, i);
        } else {
            const u = Math.floor(i / e);
            Eu(f, -1, i - u, u, i);
        }
        return f.forEach((u)=>{
            const g = t.getPointArray(u);
            n.push(g), a.forEach((h, v)=>r[v].push(h.getPoint(u)));
        }), n;
    }
    function yee(t, e = 6) {
        const { length: n } = t, r = Xe(), i = Xe(), a = new Float32Array(n);
        for(let o = 0; o < n; o++){
            const s = t.getPoint(o), c = t.getPoint(o - e), l = t.getPoint((o + e) % n);
            In(r, s, c), In(i, l, s);
            const f = xt(r, i) / (jh(r) * jh(i));
            a[o] = f;
        }
        return a;
    }
    function Cee(t, e) {
        const { max: n, deviation: r } = wee(t), { length: i } = t;
        if (r < .01 || i < e * 3) return [];
        const a = [];
        let o = null, s, c = 0;
        for(let l = 0; l < i; l++){
            const f = t[l];
            f < n - r ? o ? (o[2] = l, f < s && (s = f, c = l), o[1] = c) : (s = f, c = l, o = [
                l,
                l,
                l
            ]) : o && (a.push(o), o = null);
        }
        return o && (a[0][0] === 0 ? a[0][0] = o[0] : (o[1] = c, o[2] = i - 1, a.push(o))), a;
    }
    function Eu(t, e, n, r, i) {
        n < e && (n += i);
        const a = n - e, o = Math.ceil(a / r);
        if (o <= 0) return t[t.length - 1] !== n && t.push(i3(n, i)), n;
        for(let s = 1; s <= o; s++){
            const c = i3(e + s * a / o, i);
            t.push(c);
        }
        return t[t.length - 1];
    }
    function i3(t, e) {
        return (Math.round(t) + e) % e;
    }
    function wee(t) {
        const { length: e } = t;
        let n = 0, r = 1 / 0, i = -1 / 0, a = 0;
        for(let s = 0; s < e; s++){
            const c = t[s];
            n += c, r = Math.min(r, c), i = Math.max(i, c);
        }
        const o = n / e;
        for(let s = 0; s < e; s++){
            const c = t[s] - o;
            a += c * c;
        }
        return {
            mean: o,
            max: i,
            min: r,
            sumSq: a,
            deviation: Math.sqrt(a / e)
        };
    }
    function Tee(t) {
        const { parentAnnotationUID: e, annotationUID: n } = t;
        if (!e) return t.interpolationUID;
        const r = Xl.getAnnotation(e), { interpolationUID: i } = r, a = r.childAnnotationUIDs.indexOf(n);
        return t.interpolationUID = `${i}-${a}`, t.interpolationUID;
    }
    const { PointsManager: Jf } = ga, Fw = .2;
    function Sh(t) {
        if (!t.annotation) return;
        const { isInterpolationUpdate: e, annotation: n } = t;
        queueMicrotask(()=>{
            try {
                e && (n.isInterpolationUpdate = !0, n.autoGenerated = !1), xee(t);
            } finally{
                e && (n.autoGenerated = !0);
            }
        });
    }
    function xee(t) {
        const { annotation: e } = t;
        Tee(e);
        const { interpolationData: n, interpolationList: r } = fee(e, t) || {};
        if (!n || !r) return;
        const i = {
            toolName: e.metadata.toolName,
            toolType: e.metadata.toolName,
            viewport: t.viewport
        };
        for(let l = 0; l < r.length; l++)r[l] && See(r[l].list, r[l].pair, n, i);
        const { id: a, renderingEngineId: o, element: s } = t.viewport, c = {
            annotation: e,
            element: s,
            viewportId: a,
            renderingEngineId: o
        };
        r.length && We(t.viewport.element, z.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, c);
    }
    function See(t, e, n, r) {
        const i = n.get(e[0])[0], a = n.get(e[1])[0], o = Hw(i.data.contour.polyline), s = Hw(a.data.contour.polyline), { c1Interp: c, c2Interp: l } = Oee(o, s);
        c.kIndex = e[0], l.kIndex = e[1], t.forEach(function(f) {
            Eee(c, l, f, e, n, o.x.length > s.x.length, r);
        });
    }
    function Eee(t, e, n, r, i, a, o) {
        const [s, c] = r, l = (n - s) / (c - s), f = i.get(s)[0], u = i.get(c)[0], g = Ree(t, e, l, a), h = l > .5 ? u : f, v = vee(g);
        i.has(n) ? _ee(g, v, n, h, o) : Dee(g, v, n, h, o);
    }
    function Dee(t, e, n, r, i) {
        const a = t.points, { viewport: o } = i, s = HR(a, e, r), c = o.getViewReference({
            sliceIndex: n
        });
        if (!c) throw new Error(`Can't find slice ${n}`);
        Object.assign(s.metadata, c), Xl.addAnnotation(s, o.element), r.onInterpolationComplete?.(s, r);
        const { parentAnnotationUID: l } = r;
        if (l) {
            const f = Xl.getAnnotation(l), u = KR(f, n, i);
            PR(o, u, s);
        }
    }
    function KR(t, e, n) {
        const { viewport: r } = n, i = Xl.getAnnotations(t.metadata.toolName, r.element);
        for(let a = 0; a < i.length; a++){
            const o = i[a];
            if (o.interpolationUID === t.interpolationUID && o.metadata.sliceIndex === e) return o;
        }
    }
    function _ee(t, e, n, r, i) {
        const a = KR(r, n, i), o = t.points, s = HR(o, e, a);
        Object.assign(a, {
            metadata: s.metadata,
            data: s.data
        });
    }
    function Ree(t, e, n, r) {
        const i = r ? t.I : e.I, a = Jf.fromXYZ(t), o = Jf.fromXYZ(e), { length: s } = a, c = Jf.create3(s), l = Xe(), f = Xe(), u = Jf.create3(s);
        u.kIndex = t.kIndex;
        const g = Jf.create3(s);
        g.kIndex = e.kIndex;
        for(let h = 0; h < t.x.length; h++)if (i[h]) {
            const v = a.getPoint(h), m = o.getPoint(h);
            u.push(v), g.push(m), In(l, m, v), c.push($i(f, v, l, n));
        }
        return c.sources = [
            u,
            g
        ], c;
    }
    function Oee(t, e) {
        const n = jw(t), r = jw(e), i = Math.max(Math.ceil(n[n.length - 1] / Fw), Math.ceil(r[r.length - 1] / Fw)), a = zw(n), o = zw(r), s = i + e.x.length, c = i + t.x.length, l = $w(s, a), f = $w(c, o), u = Ww(s - 2, t.x.length), g = Ww(c - 2, e.x.length), h = Gw(l, u), v = Gw(f, g), m = Bw(t, h), y = Bw(e, v);
        return Mee(m, y), Iee(m, y);
    }
    function Iee(t, e) {
        const n = {
            x: [],
            y: [],
            z: [],
            I: []
        }, r = {
            x: [],
            y: [],
            z: [],
            I: []
        };
        for(let i = 0; i < t.x.length; i++)(t.I[i] || e.I[i]) && (n.x.push(t.x[i]), n.y.push(t.y[i]), n.z.push(t.z[i]), n.I.push(t.I[i]), r.x.push(e.x[i]), r.y.push(e.y[i]), r.z.push(e.z[i]), r.I.push(e.I[i]));
        return {
            c1Interp: n,
            c2Interp: r
        };
    }
    function Mee(t, e) {
        const n = t.x.length, r = {
            startingNode: 0,
            totalSquaredXYLengths: 1 / 0
        };
        for(let a = 0; a < n; a++){
            let o = a, s = 0;
            for(let c = 0; c < n; c++)s += (t.x[o] - e.x[c]) ** 2 + (t.y[o] - e.y[c]) ** 2 + (t.z[o] - e.z[c]) ** 2, o++, o === n && (o = 0);
            s < r.totalSquaredXYLengths && (r.totalSquaredXYLengths = s, r.startingNode = a);
        }
        const i = r.startingNode;
        G1(t.x, i), G1(t.y, i), G1(t.z, i), G1(t.I, i);
    }
    function G1(t, e) {
        e -= t.length * Math.floor(e / t.length);
        const n = t.splice(0, e);
        return t.push(...n), t;
    }
    function Bw(t, e) {
        const n = {
            x: [],
            y: [],
            z: [],
            I: []
        };
        for(let r = 0; r < t.x.length - 1; r++){
            n.x.push(t.x[r]), n.y.push(t.y[r]), n.z.push(t.z[r]), n.I.push(!0);
            const i = (t.x[r + 1] - t.x[r]) / (e[r] + 1), a = (t.y[r + 1] - t.y[r]) / (e[r] + 1), o = (t.z[r + 1] - t.z[r]) / (e[r] + 1);
            for(let s = 0; s < e[r] - 1; s++)n.x.push(n.x[n.x.length - 1] + i), n.y.push(n.y[n.y.length - 1] + a), n.z.push(n.z[n.z.length - 1] + o), n.I.push(!1);
        }
        return n;
    }
    function Gw(t, e) {
        const n = [];
        for(let o = 0; o < t.length; ++o)n[o] = o;
        n.sort(function(o, s) {
            return t[o] < t[s] ? -1 : 1;
        });
        const r = [];
        for(let o = 0; o < e.length; o++)r.push(e[n[o]]);
        const i = r.reduce(function(o, s, c) {
            return s && o.push(c), o;
        }, []), a = [];
        for(let o = 0; o < i.length - 1; o++)a.push(i[o + 1] - i[o]);
        return a;
    }
    function Ww(t, e) {
        const n = new Array(t + e);
        return n.fill(!1, 0, t), n.fill(!0, t, t + e), n;
    }
    function $w(t, e) {
        const n = 1 / (t - 1), r = [
            n
        ];
        for(let i = 1; i < t - 2; i++)r.push(r[r.length - 1] + n);
        return r.concat(e);
    }
    function zw(t) {
        const e = [];
        for(let n = 0; n < t.length; n++)e.push(t[n] / t[t.length - 1]);
        return e;
    }
    function jw(t) {
        const e = [
            0
        ];
        for(let n = 1; n < t.x.length; n++){
            const r = Math.sqrt((t.x[n] - t.x[n - 1]) ** 2 + (t.y[n] - t.y[n - 1]) ** 2 + (t.z[n] - t.z[n - 1]) ** 2);
            e.push(e[n - 1] + r);
        }
        return e;
    }
    function Hw(t) {
        const e = {
            x: [],
            y: [],
            z: []
        };
        for(let n = 0; n < t.length; n++)e.x[n] = t[n][0], e.y[n] = t[n][1], e.z[n] = t[n][2];
        return e.x.push(e.x[0]), e.y.push(e.y[0]), e.z.push(e.z[0]), e;
    }
    function Kw(t) {
        const { annotation: e } = t, n = gy(t, [
            {
                key: "interpolationUID",
                value: t.interpolationUID
            }
        ]), r = e.metadata.sliceIndex;
        let i = -1, a = t.sliceData.numberOfSlices;
        for (const [s, c] of n.entries())s === r || !c.find((f)=>!f.autoGenerated) || (s < r ? i = Math.max(s, i) : a = Math.min(s, a));
        const o = [];
        for (const [s, c] of n.entries())s <= i || s >= a || s === r || c.forEach((l)=>{
            l.autoGenerated && (Xl.removeAnnotation(l.annotationUID), o.push(l));
        });
        if (o.length) {
            const s = {
                annotations: o,
                element: t.viewport.element,
                viewportId: t.viewport.id,
                renderingEngineId: t.viewport.getRenderingEngine().id
            };
            We(t.viewport.element, z.INTERPOLATED_ANNOTATIONS_REMOVED, s);
        }
        if (i >= 0 && a < t.sliceData.numberOfSlices) {
            const s = n.get(a)[0], c = {
                viewport: t.viewport,
                sliceData: {
                    numberOfSlices: t.sliceData.numberOfSlices,
                    imageIndex: s.metadata.sliceIndex
                },
                annotation: s,
                interpolationUID: s.interpolationUID
            };
            Sh(c);
        }
    }
    function j5(t) {
        const e = AR(t);
        return e.length ? e[0] : void 0;
    }
    const { uuidv4: bee } = ga, Lee = [
        Jt.HandlesUpdated,
        Jt.InterpolationUpdated
    ];
    class Zc {
        static{
            this.toolNames = [];
        }
        static addTool(e) {
            this.toolNames.includes(e) || this.toolNames.push(e);
        }
        static acceptAutoGenerated(e, n = {}) {
            const { toolNames: r, segmentationId: i, segmentIndex: a, sliceIndex: o } = n;
            for (const s of r || Zc.toolNames){
                const c = Xl.getAnnotations(s, e);
                if (c?.length) for (const l of c){
                    const { interpolationUID: f, data: u, autoGenerated: g, metadata: h } = l;
                    f && (l.interpolationCompleted = !0), g && (a && a !== u.segmentation.segmentIndex || o !== void 0 && h && o !== h.sliceIndex || i && i !== u.segmentation.segmentationId || (Kl(l), l.autoGenerated = !1));
                }
            }
        }
        static{
            this.handleAnnotationCompleted = (e)=>{
                const n = e.detail.annotation;
                if (!n?.metadata) return;
                const { toolName: r, originalToolName: i } = n.metadata;
                if (!this.toolNames.includes(r) && !this.toolNames.includes(i)) return;
                const a = j5(n);
                if (!a) {
                    console.warn("Unable to find viewport for", n);
                    return;
                }
                const o = H5(a), s = {
                    viewport: a,
                    sliceData: o,
                    annotation: n,
                    interpolationUID: n.interpolationUID
                }, c = !!n.interpolationUID;
                if (n.autoGenerated = !1, c) {
                    Kw(s), Sh(s);
                    return;
                }
                const l = [
                    {
                        key: "segmentIndex",
                        value: n.data.segmentation.segmentIndex,
                        parentKey: (h)=>h.data.segmentation
                    },
                    {
                        key: "viewPlaneNormal",
                        value: n.metadata.viewPlaneNormal,
                        parentKey: (h)=>h.metadata
                    },
                    {
                        key: "viewUp",
                        value: n.metadata.viewUp,
                        parentKey: (h)=>h.metadata
                    }
                ];
                let f = uee(s, l);
                const { sliceIndex: u } = n.metadata, g = new Set;
                f.forEach((h)=>{
                    if (h.interpolationCompleted || h.metadata.sliceIndex === u) {
                        const { interpolationUID: v } = h;
                        g.add(v);
                    }
                }), f = f.filter((h)=>!g.has(h.interpolationUID)), n.interpolationUID = f[0]?.interpolationUID || bee(), s.interpolationUID = n.interpolationUID, Sh(s);
            };
        }
        static{
            this.handleAnnotationUpdate = (e)=>{
                const n = e.detail.annotation, { changeType: r = Jt.HandlesUpdated } = e.detail;
                if (!n?.metadata) return;
                const { toolName: i, originalToolName: a } = n.metadata;
                if (!this.toolNames.includes(i) && !this.toolNames.includes(a) || !Lee.includes(r)) return;
                const o = j5(n);
                if (!o) {
                    console.warn("Unable to find matching viewport for annotation interpolation", n);
                    return;
                }
                n.autoGenerated && (Kl(n), n.autoGenerated = !1);
                const s = H5(o), c = {
                    viewport: o,
                    sliceData: s,
                    annotation: n,
                    interpolationUID: n.interpolationUID,
                    isInterpolationUpdate: r === Jt.InterpolationUpdated
                };
                Sh(c);
            };
        }
        static{
            this.handleAnnotationDelete = (e)=>{
                const n = e.detail.annotation;
                if (!n?.metadata) return;
                const { toolName: r } = n.metadata;
                if (!this.toolNames.includes(r) || n.autoGenerated) return;
                const i = j5(n);
                if (!i) {
                    console.warn("No viewport, can't delete interpolated results", n);
                    return;
                }
                const a = H5(i), o = {
                    viewport: i,
                    sliceData: a,
                    annotation: n,
                    interpolationUID: n.interpolationUID
                };
                n.autoGenerated = !1, Kw(o);
            };
        }
    }
    function H5(t) {
        return {
            numberOfSlices: t.getNumberOfSlices(),
            imageIndex: t.getCurrentImageIdIndex()
        };
    }
    function Pee(t) {
        t.forEach((e)=>{
            const n = $4(e);
            if (!n) {
                console.warn(`ToolGroup not available for ${e}`);
                return;
            }
            n.getViewportsInfo().forEach((i)=>{
                const { renderingEngineId: a, viewportId: o } = i, s = ws(a);
                if (!s) {
                    console.warn(`RenderingEngine not available for ${a}`);
                    return;
                }
                const c = s.getViewport(o);
                ug(c.element);
            });
        });
    }
    function Vee(t) {
        const e = eo(t);
        if (!e) throw new Error(`No segmentation state found for ${t}`);
        const { segments: n } = e;
        return Object.keys(n).filter((i)=>n[i].locked).map((i)=>parseInt(i));
    }
    function Nee(t, e, n) {
        const r = P0(t, {
            segmentationId: e
        });
        if (!r || r.length === 0) return null;
        const i = r[0], { colorLUTIndex: a } = i, o = Y4(a);
        let s = o[n];
        if (!s) {
            if (typeof n != "number") return console.warn(`Can't create colour for LUT index ${n}`), null;
            s = o[n] = [
                0,
                0,
                0,
                0
            ];
        }
        return s;
    }
    function Aee(t, e) {
        return lc.getSegmentationRepresentationVisibility(t, e);
    }
    function kee({ segmentationId: t, segmentIndex: e, viewportId: n, autoGenerated: r = !1 }) {
        const i = Nee(n, t, e), a = Aee(n, {
            segmentationId: t,
            type: Ft.Contour
        }), s = ly(n)?.segmentationId === t, l = zu.getStyle({
            viewportId: n,
            segmentationId: t,
            type: Ft.Contour,
            segmentIndex: e
        });
        let f = 1, u, g = 1, h = 0;
        r ? (f = l.outlineWidthAutoGenerated ?? f, u = l.outlineDashAutoGenerated ?? u, g = l.outlineOpacity ?? g, h = l.fillAlphaAutoGenerated ?? h) : s ? (f = l.outlineWidth ?? f, u = l.outlineDash ?? u, g = l.outlineOpacity ?? g, h = l.fillAlpha ?? h) : (f = l.outlineWidthInactive ?? f, u = l.outlineDashInactive ?? u, g = l.outlineOpacityInactive ?? g, h = l.fillAlphaInactive ?? h), uy(t) === e && (f += l.activeSegmentOutlineWidthDelta), f = l.renderOutline ? f : 0, h = l.renderFill ? h : 0;
        const v = `rgba(${i[0]}, ${i[1]}, ${i[2]}, ${g})`, m = `rgb(${i[0]}, ${i[1]}, ${i[2]})`, C = !J4(n, {
            segmentationId: t,
            type: Ft.Contour
        }).has(e);
        return {
            color: v,
            fillColor: m,
            lineWidth: f,
            fillOpacity: h,
            lineDash: u,
            textbox: {
                color: v
            },
            visibility: a && C
        };
    }
    class qR extends lee {
        static{
            this.PreviewSegmentIndex = 255;
        }
        constructor(e, n){
            super(e, n), this.configuration.interpolation?.enabled && Zc.addTool(this.getToolName());
        }
        isContourSegmentationTool() {
            return !0;
        }
        createAnnotation(e) {
            const n = e.detail, { element: r } = n, i = Fe(r);
            if (!i) return;
            const { viewport: a } = i, o = super.createAnnotation(e);
            if (!this.isContourSegmentationTool()) return o;
            const s = ly(a.id);
            if (!s) throw new Error("No active segmentation detected, create one before using scissors tool");
            if (!s.representationData.Contour) throw new Error("A contour segmentation must be active");
            const { segmentationId: c } = s, l = uy(c);
            return Ma(o, {
                data: {
                    segmentation: {
                        segmentationId: c,
                        segmentIndex: l
                    }
                }
            });
        }
        addAnnotation(e, n) {
            const r = super.addAnnotation(e, n);
            return this.isContourSegmentationTool() && Kl(e), r;
        }
        cancelAnnotation(e) {
            this.isContourSegmentationTool() && Hl(e), super.cancelAnnotation(e);
        }
        getAnnotationStyle(e) {
            const n = super.getAnnotationStyle(e);
            if (!this.isContourSegmentationTool()) return n;
            const r = this._getContourSegmentationStyle(e);
            return Ma(n, r);
        }
        renderAnnotationInstance(e) {
            const { annotation: n } = e, { invalidated: r } = n, i = super.renderAnnotationInstance(e);
            if (r && this.isContourSegmentationTool()) {
                const { segmentationId: a } = n.data.segmentation;
                Qp(a);
                const s = SR(a).map((c)=>ha(c).id);
                Pee(s);
            }
            return i;
        }
        _getContourSegmentationStyle(e) {
            const n = e.annotation, { segmentationId: r, segmentIndex: i } = n.data.segmentation, { viewportId: a } = e.styleSpecifier, o = P0(a, {
                segmentationId: r
            });
            if (!o?.length) return {};
            o.length > 1 ? o.find((y)=>y.segmentationId === r && y.type === Ft.Contour) : o[0];
            const { autoGenerated: s } = n, l = Vee(r).includes(i), { color: f, fillColor: u, lineWidth: g, fillOpacity: h, lineDash: v, visibility: m } = kee({
                segmentationId: r,
                segmentIndex: i,
                viewportId: a,
                autoGenerated: s
            });
            return {
                color: f,
                fillColor: u,
                lineWidth: g,
                fillOpacity: h,
                lineDash: v,
                textbox: {
                    color: f
                },
                visibility: m,
                locked: l
            };
        }
    }
    function gg(t, e, n) {
        return t === "CT" ? "HU" : t === "PT" ? Uee(e, n) : "";
    }
    function Uee(t, e) {
        return e.isPreScaled ? e.isSuvScaled ? "SUV" : ct("generalSeriesModule", t)?.modality === "PT" ? ct("petSeriesModule", t)?.units || "unitless" : "unknown" : "raw";
    }
    const { pointCanProjectOnLine: qw } = H0, { EPSILON: Fee } = u3, Bee = 1 - Fee;
    class hy extends qR {
        static{
            this.toolName = "PlanarFreehandROI";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                storePointData: !1,
                shadow: !0,
                preventHandleOutsideImage: !1,
                contourHoleAdditionModifierKey: aa.Shift,
                alwaysRenderOpenContourHandles: {
                    enabled: !1,
                    radius: 2
                },
                allowOpenContours: !0,
                closeContourProximity: 10,
                checkCanvasEditFallbackProximity: 6,
                makeClockWise: !0,
                subPixelResolution: 4,
                smoothing: {
                    smoothOnAdd: !1,
                    smoothOnEdit: !1,
                    knotsRatioPercentageOnAdd: 40,
                    knotsRatioPercentageOnEdit: 40
                },
                interpolation: {
                    enabled: !1,
                    onInterpolationComplete: null
                },
                decimate: {
                    enabled: !1,
                    epsilon: .1
                },
                displayOnePointAsCrosshairs: !1,
                calculateStats: !0,
                getTextLines: Gee,
                statsCalculator: n2
            }
        }){
            super(e, n), this.isDrawing = !1, this.isEditingClosed = !1, this.isEditingOpen = !1, this.addNewAnnotation = (r)=>{
                const i = r.detail, { element: a } = i, o = this.createAnnotation(r);
                this.addAnnotation(o, a);
                const s = rn(a, this.getToolName());
                return this.activateDraw(r, o, s), r.preventDefault(), it(s), o;
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, c = rn(s, this.getToolName());
                this.activateOpenContourEndEdit(r, i, c, a);
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a, s = rn(o, this.getToolName());
                i.data.contour.closed ? this.activateClosedContourEdit(r, i, s) : this.activateOpenContourEdit(r, i, s), r.preventDefault();
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { polyline: l } = i.data.contour;
                let f = c.worldToCanvas(l[0]);
                for(let h = 1; h < l.length; h++){
                    const v = f, m = c.worldToCanvas(l[h]);
                    if (qw(a, v, m, o)) return !0;
                    f = m;
                }
                if (!i.data.contour.closed) return !1;
                const u = c.worldToCanvas(l[0]), g = c.worldToCanvas(l[l.length - 1]);
                return qw(a, u, g, o);
            }, this.cancel = (r)=>{
                const i = this.isDrawing, a = this.isEditingOpen, o = this.isEditingClosed;
                i ? this.cancelDrawing(r) : a ? this.cancelOpenContourEdit(r) : o && this.cancelClosedContourEdit(r);
            }, this._calculateCachedStats = (r, i, a, o)=>{
                const { data: s } = r, { cachedStats: c } = s, { polyline: l, closed: f } = s.contour, u = Object.keys(c);
                for(let h = 0; h < u.length; h++){
                    const v = u[h], m = this.getTargetImageData(v);
                    if (!m) continue;
                    const { imageData: y, metadata: C } = m, T = l.map((G)=>i.worldToCanvas(G)), x = {
                        isPreScaled: dg(i, v),
                        isSuvScaled: this.isSuvScaled(i, v, r.metadata.referencedImageId)
                    }, S = gg(C.Modality, r.metadata.referencedImageId, x), D = ql(m, ()=>{
                        const G = s.contour.polyline, Z = G.length, H = new Array(Z);
                        for(let he = 0; he < Z; he++)H[he] = i.worldToCanvas(G[he]);
                        const { maxX: ne, maxY: ae, minX: ue, minY: le } = kd(H), oe = i.canvasToWorld([
                            ue,
                            le
                        ]), re = Co(y, oe), X = i.canvasToWorld([
                            ne,
                            ae
                        ]), ie = Co(y, X);
                        return [
                            re,
                            ie
                        ];
                    }), _ = T[0], M = i.canvasToWorld(_), P = i.canvasToWorld([
                        _[0] + 1,
                        _[1]
                    ]), F = i.canvasToWorld([
                        _[0],
                        _[1] + 1
                    ]), N = rc(M, P), B = rc(M, F);
                    f ? this.updateClosedCachedStats({
                        targetId: v,
                        viewport: i,
                        canvasCoordinates: T,
                        points: l,
                        imageData: y,
                        metadata: C,
                        cachedStats: c,
                        modalityUnit: S,
                        calibratedScale: D,
                        deltaInX: N,
                        deltaInY: B
                    }) : this.updateOpenCachedStats({
                        metadata: C,
                        canvasCoordinates: T,
                        targetId: v,
                        cachedStats: c,
                        modalityUnit: S,
                        calibratedScale: D,
                        deltaInX: N,
                        deltaInY: B
                    });
                }
                const g = r.invalidated;
                return r.invalidated = !1, g && yn(r, o.viewport.element, Jt.StatsUpdated), c;
            }, this._renderStats = (r, i, a, o)=>{
                const { data: s } = r, c = this.getTargetId(i), l = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: a.viewport.id,
                    annotationUID: r.annotationUID
                }, f = this.getLinkedTextBoxStyle(l, r);
                if (!f.visibility) return;
                const u = this.configuration.getTextLines(s, c);
                if (!u || u.length === 0) return;
                const g = s.contour.polyline.map((S)=>i.worldToCanvas(S));
                if (!s.handles.textBox.hasMoved) {
                    const S = Jl(g);
                    s.handles.textBox.worldPosition = i.canvasToWorld(S);
                }
                const h = i.worldToCanvas(s.handles.textBox.worldPosition), m = fc(o, r.annotationUID ?? "", "1", u, h, g, {}, f), { x: y, y: C, width: T, height: x } = m;
                s.handles.textBox.worldBoundingBox = {
                    topLeft: i.canvasToWorld([
                        y,
                        C
                    ]),
                    topRight: i.canvasToWorld([
                        y + T,
                        C
                    ]),
                    bottomLeft: i.canvasToWorld([
                        y,
                        C + x
                    ]),
                    bottomRight: i.canvasToWorld([
                        y + T,
                        C + x
                    ])
                };
            }, hQ(this), xQ(this), LQ(this), jQ(this), qQ(this), see(this), this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        filterInteractableAnnotationsForElement(e, n) {
            if (!n || !n.length) return;
            const r = Fe(e), { viewport: i } = r;
            let a;
            if (i instanceof wi) {
                const o = i.getCamera(), { spacingInNormalDirection: s } = rg(i, o);
                a = this.filterAnnotationsWithinSlice(n, o, s);
            } else a = UR(i, n);
            return a;
        }
        filterAnnotationsWithinSlice(e, n, r) {
            const { viewPlaneNormal: i } = n, a = e.filter((l)=>{
                let f = l.metadata.viewPlaneNormal;
                if (!l.metadata.referencedImageId && !f && l.metadata.FrameOfReferenceUID) {
                    for (const g of l.data.contour.polyline){
                        const h = In(Xe(), g, n.focalPoint), v = xt(h, n.viewPlaneNormal);
                        if (!lr(v, 0)) return !1;
                    }
                    return l.metadata.viewPlaneNormal = n.viewPlaneNormal, l.metadata.cameraFocalPoint = n.focalPoint, !0;
                }
                if (!f) {
                    const { referencedImageId: g } = l.metadata, { imageOrientationPatient: h } = ct("imagePlaneModule", g), v = en(h[0], h[1], h[2]), m = en(h[3], h[4], h[5]);
                    f = Xe(), bn(f, v, m), l.metadata.viewPlaneNormal = f;
                }
                const u = Math.abs(xt(i, f)) > Bee;
                return f && u;
            });
            if (!a.length) return [];
            const o = r / 2, { focalPoint: s } = n, c = [];
            for (const l of a){
                const u = l.data.contour.polyline[0];
                if (!l.isVisible) continue;
                const g = Xe();
                In(g, s, u);
                const h = xt(g, i);
                Math.abs(h) < o && c.push(l);
            }
            return c;
        }
        isContourSegmentationTool() {
            return !1;
        }
        createAnnotation(e) {
            const n = e.detail.currentPoints.world, r = super.createAnnotation(e), i = (o)=>{
                o.data.handles.points.length = 0;
            };
            return Ma(r, {
                data: {
                    contour: {
                        polyline: [
                            [
                                ...n
                            ]
                        ]
                    },
                    label: "",
                    cachedStats: {}
                },
                onInterpolationComplete: i
            });
        }
        getAnnotationStyle(e) {
            return super.getAnnotationStyle(e);
        }
        renderAnnotationInstance(e) {
            const { enabledElement: n, targetId: r, svgDrawingHelper: i } = e, a = e.annotation;
            let o = !1;
            const { viewport: s, renderingEngine: c } = n, l = this.isDrawing, f = this.isEditingOpen, u = this.isEditingClosed;
            if (!(l || f || u)) this.configuration.displayOnePointAsCrosshairs && a.data.contour.polyline.length === 1 ? this.renderPointContourWithMarker(n, i, a) : this.renderContour(n, i, a);
            else {
                const g = this.commonData.annotation.annotationUID;
                if (a.annotationUID === g) if (l) this.renderContourBeingDrawn(n, i, a);
                else if (u) this.renderClosedContourBeingEdited(n, i, a);
                else if (f) this.renderOpenContourBeingEdited(n, i, a);
                else throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);
                else this.configuration.displayOnePointAsCrosshairs && a.data.contour.polyline.length === 1 ? this.renderPointContourWithMarker(n, i, a) : this.renderContour(n, i, a);
                o = !0;
            }
            if (this.configuration.calculateStats) return this._calculateStatsIfActive(a, r, s, c, n), this._renderStats(a, s, n, i), o;
        }
        _calculateStatsIfActive(e, n, r, i, a) {
            const o = this.commonData?.annotation.annotationUID;
            if (!(e.annotationUID === o && !this.commonData?.movingTextBox) && !this.commonData?.movingTextBox) {
                const { data: s } = e;
                s.cachedStats[n]?.unit ? e.invalidated && this._throttledCalculateCachedStats(e, r, i, a) : (s.cachedStats[n] = {
                    Modality: null,
                    area: null,
                    max: null,
                    mean: null,
                    stdDev: null,
                    areaUnit: null,
                    unit: null
                }, this._calculateCachedStats(e, r, i, a));
            }
        }
        updateClosedCachedStats({ viewport: e, points: n, imageData: r, metadata: i, cachedStats: a, targetId: o, modalityUnit: s, canvasCoordinates: c, calibratedScale: l, deltaInX: f, deltaInY: u }) {
            const { scale: g, areaUnit: h, unit: v } = l, { voxelManager: m } = e.getImageData(), y = Co(r, n[0]);
            y[0] = Math.floor(y[0]), y[1] = Math.floor(y[1]), y[2] = Math.floor(y[2]);
            let C = y[0], T = y[0], x = y[1], S = y[1], D = y[2], _ = y[2];
            for(let X = 1; X < n.length; X++){
                const ie = Co(r, n[X]);
                ie[0] = Math.floor(ie[0]), ie[1] = Math.floor(ie[1]), ie[2] = Math.floor(ie[2]), C = Math.min(C, ie[0]), T = Math.max(T, ie[0]), x = Math.min(x, ie[1]), S = Math.max(S, ie[1]), D = Math.min(D, ie[2]), _ = Math.max(_, ie[2]);
            }
            const M = Co(r, n[1]);
            M[0] = Math.floor(M[0]), M[1] = Math.floor(M[1]), M[2] = Math.floor(M[2]);
            let P = r2(c) / g / g;
            P *= f * u;
            let F = Aw(c, closed) / g;
            F *= Math.sqrt(Math.pow(f, 2) + Math.pow(u, 2));
            const N = .01 * (T - C), B = .01 * (S - x), G = .01 * (_ - D);
            C = Math.floor(C - N), T = Math.ceil(T + N), x = Math.floor(x - B), S = Math.ceil(S + B), D = Math.floor(D - G), _ = Math.ceil(_ + G);
            const Z = [
                [
                    C,
                    T
                ],
                [
                    x,
                    S
                ],
                [
                    D,
                    _
                ]
            ], H = r.indexToWorld([
                T,
                S,
                _
            ]), ne = e.worldToCanvas(H);
            let ae = 0, ue = [], le = 0, oe;
            m && (oe = m.forEach(this.configuration.statsCalculator.statsCallback, {
                imageData: r,
                isInObject: (X, ie)=>{
                    let he = !0;
                    const $e = e.worldToCanvas(X);
                    return $e[1] != ae && (le = 0, ae = $e[1], ue = bR(c, $e, [
                        ne[0],
                        $e[1]
                    ]), ue.sort(function(je) {
                        return function(He, rt) {
                            return He[je] === rt[je] ? 0 : He[je] < rt[je] ? -1 : 1;
                        };
                    }(0))), ue.length && $e[0] > ue[0][0] && (ue.shift(), le++), le % 2 === 0 && (he = !1), he;
                },
                boundsIJK: Z,
                returnPoints: this.configuration.storePointData
            }));
            const re = this.configuration.statsCalculator.getStatistics();
            a[o] = {
                Modality: i.Modality,
                area: P,
                perimeter: F,
                mean: re.mean?.value,
                max: re.max?.value,
                min: re.min?.value,
                stdDev: re.stdDev?.value,
                statsArray: re.array,
                pointsInShape: oe,
                areaUnit: h,
                modalityUnit: s,
                unit: v
            };
        }
        updateOpenCachedStats({ targetId: e, metadata: n, canvasCoordinates: r, cachedStats: i, modalityUnit: a, calibratedScale: o, deltaInX: s, deltaInY: c }) {
            const { scale: l, unit: f } = o;
            let u = Aw(r, closed) / l;
            u *= Math.sqrt(Math.pow(s, 2) + Math.pow(c, 2)), i[e] = {
                Modality: n.Modality,
                length: u,
                modalityUnit: a,
                unit: f
            };
        }
    }
    function Gee(t, e) {
        const n = t.cachedStats[e], { area: r, mean: i, stdDev: a, length: o, perimeter: s, max: c, min: l, isEmptyArea: f, unit: u, areaUnit: g, modalityUnit: h } = n || {}, v = [];
        if (cr(r)) {
            const m = f ? "Area: Oblique not supported" : `Area: ${Rn(r)} ${g}`;
            v.push(m);
        }
        return cr(i) && v.push(`Mean: ${Rn(i)} ${h}`), cr(c) && v.push(`Max: ${Rn(c)} ${h}`), cr(l) && v.push(`Min: ${Rn(l)} ${h}`), cr(a) && v.push(`Std Dev: ${Rn(a)} ${h}`), cr(s) && v.push(`Perimeter: ${Rn(s)} ${u}`), cr(o) && v.push(`${Rn(o)} ${u}`), v;
    }
    class XR extends hy {
        static{
            this.toolName = "PlanarFreehandContourSegmentationTool";
        }
        constructor(e){
            const n = Ma({
                configuration: {
                    calculateStats: !1,
                    allowOpenContours: !1
                }
            }, e);
            super(n);
        }
        isContourSegmentationTool() {
            return !0;
        }
        renderAnnotationInstance(e) {
            const n = e.annotation, { invalidated: r } = n, i = super.renderAnnotationInstance(e);
            if (r) {
                const { segmentationId: a } = n.data.segmentation;
                Qp(a);
            }
            return i;
        }
    }
    const Wee = {
        [Ft.Labelmap]: LJ,
        [Ft.Contour]: wJ,
        [Ft.Surface]: SY
    }, W1 = XR.toolName;
    class $ee {
        constructor(){
            this._needsRender = new Set, this._pendingRenderQueue = [], this._animationFrameSet = !1, this._animationFrameHandle = null, this._getAllViewports = ()=>Es().flatMap((n)=>n.getViewports()), this._renderFlaggedSegmentations = ()=>{
                if (this._throwIfDestroyed(), Array.from(this._needsRender).forEach((n)=>{
                    this._triggerRender(n);
                }), this._needsRender.clear(), this._animationFrameSet = !1, this._animationFrameHandle = null, this._pendingRenderQueue.length > 0) {
                    const n = this._pendingRenderQueue.shift();
                    n && n.length > 0 && this._setViewportsToBeRenderedNextFrame(n);
                }
            };
        }
        renderSegmentationsForViewport(e) {
            const n = e ? [
                e
            ] : this._getViewportIdsForSegmentation();
            this._setViewportsToBeRenderedNextFrame(n);
        }
        renderSegmentation(e) {
            const n = this._getViewportIdsForSegmentation(e);
            this._setViewportsToBeRenderedNextFrame(n);
        }
        _getViewportIdsForSegmentation(e) {
            const n = this._getAllViewports(), r = [];
            for (const i of n){
                const a = i.id;
                e ? P0(a, {
                    segmentationId: e
                })?.length > 0 && r.push(a) : P0(a)?.length > 0 && r.push(a);
            }
            return r;
        }
        _throwIfDestroyed() {
            if (this.hasBeenDestroyed) throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
        }
        _setViewportsToBeRenderedNextFrame(e) {
            if (this._animationFrameSet) {
                this._pendingRenderQueue.push(e);
                return;
            }
            e.forEach((n)=>{
                this._needsRender.add(n);
            }), this._render();
        }
        _render() {
            this._needsRender.size > 0 && this._animationFrameSet === !1 && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations), this._animationFrameSet = !0);
        }
        _triggerRender(e) {
            const n = P0(e);
            if (!n?.length) return;
            const { viewport: r } = An(e) || {};
            if (!r) return;
            const i = [], a = n.map((o)=>{
                o.type === Ft.Contour && this._addPlanarFreeHandToolIfAbsent(r);
                const s = Wee[o.type];
                try {
                    const c = s.render(r, o);
                    i.push(c);
                } catch (c) {
                    console.error(c);
                }
                return Promise.resolve({
                    segmentationId: o.segmentationId,
                    type: o.type
                });
            });
            Promise.allSettled(a).then((o)=>{
                const s = o.filter((f)=>f.status === "fulfilled").map((f)=>f.value);
                function c(f) {
                    const { element: u, viewportId: g } = f.detail;
                    u.removeEventListener(Ge.IMAGE_RENDERED, c), s.forEach((h)=>{
                        const v = {
                            viewportId: g,
                            segmentationId: h.segmentationId,
                            type: h.type
                        };
                        We(Ke, z.SEGMENTATION_RENDERED, {
                            ...v
                        });
                    });
                }
                r.element.addEventListener(Ge.IMAGE_RENDERED, c), r.render();
            });
        }
        _addPlanarFreeHandToolIfAbsent(e) {
            W1 in nt.tools || N_(XR);
            const n = ha(e.id);
            n.hasTool(W1) || (n.addTool(W1), n.setToolPassive(W1));
        }
    }
    function YR(t) {
        JR.renderSegmentationsForViewport(t);
    }
    function ZR(t) {
        JR.renderSegmentation(t);
    }
    const JR = new $ee;
    function zee({ modifiedSlicesToUse: t, representationData: e, type: n }) {
        const r = ot.getVolume(e[n].volumeId);
        if (!r) {
            console.warn("segmentation not found in cache");
            return;
        }
        const { imageData: i, vtkOpenGLTexture: a } = r;
        let o;
        if (t?.length > 0) o = t;
        else {
            const s = i.getDimensions()[2];
            o = [
                ...Array(s).keys()
            ];
        }
        o.forEach((s)=>{
            a.setUpdatedFrame(s);
        }), i.modified();
    }
    function jee({ viewportIds: t, segmentationId: e }) {
        t.forEach((n)=>{
            let r = P0(n, {
                segmentationId: e
            });
            r = r.filter((i)=>i.type === Ft.Labelmap), r.forEach((i)=>{
                if (i.segmentationId !== e) return;
                const a = An(n);
                if (!a) return;
                const { viewport: o } = a;
                if (o instanceof wi) return;
                const s = Td(n, e);
                s?.length && s.forEach((c, l)=>{
                    const f = c.actor.getMapper().getInputData(), u = Ud(n, e), g = ot.getImage(u[l]);
                    f.modified(), zp(f, g);
                });
            });
        });
    }
    const Hee = function(t) {
        const { segmentationId: e, modifiedSlicesToUse: n } = t.detail, { representationData: r } = eo(e), i = SR(e), a = i.some((c)=>{
            const { viewport: l } = An(c);
            return l instanceof wi;
        }), o = i.some((c)=>{
            const { viewport: l } = An(c);
            return l instanceof ua;
        }), s = a && o;
        i.forEach((c)=>{
            const { viewport: l } = An(c);
            l instanceof wi && zee({
                modifiedSlicesToUse: s ? [] : n,
                representationData: r,
                type: Ft.Labelmap
            }), l instanceof ua && jee({
                viewportIds: i,
                segmentationId: e
            });
        });
    }, QR = function(t) {
        const { segmentationId: e } = t.detail, { representationData: n } = eo(e);
        n.Labelmap && Hee(t), ZR(e);
    }, eO = function(t) {
        const { segmentationId: e } = t.detail;
        ZR(e);
    };
    function Kee(t, e) {
        return lc.updateLabelmapSegmentationImageReferences(t, e);
    }
    const qee = function(t) {
        if (!t) return;
        const e = Fe(t);
        if (!e) return;
        const { viewport: n } = e;
        n instanceof So || (t.addEventListener(Ge.PRE_STACK_NEW_IMAGE, Fd), t.addEventListener(Ge.IMAGE_RENDERED, Fd));
    }, Xee = function(t) {
        t.removeEventListener(Ge.PRE_STACK_NEW_IMAGE, Fd), t.removeEventListener(Ge.IMAGE_RENDERED, Fd);
    };
    function Fd(t) {
        const e = t.detail, { viewportId: n, renderingEngineId: r } = e, { viewport: i } = gf(n, r), a = P0(n);
        if (!a?.length) return;
        const o = a.filter((l)=>l.type === Ft.Labelmap), s = i.getActors();
        o.forEach((l)=>{
            const { segmentationId: f } = l;
            Kee(n, f);
        });
        const c = o.flatMap((l)=>Td(n, l.segmentationId)).filter((l)=>l !== void 0);
        c.length && (c.forEach((l)=>{
            o.find((u)=>Ud(n, u.segmentationId)?.includes(l.referencedId)) || i.removeActors([
                l.uid
            ]);
        }), o.forEach((l)=>{
            const { segmentationId: f } = l, u = i.getCurrentImageId(), g = Ud(n, f);
            if (!g) return;
            let h = !1;
            const v = (m)=>{
                const y = ot.getImage(m);
                if (!y) {
                    console.warn("No derived image found in the cache for segmentation representation", l);
                    return;
                }
                const C = s.find((T)=>T.referencedId === m);
                if (C) {
                    const T = C.actor.getMapper().getInputData();
                    T.setDerivedImage ? T.setDerivedImage(y) : zp(T, y);
                } else {
                    const { dimensions: T, spacing: x, direction: S } = i.getImageDataMetadata(y), D = ot.getImage(u) || {
                        imageId: u
                    }, { origin: _ } = i.getImageDataMetadata(D), M = _, P = y.voxelManager.getConstructor(), F = y.voxelManager.getScalarData(), N = Wt.newInstance({
                        name: "Pixels",
                        numberOfComponents: 1,
                        values: new P(F)
                    }), B = Up.newInstance();
                    B.setDimensions(T[0], T[1], 1), B.setSpacing(x), B.setDirection(S), B.setOrigin(M), B.getPointData().setScalars(N), B.modified(), i.addImages([
                        {
                            imageId: m,
                            representationUID: `${f}-${Ft.Labelmap}-${y.imageId}`,
                            callback: ({ imageActor: G })=>{
                                G.getMapper().setInputData(B);
                            }
                        }
                    ]), h = !0;
                    return;
                }
            };
            g.forEach(v), h && YR(n), i.render(), t.type === Ge.IMAGE_RENDERED && i.element.removeEventListener(Ge.IMAGE_RENDERED, Fd);
        }));
    }
    const tO = {
        enable: qee,
        disable: Xee
    };
    async function Yee(t) {
        const e = t.detail.annotation;
        if (!i2(e)) return;
        const n = Jee(e), r = Qee(n, e);
        if (!r.length) {
            We(Ke, z.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {
                element: n.element,
                sourceAnnotation: e
            });
            return;
        }
        const i = sy(e.data.contour.polyline, n), a = JZ(n, i, r);
        if (!a.length) {
            We(Ke, z.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {
                element: n.element,
                sourceAnnotation: e
            });
            return;
        }
        if (a.length > 1) {
            eJ(n, e, i, a);
            return;
        }
        const { targetAnnotation: o, targetPolyline: s, isContourHole: c } = a[0];
        if (c) {
            const { contourHoleProcessingEnabled: l = !1 } = t.detail;
            if (!l) return;
            PR(n, o, e);
        } else YZ(n, o, s, e, i);
    }
    function Zee(t, e = !1) {
        const n = "PlanarFreehandContourSegmentationTool", r = ha(t.id, t.renderingEngineId);
        let i;
        return r ? r.hasTool(n) ? r.getToolOptions(n) || (i = `Tool ${n} must be in active/passive state in ${r.id} toolGroup`) : i = `Tool ${n} not added to ${r.id} toolGroup` : i = `ToolGroup not found for viewport ${t.id}`, i && !e && console.warn(i), !i;
    }
    function Jee(t) {
        const e = AR(t);
        return e.find((r)=>Zee(r, !0)) ?? e[0];
    }
    function Qee(t, e) {
        const { annotationUID: n } = e;
        return L_().filter((i)=>i.annotationUID && i.annotationUID !== n && i2(i) && _Y(i, e) && t.isReferenceViewable(i.metadata));
    }
    function ete(t) {
        const e = t.detail.annotation;
        Hl(e);
    }
    function nO(t) {
        const e = t.detail.annotation;
        i2(e) && Yee(t);
    }
    function Tp(t) {
        if (!t.detail.removed.length) return;
        Es().forEach((r)=>{
            const a = r.getViewports().map((o)=>o.id);
            it(a);
        });
    }
    function rO(t) {
        const { viewportId: e } = t.detail;
        it([
            e
        ]);
    }
    function tte(t) {
        const e = t.detail.annotation;
        i2(e) && ete(t);
    }
    const iO = function(t) {
        ug(t.detail.element);
    }, nte = function(t) {
        t.addEventListener(Ge.IMAGE_RENDERED, iO);
    }, rte = function(t) {
        t.removeEventListener(Ge.IMAGE_RENDERED, iO);
    }, aO = {
        enable: nte,
        disable: rte
    }, { Active: ite } = er;
    function pf(t, e, n) {
        if (nt.isInteractingWithTool) return !1;
        const { renderingEngineId: r, viewportId: i } = n.detail, a = ha(i, r);
        if (!a) return !1;
        let o;
        const s = Object.keys(a.toolOptions);
        for(let c = 0; c < s.length; c++){
            const l = s[c], f = a.toolOptions[l], u = a.getToolInstance(l);
            if (f.mode === ite && typeof u[e] == "function") {
                o = a.getToolInstance(l);
                break;
            }
        }
        o && o[e](n);
    }
    const oO = pf.bind(null, "Mouse", "mouseClickCallback"), sO = pf.bind(null, "Mouse", "doubleClickCallback");
    function cO(t, e, n, r = "mouse") {
        const i = r === "touch" ? 36 : 6, a = [];
        return e.forEach(({ tool: o, annotations: s })=>{
            for (const c of s){
                if (c.isLocked || !c.isVisible) continue;
                const l = o.getHandleNearImagePoint(t, c, n, i);
                if (l) {
                    a.push({
                        tool: o,
                        annotation: c,
                        handle: l
                    });
                    break;
                }
            }
        }), a;
    }
    function c2(t, e) {
        const n = [];
        for(let r = 0; r < e.length; r++){
            const i = e[r];
            if (!i) {
                console.warn("undefined tool in filterToolsWithAnnotationsForElement");
                continue;
            }
            let a = ba(i.constructor.toolName, t);
            a?.length && (typeof i.filterInteractableAnnotationsForElement == "function" && (a = i.filterInteractableAnnotationsForElement(t, a)), a?.length > 0 && n.push({
                tool: i,
                annotations: a
            }));
        }
        return n;
    }
    function py(t, e, n, r = "mouse") {
        const i = r === "touch" ? 36 : 6, a = [];
        return e.forEach(({ tool: o, annotations: s })=>{
            for (const c of s){
                if (c.isLocked || !c.isVisible) continue;
                if (o.isPointNearTool(t, c, n, i, r)) {
                    a.push({
                        tool: o,
                        annotation: c
                    });
                    break;
                }
            }
        }), a;
    }
    const { Active: ate } = er;
    function l2(t) {
        const { renderingEngineId: e, viewportId: n, event: r } = t.detail, i = fg(r) || hf.getModifierKey(), a = ha(n, e);
        if (!a) return null;
        const o = Object.keys(a.toolOptions), s = a.getDefaultMousePrimary(), c = t.detail.buttons ?? r?.buttons ?? s;
        for(let l = 0; l < o.length; l++){
            const f = o[l], u = a.toolOptions[f], g = u.bindings.length && u.bindings.some((h)=>h.mouseButton === c && h.modifierKey === i);
            if (u.mode === ate && g) return a.getToolInstance(f);
        }
    }
    function Qu(t, e, n) {
        const { renderingEngineId: r, viewportId: i } = t.detail, a = ha(i, r);
        if (!a) return [];
        const o = [], s = Object.keys(a.toolOptions);
        for(let c = 0; c < s.length; c++){
            const l = s[c], f = a.toolOptions[l], u = n != null && f.bindings.length && f.bindings.some((g)=>g.mouseButton === n);
            if (e.includes(f.mode) && (!n || u)) {
                const g = a.getToolInstance(l);
                o.push(g);
            }
        }
        return o;
    }
    function ote(t, e) {
        const n = new Map, { renderingEngineId: r, viewportId: i } = t.detail, a = ha(i, r);
        if (!a) return n;
        const o = Object.keys(a.toolOptions), s = a.getDefaultMousePrimary(), c = t.detail.event, l = c?.buttons ?? s, f = fg(c) || hf.getModifierKey();
        for(let u = 0; u < o.length; u++){
            const g = o[u], h = a.getToolInstance(g), v = h.configuration?.actions ?? {}, m = Object.values(v);
            if (!m?.length || !e.includes(h.mode)) continue;
            const y = m.find((C)=>C.bindings?.length && C.bindings.some((T)=>T.mouseButton === l && T.modifierKey === f));
            y && n.set(h, y);
        }
        return n;
    }
    const { Active: ste, Passive: cte } = er;
    function lte(t) {
        if (nt.isInteractingWithTool) return !1;
        const e = t.detail, { element: n } = e, r = Fe(n), { canvas: i } = e.currentPoints;
        if (!r) return !1;
        const a = ote(t, [
            ste,
            cte
        ]), o = Array.from(a.keys()), s = c2(n, o), c = py(n, s, i);
        if (c.length > 0) {
            const { tool: l, annotation: f } = c[0], u = a.get(l);
            return (typeof u.method == "string" ? l[u.method] : u.method).call(l, t, f), !0;
        }
        return !1;
    }
    const { Active: ute, Passive: fte } = er;
    function lO(t) {
        if (nt.isInteractingWithTool) return;
        const e = l2(t);
        if (e && typeof e.preMouseDownCallback == "function" && e.preMouseDownCallback(t)) return;
        const n = t.detail.event.buttons === 1, r = Qu(t, [
            ute
        ], t.detail.event.buttons), i = n ? Qu(t, [
            fte
        ]) : void 0, a = [
            ...r || [],
            ...i || []
        ];
        if (lte(t)) return;
        const s = t.detail, { element: c } = s, l = c2(c, a), f = s.currentPoints.canvas, u = cO(c, l, f, "mouse"), g = !!t.detail.event.shiftKey;
        if (u.length > 0) {
            const { tool: v, annotation: m, handle: y } = Xw(u);
            Yw(m.annotationUID, g), v.handleSelectedCallback(t, m, y, "Mouse");
            return;
        }
        const h = py(c, l, f, "mouse");
        if (h.length > 0) {
            const { tool: v, annotation: m } = Xw(h);
            Yw(m.annotationUID, g), v.toolSelectedCallback(t, m, "Mouse", f);
            return;
        }
        e && typeof e.postMouseDownCallback == "function" && e.postMouseDownCallback(t);
    }
    function Xw(t) {
        if (t.length > 1) {
            const e = t.find((n)=>{
                const r = !Ja(n.annotation.annotationUID), i = Eo(n.annotation.annotationUID);
                return r && i;
            });
            if (e) return e;
        }
        return t[0];
    }
    function Yw(t, e = !1) {
        e ? t2(t) ? Qs(t, !1) : Qs(t, !0, !0) : Qs(t, !0, !1);
    }
    function uO(t) {
        if (nt.isInteractingWithTool) return;
        const e = l2(t);
        if (e && e.addNewAnnotation) {
            const n = e.addNewAnnotation(t, "mouse");
            Qs(n.annotationUID);
        }
    }
    function fO(t) {
        if (nt.isInteractingWithTool) return;
        const e = l2(t);
        !e || typeof e.mouseDragCallback != "function" || e.mouseDragCallback(t);
    }
    const { Active: dte, Passive: gte } = er;
    function dO(t) {
        if (nt.isInteractingWithTool || nt.isMultiPartToolActive) return;
        const e = Qu(t, [
            dte,
            gte
        ]), n = t.detail, { element: r } = n, i = c2(r, e), a = e.filter((s)=>!i.some((l)=>l.tool.getToolName() === s.getToolName()));
        let o = !1;
        for (const { tool: s, annotations: c } of i)typeof s.mouseMoveCallback == "function" && (o = s.mouseMoveCallback(t, c) || o);
        a.forEach((s)=>{
            typeof s.mouseMoveCallback == "function" && s.mouseMoveCallback(t);
        }), o === !0 && ug(r);
    }
    const gO = pf.bind(null, "Mouse", "mouseUpCallback");
    function hO(t) {
        if (nt.isInteractingWithTool) return;
        t.detail.buttons = zl.Wheel | (t.detail.event.buttons || 0);
        const e = l2(t);
        if (e) return e.mouseWheelCallback(t);
    }
    const hte = function(t) {
        t.addEventListener(z.MOUSE_CLICK, oO), t.addEventListener(z.MOUSE_DOWN, lO), t.addEventListener(z.MOUSE_DOWN_ACTIVATE, uO), t.addEventListener(z.MOUSE_DOUBLE_CLICK, sO), t.addEventListener(z.MOUSE_DRAG, fO), t.addEventListener(z.MOUSE_MOVE, dO), t.addEventListener(z.MOUSE_UP, gO), t.addEventListener(z.MOUSE_WHEEL, hO);
    }, pte = function(t) {
        t.removeEventListener(z.MOUSE_CLICK, oO), t.removeEventListener(z.MOUSE_DOWN, lO), t.removeEventListener(z.MOUSE_DOWN_ACTIVATE, uO), t.removeEventListener(z.MOUSE_DOUBLE_CLICK, sO), t.removeEventListener(z.MOUSE_DRAG, fO), t.removeEventListener(z.MOUSE_MOVE, dO), t.removeEventListener(z.MOUSE_UP, gO), t.removeEventListener(z.MOUSE_WHEEL, hO);
    }, pO = {
        enable: hte,
        disable: pte
    }, { Active: mte } = er;
    function mO(t) {
        const { renderingEngineId: e, viewportId: n } = t.detail, r = VX(), i = hf.getModifierKey(), a = ha(n, e);
        if (!a) return null;
        const o = Object.keys(a.toolOptions), s = a.getDefaultMousePrimary();
        for(let c = 0; c < o.length; c++){
            const l = o[c], f = a.toolOptions[l];
            if (f.mode !== mte) continue;
            if (f.bindings.length && f.bindings.some((g)=>g.mouseButton === (r ?? s) && g.modifierKey === i)) return a.getToolInstance(l);
        }
    }
    function vte(t, e) {
        const n = new Map, { renderingEngineId: r, viewportId: i } = t.detail, a = ha(i, r);
        if (!a) return n;
        const o = Object.keys(a.toolOptions), s = t.detail.key;
        for(let c = 0; c < o.length; c++){
            const l = o[c], f = a.getToolInstance(l), u = f.configuration?.actions;
            if (!u) continue;
            const g = Object.values(u);
            if (!g?.length || !e.includes(f.mode)) continue;
            const h = g.find((v)=>v.bindings?.some((m)=>m.key === s));
            h && n.set(f, h);
        }
        return n;
    }
    function vO(t) {
        const e = mO(t);
        if (e) {
            const { renderingEngineId: r, viewportId: i } = t.detail, a = ha(i, r), o = e.getToolName();
            Object.keys(a.toolOptions).includes(o) && a.setViewportsCursorByToolName(o);
        }
        const n = vte(t, [
            er.Active
        ]);
        if (n?.size) {
            const { element: r } = t.detail;
            for (const [i, a] of [
                ...n.entries()
            ])(typeof a.method == "function" ? a.method : i[a.method]).call(i, r, a, t);
        }
    }
    function yO(t) {
        const e = mO(t);
        if (!e) return;
        const { renderingEngineId: n, viewportId: r } = t.detail, i = ha(r, n);
        gR();
        const a = e.getToolName();
        Object.keys(i.toolOptions).includes(a) && i.setViewportsCursorByToolName(a);
    }
    const yte = function(t) {
        t.addEventListener(z.KEY_DOWN, vO), t.addEventListener(z.KEY_UP, yO);
    }, Cte = function(t) {
        t.removeEventListener(z.KEY_DOWN, vO), t.removeEventListener(z.KEY_UP, yO);
    }, CO = {
        enable: yte,
        disable: Cte
    }, { Active: wte, Passive: Tte, Enabled: xte } = er, wO = function(t) {
        Qu(t, [
            wte,
            Tte,
            xte
        ]).forEach((n)=>{
            n.onCameraModified && n.onCameraModified(t);
        });
    }, Ste = function(t) {
        t.addEventListener(Ge.CAMERA_MODIFIED, wO);
    }, Ete = function(t) {
        t.removeEventListener(Ge.CAMERA_MODIFIED, wO);
    }, TO = {
        enable: Ste,
        disable: Ete
    }, { Active: Dte, Passive: _te, Enabled: Rte } = er, xO = function(t) {
        Qu(t, [
            Dte,
            _te,
            Rte
        ]).forEach((n)=>{
            n.onImageSpacingCalibrated && n.onImageSpacingCalibrated(t);
        });
    }, Ote = function(t) {
        t.addEventListener(Ge.IMAGE_SPACING_CALIBRATED, xO);
    }, Ite = function(t) {
        t.removeEventListener(Ge.IMAGE_SPACING_CALIBRATED, xO);
    }, SO = {
        enable: Ote,
        disable: Ite
    }, { Active: Mte } = er;
    function my(t) {
        const { renderingEngineId: e, viewportId: n } = t.detail, r = t.detail.event, i = ha(n, e);
        if (!i) return null;
        const a = Object.keys(i.toolOptions), o = Object.keys(r.touches).length, s = fg(r) || hf.getModifierKey(), c = i.getDefaultMousePrimary();
        for(let l = 0; l < a.length; l++){
            const f = a[l], u = i.toolOptions[f], g = u.bindings.length && u.bindings.some((h)=>(h.numTouchPoints === o || o === 1 && h.mouseButton === c) && h.modifierKey === s);
            if (u.mode === Mte && g) return i.getToolInstance(f);
        }
    }
    function Zw(t, e, n) {
        const { renderingEngineId: r, viewportId: i } = t.detail, a = ha(i, r);
        if (!a) return [];
        const o = [], s = Object.keys(a.toolOptions);
        for(let c = 0; c < s.length; c++){
            const l = s[c], f = a.toolOptions[l], u = n != null && f.bindings.length && f.bindings.some((g)=>g.numTouchPoints === n);
            if (e.includes(f.mode) && (!n || u)) {
                const g = a.getToolInstance(l);
                o.push(g);
            }
        }
        return o;
    }
    const { Active: bte, Passive: Lte } = er;
    function EO(t) {
        if (nt.isInteractingWithTool) return;
        const e = my(t);
        if (e && typeof e.preTouchStartCallback == "function" && e.preTouchStartCallback(t)) return;
        const n = Object.keys(t.detail.event.touches).length === 1, r = Zw(t, [
            bte
        ], Object.keys(t.detail.event.touches).length), i = n ? Zw(t, [
            Lte
        ]) : void 0, a = [
            ...r || [],
            ...i || [],
            e
        ], o = t.detail, { element: s } = o, c = c2(s, a), l = o.currentPoints.canvas, f = cO(s, c, l, "touch"), u = !1;
        if (f.length > 0) {
            const { tool: h, annotation: v, handle: m } = Jw(f);
            Qw(v.annotationUID, u), h.handleSelectedCallback(t, v, m, "Touch");
            return;
        }
        const g = py(s, c, l, "touch");
        if (g.length > 0) {
            const { tool: h, annotation: v } = Jw(g);
            Qw(v.annotationUID, u), h.toolSelectedCallback(t, v, "Touch", l);
            return;
        }
        e && typeof e.postTouchStartCallback == "function" && e.postTouchStartCallback(t);
    }
    function Jw(t) {
        return t.length > 1 && t.find((e)=>!Ja(e.annotation.annotationUID) && Eo(e.annotation.annotationUID)) || t[0];
    }
    function Qw(t, e = !1) {
        e ? t2(t) ? Qs(t, !1) : Qs(t, !0, !0) : Qs(t, !0, !1);
    }
    function DO(t) {
        if (nt.isInteractingWithTool) return;
        const e = my(t);
        if (e && e.addNewAnnotation) {
            const n = e.addNewAnnotation(t, "touch");
            Qs(n.annotationUID);
        }
    }
    function _O(t) {
        if (nt.isInteractingWithTool) return;
        const e = my(t);
        !e || typeof e.touchDragCallback != "function" || e.touchDragCallback(t);
    }
    const RO = pf.bind(null, "Touch", "touchEndCallback"), Pte = pf.bind(null, "Touch", "touchTapCallback"), OO = pf.bind(null, "Touch", "touchPressCallback"), Vte = function(t) {
        t.addEventListener(z.TOUCH_START, EO), t.addEventListener(z.TOUCH_START_ACTIVATE, DO), t.addEventListener(z.TOUCH_DRAG, _O), t.addEventListener(z.TOUCH_END, RO), t.addEventListener(z.TOUCH_TAP, Pte), t.addEventListener(z.TOUCH_PRESS, OO);
    }, Nte = function(t) {
        t.removeEventListener(z.TOUCH_START, EO), t.removeEventListener(z.TOUCH_START_ACTIVATE, DO), t.removeEventListener(z.TOUCH_DRAG, _O), t.removeEventListener(z.TOUCH_END, RO), t.removeEventListener(z.TOUCH_PRESS, OO);
    }, IO = {
        enable: Vte,
        disable: Nte
    }, Ate = function() {
        Ke.addEventListener(z.ANNOTATION_COMPLETED, Zc.handleAnnotationCompleted), Ke.addEventListener(z.ANNOTATION_MODIFIED, Zc.handleAnnotationUpdate), Ke.addEventListener(z.ANNOTATION_REMOVED, Zc.handleAnnotationDelete);
    }, kte = function() {
        Ke.removeEventListener(z.ANNOTATION_COMPLETED, Zc.handleAnnotationCompleted), Ke.removeEventListener(z.ANNOTATION_MODIFIED, Zc.handleAnnotationUpdate), Ke.removeEventListener(z.ANNOTATION_REMOVED, Zc.handleAnnotationDelete);
    }, MO = {
        enable: Ate,
        disable: kte
    }, { Active: Ute, Passive: Fte, Enabled: Bte } = er, bO = function(t) {
        Qu(t, [
            Ute,
            Fte,
            Bte
        ]).forEach((n)=>{
            n.onResetCamera && n.onResetCamera(t);
        });
    }, Gte = function(t) {
        t.addEventListener(Ge.CAMERA_RESET, bO);
    }, Wte = function(t) {
        t.removeEventListener(Ge.CAMERA_RESET, bO);
    }, LO = {
        enable: Gte,
        disable: Wte
    };
    function PO(t) {
        const { element: e, viewportId: n } = t.detail, r = $te(n);
        zte(e), jte(r, e), oy.addViewportElement(n, e), j_.enable(e), fR.enable(e), cR.enable(e), hf.enable(e), tO.enable(e), aO.enable(e), TO.enable(e), SO.enable(e), LO.enable(e), pO.enable(e), CO.enable(e), IO.enable(e), nt.enabledElements.push(e);
    }
    function $te(t) {
        const e = "http://www.w3.org/2000/svg", n = document.createElementNS(e, "svg"), r = `svg-layer-${t}`;
        n.classList.add("svg-layer"), n.setAttribute("id", r), n.setAttribute("xmlns", "http://www.w3.org/2000/svg"), n.style.width = "100%", n.style.height = "100%", n.style.pointerEvents = "none", n.style.position = "absolute";
        const i = document.createElementNS(e, "defs"), a = document.createElementNS(e, "filter"), o = document.createElementNS(e, "feOffset"), s = document.createElementNS(e, "feColorMatrix"), c = document.createElementNS(e, "feBlend");
        return a.setAttribute("id", `shadow-${r}`), a.setAttribute("filterUnits", "userSpaceOnUse"), o.setAttribute("result", "offOut"), o.setAttribute("in", "SourceGraphic"), o.setAttribute("dx", "0.5"), o.setAttribute("dy", "0.5"), s.setAttribute("result", "matrixOut"), s.setAttribute("in", "offOut"), s.setAttribute("in2", "matrix"), s.setAttribute("values", "0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0"), c.setAttribute("in", "SourceGraphic"), c.setAttribute("in2", "matrixOut"), c.setAttribute("mode", "normal"), a.appendChild(o), a.appendChild(s), a.appendChild(c), i.appendChild(a), n.appendChild(i), n;
    }
    function zte(t) {
        const { viewportUid: e, renderingEngineUid: n } = t.dataset, r = `${e}:${n}`;
        nt.svgNodeCache[r] = {};
    }
    function jte(t, e) {
        e.querySelector("div.viewport-element").appendChild(t);
    }
    function Hte(t, e) {
        const n = [];
        if (!e && !t) throw new Error("At least one of renderingEngineId or viewportId should be given");
        for(let r = 0; r < nt.synchronizers.length; r++){
            const i = nt.synchronizers[r], a = !i.isDisabled(), o = i.hasSourceViewport(e, t), s = i.hasTargetViewport(e, t);
            a && (o || s) && n.push(i);
        }
        return n;
    }
    const Kte = "viewport-element";
    function VO(t) {
        const { element: e, viewportId: n } = t.detail;
        Yte(e), Zte(e), oy.removeViewportElement(n, e), j_.disable(e), fR.disable(e), cR.disable(e), hf.disable(e), tO.disable(e), aO.disable(e), TO.disable(e), SO.disable(e), LO.disable(e), pO.disable(e), CO.disable(e), IO.disable(e), qte(e), Xte(e), Jte(e);
    }
    const qte = (t)=>{
        const e = Fe(t);
        if (!e) return;
        Hte(e.viewportId, e.renderingEngineId).forEach((r)=>{
            r.remove(e);
        });
    }, Xte = (t)=>{
        const e = Fe(t);
        if (!e) return;
        const { renderingEngineId: n, viewportId: r } = e, i = ha(r, n);
        i && i.removeViewports(n, r);
    };
    function Yte(t) {
        const { viewportUid: e, renderingEngineUid: n } = t.dataset, r = `${e}:${n}`;
        delete nt.svgNodeCache[r];
    }
    function Zte(t) {
        const e = t.querySelector(`div.${Kte}`), n = e.querySelector("svg");
        n && e.removeChild(n);
    }
    const Jte = function(t) {
        const e = nt.enabledElements.findIndex((n)=>n === t);
        e > -1 && nt.enabledElements.splice(e, 1);
    }, xp = function(t) {
        const { viewportId: e } = t.detail;
        YR(e);
    };
    let e7 = !1;
    function Qte(t = {}) {
        e7 || (vY(t), ene(), nne(), e7 = !0);
    }
    function ene() {
        tne();
        const t = Ge.ELEMENT_ENABLED, e = Ge.ELEMENT_DISABLED;
        Ke.addEventListener(t, PO), Ke.addEventListener(e, VO), MO.enable();
    }
    function tne() {
        const t = Ge.ELEMENT_ENABLED, e = Ge.ELEMENT_DISABLED;
        Ke.removeEventListener(t, PO), Ke.removeEventListener(e, VO), MO.disable();
    }
    function nne() {
        rne(), Ke.addEventListener(z.ANNOTATION_COMPLETED, nO), Ke.addEventListener(z.ANNOTATION_MODIFIED, rO), Ke.addEventListener(z.ANNOTATION_SELECTION_CHANGE, Tp), Ke.addEventListener(z.ANNOTATION_SELECTION_CHANGE, Tp), Ke.addEventListener(z.ANNOTATION_REMOVED, tte), Ke.addEventListener(z.SEGMENTATION_MODIFIED, eO), Ke.addEventListener(z.SEGMENTATION_DATA_MODIFIED, QR), Ke.addEventListener(z.SEGMENTATION_REPRESENTATION_MODIFIED, xp), Ke.addEventListener(z.SEGMENTATION_REPRESENTATION_ADDED, xp);
    }
    function rne() {
        Ke.removeEventListener(z.ANNOTATION_COMPLETED, nO), Ke.removeEventListener(z.ANNOTATION_MODIFIED, rO), Ke.removeEventListener(z.ANNOTATION_SELECTION_CHANGE, Tp), Ke.removeEventListener(z.ANNOTATION_SELECTION_CHANGE, Tp), Ke.removeEventListener(z.SEGMENTATION_MODIFIED, eO), Ke.removeEventListener(z.SEGMENTATION_DATA_MODIFIED, QR), Ke.removeEventListener(z.SEGMENTATION_REPRESENTATION_MODIFIED, xp), Ke.removeEventListener(z.SEGMENTATION_REPRESENTATION_ADDED, xp);
    }
    const { transformWorldToIndex: t7 } = ga;
    class u2 extends ji {
        static{
            this.toolName = "RectangleROI";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                storePointData: !1,
                shadow: !0,
                preventHandleOutsideImage: !1,
                calculateStats: !0,
                getTextLines: ine,
                statsCalculator: n2
            }
        }){
            super(e, n), this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l } = c;
                this.isDrawing = !0;
                const f = this.constructor.createAnnotationForViewport(l, {
                    data: {
                        handles: {
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        cachedStats: {}
                    }
                });
                nr(f, o);
                const u = rn(o, this.getToolName());
                return this.editData = {
                    annotation: f,
                    viewportIdsToRender: u,
                    handleIndex: 3,
                    movingTextBox: !1,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), Mn(o), r.preventDefault(), it(u), f;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, { points: f } = l.handles, u = c.worldToCanvas(f[0]), g = c.worldToCanvas(f[3]), h = this._getRectangleImageCoordinates([
                    u,
                    g
                ]), v = [
                    a[0],
                    a[1]
                ], { left: m, top: y, width: C, height: T } = h;
                return vZ([
                    m,
                    y,
                    C,
                    T
                ], v) <= o;
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o), Mn(o);
                const c = Fe(o), { renderingEngine: l } = c;
                it(s), r.preventDefault();
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, { data: c } = i;
                i.highlighted = !0;
                let l = !1, f;
                a.worldPosition ? l = !0 : f = c.handles.points.findIndex((v)=>v === a);
                const u = rn(s, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: u,
                    handleIndex: f,
                    movingTextBox: l
                }, this._activateModify(s), Mn(s);
                const g = Fe(s), { renderingEngine: h } = g;
                it(u), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                c && !l || (f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a), this.doneEditMemo(), this.editData = null, this.isDrawing = !1, this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o));
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: f
                });
                const { data: u } = o;
                if (l) {
                    const { deltaPoints: g } = i, h = g.world, { textBox: v } = u.handles, { worldPosition: m } = v;
                    m[0] += h[0], m[1] += h[1], m[2] += h[2], v.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: g } = i, h = g.world, { points: v } = u.handles;
                    v.forEach((m)=>{
                        m[0] += h[0], m[1] += h[1], m[2] += h[2];
                    }), o.invalidated = !0;
                } else {
                    const { currentPoints: g } = i, h = Fe(a), { worldToCanvas: v, canvasToWorld: m } = h.viewport, y = g.world, { points: C } = u.handles;
                    C[c] = [
                        ...y
                    ];
                    let T, x, S, D, _, M, P, F;
                    switch(c){
                        case 0:
                        case 3:
                            T = v(C[0]), D = v(C[3]), x = [
                                D[0],
                                T[1]
                            ], S = [
                                T[0],
                                D[1]
                            ], M = m(x), P = m(S), C[1] = M, C[2] = P;
                            break;
                        case 1:
                        case 2:
                            x = v(C[1]), S = v(C[2]), T = [
                                S[0],
                                x[1]
                            ], D = [
                                x[0],
                                S[1]
                            ], _ = m(T), F = m(D), C[0] = _, C[3] = F;
                            break;
                    }
                    o.invalidated = !0;
                }
                this.editData.hasMoved = !0, Fe(a), it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_MOVE, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { points: y, activeHandleIndex: C } = m.handles, T = y.map((re)=>o.worldToCanvas(re));
                    u.annotationUID = v;
                    const { color: x, lineWidth: S, lineDash: D } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), { viewPlaneNormal: _, viewUp: M } = o.getCamera();
                    if (!m.cachedStats[l] || m.cachedStats[l].areaUnit == null) m.cachedStats[l] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null
                    }, this._calculateCachedStats(h, _, M, f, r);
                    else if (h.invalidated && (this._throttledCalculateCachedStats(h, _, M, f, r), o instanceof wi)) {
                        const { referencedImageId: re } = h.metadata;
                        for(const X in m.cachedStats)X.startsWith("imageId") && f.getStackViewports().find(($e)=>{
                            const je = ur(re), He = $e.hasImageURI(je), rt = ur($e.getCurrentImageId());
                            return He && rt !== je;
                        }) && delete m.cachedStats[X];
                    }
                    if (!o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    let P;
                    if (!Eo(v)) continue;
                    !Ja(v) && !this.editData && C !== null && C !== void 0 && (P = [
                        T[C]
                    ]), P && Do(i, v, "0", P, {
                        color: x
                    });
                    const F = `${v}-rect`;
                    NZ(i, v, "0", T, {
                        color: x,
                        lineDash: D,
                        lineWidth: S
                    }, F), a = !0;
                    const B = this.getLinkedTextBoxStyle(u, h);
                    if (!B.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const G = this.configuration.getTextLines(m, l);
                    if (!G || G.length === 0) continue;
                    if (!m.handles.textBox.hasMoved) {
                        const re = Jl(T);
                        m.handles.textBox.worldPosition = o.canvasToWorld(re);
                    }
                    const Z = o.worldToCanvas(m.handles.textBox.worldPosition), ne = fc(i, v, "1", G, Z, T, {}, B), { x: ae, y: ue, width: le, height: oe } = ne;
                    m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            ae,
                            ue
                        ]),
                        topRight: o.canvasToWorld([
                            ae + le,
                            ue
                        ]),
                        bottomLeft: o.canvasToWorld([
                            ae,
                            ue + oe
                        ]),
                        bottomRight: o.canvasToWorld([
                            ae + le,
                            ue + oe
                        ])
                    };
                }
                return a;
            }, this._getRectangleImageCoordinates = (r)=>{
                const [i, a] = r;
                return {
                    left: Math.min(i[0], a[0]),
                    top: Math.min(i[1], a[1]),
                    width: Math.abs(i[0] - a[0]),
                    height: Math.abs(i[1] - a[1])
                };
            }, this._calculateCachedStats = (r, i, a, o, s)=>{
                if (!this.configuration.calculateStats) return;
                const { data: c } = r, { viewport: l } = s, { element: f } = l, u = c.handles.points[0], g = c.handles.points[3], { cachedStats: h } = c, v = Object.keys(h);
                for(let y = 0; y < v.length; y++){
                    const C = v[y], T = this.getTargetImageData(C);
                    if (!T) continue;
                    const { dimensions: x, imageData: S, metadata: D, voxelManager: _ } = T, M = t7(S, u);
                    M[0] = Math.floor(M[0]), M[1] = Math.floor(M[1]), M[2] = Math.floor(M[2]);
                    const P = t7(S, g);
                    if (P[0] = Math.floor(P[0]), P[1] = Math.floor(P[1]), P[2] = Math.floor(P[2]), this._isInsideVolume(M, P, x)) {
                        this.isHandleOutsideImage = !1;
                        const F = Math.min(M[0], P[0]), N = Math.max(M[0], P[0]), B = Math.min(M[1], P[1]), G = Math.max(M[1], P[1]), Z = Math.min(M[2], P[2]), H = Math.max(M[2], P[2]), ne = [
                            [
                                F,
                                N
                            ],
                            [
                                B,
                                G
                            ],
                            [
                                Z,
                                H
                            ]
                        ], { worldWidth: ae, worldHeight: ue } = jJ(i, a, u, g), le = [
                            M,
                            P
                        ], { scale: oe, areaUnit: re } = ql(T, le), X = Math.abs(ae * ue) / (oe * oe), ie = {
                            isPreScaled: dg(l, C),
                            isSuvScaled: this.isSuvScaled(l, C, r.metadata.referencedImageId)
                        }, he = gg(D.Modality, r.metadata.referencedImageId, ie);
                        let $e;
                        _ && ($e = _.forEach(this.configuration.statsCalculator.statsCallback, {
                            boundsIJK: ne,
                            imageData: S,
                            returnPoints: this.configuration.storePointData
                        }));
                        const je = this.configuration.statsCalculator.getStatistics();
                        h[C] = {
                            Modality: D.Modality,
                            area: X,
                            mean: je.mean?.value,
                            stdDev: je.stdDev?.value,
                            max: je.max?.value,
                            min: je.min?.value,
                            statsArray: je.array,
                            pointsInShape: $e,
                            areaUnit: re,
                            modalityUnit: he
                        };
                    } else this.isHandleOutsideImage = !0, h[C] = {
                        Modality: D.Modality
                    };
                }
                const m = r.invalidated;
                return r.invalidated = !1, m && yn(r, f, Jt.StatsUpdated), h;
            }, this._isInsideVolume = (r, i, a)=>Mi(r, a) && Mi(i, a), this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(u2, i, n, r), { toolInstance: f, ...u } = r || {}, g = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n,
                            activeHandleIndex: null
                        },
                        label: "",
                        cachedStats: {}
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...u
                    }
                };
                nr(g, l.element), it([
                    l.id
                ]);
            };
        }
    }
    function ine(t, e) {
        const n = t.cachedStats[e], { area: r, mean: i, max: a, stdDev: o, areaUnit: s, modalityUnit: c, min: l } = n;
        if (i == null) return;
        const f = [];
        return cr(r) && f.push(`Area: ${Rn(r)} ${s}`), cr(i) && f.push(`Mean: ${Rn(i)} ${c}`), cr(a) && f.push(`Max: ${Rn(a)} ${c}`), cr(l) && f.push(`Max: ${Rn(l)} ${c}`), cr(o) && f.push(`Std Dev: ${Rn(o)} ${c}`), f;
    }
    const { transformWorldToIndex: $1 } = ga;
    class f2 extends ji {
        static{
            this.toolName = "Bidirectional";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                preventHandleOutsideImage: !1,
                getTextLines: ane
            }
        }){
            super(e, n), this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, { points: f } = l.handles;
                let u = c.worldToCanvas(f[0]), g = c.worldToCanvas(f[1]), h = {
                    start: {
                        x: u[0],
                        y: u[1]
                    },
                    end: {
                        x: g[0],
                        y: g[1]
                    }
                }, v = Cs([
                    h.start.x,
                    h.start.y
                ], [
                    h.end.x,
                    h.end.y
                ], [
                    a[0],
                    a[1]
                ]);
                return v <= o || (u = c.worldToCanvas(f[2]), g = c.worldToCanvas(f[3]), h = {
                    start: {
                        x: u[0],
                        y: u[1]
                    },
                    end: {
                        x: g[0],
                        y: g[1]
                    }
                }, v = Cs([
                    h.start.x,
                    h.start.y
                ], [
                    h.end.x,
                    h.end.y
                ], [
                    a[0],
                    a[1]
                ]), v <= o);
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o);
                const c = Fe(o), { renderingEngine: l } = c;
                it(s), Mn(o), r.preventDefault();
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, c = i.data;
                i.highlighted = !0;
                let l = !1, f;
                a.worldPosition ? l = !0 : f = c.handles.points.findIndex((v)=>v === a);
                const u = rn(s, this.getToolName());
                Mn(s), this.editData = {
                    annotation: i,
                    viewportIdsToRender: u,
                    handleIndex: f,
                    movingTextBox: l
                }, this._activateModify(s);
                const g = Fe(s), { renderingEngine: h } = g;
                it(u), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                if (c && !l) return;
                this.doneEditMemo(), f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a);
                const { renderingEngine: u } = Fe(a);
                if (this.editData.handleIndex !== void 0) {
                    const { points: g } = f.handles, h = rc(g[0], g[1]);
                    if (rc(g[2], g[3]) > h) {
                        const m = [
                            [
                                ...g[2]
                            ],
                            [
                                ...g[3]
                            ]
                        ], y = [
                            ...g[0]
                        ], C = [
                            ...g[1]
                        ], T = sn();
                        qo(T, m[1][0] - m[0][0], m[1][1] - m[1][0]);
                        const x = sn();
                        qo(x, -T[1], T[0]);
                        const S = sn();
                        qo(S, C[0] - y[0], C[1] - y[0]);
                        let D;
                        kc(S, x) > 0 ? D = [
                            y,
                            C
                        ] : D = [
                            C,
                            y
                        ], f.handles.points = [
                            m[0],
                            m[1],
                            D[0],
                            D[1]
                        ];
                    }
                }
                this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o), this.editData = null, this.isDrawing = !1;
            }, this._dragDrawCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { currentPoints: a, element: o } = i, s = Fe(o), { viewport: c } = s, { worldToCanvas: l } = c, { annotation: f, viewportIdsToRender: u, handleIndex: g, newAnnotation: h } = this.editData;
                this.createMemo(o, f, {
                    newAnnotation: h
                });
                const { data: v } = f, m = a.world;
                v.handles.points[g] = [
                    ...m
                ];
                const y = v.handles.points.map(l), C = {
                    longLineSegment: {
                        start: {
                            x: y[0][0],
                            y: y[0][1]
                        },
                        end: {
                            x: y[1][0],
                            y: y[1][1]
                        }
                    },
                    shortLineSegment: {
                        start: {
                            x: y[2][0],
                            y: y[2][1]
                        },
                        end: {
                            x: y[3][0],
                            y: y[3][1]
                        }
                    }
                }, x = Or(y[0], y[1]) / 3, S = C.longLineSegment.start.x - C.longLineSegment.end.x, D = C.longLineSegment.start.y - C.longLineSegment.end.y, _ = Math.sqrt(S * S + D * D), M = S / _, P = D / _, F = (C.longLineSegment.start.x + C.longLineSegment.end.x) / 2, N = (C.longLineSegment.start.y + C.longLineSegment.end.y) / 2, B = F + x * P, G = N - x * M, Z = F - x * P, H = N + x * M;
                v.handles.points[2] = c.canvasToWorld([
                    B,
                    G
                ]), v.handles.points[3] = c.canvasToWorld([
                    Z,
                    H
                ]), f.invalidated = !0, it(u), yn(f, o, Jt.HandlesUpdated), this.editData.hasMoved = !0;
            }, this._dragModifyCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: f
                });
                const { data: u } = o;
                if (l) {
                    const { deltaPoints: g } = i, h = g.world, { textBox: v } = u.handles, { worldPosition: m } = v;
                    m[0] += h[0], m[1] += h[1], m[2] += h[2], v.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: g } = i, h = g.world;
                    u.handles.points.forEach((m)=>{
                        m[0] += h[0], m[1] += h[1], m[2] += h[2];
                    }), o.invalidated = !0;
                } else this._dragModifyHandle(r), o.invalidated = !0;
                it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this._dragModifyHandle = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = Fe(o), { viewport: c } = s, { annotation: l, handleIndex: f } = this.editData, { data: u } = l, g = a.world, h = [
                    c.worldToCanvas(u.handles.points[0]),
                    c.worldToCanvas(u.handles.points[1]),
                    c.worldToCanvas(u.handles.points[2]),
                    c.worldToCanvas(u.handles.points[3])
                ], v = {
                    start: {
                        x: h[0][0],
                        y: h[0][1]
                    },
                    end: {
                        x: h[1][0],
                        y: h[1][1]
                    }
                }, m = {
                    start: {
                        x: h[2][0],
                        y: h[2][1]
                    },
                    end: {
                        x: h[3][0],
                        y: h[3][1]
                    }
                }, y = [
                    ...g
                ], C = c.worldToCanvas(y);
                if (f === 0 || f === 1) {
                    const x = h[f === 0 ? 1 : 0], S = qo(sn(), C[0] - x[0], C[1] - x[1]), D = qo(sn(), h[f][0] - x[0], h[f][1] - x[1]);
                    Ou(S, S), Ou(D, D);
                    const _ = {
                        start: {
                            x: x[0],
                            y: x[1]
                        },
                        end: {
                            x: C[0],
                            y: C[1]
                        }
                    };
                    if (this._movingLongAxisWouldPutItThroughShortAxis(_, m)) return;
                    const M = x, P = this._getSignedAngle(D, S);
                    let F = h[2][0], N = h[2][1], B = h[3][0], G = h[3][1];
                    F -= M[0], N -= M[1], B -= M[0], G -= M[1];
                    const Z = F * Math.cos(P) - N * Math.sin(P), H = F * Math.sin(P) + N * Math.cos(P), ne = B * Math.cos(P) - G * Math.sin(P), ae = B * Math.sin(P) + G * Math.cos(P);
                    F = Z + M[0], N = H + M[1], B = ne + M[0], G = ae + M[1];
                    const ue = c.canvasToWorld([
                        F,
                        N
                    ]), le = c.canvasToWorld([
                        B,
                        G
                    ]);
                    u.handles.points[f] = y, u.handles.points[2] = ue, u.handles.points[3] = le;
                } else {
                    const T = f === 2 ? 3 : 2, x = {
                        longLineSegment: {
                            start: v.start,
                            end: v.end
                        },
                        shortLineSegment: {
                            start: m.start,
                            end: m.end
                        }
                    }, S = yi(sn(), [
                        x.longLineSegment.end.x,
                        x.longLineSegment.end.y
                    ], [
                        x.longLineSegment.start.x,
                        x.longLineSegment.start.y
                    ]), D = Ou(sn(), S), _ = yi(sn(), [
                        C[0],
                        C[1]
                    ], [
                        h[f][0],
                        h[f][1]
                    ]), M = Rv(_), P = this._getSignedAngle(D, _), F = Math.cos(P) * M, N = id(sn(), [
                        h[T][0],
                        h[T][1]
                    ], D, F);
                    if (this._movingLongAxisWouldPutItThroughShortAxis({
                        start: {
                            x: C[0],
                            y: C[1]
                        },
                        end: {
                            x: N[0],
                            y: N[1]
                        }
                    }, {
                        start: {
                            x: x.longLineSegment.start.x,
                            y: x.longLineSegment.start.y
                        },
                        end: {
                            x: x.longLineSegment.end.x,
                            y: x.longLineSegment.end.y
                        }
                    }) || !xw([
                        C[0],
                        C[1]
                    ], [
                        N[0],
                        N[1]
                    ], [
                        v.start.x,
                        v.start.y
                    ], [
                        v.end.x,
                        v.end.y
                    ])) return;
                    u.handles.points[T] = c.canvasToWorld(N), u.handles.points[f] = y;
                }
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.addEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragDrawCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragDrawCallback);
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !0;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { points: y, activeHandleIndex: C } = m.handles, T = y.map((ie)=>o.worldToCanvas(ie));
                    u.annotationUID = v;
                    const { color: x, lineWidth: S, lineDash: D, shadow: _ } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    });
                    if (!m.cachedStats[l] || m.cachedStats[l].unit == null ? (m.cachedStats[l] = {
                        length: null,
                        width: null,
                        unit: null
                    }, this._calculateCachedStats(h, f, r)) : h.invalidated && this._throttledCalculateCachedStats(h, f, r), !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    let M;
                    if (!Eo(v)) continue;
                    !Ja(v) && !this.editData && C !== null && (M = [
                        T[C]
                    ]), M && Do(i, v, "0", M, {
                        color: x
                    });
                    const P = `${v}-line-1`, F = `${v}-line-2`;
                    Oa(i, v, "0", T[0], T[1], {
                        color: x,
                        lineDash: D,
                        lineWidth: S,
                        shadow: _
                    }, P), Oa(i, v, "1", T[2], T[3], {
                        color: x,
                        lineDash: D,
                        lineWidth: S,
                        shadow: _
                    }, F), a = !0;
                    const G = this.getLinkedTextBoxStyle(u, h);
                    if (!G.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const Z = this.configuration.getTextLines(m, l);
                    if (!Z || Z.length === 0) continue;
                    let H;
                    m.handles.textBox.hasMoved || (H = Jl(T), m.handles.textBox.worldPosition = o.canvasToWorld(H));
                    const ne = o.worldToCanvas(m.handles.textBox.worldPosition), ue = fc(i, v, "1", Z, ne, T, {}, G), { x: le, y: oe, width: re, height: X } = ue;
                    m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            le,
                            oe
                        ]),
                        topRight: o.canvasToWorld([
                            le + re,
                            oe
                        ]),
                        bottomLeft: o.canvasToWorld([
                            le,
                            oe + X
                        ]),
                        bottomRight: o.canvasToWorld([
                            le + re,
                            oe + X
                        ])
                    };
                }
                return a;
            }, this._movingLongAxisWouldPutItThroughShortAxis = (r, i)=>{
                const a = sn();
                qo(a, i.end.x - i.start.x, i.end.y - i.start.y), Ou(a, a);
                const o = {
                    start: {
                        x: i.start.x - a[0] * 10,
                        y: i.start.y - a[1] * 10
                    },
                    end: {
                        x: i.end.x + a[0] * 10,
                        y: i.end.y + a[1] * 10
                    }
                };
                return !xw([
                    o.start.x,
                    o.start.y
                ], [
                    o.end.x,
                    o.end.y
                ], [
                    r.start.x,
                    r.start.y
                ], [
                    r.end.x,
                    r.end.y
                ]);
            }, this._calculateCachedStats = (r, i, a)=>{
                const { data: o } = r, { element: s } = a.viewport, c = o.handles.points[0], l = o.handles.points[1], f = o.handles.points[2], u = o.handles.points[3], { cachedStats: g } = o, h = Object.keys(g);
                for(let m = 0; m < h.length; m++){
                    const y = h[m], C = this.getTargetImageData(y);
                    if (!C) continue;
                    const { imageData: T, dimensions: x } = C, S = $1(T, c), D = $1(T, l), _ = $1(T, f), M = $1(T, u), P = [
                        S,
                        D
                    ], F = [
                        _,
                        M
                    ], { scale: N, unit: B } = ql(C, P), { scale: G, unit: Z } = ql(C, F), H = this._calculateLength(c, l) / N, ne = this._calculateLength(f, u) / G, ae = H > ne ? H : ne, ue = H > ne ? ne : H, le = H > ne ? B : Z, oe = H > ne ? Z : B;
                    this._isInsideVolume(S, D, _, M, x) ? this.isHandleOutsideImage = !1 : this.isHandleOutsideImage = !0, g[y] = {
                        length: ae,
                        width: ue,
                        unit: le,
                        widthUnit: oe
                    };
                }
                const v = r.invalidated;
                return r.invalidated = !1, v && yn(r, s, Jt.StatsUpdated), g;
            }, this._isInsideVolume = (r, i, a, o, s)=>Mi(r, s) && Mi(i, s) && Mi(a, s) && Mi(o, s), this._getSignedAngle = (r, i)=>Math.atan2(r[0] * i[1] - r[1] * i[0], r[0] * i[0] + r[1] * i[1]), this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        addNewAnnotation(e) {
            const n = e.detail, { currentPoints: r, element: i } = n, a = r.world, o = Fe(i), { viewport: s, renderingEngine: c } = o;
            this.isDrawing = !0;
            const l = s.getCamera(), { viewPlaneNormal: f, viewUp: u } = l, g = this.getReferencedImageId(s, a, f, u), h = s.getFrameOfReferenceUID(), v = {
                highlighted: !0,
                invalidated: !0,
                metadata: {
                    toolName: this.getToolName(),
                    viewPlaneNormal: [
                        ...f
                    ],
                    viewUp: [
                        ...u
                    ],
                    FrameOfReferenceUID: h,
                    referencedImageId: g,
                    ...s.getViewReference({
                        points: [
                            a
                        ]
                    })
                },
                data: {
                    handles: {
                        points: [
                            [
                                ...a
                            ],
                            [
                                ...a
                            ],
                            [
                                ...a
                            ],
                            [
                                ...a
                            ]
                        ],
                        textBox: {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        },
                        activeHandleIndex: null
                    },
                    label: "",
                    cachedStats: {}
                }
            };
            nr(v, i);
            const m = rn(i, this.getToolName());
            return this.editData = {
                annotation: v,
                viewportIdsToRender: m,
                handleIndex: 1,
                movingTextBox: !1,
                newAnnotation: !0,
                hasMoved: !1
            }, this._activateDraw(i), Mn(i), e.preventDefault(), it(m), v;
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(f2, i, n[0], r), [f, u] = n, [g, h] = f, [v, m] = u, y = [
                    g,
                    h,
                    v,
                    m
                ], { toolInstance: C, ...T } = r || {}, x = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: y,
                            activeHandleIndex: null,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        cachedStats: {}
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...T
                    }
                };
                return nr(x, l.element), it([
                    l.id
                ]), x;
            };
        }
        _calculateLength(e, n) {
            const r = e[0] - n[0], i = e[1] - n[1], a = e[2] - n[2];
            return Math.sqrt(r * r + i * i + a * a);
        }
    }
    function ane(t, e) {
        const { cachedStats: n, label: r } = t, { length: i, width: a, unit: o } = n[e], s = [];
        return r && s.push(r), i === void 0 || s.push(`L: ${Rn(i)} ${o || o}`, `W: ${Rn(a)} ${o}`), s;
    }
    function one(t, e, n) {
        t.data.label = n, yn(t, e, Jt.LabelChange);
    }
    class sne {
        constructor(e){
            this._controlPoints = [], this._invalidated = !1, this._length = 0, this._controlPoints = [], this._resolution = e?.resolution ?? 20, this._fixedResolution = e?.fixedResolution ?? !1, this._closed = e?.closed ?? !1, this._invalidated = !0;
        }
        get controlPoints() {
            return this._controlPoints;
        }
        get numControlPoints() {
            return this._controlPoints.length;
        }
        get resolution() {
            return this._resolution;
        }
        set resolution(e) {
            this._fixedResolution || this._resolution === e || (this._resolution = e, this.invalidated = !0);
        }
        get fixedResolution() {
            return this._fixedResolution;
        }
        get closed() {
            return this._closed;
        }
        set closed(e) {
            this._closed !== e && (this._closed = e, this.invalidated = !0);
        }
        get aabb() {
            return this._update(), this._aabb;
        }
        get length() {
            return this._update(), this._length;
        }
        get invalidated() {
            return this._invalidated;
        }
        set invalidated(e) {
            this._invalidated = e;
        }
        hasTangentPoints() {
            return !1;
        }
        addControlPoint(e) {
            this._controlPoints.push([
                e[0],
                e[1]
            ]), this.invalidated = !0;
        }
        addControlPoints(e) {
            e.forEach((n)=>this.addControlPoint(n));
        }
        addControlPointAtU(e) {
            const n = this._getLineSegmentAt(e), { start: r, end: i } = n.points, a = Math.floor(e), o = this._curveSegments[a], s = e - Math.floor(a), c = [
                r[0] + s * (i[0] - r[0]),
                r[1] + s * (i[1] - r[1])
            ], l = this._controlPoints.indexOf(o.controlPoints.p1) + 1;
            return this._controlPoints.splice(l, 0, c), this.invalidated = !0, {
                index: l,
                point: c
            };
        }
        deleteControlPointByIndex(e) {
            const n = this._closed ? 3 : 1;
            return e >= 0 && e < this._controlPoints.length && this._controlPoints.length > n ? (this._controlPoints.splice(e, 1), this.invalidated = !0, !0) : !1;
        }
        clearControlPoints() {
            this._controlPoints = [], this.invalidated = !0;
        }
        setControlPoints(e) {
            this.clearControlPoints(), this.addControlPoints(e);
        }
        updateControlPoint(e, n) {
            if (e < 0 || e >= this._controlPoints.length) throw new Error("Index out of bounds");
            this._controlPoints[e] = [
                ...n
            ], this.invalidated = !0;
        }
        getControlPoints() {
            return this._controlPoints.map((e)=>[
                    e[0],
                    e[1]
                ]);
        }
        getClosestControlPoint(e) {
            const n = this._controlPoints;
            let r = 1 / 0, i = -1;
            for(let a = 0, o = n.length; a < o; a++){
                const s = n[a], c = e[0] - s[0], l = e[1] - s[1], f = c * c + l * l;
                f < r && (r = f, i = a);
            }
            return {
                index: i,
                point: i === -1 ? void 0 : [
                    ...n[i]
                ],
                distance: Math.sqrt(r)
            };
        }
        getClosestControlPointWithinDistance(e, n) {
            const r = this.getClosestControlPoint(e);
            return r.distance <= n ? r : void 0;
        }
        getClosestPoint(e) {
            this._update();
            const n = this._getCurveSegmmentsDistanceSquaredInfo(e);
            if (!n.length) return;
            n.sort((u, g)=>u.distanceSquared - g.distanceSquared);
            let r, i = -1, a = 1 / 0, o, s;
            for(let u = 0; u < n.length; u++){
                const g = n[u];
                if (g.distanceSquared > a) continue;
                const { curveSegmentIndex: h, curveSegment: v } = g, { lineSegments: m } = v;
                for(let y = 0; y < m.length; y++){
                    const C = m[y], { point: T, distanceSquared: x } = e3(C.points.start, C.points.end, e);
                    x < a && (s = C, i = h, o = g.curveSegment, r = T, a = x);
                }
            }
            const l = (s.previousLineSegmentsLength + cg(s.points.start, r)) / o.length, f = i + l;
            return {
                point: r,
                uValue: f,
                distance: Math.sqrt(a)
            };
        }
        getClosestPointOnControlPointLines(e) {
            const n = [
                ...this._controlPoints
            ];
            if (this._closed && n.push(this._controlPoints[0]), !n.length) return;
            let r, i = 1 / 0, a = n[0];
            for(let o = 1, s = n.length; o < s; o++){
                const c = n[o], { point: l, distanceSquared: f } = e3(a, c, e);
                f < i && (r = l, i = f), a = c;
            }
            return {
                point: r,
                distance: Math.sqrt(i)
            };
        }
        getPolylinePoints() {
            return this._update(), this._convertCurveSegmentsToPolyline(this._curveSegments);
        }
        getPreviewPolylinePoints(e, n) {
            if (this._closed) return [];
            this._update();
            const i = this.getClosestControlPointWithinDistance(e, n)?.index === 0, a = this.getPreviewCurveSegments(e, i);
            return a?.length ? this._convertCurveSegmentsToPolyline(a) : [];
        }
        isPointNearCurve(e, n) {
            this._update();
            const r = this._getCurveSegmmentsWithinDistance(e, n), i = n * n;
            for(let a = 0; a < r.length; a++){
                const { lineSegments: o } = r[a];
                for(let s = 0; s < o.length; s++){
                    const c = o[s];
                    if (ey(c.points.start, c.points.end, e) <= i) return !0;
                }
            }
            return !1;
        }
        containsPoint(e) {
            if (this._update(), this._controlPoints.length < 3) return !1;
            const r = [
                ...this._curveSegments
            ], i = this._getClosingCurveSegmentWithStraightLineSegment();
            i && r.push(i);
            let a = 0;
            for(let o = 0; o < r.length; o++){
                const s = r[o], { aabb: c } = s;
                if (!(e[0] <= c.maxX && e[1] >= c.minY && e[1] < c.maxY)) continue;
                const { lineSegments: f } = s;
                for(let u = 0; u < f.length; u++){
                    const g = f[u], { aabb: h } = g;
                    if (e[0] <= h.maxX && e[1] >= h.minY && e[1] < h.maxY) {
                        const { start: m, end: y } = g.points, C = m[0] === y[0], T = (e[1] - m[1]) * (y[0] - m[0]) / (y[1] - m[1]) + m[0];
                        a += C || e[0] <= T ? 1 : 0;
                    }
                }
            }
            return a % 2 === 1;
        }
        _update() {
            if (!this._invalidated) return;
            const e = this.getSplineCurves();
            let n = 0, r = 1 / 0, i = 1 / 0, a = -1 / 0, o = -1 / 0;
            for(let s = 0, c = e.length; s < c; s++){
                const { aabb: l, length: f } = e[s];
                r = r <= l.minX ? r : l.minX, i = i <= l.minY ? i : l.minY, a = a >= l.maxX ? a : l.maxX, o = o >= l.maxY ? o : l.maxY, n += f;
            }
            this._curveSegments = e, this._aabb = {
                minX: r,
                minY: i,
                maxX: a,
                maxY: o
            }, this._length = n, this._invalidated = !1;
        }
        _convertCurveSegmentsToPolyline(e) {
            this._update();
            const n = [];
            return e.forEach(({ lineSegments: r }, i)=>{
                r.forEach((a, o)=>{
                    i === 0 && o === 0 && n.push([
                        ...a.points.start
                    ]), n.push([
                        ...a.points.end
                    ]);
                });
            }), n;
        }
        _getCurveSegmmentsDistanceSquaredInfo(e) {
            this._update();
            const n = [], { _curveSegments: r } = this;
            for(let i = 0; i < r.length; i++){
                const a = r[i], o = yw(a.aabb, e);
                n.push({
                    curveSegmentIndex: i,
                    curveSegment: a,
                    distanceSquared: o
                });
            }
            return n;
        }
        _getCurveSegmmentsWithinDistance(e, n) {
            this._update();
            const r = n * n;
            if (yw(this.aabb, e) > r) return [];
            const i = this._getCurveSegmmentsDistanceSquaredInfo(e), a = [];
            for(let o = 0, s = i.length; o < s; o++){
                const { curveSegment: c, distanceSquared: l } = i[o];
                l <= r && a.push(c);
            }
            return a;
        }
        _getLineSegmentAt(e) {
            this._update();
            const n = Math.floor(e), r = e - n, i = this._curveSegments[n], { lineSegments: a } = i, o = i.length * r;
            for(let s = 0; s < a.length; s++){
                const c = a[s], l = c.previousLineSegmentsLength + c.length;
                if (o >= c.previousLineSegmentsLength && o <= l) return c;
            }
        }
        _getClosingCurveSegmentWithStraightLineSegment() {
            if (this.closed) return;
            const e = this._controlPoints, n = e[0], r = e[e.length - 1], i = {
                points: {
                    start: [
                        ...n
                    ],
                    end: [
                        ...r
                    ]
                },
                aabb: {
                    minX: Math.min(n[0], r[0]),
                    minY: Math.min(n[1], r[1]),
                    maxX: Math.max(n[0], r[0]),
                    maxY: Math.max(n[1], r[1])
                }
            };
            return {
                aabb: {
                    minX: i.aabb.minX,
                    minY: i.aabb.minY,
                    maxX: i.aabb.maxX,
                    maxY: i.aabb.maxY
                },
                lineSegments: [
                    i
                ]
            };
        }
    }
    const cne = 1e-8;
    class NO extends sne {
        getPreviewCurveSegments(e, n) {
            const r = this._getNumCurveSegments() + 1, i = Math.max(0, r - 2), a = n ? r : r - 1, o = this.getTransformMatrix(), s = [
                ...this.controlPoints
            ], c = [];
            n || s.push(e);
            for(let l = i; l <= a; l++){
                const f = this._getCurveSegment(l, o, s, n);
                c.push(f);
            }
            return c;
        }
        getSplineCurves() {
            const e = this._getNumCurveSegments(), n = new Array(e);
            if (e <= 0) return [];
            const r = this.getTransformMatrix();
            let i = 0;
            for(let a = 0; a < e; a++){
                const o = this._getCurveSegment(a, r);
                o.previousCurveSegmentsLength = i, n[a] = o, i += o.length;
            }
            return n;
        }
        _getNumCurveSegments(e = this.controlPoints, n = this.closed) {
            return n ? e.length : Math.max(0, e.length - 1);
        }
        _getPoint(e, n, r = this.controlPoints, i = this.closed) {
            const a = this._getNumCurveSegments(r, i), o = Math.floor(e);
            let s = o % a;
            const c = e - o;
            if (s < 0 || s >= a) if (this.closed) s = (a + s) % a;
            else return;
            const { p0: f, p1: u, p2: g, p3: h } = this._getCurveSegmentPoints(s, r, i), v = c * c, m = v * c, y = ah(1, c, v, m), C = Ll(yx(), y, n);
            return [
                O9(C, ah(f[0], u[0], g[0], h[0])),
                O9(C, ah(f[1], u[1], g[1], h[1]))
            ];
        }
        _getCurveSegmentPoints(e, n = this.controlPoints, r = this.closed) {
            const i = this._getNumCurveSegments(n, r), a = e, o = a - 1, s = r ? (a + 1) % i : a + 1, c = s + 1, l = n[a], f = n[s];
            let u, g;
            return o >= 0 ? u = n[o] : u = r ? n[n.length - 1] : Cw(f, l), c < n.length ? g = n[c] : g = r ? n[0] : Cw(l, f), {
                p0: u,
                p1: l,
                p2: f,
                p3: g
            };
        }
        _getLineSegments(e, n, r = this.controlPoints, i = this.closed) {
            const a = this._getNumCurveSegments(r, i), o = this.resolution + 1, s = 1 / o, c = e;
            let l = c + 1;
            !i && e === a - 1 && (l -= cne);
            const f = [];
            let u, g, h = 0;
            for(let v = 0, m = c; v <= o; v++, m += s){
                m = m > l ? l : m;
                const y = this._getPoint(m, n, r, i);
                if (!v) {
                    u = y;
                    continue;
                }
                g = y;
                const C = g[0] - u[0], T = g[1] - u[1], x = Math.sqrt(C ** 2 + T ** 2), S = {
                    minX: u[0] <= g[0] ? u[0] : g[0],
                    maxX: u[0] >= g[0] ? u[0] : g[0],
                    minY: u[1] <= g[1] ? u[1] : g[1],
                    maxY: u[1] >= g[1] ? u[1] : g[1]
                };
                f.push({
                    points: {
                        start: u,
                        end: g
                    },
                    aabb: S,
                    length: x,
                    previousLineSegmentsLength: h
                }), u = g, h += x;
            }
            return f;
        }
        _getCurveSegment(e, n = this.getTransformMatrix(), r = this.controlPoints, i = this.closed) {
            const { p0: a, p1: o, p2: s, p3: c } = this._getCurveSegmentPoints(e, r, i), l = this._getLineSegments(e, n, r, i);
            let f = 0, u = 1 / 0, g = 1 / 0, h = -1 / 0, v = -1 / 0;
            return l.forEach(({ aabb: m, length: y })=>{
                u = Math.min(u, m.minX), g = Math.min(g, m.minY), h = Math.max(h, m.maxX), v = Math.max(v, m.maxY), f += y;
            }), {
                controlPoints: {
                    p0: a,
                    p1: o,
                    p2: s,
                    p3: c
                },
                aabb: {
                    minX: u,
                    minY: g,
                    maxX: h,
                    maxY: v
                },
                length: f,
                previousCurveSegmentsLength: 0,
                lineSegments: l
            };
        }
    }
    const lne = hx(xs(), N3(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);
    class une extends NO {
        getTransformMatrix() {
            return lne;
        }
    }
    class Sp extends NO {
        constructor(e){
            super(e), this._scale = e?.scale ?? .5, this._fixedScale = e?.fixedScale ?? !1;
        }
        get scale() {
            return this._scale;
        }
        set scale(e) {
            this._fixedScale || this._scale === e || (this._scale = e, this.invalidated = !0);
        }
        get fixedScale() {
            return this._fixedScale;
        }
        getTransformMatrix() {
            const { scale: e } = this, n = 2 * e;
            return [
                0,
                1,
                0,
                0,
                -e,
                0,
                e,
                0,
                n,
                e - 3,
                3 - n,
                -e,
                -e,
                2 - e,
                e - 2,
                e
            ];
        }
    }
    class fne extends Sp {
        constructor(){
            super({
                scale: .5,
                fixedScale: !0
            });
        }
    }
    class dne extends Sp {
        constructor(){
            super({
                resolution: 0,
                fixedResolution: !0,
                scale: 0,
                fixedScale: !0
            });
        }
    }
    class vy extends oc {
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ]
        }){
            super(e, n);
        }
        touchDragCallback(e) {
            this._dragCallback(e);
        }
        mouseDragCallback(e) {
            this._dragCallback(e);
        }
        _dragCallback(e) {
            const { element: n, deltaPoints: r } = e.detail, i = Fe(n), a = r.world;
            if (a[0] === 0 && a[1] === 0 && a[2] === 0) return;
            const o = i.viewport.getCamera(), { focalPoint: s, position: c } = o, l = [
                c[0] - a[0],
                c[1] - a[1],
                c[2] - a[2]
            ], f = [
                s[0] - a[0],
                s[1] - a[1],
                s[2] - a[2]
            ];
            i.viewport.setCamera({
                focalPoint: f,
                position: l
            }), i.viewport.render();
        }
    }
    vy.toolName = "Pan";
    const K5 = 4, gne = 1024, hne = "PT";
    class yy extends oc {
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ]
        }){
            super(e, n), this._getImageDynamicRangeFromMiddleSlice = (r, i)=>{
                const a = Math.floor(i[2] / 2), o = i[0] * i[1];
                let s, c;
                r instanceof Float32Array ? (s = 4, c = Float32Array) : r instanceof Uint8Array ? (s = 1, c = Uint8Array) : r instanceof Uint16Array ? (s = 2, c = Uint16Array) : r instanceof Int16Array && (s = 2, c = Int16Array);
                const l = r.buffer, f = a * o * s, u = new c(l, f, o), { max: g, min: h } = this._getMinMax(u, o);
                return g - h;
            };
        }
        touchDragCallback(e) {
            this.mouseDragCallback(e);
        }
        mouseDragCallback(e) {
            const { element: n, deltaPoints: r } = e.detail, i = Fe(n), { viewport: a } = i;
            let o, s, c, l, f, u, g = !1;
            const h = a.getProperties();
            if (a instanceof wi) {
                o = a.getVolumeId(), u = Gp(o), { lower: s, upper: c } = h.voiRange;
                const v = ot.getVolume(o);
                if (!v) throw new Error("Volume not found " + o);
                l = v.metadata.Modality, g = v.scaling && Object.keys(v.scaling).length > 0;
            } else if (h.voiRange) {
                l = a.modality, { lower: s, upper: c } = h.voiRange;
                const { preScale: v = {
                    scaled: !1
                } } = a.getImageData?.() || {};
                g = v.scaled && v.scalingParameters?.suvbw !== void 0;
            } else throw new Error("Viewport is not a valid type");
            if (l === hne && g ? f = this.getPTScaledNewRange({
                deltaPointsCanvas: r.canvas,
                lower: s,
                upper: c,
                clientHeight: n.clientHeight,
                isPreScaled: g,
                viewport: a,
                volumeId: o
            }) : f = this.getNewRange({
                viewport: a,
                deltaPointsCanvas: r.canvas,
                volumeId: o,
                lower: s,
                upper: c
            }), !(f.lower >= f.upper) && (a.setProperties({
                voiRange: f
            }), a.render(), a instanceof wi)) {
                u.forEach((v)=>{
                    a !== v && v.render();
                });
                return;
            }
        }
        getPTScaledNewRange({ deltaPointsCanvas: e, lower: n, upper: r, clientHeight: i, viewport: a, volumeId: o, isPreScaled: s }) {
            let c = K5;
            s ? c = 5 / i : c = this._getMultiplierFromDynamicRange(a, o) || K5;
            const f = e[1] * c;
            return r -= f, r = s ? Math.max(r, .1) : r, {
                lower: n,
                upper: r
            };
        }
        getNewRange({ viewport: e, deltaPointsCanvas: n, volumeId: r, lower: i, upper: a }) {
            const o = this._getMultiplierFromDynamicRange(e, r) || K5, s = n[0] * o, c = n[1] * o;
            let { windowWidth: l, windowCenter: f } = Zd(i, a);
            l += s, f += c, l = Math.max(l, 1);
            const u = e.getProperties().VOILUTFunction;
            return Fu(l, f, u);
        }
        _getMultiplierFromDynamicRange(e, n) {
            let r;
            if (n) {
                const a = ot.getVolume(n), { voxelManager: o } = e.getImageData(), c = o.getMiddleSliceData().reduce((u, g)=>[
                        Math.min(u[0], g),
                        Math.max(u[1], g)
                    ], [
                    1 / 0,
                    -1 / 0
                ]), l = a?.metadata?.BitsStored, f = l ? 2 ** l : 1 / 0;
                r = Math.min(c[1] - c[0], f);
            } else r = this._getImageDynamicRangeFromViewport(e);
            const i = r / gne;
            return i > 1 ? Math.round(i) : i;
        }
        _getImageDynamicRangeFromViewport(e) {
            const { imageData: n, voxelManager: r } = e.getImageData();
            if (r?.getRange) {
                const s = r.getRange();
                return s[1] - s[0];
            }
            const i = n.getDimensions();
            if (n.getRange) {
                const s = n.getRange();
                return s[1] - s[0];
            }
            let a;
            if (n.getScalarData ? a = n.getScalarData() : a = n.getPointData().getScalars().getData(), i[2] !== 1) return this._getImageDynamicRangeFromMiddleSlice(a, i);
            let o;
            if (a.getRange) o = a.getRange();
            else {
                const { min: s, max: c } = this._getMinMax(a, a.length);
                o = [
                    s,
                    c
                ];
            }
            return o[1] - o[0];
        }
        _getMinMax(e, n) {
            let r = 1 / 0, i = -1 / 0;
            for(let a = 0; a < n; a++){
                const o = e[a];
                o < r && (r = o), o > i && (i = o);
            }
            return {
                max: i,
                min: r
            };
        }
    }
    yy.toolName = "WindowLevel";
    class Cy extends oc {
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                invert: !1,
                debounceIfNotLoaded: !0,
                loop: !1
            }
        }){
            super(e, n), this.deltaY = 1;
        }
        mouseWheelCallback(e) {
            this._scroll(e);
        }
        mouseDragCallback(e) {
            this._dragCallback(e);
        }
        touchDragCallback(e) {
            this._dragCallback(e);
        }
        _dragCallback(e) {
            this._scrollDrag(e);
        }
        _scrollDrag(e) {
            const { deltaPoints: n, viewportId: r, renderingEngineId: i } = e.detail, { viewport: a } = gf(r, i), { debounceIfNotLoaded: o, invert: s, loop: c } = this.configuration, l = n.canvas[1];
            let f;
            a instanceof wi && (f = a.getVolumeId());
            const u = this._getPixelPerImage(a), g = l + this.deltaY;
            if (u) if (Math.abs(g) >= u) {
                const h = Math.round(g / u);
                dp(a, {
                    delta: s ? -h : h,
                    volumeId: f,
                    debounceLoading: o,
                    loop: c
                }), this.deltaY = g % u;
            } else this.deltaY = g;
        }
        _scroll(e) {
            const { wheel: n, element: r } = e.detail, { direction: i } = n, { invert: a } = this.configuration, { viewport: o } = Fe(r), s = i * (a ? -1 : 1);
            dp(o, {
                delta: s,
                debounceLoading: this.configuration.debounceIfNotLoaded,
                loop: this.configuration.loop,
                volumeId: o instanceof So ? o.getVolumeId() : void 0,
                scrollSlabs: this.configuration.scrollSlabs
            });
        }
        _getPixelPerImage(e) {
            const { element: n } = e, r = e.getNumberOfSlices();
            return Math.max(2, n.offsetHeight / Math.max(r, 8));
        }
    }
    Cy.toolName = "StackScroll";
    class wy extends oc {
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                zoomToCenter: !1,
                minZoomScale: .001,
                maxZoomScale: 3e3,
                pinchToZoom: !0,
                pan: !0,
                invert: !1
            }
        }){
            super(e, n), this.preMouseDownCallback = (r)=>{
                const i = r.detail, { element: a, currentPoints: o } = i, s = o.world, l = Fe(a).viewport.getCamera(), { focalPoint: f } = l;
                this.initialMousePosWorld = s;
                let u = en(f[0] - s[0], f[1] - s[1], f[2] - s[2]);
                return u = jn(Xe(), u), this.dirVec = u, !1;
            }, this.preTouchStartCallback = (r)=>{
                if (!this.configuration.pinchToZoom) return this.preMouseDownCallback(r);
            }, this._dragParallelProjection = (r, i, a, o = !1)=>{
                const { element: s, deltaPoints: c } = r.detail, l = o ? r.detail.deltaDistance.canvas : c.canvas[1], f = [
                    s.clientWidth,
                    s.clientHeight
                ], { parallelScale: u, focalPoint: g, position: h } = a, v = 5 / f[1], m = l * v * (this.configuration.invert ? -1 : 1), y = (1 - m) * u;
                let C = g, T = h;
                if (!this.configuration.zoomToCenter) {
                    const M = rc(g, this.initialMousePosWorld);
                    T = $i(Xe(), h, this.dirVec, -M * m), C = $i(Xe(), g, this.dirVec, -M * m);
                }
                const x = i.getImageData();
                let S = [
                    1,
                    1,
                    1
                ], D = y, _ = !1;
                if (x) {
                    S = x.spacing;
                    const { dimensions: M } = x, P = M[0] * S[0], F = M[1] * S[1], N = f[0] / f[1], B = i.options?.displayArea, G = B?.imageArea?.[0] ?? 1.1, Z = B?.imageArea?.[1] ?? 1.1, H = P * G, ne = F * Z, ae = H / ne;
                    let ue;
                    ae > N ? ue = H / N * .5 : ue = ne * .5;
                    const { minZoomScale: le, maxZoomScale: oe } = this.configuration, re = ue / oe, X = ue / le;
                    y < re ? (D = re, _ = !0) : y > X && (D = X, _ = !0);
                }
                i.setCamera({
                    parallelScale: D,
                    focalPoint: _ ? g : C,
                    position: _ ? h : T
                });
            }, this._dragPerspectiveProjection = (r, i, a, o = !1)=>{
                const { element: s, deltaPoints: c } = r.detail, l = o ? r.detail.deltaDistance.canvas : c.canvas[1], f = [
                    s.clientWidth,
                    s.clientHeight
                ], { position: u, focalPoint: g, viewPlaneNormal: h } = a, v = Xo.distance2BetweenPoints(u, g), m = Math.sqrt(v) / f[1], y = [
                    -h[0],
                    -h[1],
                    -h[2]
                ], C = this.configuration.invert ? l / m : l * m;
                let T = C * y[0];
                u[0] += T, g[0] += T, T = C * y[1], u[1] += T, g[1] += T, T = C * y[2], u[2] += T, g[2] += T, i.setCamera({
                    position: u,
                    focalPoint: g
                });
            }, this.initialMousePosWorld = [
                0,
                0,
                0
            ], this.dirVec = [
                0,
                0,
                0
            ], this.configuration.pinchToZoom ? this.touchDragCallback = this._pinchCallback.bind(this) : this.touchDragCallback = this._dragCallback.bind(this), this.mouseDragCallback = this._dragCallback.bind(this);
        }
        mouseWheelCallback(e) {
            this._zoom(e);
        }
        _pinchCallback(e) {
            if (e.detail.currentPointsList.length > 1) {
                const { element: r, currentPoints: i } = e.detail, a = Fe(r), { viewport: o } = a, s = o.getCamera(), c = i.world, { focalPoint: l } = s;
                this.initialMousePosWorld = c;
                let f = en(l[0] - c[0], l[1] - c[1], l[2] - c[2]);
                f = jn(Xe(), f), this.dirVec = f, s.parallelProjection ? this._dragParallelProjection(e, o, s, !0) : this._dragPerspectiveProjection(e, o, s, !0), o.render();
            }
            this.configuration.pan && this._panCallback(e);
        }
        _dragCallback(e) {
            const { element: n } = e.detail, r = Fe(n), { viewport: i } = r, a = i.getCamera();
            a.parallelProjection ? this._dragParallelProjection(e, i, a) : this._dragPerspectiveProjection(e, i, a), i.render();
        }
        _zoom(e) {
            const { element: n, points: r } = e.detail, i = Fe(n), { viewport: a } = i;
            a.getCamera();
            const s = e.detail.wheel.direction, c = {
                detail: {
                    element: n,
                    eventName: z.MOUSE_WHEEL,
                    renderingEngineId: i.renderingEngineId,
                    viewportId: a.id,
                    camera: {},
                    deltaPoints: {
                        page: r.page,
                        client: r.client,
                        world: r.world,
                        canvas: [
                            0,
                            -s * 5
                        ]
                    },
                    startPoints: r,
                    lastPoints: r,
                    currentPoints: r
                }
            };
            a.type === On.STACK && this.preMouseDownCallback(c), this._dragCallback(c);
        }
        _panCallback(e) {
            const { element: n, deltaPoints: r } = e.detail, i = Fe(n), a = r.world, o = i.viewport.getCamera(), { focalPoint: s, position: c } = o, l = [
                c[0] - a[0],
                c[1] - a[1],
                c[2] - a[2]
            ], f = [
                s[0] - a[0],
                s[1] - a[1],
                s[2] - a[2]
            ];
            i.viewport.setCamera({
                focalPoint: f,
                position: l
            }), i.viewport.render();
        }
    }
    wy.toolName = "Zoom";
    const z1 = "magnify-viewport";
    class Ty extends oc {
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                magnifySize: 10,
                magnifyWidth: 250,
                magnifyHeight: 250
            }
        }){
            super(e, n), this._hasBeenRemoved = !1, this.preMouseDownCallback = (r)=>{
                const i = r.detail, { element: a, currentPoints: o } = i, s = Fe(a), { viewport: c, renderingEngine: l } = s;
                if (!(c instanceof ua)) throw new Error("MagnifyTool only works on StackViewports");
                const f = this._getReferencedImageId(c);
                if (!f) throw new Error("MagnifyTool: No referenced image id found, reconstructed planes not supported yet");
                const u = rn(a, this.getToolName());
                return this.editData = {
                    referencedImageId: f,
                    viewportIdsToRender: u,
                    enabledElement: s,
                    renderingEngine: l,
                    currentPoints: o
                }, this._createMagnificationViewport(), this._activateDraw(a), Mn(a), r.preventDefault(), it(u), !0;
            }, this.preTouchStartCallback = (r)=>{
                this.preMouseDownCallback(r);
            }, this._createMagnificationViewport = ()=>{
                const { enabledElement: r, referencedImageId: i, viewportIdsToRender: a, renderingEngine: o, currentPoints: s } = this.editData, { viewport: c } = r, { element: l } = c, f = c.getProperties(), { rotation: u } = c.getViewPresentation(), { canvas: g, world: h } = s;
                let v;
                if (v = l.querySelector(".magnifyTool"), v === null) {
                    const y = document.createElement("div");
                    y.classList.add("magnifyTool"), y.style.display = "block", y.style.width = `${this.configuration.magnifyWidth}px`, y.style.height = `${this.configuration.magnifyHeight}px`, y.style.position = "absolute", v = y, l.querySelector(".viewport-element").appendChild(y);
                    const T = {
                        viewportId: z1,
                        type: On.STACK,
                        element: v
                    };
                    o.enableElement(T);
                }
                v.style.top = `${g[1] - this.configuration.magnifyHeight / 2}px`, v.style.left = `${g[0] - this.configuration.magnifyWidth / 2}px`;
                const m = o.getViewport(z1);
                m.setStack([
                    i
                ]).then(()=>{
                    if (this._hasBeenRemoved) return;
                    m.setProperties(f), m.setViewPresentation({
                        rotation: u
                    });
                    const { parallelScale: y } = c.getCamera(), { focalPoint: C, position: T, viewPlaneNormal: x } = m.getCamera(), S = Math.sqrt(Math.pow(C[0] - T[0], 2) + Math.pow(C[1] - T[1], 2) + Math.pow(C[2] - T[2], 2)), D = [
                        h[0],
                        h[1],
                        h[2]
                    ], _ = [
                        D[0] + S * x[0],
                        D[1] + S * x[1],
                        D[2] + S * x[2]
                    ];
                    m.setCamera({
                        parallelScale: y * (1 / this.configuration.magnifySize),
                        focalPoint: D,
                        position: _
                    }), m.render();
                }), v.style.display = "block", it(a);
            }, this._dragCallback = (r)=>{
                const i = r.detail, { deltaPoints: a, element: o, currentPoints: s } = i, c = a.world, l = s.canvas, f = Fe(o), { renderingEngine: u } = f, g = u.getViewport(z1), h = o.querySelector(".magnifyTool");
                if (!h) return;
                h.style.top = `${l[1] - this.configuration.magnifyHeight / 2}px`, h.style.left = `${l[0] - this.configuration.magnifyWidth / 2}px`;
                const { focalPoint: v, position: m } = g.getCamera(), y = [
                    m[0] + c[0],
                    m[1] + c[1],
                    m[2] + c[2]
                ], C = [
                    v[0] + c[0],
                    v[1] + c[1],
                    v[2] + c[2]
                ];
                g.setCamera({
                    focalPoint: C,
                    position: y
                }), g.render();
            }, this._dragEndCallback = (r)=>{
                const { element: i } = r.detail, a = Fe(i), { renderingEngine: o } = a;
                o.disableElement(z1);
                const s = i.querySelector(".viewport-element"), c = s.querySelector(".magnifyTool");
                s.removeChild(c), this._deactivateDraw(i), fr(i), this._hasBeenRemoved = !0;
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, this._hasBeenRemoved = !1, r.addEventListener(z.MOUSE_UP, this._dragEndCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._dragEndCallback), r.addEventListener(z.TOUCH_END, this._dragEndCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._dragEndCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._dragEndCallback), r.removeEventListener(z.TOUCH_END, this._dragEndCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback);
            };
        }
        _getReferencedImageId(e) {
            const n = this.getTargetId(e);
            let r;
            return e instanceof ua && (r = n.split("imageId:")[1]), r;
        }
    }
    Ty.toolName = "Magnify";
    const { transformWorldToIndex: n7 } = ga;
    class d2 extends ji {
        static{
            this.toolName = "Length";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                preventHandleOutsideImage: !1,
                getTextLines: pne,
                actions: {
                    undo: {
                        method: "undo",
                        bindings: [
                            {
                                key: "z"
                            }
                        ]
                    },
                    redo: {
                        method: "redo",
                        bindings: [
                            {
                                key: "y"
                            }
                        ]
                    }
                }
            }
        }){
            super(e, n), this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l } = c;
                Mn(o), this.isDrawing = !0;
                const { viewPlaneNormal: f, viewUp: u, position: g } = l.getCamera(), h = this.getReferencedImageId(l, s, f, u), v = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        }),
                        toolName: this.getToolName(),
                        referencedImageId: h,
                        viewUp: u,
                        cameraPosition: g
                    },
                    data: {
                        handles: {
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            activeHandleIndex: null,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        label: "",
                        cachedStats: {}
                    }
                };
                nr(v, o);
                const m = rn(o, this.getToolName());
                return this.editData = {
                    annotation: v,
                    viewportIdsToRender: m,
                    handleIndex: 1,
                    movingTextBox: !1,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), r.preventDefault(), it(m), v;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, [f, u] = l.handles.points, g = c.worldToCanvas(f), h = c.worldToCanvas(u), v = {
                    start: {
                        x: g[0],
                        y: g[1]
                    },
                    end: {
                        x: h[0],
                        y: h[1]
                    }
                };
                return Cs([
                    v.start.x,
                    v.start.y
                ], [
                    v.end.x,
                    v.end.y
                ], [
                    a[0],
                    a[1]
                ]) <= o;
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o), Mn(o), it(s), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                c && !l || (f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a), this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), this.doneEditMemo(), c && Ti(o), this.editData = null, this.isDrawing = !1);
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData, { data: u } = o;
                if (this.createMemo(a, o, {
                    newAnnotation: f
                }), l) {
                    const { deltaPoints: g } = i, h = g.world, { textBox: v } = u.handles, { worldPosition: m } = v;
                    m[0] += h[0], m[1] += h[1], m[2] += h[2], v.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: g } = i, h = g.world;
                    u.handles.points.forEach((m)=>{
                        m[0] += h[0], m[1] += h[1], m[2] += h[2];
                    }), o.invalidated = !0;
                } else {
                    const { currentPoints: g } = i, h = g.world;
                    u.handles.points[c] = [
                        ...h
                    ], o.invalidated = !0;
                }
                this.editData.hasMoved = !0, it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_MOVE, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { points: y, activeHandleIndex: C } = m.handles;
                    u.annotationUID = v;
                    const { color: T, lineWidth: x, lineDash: S, shadow: D } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), _ = y.map((oe)=>o.worldToCanvas(oe));
                    if (!m.cachedStats[l] || m.cachedStats[l].unit == null ? (m.cachedStats[l] = {
                        length: null,
                        unit: null
                    }, this._calculateCachedStats(h, f, r)) : h.invalidated && this._throttledCalculateCachedStats(h, f, r), !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    let M;
                    if (!Eo(v)) continue;
                    !Ja(v) && !this.editData && C !== null && (M = [
                        _[C]
                    ]), M && Do(i, v, "0", _, {
                        color: T,
                        lineDash: S,
                        lineWidth: x
                    });
                    const P = `${v}-line`;
                    if (Oa(i, v, "1", _[0], _[1], {
                        color: T,
                        width: x,
                        lineDash: S,
                        shadow: D
                    }, P), a = !0, !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    const N = this.getLinkedTextBoxStyle(u, h);
                    if (!N.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const B = this.configuration.getTextLines(m, l);
                    if (!m.handles.textBox.hasMoved) {
                        const oe = Jl(_);
                        m.handles.textBox.worldPosition = o.canvasToWorld(oe);
                    }
                    const G = o.worldToCanvas(m.handles.textBox.worldPosition), H = fc(i, v, "1", B, G, _, {}, N), { x: ne, y: ae, width: ue, height: le } = H;
                    m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            ne,
                            ae
                        ]),
                        topRight: o.canvasToWorld([
                            ne + ue,
                            ae
                        ]),
                        bottomLeft: o.canvasToWorld([
                            ne,
                            ae + le
                        ]),
                        bottomRight: o.canvasToWorld([
                            ne + ue,
                            ae + le
                        ])
                    };
                }
                return a;
            }, this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(d2, i, n, r), { toolInstance: f, ...u } = r || {}, g = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n
                        }
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...u
                    }
                };
                nr(g, l.element), it([
                    l.id
                ]);
            };
        }
        handleSelectedCallback(e, n, r) {
            const i = e.detail, { element: a } = i, { data: o } = n;
            n.highlighted = !0;
            let s = !1, c;
            r.worldPosition ? s = !0 : c = o.handles.points.findIndex((f)=>f === r);
            const l = rn(a, this.getToolName());
            this.editData = {
                annotation: n,
                viewportIdsToRender: l,
                handleIndex: c,
                movingTextBox: s
            }, this._activateModify(a), Mn(a), it(l), e.preventDefault();
        }
        _calculateLength(e, n) {
            const r = e[0] - n[0], i = e[1] - n[1], a = e[2] - n[2];
            return Math.sqrt(r * r + i * i + a * a);
        }
        _calculateCachedStats(e, n, r) {
            const i = e.data, { element: a } = r.viewport, o = i.handles.points[0], s = i.handles.points[1], { cachedStats: c } = i, l = Object.keys(c);
            for(let u = 0; u < l.length; u++){
                const g = l[u], h = this.getTargetImageData(g);
                if (!h) continue;
                const { imageData: v, dimensions: m } = h, y = n7(v, o), C = n7(v, s), T = [
                    y,
                    C
                ], { scale: x, unit: S } = ql(h, T), D = this._calculateLength(o, s) / x;
                this._isInsideVolume(y, C, m) ? this.isHandleOutsideImage = !1 : this.isHandleOutsideImage = !0, c[g] = {
                    length: D,
                    unit: S
                };
            }
            const f = e.invalidated;
            return e.invalidated = !1, f && yn(e, a, Jt.StatsUpdated), c;
        }
        _isInsideVolume(e, n, r) {
            return Mi(e, r) && Mi(n, r);
        }
    }
    function pne(t, e) {
        const n = t.cachedStats[e], { length: r, unit: i } = n;
        return r == null || isNaN(r) ? void 0 : [
            `${Rn(r)} ${i}`
        ];
    }
    const { transformWorldToIndex: mne } = ga;
    class Bd extends ji {
        static{
            this.toolName = "Probe";
        }
        static{
            this.probeDefaults = {
                supportedInteractionTypes: [
                    "Mouse",
                    "Touch"
                ],
                configuration: {
                    shadow: !0,
                    preventHandleOutsideImage: !1,
                    getTextLines: vne,
                    handleRadius: "6",
                    textCanvasOffset: {
                        x: 6,
                        y: -6
                    }
                }
            };
        }
        constructor(e = {}, n){
            super(e, ji.mergeDefaultProps(Bd.probeDefaults, n)), this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l } = c;
                this.isDrawing = !0;
                const f = this.constructor.createAnnotationForViewport(l, {
                    data: {
                        handles: {
                            points: [
                                [
                                    ...s
                                ]
                            ]
                        }
                    }
                });
                nr(f, o);
                const u = rn(o, this.getToolName());
                return this.editData = {
                    annotation: f,
                    newAnnotation: !0,
                    viewportIdsToRender: u
                }, this._activateModify(o), Mn(o), r.preventDefault(), it(u), f;
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c } = this.editData, { viewportId: l, renderingEngine: f } = Fe(a);
                this.eventDispatchDetail = {
                    viewportId: l,
                    renderingEngineId: f.id
                }, this._deactivateModify(a), fr(a), c && this.createMemo(a, o, {
                    newAnnotation: c
                }), this.editData = null, this.isDrawing = !1, this.doneEditMemo(), this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o);
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, { annotation: c, viewportIdsToRender: l, newAnnotation: f } = this.editData, { data: u } = c;
                this.createMemo(o, c, {
                    newAnnotation: f
                }), u.handles.points[0] = [
                    ...s
                ], c.invalidated = !0, it(l);
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], v = h.annotationUID, m = h.data, y = m.handles.points[0], C = o.worldToCanvas(y);
                    u.annotationUID = v;
                    const { color: T, lineWidth: x } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    });
                    if (m.cachedStats || (m.cachedStats = {}), !m.cachedStats[l] || m.cachedStats[l].value === null) m.cachedStats[l] = {
                        Modality: null,
                        index: null,
                        value: null
                    }, this._calculateCachedStats(h, f, r, Jt.StatsUpdated);
                    else if (h.invalidated && (this._calculateCachedStats(h, f, r), o instanceof wi)) {
                        const { referencedImageId: M } = h.metadata;
                        for(const P in m.cachedStats)P.startsWith("imageId") && f.getStackViewports().find((B)=>{
                            const G = ur(M), Z = B.hasImageURI(G), H = ur(B.getCurrentImageId());
                            return Z && H !== G;
                        }) && delete m.cachedStats[P];
                    }
                    if (!o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    if (!Eo(v)) continue;
                    Do(i, v, "0", [
                        C
                    ], {
                        color: T,
                        lineWidth: x,
                        handleRadius: this.configuration.handleRadius
                    }), a = !0;
                    const D = this.getLinkedTextBoxStyle(u, h);
                    if (!D.visibility) continue;
                    const _ = this.configuration.getTextLines(m, l);
                    if (_) {
                        const M = [
                            C[0] + this.configuration.textCanvasOffset.x,
                            C[1] + this.configuration.textCanvasOffset.y
                        ];
                        yp(i, v, "0", _, [
                            M[0],
                            M[1]
                        ], D);
                    }
                }
                return a;
            };
        }
        isPointNearTool(e, n, r, i) {
            const a = Fe(e), { viewport: o } = a, { data: s } = n, c = s.handles.points[0], l = o.worldToCanvas(c);
            return Or(r, l) < i;
        }
        toolSelectedCallback() {}
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, viewUp: c, instance: l, viewport: f } = this.hydrateBase(Bd, i, n, r), { toolInstance: u, ...g } = r || {}, h = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n
                        }
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: l.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...g
                    }
                };
                nr(h, f.element), it([
                    f.id
                ]);
            };
        }
        getHandleNearImagePoint(e, n, r, i) {
            const a = Fe(e), { viewport: o } = a, { data: s } = n, c = s.handles.points[0], l = o.worldToCanvas(c);
            if (Or(r, l) < i === !0) return c;
        }
        handleSelectedCallback(e, n) {
            const r = e.detail, { element: i } = r;
            n.highlighted = !0;
            const a = rn(i, this.getToolName());
            this.editData = {
                annotation: n,
                viewportIdsToRender: a
            }, this._activateModify(i), Mn(i), it(a), e.preventDefault();
        }
        _calculateCachedStats(e, n, r, i = Jt.StatsUpdated) {
            const a = e.data, { renderingEngineId: o, viewport: s } = r, { element: c } = s, l = a.handles.points[0], { cachedStats: f } = a, u = Object.keys(f);
            for(let h = 0; h < u.length; h++){
                const v = u[h], m = {
                    isPreScaled: dg(s, v),
                    isSuvScaled: this.isSuvScaled(s, v, e.metadata.referencedImageId)
                }, y = this.getTargetImageData(v);
                if (!y) continue;
                const { dimensions: C, imageData: T, metadata: x, voxelManager: S } = y, D = x.Modality;
                let _ = mne(T, l);
                if (_ = zV(_, _), Mi(_, C)) {
                    this.isHandleOutsideImage = !1;
                    let M = S.getAtIJKPoint(_);
                    if (v.startsWith("imageId:")) {
                        const F = v.split("imageId:")[1], N = ur(F), G = up(N)[0];
                        _[2] = G.getCurrentImageIdIndex();
                    }
                    let P;
                    if (D === "US") {
                        const F = $J(y, [
                            _
                        ]), N = F.values.every((B)=>B !== null);
                        M = N ? F.values : M, P = N ? F.units : "raw";
                    } else P = gg(D, e.metadata.referencedImageId, m);
                    f[v] = {
                        index: _,
                        value: M,
                        Modality: D,
                        modalityUnit: P
                    };
                } else this.isHandleOutsideImage = !0, f[v] = {
                    index: _,
                    Modality: D
                };
            }
            const g = e.invalidated;
            return e.invalidated = !1, g && yn(e, c, i), f;
        }
    }
    function vne(t, e) {
        const n = t.cachedStats[e], { index: r, value: i, modalityUnit: a } = n;
        if (i === void 0 || !r) return;
        const o = [];
        if (o.push(`(${r[0]}, ${r[1]}, ${r[2]})`), i instanceof Array && a instanceof Array) for(let s = 0; s < i.length; s++)o.push(`${Rn(i[s])} ${a[s]}`);
        else o.push(`${Rn(i)} ${a}`);
        return o;
    }
    const { transformWorldToIndex: r7 } = ga;
    class g2 extends ji {
        static{
            this.toolName = "EllipticalROI";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                shadow: !0,
                preventHandleOutsideImage: !1,
                storePointData: !1,
                centerPointRadius: 0,
                calculateStats: !0,
                getTextLines: yne,
                statsCalculator: n2
            }
        }){
            super(e, n), this.isHandleOutsideImage = !1, this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world;
                a.canvas;
                const c = Fe(o), { viewport: l, renderingEngine: f } = c;
                this.isDrawing = !0;
                const u = l.getCamera(), { viewPlaneNormal: g, viewUp: h } = u, v = this.getReferencedImageId(l, s, g, h), m = l.getFrameOfReferenceUID(), y = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [
                            ...g
                        ],
                        viewUp: [
                            ...h
                        ],
                        FrameOfReferenceUID: m,
                        referencedImageId: v,
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        })
                    },
                    data: {
                        label: "",
                        handles: {
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            },
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            activeHandleIndex: null
                        },
                        cachedStats: {},
                        initialRotation: l.getRotation()
                    }
                };
                nr(y, o);
                const C = rn(o, this.getToolName());
                return this.editData = {
                    annotation: y,
                    viewportIdsToRender: C,
                    centerWorld: s,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), Mn(o), r.preventDefault(), it(C), y;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, { points: f } = l.handles, u = f.map((P)=>c.worldToCanvas(P)), [g, h, v, m] = u, y = Math.hypot(v[0] - m[0], v[1] - m[1]), C = Math.hypot(h[0] - g[0], h[1] - g[1]), T = Math.atan2(v[1] - m[1], v[0] - m[0]), x = [
                    (v[0] + m[0]) / 2,
                    (h[1] + g[1]) / 2
                ], S = {
                    center: x,
                    xRadius: (y - o) / 2,
                    yRadius: (C - o) / 2,
                    angle: T
                }, D = {
                    center: x,
                    xRadius: (y + o) / 2,
                    yRadius: (C + o) / 2,
                    angle: T
                }, _ = this._pointInEllipseCanvas(S, a);
                return !!(this._pointInEllipseCanvas(D, a) && !_);
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, Mn(o), this._activateModify(o);
                const c = Fe(o), { renderingEngine: l } = c;
                it(s), r.preventDefault();
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, { data: c } = i;
                i.highlighted = !0;
                let l = !1, f, u, g, h, v, m;
                if (a.worldPosition) l = !0;
                else {
                    const { points: C } = c.handles, { viewport: T } = Fe(s), { worldToCanvas: x, canvasToWorld: S } = T;
                    f = C.findIndex((_)=>_ === a);
                    const D = C.map(x);
                    m = D[f], h = Math.abs(D[2][0] - D[3][0]), v = Math.abs(D[0][1] - D[1][1]), u = [
                        (D[2][0] + D[3][0]) / 2,
                        (D[0][1] + D[1][1]) / 2
                    ], g = S(u);
                }
                const y = rn(s, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: y,
                    handleIndex: f,
                    canvasWidth: h,
                    canvasHeight: v,
                    centerWorld: g,
                    originalHandleCanvas: m,
                    movingTextBox: l
                }, this._activateModify(s), Mn(s), it(y), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                c && !l || (this.doneEditMemo(), o.highlighted = !1, f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a), this.editData = null, this.isDrawing = !1, this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o));
            }, this._dragDrawCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { currentPoints: o } = i, s = o.canvas, c = Fe(a), { viewport: l } = c, { canvasToWorld: f } = l, { annotation: u, viewportIdsToRender: g, centerWorld: h, newAnnotation: v } = this.editData;
                this.createMemo(a, u, {
                    newAnnotation: v
                });
                const m = l.worldToCanvas(h), { data: y } = u, C = Math.abs(s[0] - m[0]), T = Math.abs(s[1] - m[1]), x = [
                    m[0],
                    m[1] - T
                ], S = [
                    m[0],
                    m[1] + T
                ], D = [
                    m[0] - C,
                    m[1]
                ], _ = [
                    m[0] + C,
                    m[1]
                ];
                y.handles.points = [
                    f(x),
                    f(S),
                    f(D),
                    f(_)
                ], u.invalidated = !0, this.editData.hasMoved = !0, it(g), yn(u, a, Jt.HandlesUpdated);
            }, this._dragModifyCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: f
                });
                const { data: u } = o;
                if (l) {
                    const { deltaPoints: v } = i, m = v.world, { textBox: y } = u.handles, { worldPosition: C } = y;
                    C[0] += m[0], C[1] += m[1], C[2] += m[2], y.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: v } = i, m = v.world;
                    u.handles.points.forEach((C)=>{
                        C[0] += m[0], C[1] += m[1], C[2] += m[2];
                    }), o.invalidated = !0;
                } else this._dragHandle(r), o.invalidated = !0;
                const g = Fe(a), { renderingEngine: h } = g;
                it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this._dragHandle = (r)=>{
                const i = r.detail, { element: a } = i, { viewport: o } = Fe(a), { canvasToWorld: s, worldToCanvas: c } = o, { annotation: l, canvasWidth: f, canvasHeight: u, handleIndex: g, centerWorld: h, originalHandleCanvas: v } = this.editData, m = o.worldToCanvas(h), { data: y } = l, { points: C } = y.handles, { currentPoints: T } = i, x = T.canvas;
                if (g === 0 || g === 1) {
                    const S = Math.abs(x[1] - m[1]), D = [
                        m[0],
                        m[1] - S
                    ], _ = [
                        m[0],
                        m[1] + S
                    ];
                    C[0] = s(D), C[1] = s(_);
                    const M = x[0] - v[0], P = f / 2 + M, F = [
                        m[0] - P,
                        m[1]
                    ], N = [
                        m[0] + P,
                        m[1]
                    ];
                    C[2] = s(F), C[3] = s(N);
                } else {
                    const S = Math.abs(x[0] - m[0]), D = [
                        m[0] - S,
                        m[1]
                    ], _ = [
                        m[0] + S,
                        m[1]
                    ];
                    C[2] = s(D), C[3] = s(_);
                    const M = x[1] - v[1], P = u / 2 + M, F = [
                        m[0],
                        m[1] - P
                    ], N = [
                        m[0],
                        m[1] + P
                    ];
                    C[0] = s(F), C[1] = s(N);
                }
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.addEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragDrawCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragDrawCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { handles: y } = m, { points: C, activeHandleIndex: T } = y;
                    u.annotationUID = v;
                    const { color: x, lineWidth: S, lineDash: D } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), _ = C.map((ie)=>o.worldToCanvas(ie)), M = Tw(_), { centerPointRadius: P } = this.configuration;
                    if (!m.cachedStats[l] || m.cachedStats[l].areaUnit == null) m.cachedStats[l] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null
                    }, this._calculateCachedStats(h, o, f);
                    else if (h.invalidated && (this._throttledCalculateCachedStats(h, o, f, r), o instanceof wi)) {
                        const { referencedImageId: ie } = h.metadata;
                        for(const he in m.cachedStats)he.startsWith("imageId") && f.getStackViewports().find((He)=>{
                            const rt = ur(ie), Qe = He.hasImageURI(rt), et = ur(He.getCurrentImageId());
                            return Qe && et !== rt;
                        }) && delete m.cachedStats[he];
                    }
                    if (!o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    let F;
                    if (!Eo(v)) continue;
                    !Ja(v) && !this.editData && T !== null && (F = [
                        _[T]
                    ]), F && Do(i, v, "0", F, {
                        color: x
                    });
                    const N = `${v}-ellipse`, B = "0";
                    if (IZ(i, v, B, _, {
                        color: x,
                        lineDash: D,
                        lineWidth: S
                    }, N), P > 0 && Math.min(Math.abs(M[0][0] - M[1][0]) / 2, Math.abs(M[0][1] - M[1][1]) / 2) > 3 * P) {
                        const he = this._getCanvasEllipseCenter(_);
                        n3(i, v, `${B}-center`, he, P, {
                            color: x,
                            lineDash: D,
                            lineWidth: S
                        });
                    }
                    a = !0;
                    const G = this.getLinkedTextBoxStyle(u, h);
                    if (!G.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const Z = this.configuration.getTextLines(m, l);
                    if (!Z || Z.length === 0) continue;
                    let H;
                    m.handles.textBox.hasMoved || (H = Jl(M), m.handles.textBox.worldPosition = o.canvasToWorld(H));
                    const ne = o.worldToCanvas(m.handles.textBox.worldPosition), ue = fc(i, v, "1", Z, ne, _, {}, G), { x: le, y: oe, width: re, height: X } = ue;
                    m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            le,
                            oe
                        ]),
                        topRight: o.canvasToWorld([
                            le + re,
                            oe
                        ]),
                        bottomLeft: o.canvasToWorld([
                            le,
                            oe + X
                        ]),
                        bottomRight: o.canvasToWorld([
                            le + re,
                            oe + X
                        ])
                    };
                }
                return a;
            }, this._calculateCachedStats = (r, i, a)=>{
                if (!this.configuration.calculateStats) return;
                const o = r.data, { element: s } = i, { points: c } = o.handles, l = c.map((D)=>i.worldToCanvas(D)), { viewPlaneNormal: f, viewUp: u } = i.getCamera(), [g, h] = Tw(l), v = i.canvasToWorld(g), m = i.canvasToWorld(h), { cachedStats: y } = o, C = Object.keys(y), T = v, x = m;
                for(let D = 0; D < C.length; D++){
                    const _ = C[D], M = this.getTargetImageData(_);
                    if (!M) continue;
                    const { dimensions: P, imageData: F, metadata: N, voxelManager: B } = M, G = r7(F, T);
                    G[0] = Math.floor(G[0]), G[1] = Math.floor(G[1]), G[2] = Math.floor(G[2]);
                    const Z = r7(F, x);
                    Z[0] = Math.floor(Z[0]), Z[1] = Math.floor(Z[1]), Z[2] = Math.floor(Z[2]), this.isHandleOutsideImage = !this._isInsideVolume(G, Z, P);
                    const H = Math.min(G[0], Z[0]), ne = Math.max(G[0], Z[0]), ae = Math.min(G[1], Z[1]), ue = Math.max(G[1], Z[1]), le = Math.min(G[2], Z[2]), oe = Math.max(G[2], Z[2]), re = [
                        [
                            H,
                            ne
                        ],
                        [
                            ae,
                            ue
                        ],
                        [
                            le,
                            oe
                        ]
                    ], ie = {
                        center: [
                            (v[0] + m[0]) / 2,
                            (v[1] + m[1]) / 2,
                            (v[2] + m[2]) / 2
                        ],
                        xRadius: Math.abs(v[0] - m[0]) / 2,
                        yRadius: Math.abs(v[1] - m[1]) / 2,
                        zRadius: Math.abs(v[2] - m[2]) / 2
                    }, { worldWidth: he, worldHeight: $e } = GR(f, u, T, x), je = he === 0 && $e === 0, He = [
                        G,
                        Z
                    ], { scale: rt, areaUnit: Qe } = ql(M, He), et = Math.abs(Math.PI * (he / 2) * ($e / 2)) / rt / rt, St = {
                        isPreScaled: dg(i, _),
                        isSuvScaled: this.isSuvScaled(i, _, r.metadata.referencedImageId)
                    }, Ln = gg(N.Modality, r.metadata.referencedImageId, St);
                    let Nn;
                    B && B.forEach(this.configuration.statsCalculator.statsCallback, {
                        boundsIJK: re,
                        imageData: F,
                        isInObject: (Pe)=>ER(ie, Pe, {
                                fast: !0
                            }),
                        returnPoints: this.configuration.storePointData
                    });
                    const zt = this.configuration.statsCalculator.getStatistics();
                    y[_] = {
                        Modality: N.Modality,
                        area: et,
                        mean: zt.mean?.value,
                        max: zt.max?.value,
                        min: zt.min?.value,
                        stdDev: zt.stdDev?.value,
                        statsArray: zt.array,
                        pointsInShape: Nn,
                        isEmptyArea: je,
                        areaUnit: Qe,
                        modalityUnit: Ln
                    };
                }
                const S = r.invalidated;
                return r.invalidated = !1, S && yn(r, s, Jt.StatsUpdated), y;
            }, this._isInsideVolume = (r, i, a)=>Mi(r, a) && Mi(i, a), this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(g2, i, n, r), { toolInstance: f, ...u } = r || {}, g = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n,
                            activeHandleIndex: null
                        },
                        label: "",
                        cachedStats: {}
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...u
                    }
                };
                nr(g, l.element), it([
                    l.id
                ]);
            };
        }
        _pointInEllipseCanvas(e, n) {
            const { xRadius: r, yRadius: i, center: a, angle: o } = e, s = ZV(sn(), n, a, -o);
            if (r <= 0 || i <= 0) return !1;
            const c = [
                s[0] - a[0],
                s[1] - a[1]
            ];
            return c[0] * c[0] / (r * r) + c[1] * c[1] / (i * i) <= 1;
        }
        _getCanvasEllipseCenter(e) {
            const [n, r, i, a] = e, o = [
                i[0],
                r[1]
            ], s = [
                a[0],
                n[1]
            ];
            return [
                (o[0] + s[0]) / 2,
                (o[1] + s[1]) / 2
            ];
        }
    }
    function yne(t, e) {
        const n = t.cachedStats[e], { area: r, mean: i, stdDev: a, max: o, isEmptyArea: s, areaUnit: c, modalityUnit: l, min: f } = n, u = [];
        if (cr(r)) {
            const g = s ? "Area: Oblique not supported" : `Area: ${Rn(r)} ${c}`;
            u.push(g);
        }
        return cr(i) && u.push(`Mean: ${Rn(i)} ${l}`), cr(o) && u.push(`Max: ${Rn(o)} ${l}`), cr(f) && u.push(`Min: ${Rn(f)} ${l}`), cr(a) && u.push(`Std Dev: ${Rn(a)} ${l}`), u;
    }
    const { transformWorldToIndex: i7 } = ga;
    class h2 extends ji {
        static{
            this.toolName = "CircleROI";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                shadow: !0,
                preventHandleOutsideImage: !1,
                storePointData: !1,
                centerPointRadius: 0,
                calculateStats: !0,
                getTextLines: Cne,
                statsCalculator: n2,
                simplified: !0
            }
        }){
            super(e, n), this.isHandleOutsideImage = !1, this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l } = c;
                this.isDrawing = !0;
                const f = l.getCamera(), { viewPlaneNormal: u, viewUp: g } = f, h = this.getReferencedImageId(l, s, u, g), v = l.getFrameOfReferenceUID();
                let m;
                this.configuration.simplified ? m = [
                    [
                        ...s
                    ],
                    [
                        ...s
                    ]
                ] : m = [
                    [
                        ...s
                    ],
                    [
                        ...s
                    ],
                    [
                        ...s
                    ],
                    [
                        ...s
                    ],
                    [
                        ...s
                    ]
                ];
                const y = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [
                            ...u
                        ],
                        viewUp: [
                            ...g
                        ],
                        FrameOfReferenceUID: v,
                        referencedImageId: h,
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        })
                    },
                    data: {
                        label: "",
                        handles: {
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            },
                            points: m,
                            activeHandleIndex: null
                        },
                        cachedStats: {}
                    }
                };
                nr(y, o);
                const C = rn(o, this.getToolName());
                return this.editData = {
                    annotation: y,
                    viewportIdsToRender: C,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), Mn(o), r.preventDefault(), it(C), y;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { points: l } = i.data.handles, f = l.map((v)=>c.worldToCanvas(v)), u = f[0], g = B5([
                    u,
                    f[1]
                ]), h = B5([
                    u,
                    a
                ]);
                return Math.abs(h - g) < o / 2;
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, Mn(o), this._activateModify(o), it(s), r.preventDefault();
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, { data: c } = i;
                i.highlighted = !0;
                let l = !1, f;
                if (a.worldPosition) l = !0;
                else {
                    const { points: g } = c.handles;
                    f = g.findIndex((h)=>h === a);
                }
                const u = rn(s, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: u,
                    handleIndex: f,
                    movingTextBox: l
                }, this._activateModify(s), Mn(s), it(u), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                c && !l || (this.doneEditMemo(), o.highlighted = !1, f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a), this.editData = null, this.isDrawing = !1, this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o));
            }, this._dragDrawCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a, currentPoints: o } = i, { world: s, canvas: c } = o, l = Fe(a), { viewport: f } = l, { canvasToWorld: u } = f, { annotation: g, viewportIdsToRender: h, newAnnotation: v } = this.editData;
                this.createMemo(a, g, {
                    newAnnotation: v
                });
                const { data: m } = g, y = m.handles.points[0], C = f.worldToCanvas(y);
                if (this.configuration.simplified) m.handles.points[1] = s;
                else {
                    const T = Or(C, c);
                    m.handles.points[0] = [
                        ...y
                    ], m.handles.points[1] = u([
                        C[0],
                        C[1] - T
                    ]), m.handles.points[2] = u([
                        C[0],
                        C[1] + T
                    ]), m.handles.points[3] = u([
                        C[0] - T,
                        C[1]
                    ]), m.handles.points[4] = u([
                        C[0] + T,
                        C[1]
                    ]);
                }
                g.invalidated = !0, this.editData.hasMoved = !0, it(h), yn(g, a, Jt.HandlesUpdated);
            }, this._dragModifyCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: f
                });
                const { data: u } = o;
                if (l) {
                    const { deltaPoints: g } = i, h = g.world, { textBox: v } = u.handles, { worldPosition: m } = v;
                    m[0] += h[0], m[1] += h[1], m[2] += h[2], v.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: g } = i, h = g.world;
                    u.handles.points.forEach((m)=>{
                        m[0] += h[0], m[1] += h[1], m[2] += h[2];
                    }), o.invalidated = !0;
                } else this._dragHandle(r), o.invalidated = !0;
                it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this._dragHandle = (r)=>{
                const i = r.detail, { element: a } = i, o = Fe(a), { canvasToWorld: s, worldToCanvas: c } = o.viewport, { annotation: l, handleIndex: f } = this.editData, { data: u } = l, { points: g } = u.handles, { currentPoints: h, deltaPoints: v } = i;
                if (f === 0) {
                    const m = v.world;
                    g.forEach((y)=>{
                        Qc(y, y, m);
                    });
                } else {
                    const m = g[0], y = c(m), C = h.canvas, T = Or(y, C);
                    g[1] = s([
                        y[0],
                        y[1] - T
                    ]), g[2] = s([
                        y[0],
                        y[1] + T
                    ]), g[3] = s([
                        y[0] - T,
                        y[1]
                    ]), g[4] = s([
                        y[0] + T,
                        y[1]
                    ]);
                }
                l.invalidated = !0;
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData;
                    return i.highlighted = !1, i.data.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragModifyCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragModifyCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.addEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragDrawCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragDrawCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragDrawCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragDrawCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { handles: y } = m, { points: C, activeHandleIndex: T } = y;
                    u.annotationUID = v;
                    const { color: x, lineWidth: S, lineDash: D } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), _ = C.map((H)=>o.worldToCanvas(H)), M = _[0], P = B5([
                        M,
                        _[1]
                    ]), F = ww([
                        M,
                        _[1]
                    ]), { centerPointRadius: N } = this.configuration;
                    if (!m.cachedStats[l] || m.cachedStats[l].areaUnit == null) m.cachedStats[l] = {
                        Modality: null,
                        area: null,
                        max: null,
                        mean: null,
                        stdDev: null,
                        areaUnit: null,
                        radius: null,
                        radiusUnit: null,
                        perimeter: null
                    }, this._calculateCachedStats(h, o, f, r);
                    else if (h.invalidated && (this._throttledCalculateCachedStats(h, o, f, r), o instanceof wi)) {
                        const { referencedImageId: H } = h.metadata;
                        for(const ne in m.cachedStats)ne.startsWith("imageId") && f.getStackViewports().find((le)=>{
                            const oe = ur(H), re = le.hasImageURI(oe), X = ur(le.getCurrentImageId());
                            return re && X !== oe;
                        }) && delete m.cachedStats[ne];
                    }
                    if (!o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    let B;
                    if (!Eo(v)) continue;
                    !Ja(v) && !this.editData && T !== null && (this.configuration.simplified ? B = [
                        _[T]
                    ] : B = _), B && Do(i, v, "0", B, {
                        color: x
                    });
                    const G = `${v}-circle`, Z = "0";
                    if (n3(i, v, Z, M, P, {
                        color: x,
                        lineDash: D,
                        lineWidth: S
                    }, G), N > 0 && P > 3 * N && n3(i, v, `${Z}-center`, M, N, {
                        color: x,
                        lineDash: D,
                        lineWidth: S
                    }), a = !0, this.configuration.calculateStats) {
                        const H = this.getLinkedTextBoxStyle(u, h);
                        if (!H.visibility) {
                            m.handles.textBox = {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            };
                            continue;
                        }
                        const ne = this.configuration.getTextLines(m, l);
                        if (!ne || ne.length === 0) continue;
                        let ae;
                        m.handles.textBox.hasMoved || (ae = Jl(F), m.handles.textBox.worldPosition = o.canvasToWorld(ae));
                        const ue = o.worldToCanvas(m.handles.textBox.worldPosition), oe = fc(i, v, "1", ne, ue, [
                            M,
                            _[1]
                        ], {}, H), { x: re, y: X, width: ie, height: he } = oe;
                        m.handles.textBox.worldBoundingBox = {
                            topLeft: o.canvasToWorld([
                                re,
                                X
                            ]),
                            topRight: o.canvasToWorld([
                                re + ie,
                                X
                            ]),
                            bottomLeft: o.canvasToWorld([
                                re,
                                X + he
                            ]),
                            bottomRight: o.canvasToWorld([
                                re + ie,
                                X + he
                            ])
                        };
                    }
                }
                return a;
            }, this._calculateCachedStats = (r, i, a, o)=>{
                if (!this.configuration.calculateStats) return;
                const s = r.data, { element: c } = i, l = r.invalidated, { points: f } = s.handles, u = f.map((P)=>i.worldToCanvas(P)), g = u[0], h = u[1], { viewPlaneNormal: v, viewUp: m } = i.getCamera(), [y, C] = ww([
                    g,
                    h
                ]), T = i.canvasToWorld(y), x = i.canvasToWorld(C), { cachedStats: S } = s, D = Object.keys(S), _ = T, M = x;
                for(let P = 0; P < D.length; P++){
                    const F = D[P], N = this.getTargetImageData(F);
                    if (!N) continue;
                    const { dimensions: B, imageData: G, metadata: Z, voxelManager: H } = N, ne = i7(G, _);
                    ne[0] = Math.floor(ne[0]), ne[1] = Math.floor(ne[1]), ne[2] = Math.floor(ne[2]);
                    const ae = i7(G, M);
                    if (ae[0] = Math.floor(ae[0]), ae[1] = Math.floor(ae[1]), ae[2] = Math.floor(ae[2]), this._isInsideVolume(ne, ae, B)) {
                        const ue = Math.min(ne[0], ae[0]), le = Math.max(ne[0], ae[0]), oe = Math.min(ne[1], ae[1]), re = Math.max(ne[1], ae[1]), X = Math.min(ne[2], ae[2]), ie = Math.max(ne[2], ae[2]), he = [
                            [
                                ue,
                                le
                            ],
                            [
                                oe,
                                re
                            ],
                            [
                                X,
                                ie
                            ]
                        ], $e = f[0], je = Math.abs(T[0] - x[0]) / 2, He = Math.abs(T[1] - x[1]) / 2, rt = Math.abs(T[2] - x[2]) / 2, Qe = {
                            center: $e,
                            xRadius: je < Cd / 2 ? 0 : je,
                            yRadius: He < Cd / 2 ? 0 : He,
                            zRadius: rt < Cd / 2 ? 0 : rt
                        }, { worldWidth: et, worldHeight: St } = GR(v, m, _, M), Ln = et === 0 && St === 0, Nn = [
                            ne,
                            ae
                        ], { scale: zt, unit: Pe, areaUnit: Ct } = ql(N, Nn), yt = zJ(N), En = Math.abs(Math.PI * (et / zt / 2) * (St / yt / zt / 2)), ln = {
                            isPreScaled: dg(i, F),
                            isSuvScaled: this.isSuvScaled(i, F, r.metadata.referencedImageId)
                        }, Hn = gg(Z.Modality, r.metadata.referencedImageId, ln);
                        let Un;
                        H && (Un = H.forEach(this.configuration.statsCalculator.statsCallback, {
                            isInObject: (Q)=>ER(Qe, Q, {
                                    fast: !0
                                }),
                            boundsIJK: he,
                            imageData: G,
                            returnPoints: this.configuration.storePointData
                        }));
                        const q = this.configuration.statsCalculator.getStatistics();
                        S[F] = {
                            Modality: Z.Modality,
                            area: En,
                            mean: q.mean?.value,
                            max: q.max?.value,
                            min: q.min?.value,
                            pointsInShape: Un,
                            stdDev: q.stdDev?.value,
                            statsArray: q.array,
                            isEmptyArea: Ln,
                            areaUnit: Ct,
                            radius: et / 2 / zt,
                            radiusUnit: Pe,
                            perimeter: 2 * Math.PI * (et / 2) / zt,
                            modalityUnit: Hn
                        };
                    } else this.isHandleOutsideImage = !0, S[F] = {
                        Modality: Z.Modality
                    };
                }
                return r.invalidated = !1, l && yn(r, c, Jt.StatsUpdated), S;
            }, this._isInsideVolume = (r, i, a)=>Mi(r, a) && Mi(i, a), this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(h2, i, n, r), { toolInstance: f, ...u } = r || {}, g = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            },
                            activeHandleIndex: null
                        },
                        label: "",
                        cachedStats: {}
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...u
                    }
                };
                nr(g, l.element), it([
                    l.id
                ]);
            };
        }
    }
    function Cne(t, e) {
        const n = t.cachedStats[e], { radius: r, radiusUnit: i, area: a, mean: o, stdDev: s, max: c, min: l, isEmptyArea: f, areaUnit: u, modalityUnit: g } = n, h = [];
        if (cr(r)) {
            const v = f ? "Radius: Oblique not supported" : `Radius: ${Rn(r)} ${i}`;
            h.push(v);
        }
        if (cr(a)) {
            const v = f ? "Area: Oblique not supported" : `Area: ${Rn(a)} ${u}`;
            h.push(v);
        }
        return cr(o) && h.push(`Mean: ${Rn(o)} ${g}`), cr(c) && h.push(`Max: ${Rn(c)} ${g}`), cr(l) && h.push(`Min: ${Rn(l)} ${g}`), cr(s) && h.push(`Std Dev: ${Rn(s)} ${g}`), h;
    }
    const a7 = 3, o7 = 10, wne = {
        resolution: 20,
        controlPointAdditionDistance: 6,
        controlPointDeletionDistance: 6,
        showControlPointsConnectors: !1,
        controlPointAdditionEnabled: !0,
        controlPointDeletionEnabled: !0
    };
    var Ac;
    (function(t) {
        t.Cardinal = "CARDINAL", t.Linear = "LINEAR", t.CatmullRom = "CATMULLROM", t.BSpline = "BSPLINE";
    })(Ac || (Ac = {}));
    var Sd;
    (function(t) {
        t.AddControlPoint = "addControlPoint", t.DeleteControlPoint = "deleteControlPoint";
    })(Sd || (Sd = {}));
    const Tne = [
        "CatmullRomSplineROI",
        "LinearSplineROI",
        "BSplineROI",
        "CardinalSplineROI"
    ];
    class p2 extends qR {
        static{
            this.toolName = "SplineROI";
        }
        static{
            this.SplineTypes = Ac;
        }
        static{
            this.Actions = Sd;
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                preventHandleOutsideImage: !1,
                calculateStats: !0,
                simplifiedSpline: !1,
                getTextLines: xne,
                contourHoleAdditionModifierKey: aa.Shift,
                decimate: {
                    enabled: !1,
                    epsilon: .1
                },
                spline: {
                    configuration: {
                        [Ac.Cardinal]: {
                            Class: Sp,
                            scale: .5
                        },
                        [Ac.CatmullRom]: {
                            Class: fne
                        },
                        [Ac.Linear]: {
                            Class: dne
                        },
                        [Ac.BSpline]: {
                            Class: une,
                            controlPointAdditionEnabled: !1,
                            controlPointDeletionEnabled: !1,
                            showControlPointsConnectors: !0
                        }
                    },
                    type: Ac.CatmullRom,
                    drawPreviewEnabled: !0,
                    enableTwoPointPreview: !1,
                    lastControlPointDeletionKeys: [
                        "Backspace",
                        "Delete"
                    ]
                },
                actions: {
                    [Sd.AddControlPoint]: {
                        method: "addControlPointCallback",
                        bindings: [
                            {
                                mouseButton: zl.Primary,
                                modifierKey: aa.Shift
                            }
                        ]
                    },
                    [Sd.DeleteControlPoint]: {
                        method: "deleteControlPointCallback",
                        bindings: [
                            {
                                mouseButton: zl.Primary,
                                modifierKey: aa.Ctrl
                            }
                        ]
                    }
                }
            }
        }){
            super(e, n), this.splineToolNames = [
                "CatmullRomSplineROI",
                "LinearSplineROI",
                "BSplineROI",
                "CardinalSplineROI"
            ], this.isHandleOutsideImage = !1, this.fireChangeOnUpdate = null, this.isPointNearTool = (r, i, a, o)=>{
                const { instance: s } = i.data.spline;
                return s.isPointNearCurve(a, o);
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o), it(s), r.preventDefault();
            }, this.handleSelectedCallback = (r, i, a)=>{
                const o = r.detail, { element: s } = o, { data: c } = i;
                i.highlighted = !0;
                let l = !1, f;
                if (a.worldPosition) l = !0;
                else {
                    const { points: g } = c.handles;
                    f = g.findIndex((h)=>h === a);
                }
                const u = rn(s, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: u,
                    handleIndex: f,
                    movingTextBox: l
                }, this._activateModify(s), it(u), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, contourHoleProcessingEnabled: l } = this.editData, { data: f } = o;
                o.autoGenerated = !1, f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a);
                const u = Fe(a), g = this.getTargetImageData(this.getTargetId(u.viewport)), { imageData: h, dimensions: v } = g;
                this.isHandleOutsideImage = f.handles.points.map((y)=>Co(h, y)).some((y)=>!Mi(y, v)), this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID);
                const m = c ? Jt.Completed : Jt.HandlesUpdated;
                this.fireChangeOnUpdate ? (this.fireChangeOnUpdate.annotationUID = o.annotationUID, this.fireChangeOnUpdate.changeType = m) : this.fireChangeOnUpdate = {
                    annotationUID: o.annotationUID,
                    changeType: m,
                    contourHoleProcessingEnabled: l
                }, it(s), this.doneEditMemo(), this.editData = null, this.isDrawing = !1;
            }, this._keyDownCallback = (r)=>{
                const i = r.detail, { element: a } = i, o = i.key ?? "", { lastControlPointDeletionKeys: s } = this.configuration.spline;
                if (!s.includes(o)) return;
                const { annotation: l } = this.editData, { data: f } = l;
                if (f.handles.points.length === a7) {
                    this.cancel(a);
                    return;
                } else {
                    const u = f.handles.points.length - 1;
                    this._deleteControlPointByIndex(a, l, u);
                }
                r.preventDefault();
            }, this._mouseMoveCallback = (r)=>{
                const { drawPreviewEnabled: i } = this.configuration.spline;
                if (!i) return;
                const { element: a } = r.detail, { renderingEngine: o } = Fe(a), s = rn(a, this.getToolName());
                this.editData.lastCanvasPoint = r.detail.currentPoints.canvas, it(s), r.preventDefault();
            }, this._mouseDownCallback = (r)=>{
                const i = r.type === z.MOUSE_DOUBLE_CLICK, { annotation: a, viewportIdsToRender: o } = this.editData, { data: s } = a;
                if (s.contour.closed) return;
                this.doneEditMemo();
                const c = r.detail, { currentPoints: l, element: f } = c, { canvas: u, world: g } = l;
                let h = s.handles.points.length >= 2 && i, v = !0;
                if (s.handles.points.length && this.createMemo(f, a, {
                    newAnnotation: s.handles.points.length === 1
                }), s.handles.points.length >= 3) {
                    this.createMemo(f, a);
                    const { instance: m } = s.spline;
                    m.getClosestControlPointWithinDistance(u, o7)?.index === 0 && (v = !1, h = !0);
                }
                v && s.handles.points.push(g), s.contour.closed = s.contour.closed || h, a.invalidated = !0, it(o), s.contour.closed && this._endCallback(r), r.preventDefault();
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData, { data: u } = o;
                if (this.createMemo(a, o, {
                    newAnnotation: f
                }), l) {
                    const { deltaPoints: v } = i, m = v.world, { textBox: y } = u.handles, { worldPosition: C } = y;
                    C[0] += m[0], C[1] += m[1], C[2] += m[2], y.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: v } = i, m = v.world;
                    this.moveAnnotation(o, m);
                } else {
                    const { currentPoints: v } = i, m = v.world;
                    u.handles.points[c] = [
                        ...m
                    ], o.invalidated = !0;
                }
                this.editData.hasMoved = !0;
                const g = Fe(a), { renderingEngine: h } = g;
                it(s);
            }, this.triggerAnnotationCompleted = (r, i)=>{
                const a = z.ANNOTATION_COMPLETED, o = {
                    annotation: r,
                    changeType: Jt.Completed,
                    contourHoleProcessingEnabled: i
                };
                We(Ke, a, o);
            }, this.triggerAnnotationModified = (r, i, a = Jt.StatsUpdated)=>{
                const { viewportId: o, renderingEngineId: s } = i, c = z.ANNOTATION_MODIFIED;
                We(Ke, c, {
                    annotation: r,
                    viewportId: o,
                    renderingEngineId: s,
                    changeType: a
                });
            }, this.triggerChangeEvent = (r, i, a = Jt.StatsUpdated, o)=>{
                a === Jt.Completed ? this.triggerAnnotationCompleted(r, o) : this.triggerAnnotationModified(r, i, a);
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.KEY_DOWN, this._keyDownCallback), r.addEventListener(z.MOUSE_MOVE, this._mouseMoveCallback), r.addEventListener(z.MOUSE_DOWN, this._mouseDownCallback), r.addEventListener(z.MOUSE_DOUBLE_CLICK, this._mouseDownCallback), r.addEventListener(z.TOUCH_TAP, this._mouseDownCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.KEY_DOWN, this._keyDownCallback), r.removeEventListener(z.MOUSE_MOVE, this._mouseMoveCallback), r.removeEventListener(z.MOUSE_DOWN, this._mouseDownCallback), r.removeEventListener(z.MOUSE_DOUBLE_CLICK, this._mouseDownCallback), r.removeEventListener(z.TOUCH_TAP, this._mouseDownCallback);
            }, this._renderStats = (r, i, a, o)=>{
                const s = r.data, c = this.getTargetId(i);
                if (!s.spline.instance.closed || !o.visibility) return;
                const l = this.configuration.getTextLines(s, c);
                if (!l || l.length === 0) return;
                const f = s.handles.points.map((T)=>i.worldToCanvas(T));
                if (!s.handles.textBox.hasMoved) {
                    const T = Jl(f);
                    s.handles.textBox.worldPosition = i.canvasToWorld(T);
                }
                const u = i.worldToCanvas(s.handles.textBox.worldPosition), h = fc(a, r.annotationUID ?? "", "textBox", l, u, f, {}, o), { x: v, y: m, width: y, height: C } = h;
                s.handles.textBox.worldBoundingBox = {
                    topLeft: i.canvasToWorld([
                        v,
                        m
                    ]),
                    topRight: i.canvasToWorld([
                        v + y,
                        m
                    ]),
                    bottomLeft: i.canvasToWorld([
                        v,
                        m + C
                    ]),
                    bottomRight: i.canvasToWorld([
                        v + y,
                        m + C
                    ])
                };
            }, this.addControlPointCallback = (r, i)=>{
                const { data: a } = i, o = a.spline.type, s = this._getSplineConfig(o), c = s.controlPointAdditionDistance;
                if (s.controlPointAdditionEnabled === !1) return;
                const l = r.detail, { element: f } = l, u = Fe(f), { renderingEngine: g, viewport: h } = u, { canvasToWorld: v } = h, { instance: m } = a.spline, y = r.detail.currentPoints.canvas, C = m.getClosestPoint(y);
                if (C.distance > c) return;
                const { index: T, point: x } = m.addControlPointAtU(C.uValue);
                a.handles.points.splice(T, 0, v(x)), i.invalidated = !0;
                const S = rn(f, this.getToolName());
                it(S);
            }, this.deleteControlPointCallback = (r, i)=>{
                const a = i.data.spline.type, o = this._getSplineConfig(a), s = o.controlPointDeletionDistance;
                if (o.controlPointDeletionEnabled === !1) return;
                const c = r.detail, { element: l, currentPoints: f } = c, { canvas: u } = f, { instance: g } = i.data.spline, h = g.getClosestControlPointWithinDistance(u, s);
                h && this._deleteControlPointByIndex(l, i, h.index);
            }, this._calculateCachedStats = (r, i)=>{
                if (!this.configuration.calculateStats) return;
                const a = r.data;
                if (!a.contour.closed) return;
                const o = Fe(i);
                if (!o) return;
                const { viewport: s } = o, { cachedStats: c } = a, { polyline: l } = a.contour, f = Object.keys(c);
                for(let g = 0; g < f.length; g++){
                    const h = f[g], v = this.getTargetImageData(h);
                    if (!v) continue;
                    const { metadata: m } = v, y = l.map((B)=>s.worldToCanvas(B)), C = y[0], T = s.canvasToWorld(C), x = s.canvasToWorld([
                        C[0] + 1,
                        C[1]
                    ]), S = s.canvasToWorld([
                        C[0],
                        C[1] + 1
                    ]), D = rc(T, x), _ = rc(T, S), { imageData: M } = v, { scale: P, areaUnit: F } = ql(v, ()=>{
                        const { maxX: B, maxY: G, minX: Z, minY: H } = kd(y), ne = s.canvasToWorld([
                            Z,
                            H
                        ]), ae = Co(M, ne), ue = s.canvasToWorld([
                            B,
                            G
                        ]), le = Co(M, ue);
                        return [
                            ae,
                            le
                        ];
                    });
                    let N = r2(y) / P / P;
                    N *= D * _, c[h] = {
                        Modality: m.Modality,
                        area: N,
                        areaUnit: F
                    };
                }
                const u = r.invalidated;
                return r.invalidated = !1, u && this.triggerAnnotationModified(r, o, Jt.StatsUpdated), c;
            }, this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            }), this.annotationCompletedBinded = this.annotationCompleted.bind(this);
        }
        annotationCompleted(e) {
            const { sourceAnnotation: n } = e.detail;
            !this.splineToolNames.includes(n?.metadata?.toolName) || !this.configuration.simplifiedSpline || !this.isContourSegmentationTool() || KY(n);
        }
        initializeListeners() {
            Ke.addEventListener(z.ANNOTATION_COMPLETED, this.annotationCompletedBinded);
        }
        removeListeners() {
            Ke.removeEventListener(z.ANNOTATION_COMPLETED, this.annotationCompletedBinded);
        }
        onSetToolEnabled() {
            this.initializeListeners();
        }
        onSetToolActive() {
            this.initializeListeners();
        }
        onSetToolDisabled() {
            this.removeListeners();
        }
        addNewAnnotation(e) {
            const n = e.detail, { currentPoints: r, element: i } = n, { canvas: a } = r, o = fg(e.detail.event) === this.configuration.contourHoleAdditionModifierKey, s = Fe(i), { renderingEngine: c } = s, l = this.createAnnotation(e);
            this.isDrawing = !0, this.addAnnotation(l, i);
            const f = rn(i, this.getToolName());
            return this.editData = {
                annotation: l,
                viewportIdsToRender: f,
                movingTextBox: !1,
                newAnnotation: !0,
                hasMoved: !1,
                lastCanvasPoint: a,
                contourHoleProcessingEnabled: o
            }, this._activateDraw(i), e.preventDefault(), it(f), l;
        }
        cancel(e) {
            if (!this.isDrawing) return;
            this.isDrawing = !1, this._deactivateDraw(e), this._deactivateModify(e), fr(e);
            const { annotation: n, viewportIdsToRender: r, newAnnotation: i } = this.editData;
            i && Ir(n.annotationUID), super.cancelAnnotation(n);
            const a = Fe(e), { renderingEngine: o } = a;
            return it(r), this.editData = null, n.annotationUID;
        }
        isContourSegmentationTool() {
            return !1;
        }
        renderAnnotationInstance(e) {
            const { enabledElement: n, targetId: r, svgDrawingHelper: i, annotationStyle: a } = e, { viewport: o } = n, { worldToCanvas: s } = o, { element: c } = o, l = e.annotation, { annotationUID: f, data: u, highlighted: g } = l, { handles: h } = u, { points: v, activeHandleIndex: m } = h, y = this.editData?.newAnnotation, { lineWidth: C, lineDash: T, color: x, locked: S } = a, D = v.map((H)=>s(H)), { drawPreviewEnabled: _ } = this.configuration.spline, M = l.data.spline.type, P = this._getSplineConfig(M), F = l.data.spline.instance, N = og(l);
            if (N.findIndex((H)=>!H) !== -1) throw new Error(`Can't find annotation for child ${l.childAnnotationUIDs.join()}`);
            [
                l,
                ...N
            ].filter((H)=>this._isSplineROIAnnotation(H)).forEach((H)=>{
                const ae = this._updateSplineInstance(c, H).getPolylinePoints();
                this.updateContourPolyline(H, {
                    points: ae,
                    closed: u.contour.closed,
                    targetWindingDirection: Za.Clockwise
                }, o, {
                    updateWindingDirection: u.contour.closed
                });
            }), super.renderAnnotationInstance(e), !u.cachedStats[r] || u.cachedStats[r].areaUnit == null ? (u.cachedStats[r] = {
                Modality: null,
                area: null,
                areaUnit: null
            }, this._calculateCachedStats(l, c)) : l.invalidated && this._throttledCalculateCachedStats(l, c);
            let Z;
            if (!S && !this.editData && m !== null && (Z = [
                D[m]
            ]), (Z || y || g) && Do(i, f, "0", D, {
                color: x,
                lineWidth: C,
                handleRadius: "3"
            }), _ && F.numControlPoints >= 1 && this.editData?.lastCanvasPoint && !F.closed) {
                const { lastCanvasPoint: H } = this.editData, { enableTwoPointPreview: ne } = this.configuration.spline;
                if (F.numControlPoints === 1 && ne) {
                    const ue = [
                        D[0],
                        H
                    ];
                    Yc(i, f, "previewSplineChange", ue, {
                        color: "#9EA0CA",
                        lineDash: T,
                        lineWidth: 1
                    });
                } else if (F.numControlPoints > 1) {
                    const ae = F.getPreviewPolylinePoints(H, o7);
                    Yc(i, f, "previewSplineChange", ae, {
                        color: "#9EA0CA",
                        lineDash: T,
                        lineWidth: 1
                    });
                }
            }
            if (P.showControlPointsConnectors) {
                const H = [
                    ...D
                ];
                F.closed && H.push(D[0]), Yc(i, f, "controlPointsConnectors", H, {
                    color: "rgba(255, 255, 255, 0.5)",
                    lineWidth: 1
                });
            }
            return this._renderStats(l, o, i, a.textbox), this.fireChangeOnUpdate?.annotationUID === f && (this.triggerChangeEvent(l, n, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled), this.fireChangeOnUpdate = null), l.invalidated = !1, !0;
        }
        createInterpolatedSplineControl(e) {
            if (e.data.handles.points?.length) return;
            const { polyline: n } = e.data.contour;
            if (!n || !n.length) return;
            e.data.handles.points = [];
            const { points: r } = e.data.handles, i = Math.max(10, Math.floor(n.length / 20));
            for(let a = 0; a < n.length - i; a += i)r.push(n[a]);
            r.push(n[n.length - 1]);
        }
        isSplineAnnotation(e) {
            return Tne.includes(e?.metadata?.toolName);
        }
        createSplineObjectFromType(e, n) {
            const r = this._getSplineConfig(n), i = new r.Class;
            e.data.spline = {
                type: r.type,
                instance: i,
                resolution: r.resolution
            };
        }
        createAnnotation(e) {
            const n = super.createAnnotation(e), { world: r } = e.detail.currentPoints, { type: i } = this.configuration.spline, a = this._getSplineConfig(i), o = new a.Class, s = ()=>({
                    type: a.type,
                    instance: o,
                    resolution: a.resolution
                });
            let c;
            return this.configuration.interpolation?.enabled && (c = (l)=>{
                l.data.spline ||= s(), this.createInterpolatedSplineControl(l);
            }), Ma(n, {
                data: {
                    handles: {
                        points: [
                            [
                                ...r
                            ]
                        ]
                    },
                    spline: s(),
                    cachedStats: {}
                },
                onInterpolationComplete: c
            });
        }
        _deleteControlPointByIndex(e, n, r) {
            const i = Fe(e), { points: a } = n.data.handles;
            a.length === 3 ? Ir(n.annotationUID) : a.splice(r, 1);
            const { renderingEngine: o } = i, s = rn(e, this.getToolName());
            n.invalidated = !0, it(s);
        }
        _isSplineROIAnnotation(e) {
            return !!e.data?.spline;
        }
        _getSplineConfig(e) {
            const { configuration: n } = this, r = n.spline.configuration;
            return Object.assign({
                type: e
            }, wne, r[e]);
        }
        _updateSplineInstance(e, n) {
            const r = Fe(e), { viewport: i } = r, { worldToCanvas: a } = i, { data: o } = n, { type: s, instance: c } = n.data.spline, l = this._getSplineConfig(s), u = o.handles.points.map(a), g = l.resolution !== void 0 ? parseInt(l.resolution) : void 0, h = l.scale !== void 0 ? parseFloat(l.scale) : void 0;
            return c.setControlPoints(u), c.closed = !!o.contour.closed, !c.fixedResolution && g !== void 0 && c.resolution !== g && (c.resolution = g, n.invalidated = !0), c instanceof Sp && !c.fixedScale && h !== void 0 && c.scale !== h && (c.scale = h, n.invalidated = !0), c;
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                if (n.length < a7) {
                    console.warn("Spline requires at least 3 control points");
                    return;
                }
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, viewUp: c, instance: l, viewport: f } = this.hydrateBase(p2, i, n, r), u = r?.splineType || Ac.CatmullRom, h = l._getSplineConfig(u).Class, v = new h, { toolInstance: m, ...y } = r || {}, C = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n
                        },
                        label: "",
                        cachedStats: {},
                        spline: {
                            type: u,
                            instance: v
                        },
                        contour: {
                            closed: !0
                        }
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !0,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: l.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...y
                    }
                };
                nr(C, f.element), it([
                    f.id
                ]);
            };
        }
    }
    function xne(t, e) {
        const n = t.cachedStats[e], { area: r, isEmptyArea: i, areaUnit: a } = n, o = [];
        if (r) {
            const s = i ? "Area: Oblique not supported" : `Area: ${Rn(r)} ${a}`;
            o.push(s);
        }
        return o;
    }
    class m2 extends ji {
        static{
            this.toolName = "ArrowAnnotate";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                shadow: !0,
                getTextCallback: Sne,
                changeTextCallback: Ene,
                preventHandleOutsideImage: !1,
                arrowFirst: !0,
                arrowHeadStyle: "legacy"
            }
        }){
            super(e, n), this.addNewAnnotation = (r)=>{
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l, renderingEngine: f } = c;
                Mn(o), this.isDrawing = !0;
                const u = l.getCamera(), { viewPlaneNormal: g, viewUp: h } = u, v = this.getReferencedImageId(l, s, g, h), { arrowFirst: m } = this.configuration, y = l.getFrameOfReferenceUID(), C = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [
                            ...g
                        ],
                        viewUp: [
                            ...h
                        ],
                        FrameOfReferenceUID: y,
                        referencedImageId: v,
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        })
                    },
                    data: {
                        text: "",
                        handles: {
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            activeHandleIndex: null,
                            arrowFirst: m,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        label: ""
                    }
                };
                nr(C, o);
                const T = rn(o, this.getToolName());
                return this.editData = {
                    annotation: C,
                    viewportIdsToRender: T,
                    handleIndex: 1,
                    movingTextBox: !1,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), r.preventDefault(), it(T), C;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, [f, u] = l.handles.points, g = c.worldToCanvas(f), h = c.worldToCanvas(u), v = {
                    start: {
                        x: g[0],
                        y: g[1]
                    },
                    end: {
                        x: h[0],
                        y: h[1]
                    }
                };
                return Cs([
                    v.start.x,
                    v.start.y
                ], [
                    v.end.x,
                    v.end.y
                ], [
                    a[0],
                    a[1]
                ]) <= o;
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o), Mn(o);
                const c = Fe(o), { renderingEngine: l } = c;
                it(s), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l, movingTextBox: f } = this.editData, { data: u } = o;
                c && !l || (u.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a), this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), c ? this.configuration.getTextCallback((g)=>{
                    if (!g) {
                        Ir(o.annotationUID), it(s), this.editData = null, this.isDrawing = !1;
                        return;
                    }
                    o.data.text = g, yn(o, a, Jt.HandlesUpdated), Ti(o), this.createMemo(a, o, {
                        newAnnotation: !!this.memo
                    }), one(o, a, g), it(s);
                }) : f || yn(o, a, Jt.HandlesUpdated), this.doneEditMemo(), this.editData = null, this.isDrawing = !1);
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: f
                });
                const { data: u } = o;
                if (l) {
                    const { deltaPoints: g } = i, h = g.world, { textBox: v } = u.handles, { worldPosition: m } = v;
                    m[0] += h[0], m[1] += h[1], m[2] += h[2], v.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: g } = i, h = g.world;
                    u.handles.points.forEach((m)=>{
                        m[0] += h[0], m[1] += h[1], m[2] += h[2];
                    }), o.invalidated = !0;
                } else {
                    const { currentPoints: g } = i, h = g.world;
                    u.handles.points[c] = [
                        ...h
                    ], o.invalidated = !0;
                }
                this.editData.hasMoved = !0, it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this.touchTapCallback = (r)=>{
                r.detail.taps == 2 && this.doubleClickCallback(r);
            }, this.doubleClickCallback = (r)=>{
                const i = r.detail, { element: a } = i;
                let o = ba(this.getToolName(), a);
                if (o = this.filterInteractableAnnotationsForElement(a, o), !o?.length) return;
                const s = o.find((l)=>this.isPointNearTool(a, l, i.currentPoints.canvas, 6));
                if (!s) return;
                const c = s;
                this.configuration.changeTextCallback(s, r.detail, this._doneChangingTextCallback.bind(this, a, c)), this.editData = null, this.isDrawing = !1, r.stopImmediatePropagation(), r.preventDefault();
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_END, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_MOVE, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let f = 0; f < c.length; f++){
                    const u = c[f], { annotationUID: g, data: h } = u, { handles: v, text: m } = h, { points: y, activeHandleIndex: C } = v;
                    l.annotationUID = g;
                    const { color: T, lineWidth: x, lineDash: S, markerSize: D } = this.getAnnotationStyle({
                        annotation: u,
                        styleSpecifier: l
                    }), _ = y.map((ue)=>o.worldToCanvas(ue));
                    let M;
                    if (!Ja(g) && !this.editData && C !== null && (M = [
                        _[C]
                    ]), !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    if (!Eo(g)) continue;
                    M && Do(i, g, "0", _, {
                        color: T,
                        lineWidth: x
                    });
                    const P = "1";
                    if (this.configuration.arrowFirst ? Ow(i, g, P, _[1], _[0], {
                        color: T,
                        width: x,
                        lineDash: S,
                        viaMarker: this.configuration.arrowHeadStyle !== "legacy",
                        markerSize: D
                    }) : Ow(i, g, P, _[0], _[1], {
                        color: T,
                        width: x,
                        lineDash: S,
                        viaMarker: this.configuration.arrowHeadStyle !== "legacy",
                        markerSize: D
                    }), a = !0, !m) continue;
                    const F = this.getLinkedTextBoxStyle(l, u);
                    if (!F.visibility) {
                        h.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    if (!h.handles.textBox.hasMoved) {
                        const ue = _[1];
                        h.handles.textBox.worldPosition = o.canvasToWorld(ue);
                    }
                    const N = o.worldToCanvas(h.handles.textBox.worldPosition), G = fc(i, g, "1", [
                        m
                    ], N, _, {}, F), { x: Z, y: H, width: ne, height: ae } = G;
                    h.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            Z,
                            H
                        ]),
                        topRight: o.canvasToWorld([
                            Z + ne,
                            H
                        ]),
                        bottomLeft: o.canvasToWorld([
                            Z,
                            H + ae
                        ]),
                        bottomRight: o.canvasToWorld([
                            Z + ne,
                            H + ae
                        ])
                    };
                }
                return a;
            };
        }
        static{
            this.hydrate = (e, n, r, i)=>{
                const a = An(e);
                if (!a) return;
                const { FrameOfReferenceUID: o, referencedImageId: s, viewPlaneNormal: c, instance: l, viewport: f } = this.hydrateBase(m2, a, n, i), { toolInstance: u, ...g } = i || {}, h = {
                    annotationUID: i?.annotationUID || Vn(),
                    data: {
                        text: r || "",
                        handles: {
                            points: n
                        }
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: l.getToolName(),
                        viewPlaneNormal: c,
                        FrameOfReferenceUID: o,
                        referencedImageId: s,
                        ...g
                    }
                };
                nr(h, f.element), it([
                    f.id
                ]);
            };
        }
        handleSelectedCallback(e, n, r) {
            const i = e.detail, { element: a } = i, { data: o } = n;
            n.highlighted = !0;
            let s = !1, c;
            r.worldPosition ? s = !0 : c = o.handles.points.findIndex((g)=>g === r);
            const l = rn(a, this.getToolName());
            this.editData = {
                annotation: n,
                viewportIdsToRender: l,
                handleIndex: c,
                movingTextBox: s
            }, this._activateModify(a), Mn(a);
            const f = Fe(a), { renderingEngine: u } = f;
            it(l), e.preventDefault();
        }
        _doneChangingTextCallback(e, n, r) {
            n.data.text = r, Fe(e);
            const i = rn(e, this.getToolName());
            it(i), yn(n, e);
        }
        _isInsideVolume(e, n, r) {
            return Mi(e, r) && Mi(n, r);
        }
    }
    function Sne(t) {
        return t(prompt("Enter your annotation:"));
    }
    function Ene(t, e, n) {
        return n(prompt("Enter your annotation:"));
    }
    class v2 extends ji {
        static{
            this.toolName = "Angle";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                shadow: !0,
                showAngleArc: !1,
                arcOffset: 5,
                preventHandleOutsideImage: !1,
                getTextLines: Dne
            }
        }){
            super(e, n), this.addNewAnnotation = (r)=>{
                if (this.angleStartedNotYetCompleted) return;
                this.angleStartedNotYetCompleted = !0;
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l, renderingEngine: f } = c;
                Mn(o), this.isDrawing = !0;
                const u = l.getCamera(), { viewPlaneNormal: g, viewUp: h } = u, v = this.getReferencedImageId(l, s, g, h), m = l.getFrameOfReferenceUID(), y = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [
                            ...g
                        ],
                        viewUp: [
                            ...h
                        ],
                        FrameOfReferenceUID: m,
                        referencedImageId: v,
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        })
                    },
                    data: {
                        handles: {
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            activeHandleIndex: null,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        label: "",
                        cachedStats: {}
                    }
                };
                nr(y, o);
                const C = rn(o, this.getToolName());
                return this.editData = {
                    annotation: y,
                    viewportIdsToRender: C,
                    handleIndex: 1,
                    movingTextBox: !1,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), r.preventDefault(), it(C), y;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, [f, u, g] = l.handles.points, h = c.worldToCanvas(f), v = c.worldToCanvas(u), m = {
                    start: {
                        x: h[0],
                        y: h[1]
                    },
                    end: {
                        x: v[0],
                        y: v[1]
                    }
                };
                if (Cs([
                    m.start.x,
                    m.start.y
                ], [
                    m.end.x,
                    m.end.y
                ], [
                    a[0],
                    a[1]
                ]) <= o) return !0;
                if (!g) return !1;
                const C = c.worldToCanvas(g), T = {
                    start: {
                        x: v[0],
                        y: v[1]
                    },
                    end: {
                        x: C[0],
                        y: C[1]
                    }
                };
                return Cs([
                    T.start.x,
                    T.start.y
                ], [
                    T.end.x,
                    T.end.y
                ], [
                    a[0],
                    a[1]
                ]) <= o;
            }, this.toolSelectedCallback = (r, i)=>{
                const a = r.detail, { element: o } = a;
                i.highlighted = !0;
                const s = rn(o, this.getToolName());
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: s,
                    movingTextBox: !1
                }, this._activateModify(o), Mn(o);
                const c = Fe(o), { renderingEngine: l } = c;
                it(s), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                if (c && !l) return;
                if (this.angleStartedNotYetCompleted && f.handles.points.length === 2) {
                    this.editData.handleIndex = 2;
                    return;
                }
                this.angleStartedNotYetCompleted = !1, f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a);
                const u = Fe(a), { renderingEngine: g } = u;
                this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), this.doneEditMemo(), c && Ti(o), this.editData = null, this.isDrawing = !1;
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, newAnnotation: f } = this.editData, { data: u } = o;
                if (this.createMemo(a, o, {
                    newAnnotation: f
                }), l) {
                    const { deltaPoints: v } = i, m = v.world, { textBox: y } = u.handles, { worldPosition: C } = y;
                    C[0] += m[0], C[1] += m[1], C[2] += m[2], y.hasMoved = !0;
                } else if (c === void 0) {
                    const { deltaPoints: v } = i, m = v.world;
                    u.handles.points.forEach((C)=>{
                        C[0] += m[0], C[1] += m[1], C[2] += m[2];
                    }), o.invalidated = !0;
                } else {
                    const { currentPoints: v } = i, m = v.world;
                    u.handles.points[c] = [
                        ...m
                    ], o.invalidated = !0;
                }
                this.editData.hasMoved = !0;
                const g = Fe(a), { renderingEngine: h } = g;
                it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this.cancel = (r)=>{
                if (this.isDrawing) {
                    this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                    const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                    return i.highlighted = !1, s.handles.activeHandleIndex = null, it(a), o && Ti(i), this.editData = null, this.angleStartedNotYetCompleted = !1, i.annotationUID;
                }
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_MOVE, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { points: y, activeHandleIndex: C } = m.handles;
                    u.annotationUID = v;
                    const { color: T, lineWidth: x, lineDash: S, angleArcLineDash: D } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), _ = y.map((le)=>o.worldToCanvas(le));
                    !m.cachedStats[l] || m.cachedStats[l].angle == null ? (m.cachedStats[l] = {
                        angle: null
                    }, this._calculateCachedStats(h, f, r)) : h.invalidated && this._throttledCalculateCachedStats(h, f, r);
                    let M;
                    if (!Ja(h.annotationUID) && !this.editData && C !== null && (M = [
                        _[C]
                    ]), !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    if (!Eo(v)) continue;
                    M && Do(i, v, "0", _, {
                        color: T,
                        lineDash: S,
                        lineWidth: x
                    });
                    let P = "1";
                    if (Oa(i, v, P, _[0], _[1], {
                        color: T,
                        width: x,
                        lineDash: S
                    }), a = !0, _.length !== 3) return a;
                    if (P = "2", Oa(i, v, P, _[1], _[2], {
                        color: T,
                        width: x,
                        lineDash: S
                    }), this.configuration.showAngleArc) {
                        const le = _[1], oe = this.configuration.arcOffset, re = Math.min(Cs([
                            le[0],
                            le[1]
                        ], [
                            _[0][0],
                            _[0][1]
                        ], [
                            _[2][0],
                            _[2][1]
                        ]), Cs([
                            le[0],
                            le[1]
                        ], [
                            _[2][0],
                            _[2][1]
                        ], [
                            _[0][0],
                            _[0][1]
                        ])) / oe, X = [];
                        let ie = Math.atan2(_[0][1] - le[1], _[0][0] - le[0]), he = Math.atan2(_[2][1] - le[1], _[2][0] - le[0]);
                        if (he < ie && (he += 2 * Math.PI), he - ie > Math.PI) {
                            const He = ie;
                            ie = he, he = He + 2 * Math.PI;
                        }
                        const je = 32;
                        for(let He = 0; He <= je; He++){
                            const rt = ie + He / je * (he - ie);
                            X.push([
                                le[0] + re * Math.cos(rt),
                                le[1] + re * Math.sin(rt)
                            ]);
                        }
                        A0(i, v, "3", X, {
                            color: T,
                            width: x,
                            lineDash: D
                        });
                    }
                    if (!m.cachedStats[l]?.angle) continue;
                    const F = this.getLinkedTextBoxStyle(u, h);
                    if (!F.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const N = this.configuration.getTextLines(m, l);
                    if (!m.handles.textBox.hasMoved) {
                        const le = _[1];
                        m.handles.textBox.worldPosition = o.canvasToWorld(le);
                    }
                    const B = o.worldToCanvas(m.handles.textBox.worldPosition), Z = fc(i, v, "1", N, B, _, {}, F), { x: H, y: ne, width: ae, height: ue } = Z;
                    m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            H,
                            ne
                        ]),
                        topRight: o.canvasToWorld([
                            H + ae,
                            ne
                        ]),
                        bottomLeft: o.canvasToWorld([
                            H,
                            ne + ue
                        ]),
                        bottomRight: o.canvasToWorld([
                            H + ae,
                            ne + ue
                        ])
                    };
                }
                return a;
            }, this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 100, {
                trailing: !0
            });
        }
        static{
            this.hydrate = (e, n, r)=>{
                const i = An(e);
                if (!i) return;
                const { FrameOfReferenceUID: a, referencedImageId: o, viewPlaneNormal: s, instance: c, viewport: l } = this.hydrateBase(v2, i, n, r), { toolInstance: f, ...u } = r || {}, g = {
                    annotationUID: r?.annotationUID || Vn(),
                    data: {
                        handles: {
                            points: n
                        }
                    },
                    highlighted: !1,
                    autoGenerated: !1,
                    invalidated: !1,
                    isLocked: !1,
                    isVisible: !0,
                    metadata: {
                        toolName: c.getToolName(),
                        viewPlaneNormal: s,
                        FrameOfReferenceUID: a,
                        referencedImageId: o,
                        ...u
                    }
                };
                nr(g, l.element), it([
                    l.id
                ]);
            };
        }
        handleSelectedCallback(e, n, r) {
            const i = e.detail, { element: a } = i, { data: o } = n;
            n.highlighted = !0;
            let s = !1, c;
            r.worldPosition ? s = !0 : c = o.handles.points.findIndex((g)=>g === r);
            const l = rn(a, this.getToolName());
            this.editData = {
                annotation: n,
                viewportIdsToRender: l,
                handleIndex: c,
                movingTextBox: s
            }, this._activateModify(a), Mn(a);
            const f = Fe(a), { renderingEngine: u } = f;
            it(l), e.preventDefault();
        }
        _calculateCachedStats(e, n, r) {
            const i = e.data, { element: a } = r.viewport;
            if (i.handles.points.length !== 3) return;
            const o = i.handles.points[0], s = i.handles.points[1], c = i.handles.points[2], { cachedStats: l } = i, f = Object.keys(l);
            for(let g = 0; g < f.length; g++){
                const h = f[g], v = xh([
                    o,
                    s
                ], [
                    s,
                    c
                ]), { dimensions: m, imageData: y } = this.getTargetImageData(h);
                this.isHandleOutsideImage = [
                    o,
                    s,
                    c
                ].map((C)=>Co(y, C)).some((C)=>!Mi(C, m)), l[h] = {
                    angle: isNaN(v) ? "Incomplete Angle" : v
                };
            }
            const u = e.invalidated;
            return e.invalidated = !1, u && yn(e, a, Jt.StatsUpdated), l;
        }
    }
    function Dne(t, e) {
        const n = t.cachedStats[e], { angle: r } = n;
        return r === void 0 ? void 0 : isNaN(r) ? [
            `${r}`
        ] : [
            `${Rn(r)} °`
        ];
    }
    const _ne = (...t)=>{
        const e = t[0].length === 2 ? [
            0,
            0
        ] : [
            0,
            0,
            0
        ], n = t.length;
        for (const r of t)e[0] += r[0] / n, e[1] += r[1] / n, e.length === 3 && (e[2] += r[2] / n);
        return e;
    }, Vc = _ne;
    class AO extends ji {
        static{
            this.toolName = "CobbAngle";
        }
        constructor(e = {}, n = {
            supportedInteractionTypes: [
                "Mouse",
                "Touch"
            ],
            configuration: {
                shadow: !0,
                preventHandleOutsideImage: !1,
                getTextLines: Rne,
                showArcLines: !1
            }
        }){
            super(e, n), this.addNewAnnotation = (r)=>{
                if (this.angleStartedNotYetCompleted) return;
                this.angleStartedNotYetCompleted = !0;
                const i = r.detail, { currentPoints: a, element: o } = i, s = a.world, c = Fe(o), { viewport: l, renderingEngine: f } = c;
                Mn(o), this.isDrawing = !0;
                const u = l.getCamera(), { viewPlaneNormal: g, viewUp: h } = u, v = this.getReferencedImageId(l, s, g, h), m = l.getFrameOfReferenceUID(), y = {
                    highlighted: !0,
                    invalidated: !0,
                    metadata: {
                        toolName: this.getToolName(),
                        viewPlaneNormal: [
                            ...g
                        ],
                        viewUp: [
                            ...h
                        ],
                        FrameOfReferenceUID: m,
                        referencedImageId: v,
                        ...l.getViewReference({
                            points: [
                                s
                            ]
                        })
                    },
                    data: {
                        handles: {
                            points: [
                                [
                                    ...s
                                ],
                                [
                                    ...s
                                ]
                            ],
                            activeHandleIndex: null,
                            textBox: {
                                hasMoved: !1,
                                worldPosition: [
                                    0,
                                    0,
                                    0
                                ],
                                worldBoundingBox: {
                                    topLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    topRight: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomLeft: [
                                        0,
                                        0,
                                        0
                                    ],
                                    bottomRight: [
                                        0,
                                        0,
                                        0
                                    ]
                                }
                            }
                        },
                        label: "",
                        cachedStats: {}
                    }
                };
                nr(y, o);
                const C = rn(o, this.getToolName());
                return this.editData = {
                    annotation: y,
                    viewportIdsToRender: C,
                    handleIndex: 1,
                    movingTextBox: !1,
                    newAnnotation: !0,
                    hasMoved: !1
                }, this._activateDraw(o), r.preventDefault(), it(C), y;
            }, this.isPointNearTool = (r, i, a, o)=>{
                const s = Fe(r), { viewport: c } = s, { data: l } = i, { distanceToPoint: f, distanceToPoint2: u } = this.distanceToLines({
                    viewport: c,
                    points: l.handles.points,
                    canvasCoords: a,
                    proximity: o
                });
                return f <= o || u <= o;
            }, this.toolSelectedCallback = (r, i, a, o, s = 6)=>{
                const c = r.detail, { element: l } = c;
                i.highlighted = !0;
                const f = rn(l, this.getToolName()), u = Fe(l), { renderingEngine: g, viewport: h } = u, { isNearFirstLine: v, isNearSecondLine: m } = this.distanceToLines({
                    viewport: h,
                    points: i.data.handles.points,
                    canvasCoords: o,
                    proximity: s
                });
                this.editData = {
                    annotation: i,
                    viewportIdsToRender: f,
                    movingTextBox: !1,
                    isNearFirstLine: v,
                    isNearSecondLine: m
                }, this._activateModify(l), Mn(l), it(f), r.preventDefault();
            }, this._endCallback = (r)=>{
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, newAnnotation: c, hasMoved: l } = this.editData, { data: f } = o;
                if (c && !l) return;
                if (this.doneEditMemo(), this.angleStartedNotYetCompleted && f.handles.points.length < 4) {
                    fr(a), this.editData.handleIndex = f.handles.points.length;
                    return;
                }
                this.angleStartedNotYetCompleted = !1, f.handles.activeHandleIndex = null, this._deactivateModify(a), this._deactivateDraw(a), fr(a);
                const u = Fe(a), { renderingEngine: g } = u;
                this.isHandleOutsideImage && this.configuration.preventHandleOutsideImage && Ir(o.annotationUID), it(s), c && Ti(o), this.editData = null, this.isDrawing = !1;
            }, this._mouseDownCallback = (r)=>{
                const { annotation: i, handleIndex: a } = this.editData, o = r.detail, { element: s, currentPoints: c } = o, l = c.world, { data: f } = i;
                if (a === 1) {
                    f.handles.points[1] = l, this.editData.hasMoved = f.handles.points[1][0] !== f.handles.points[0][0] || f.handles.points[1][1] !== f.handles.points[0][0];
                    return;
                }
                if (a === 3) {
                    f.handles.points[3] = l, this.editData.hasMoved = f.handles.points[3][0] !== f.handles.points[2][0] || f.handles.points[3][1] !== f.handles.points[2][0], this.angleStartedNotYetCompleted = !1;
                    return;
                }
                this.editData.hasMoved = !1, Mn(s), f.handles.points[2] = f.handles.points[3] = l, this.editData.handleIndex = f.handles.points.length - 1;
            }, this._dragCallback = (r)=>{
                this.isDrawing = !0;
                const i = r.detail, { element: a } = i, { annotation: o, viewportIdsToRender: s, handleIndex: c, movingTextBox: l, isNearFirstLine: f, isNearSecondLine: u, newAnnotation: g } = this.editData;
                this.createMemo(a, o, {
                    newAnnotation: g
                });
                const { data: h } = o;
                if (l) {
                    const { deltaPoints: y } = i, C = y.world, { textBox: T } = h.handles, { worldPosition: x } = T;
                    x[0] += C[0], x[1] += C[1], x[2] += C[2], T.hasMoved = !0;
                } else if (c === void 0 && (f || u)) {
                    const { deltaPoints: y } = i, C = y.world, T = h.handles.points;
                    f ? [
                        T[0],
                        T[1]
                    ].forEach((S)=>{
                        S[0] += C[0], S[1] += C[1], S[2] += C[2];
                    }) : u && [
                        T[2],
                        T[3]
                    ].forEach((S)=>{
                        S[0] += C[0], S[1] += C[1], S[2] += C[2];
                    }), o.invalidated = !0;
                } else {
                    const { currentPoints: y } = i, C = y.world;
                    h.handles.points[c] = [
                        ...C
                    ], o.invalidated = !0;
                }
                this.editData.hasMoved = !0;
                const v = Fe(a), { renderingEngine: m } = v;
                it(s), o.invalidated && yn(o, a, Jt.HandlesUpdated);
            }, this.cancel = (r)=>{
                if (!this.isDrawing) return;
                this.isDrawing = !1, this._deactivateDraw(r), this._deactivateModify(r), fr(r);
                const { annotation: i, viewportIdsToRender: a, newAnnotation: o } = this.editData, { data: s } = i;
                s.handles.points.length < 4 && Ir(i.annotationUID), i.highlighted = !1, s.handles.activeHandleIndex = null;
                const c = Fe(r), { renderingEngine: l } = c;
                return it(a), o && Ti(i), this.editData = null, this.angleStartedNotYetCompleted = !1, i.annotationUID;
            }, this._activateModify = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_START, this._mouseDownCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateModify = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_START, this._mouseDownCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._activateDraw = (r)=>{
                nt.isInteractingWithTool = !0, r.addEventListener(z.MOUSE_UP, this._endCallback), r.addEventListener(z.MOUSE_DRAG, this._dragCallback), r.addEventListener(z.MOUSE_MOVE, this._dragCallback), r.addEventListener(z.MOUSE_CLICK, this._endCallback), r.addEventListener(z.MOUSE_DOWN, this._mouseDownCallback), r.addEventListener(z.TOUCH_END, this._endCallback), r.addEventListener(z.TOUCH_DRAG, this._dragCallback), r.addEventListener(z.TOUCH_START, this._mouseDownCallback), r.addEventListener(z.TOUCH_TAP, this._endCallback);
            }, this._deactivateDraw = (r)=>{
                nt.isInteractingWithTool = !1, r.removeEventListener(z.MOUSE_UP, this._endCallback), r.removeEventListener(z.MOUSE_DRAG, this._dragCallback), r.removeEventListener(z.MOUSE_MOVE, this._dragCallback), r.removeEventListener(z.MOUSE_CLICK, this._endCallback), r.removeEventListener(z.MOUSE_DOWN, this._mouseDownCallback), r.removeEventListener(z.TOUCH_END, this._endCallback), r.removeEventListener(z.TOUCH_DRAG, this._dragCallback), r.removeEventListener(z.TOUCH_START, this._mouseDownCallback), r.removeEventListener(z.TOUCH_TAP, this._endCallback);
            }, this.renderAnnotation = (r, i)=>{
                let a = !1;
                const { viewport: o } = r, { element: s } = o;
                let c = ba(this.getToolName(), s);
                if (!c?.length || (c = this.filterInteractableAnnotationsForElement(s, c), !c?.length)) return a;
                const l = this.getTargetId(o), f = o.getRenderingEngine(), u = {
                    toolGroupId: this.toolGroupId,
                    toolName: this.getToolName(),
                    viewportId: r.viewport.id
                };
                for(let g = 0; g < c.length; g++){
                    const h = c[g], { annotationUID: v, data: m } = h, { points: y, activeHandleIndex: C } = m.handles;
                    u.annotationUID = v;
                    const { color: T, lineWidth: x, lineDash: S } = this.getAnnotationStyle({
                        annotation: h,
                        styleSpecifier: u
                    }), D = y.map((rt)=>o.worldToCanvas(rt));
                    !m.cachedStats[l] || m.cachedStats[l].angle == null ? (m.cachedStats[l] = {
                        angle: null,
                        arc1Angle: null,
                        arc2Angle: null,
                        points: {
                            world: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null
                            },
                            canvas: {
                                arc1Start: null,
                                arc1End: null,
                                arc2Start: null,
                                arc2End: null,
                                arc1Angle: null,
                                arc2Angle: null
                            }
                        }
                    }, this._calculateCachedStats(h, f, r)) : h.invalidated && this._throttledCalculateCachedStats(h, f, r);
                    let _;
                    if (!Ja(v) && !this.editData && C !== null && (_ = [
                        D[C]
                    ]), !o.getRenderingEngine()) return console.warn("Rendering Engine has been destroyed"), a;
                    if (!Eo(v)) continue;
                    _ && Do(i, v, "0", D, {
                        color: T,
                        lineDash: S,
                        lineWidth: x
                    });
                    const M = [
                        D[0],
                        D[1]
                    ], P = [
                        D[2],
                        D[3]
                    ];
                    let F = "line1";
                    if (Oa(i, v, F, M[0], M[1], {
                        color: T,
                        width: x,
                        lineDash: S
                    }), a = !0, D.length < 4) return a;
                    F = "line2", Oa(i, v, F, P[0], P[1], {
                        color: T,
                        width: x,
                        lineDash: S
                    }), F = "linkLine";
                    const N = Vc(M[0], M[1]), B = Vc(P[0], P[1]);
                    Oa(i, v, F, N, B, {
                        color: T,
                        lineWidth: "1",
                        lineDash: "1,4"
                    });
                    const { arc1Start: G, arc1End: Z, arc2End: H, arc2Start: ne } = m.cachedStats[l].points.canvas, { arc1Angle: ae, arc2Angle: ue } = m.cachedStats[l];
                    if (this.configuration.showArcLines && (F = "arc1", Oa(i, v, F, G, Z, {
                        color: T,
                        lineWidth: "1"
                    }), F = "arc2", Oa(i, v, F, ne, H, {
                        color: T,
                        lineWidth: "1"
                    })), !m.cachedStats[l]?.angle) continue;
                    const le = this.getLinkedTextBoxStyle(u, h);
                    if (!le.visibility) {
                        m.handles.textBox = {
                            hasMoved: !1,
                            worldPosition: [
                                0,
                                0,
                                0
                            ],
                            worldBoundingBox: {
                                topLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                topRight: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomLeft: [
                                    0,
                                    0,
                                    0
                                ],
                                bottomRight: [
                                    0,
                                    0,
                                    0
                                ]
                            }
                        };
                        continue;
                    }
                    const oe = this.configuration.getTextLines(m, l);
                    if (!m.handles.textBox.hasMoved) {
                        const rt = Jl(D);
                        m.handles.textBox.worldPosition = o.canvasToWorld(rt);
                    }
                    const re = o.worldToCanvas(m.handles.textBox.worldPosition), ie = fc(i, v, "cobbAngleText", oe, re, D, {}, le), { x: he, y: $e, width: je, height: He } = ie;
                    if (m.handles.textBox.worldBoundingBox = {
                        topLeft: o.canvasToWorld([
                            he,
                            $e
                        ]),
                        topRight: o.canvasToWorld([
                            he + je,
                            $e
                        ]),
                        bottomLeft: o.canvasToWorld([
                            he,
                            $e + He
                        ]),
                        bottomRight: o.canvasToWorld([
                            he + je,
                            $e + He
                        ])
                    }, this.configuration.showArcLines) {
                        const rt = "arcAngle1", Qe = [
                            `${ae.toFixed(2)} °`
                        ], et = Vc(G, Z);
                        yp(i, v, rt, Qe, et, {
                            ...le,
                            padding: 3
                        });
                        const St = "arcAngle2", Ln = [
                            `${ue.toFixed(2)} °`
                        ], Nn = Vc(ne, H);
                        yp(i, v, St, Ln, Nn, {
                            ...le,
                            padding: 3
                        });
                    }
                }
                return a;
            }, this.distanceToLines = ({ viewport: r, points: i, canvasCoords: a, proximity: o })=>{
                const [s, c, l, f] = i, u = r.worldToCanvas(s), g = r.worldToCanvas(c), h = r.worldToCanvas(l), v = r.worldToCanvas(f), m = {
                    start: {
                        x: u[0],
                        y: u[1]
                    },
                    end: {
                        x: g[0],
                        y: g[1]
                    }
                }, y = {
                    start: {
                        x: h[0],
                        y: h[1]
                    },
                    end: {
                        x: v[0],
                        y: v[1]
                    }
                }, C = Cs([
                    m.start.x,
                    m.start.y
                ], [
                    m.end.x,
                    m.end.y
                ], [
                    a[0],
                    a[1]
                ]), T = Cs([
                    y.start.x,
                    y.start.y
                ], [
                    y.end.x,
                    y.end.y
                ], [
                    a[0],
                    a[1]
                ]);
                let x = !1, S = !1;
                return C <= o ? x = !0 : T <= o && (S = !0), {
                    distanceToPoint: C,
                    distanceToPoint2: T,
                    isNearFirstLine: x,
                    isNearSecondLine: S
                };
            }, this.getArcsStartEndPoints = ({ firstLine: r, secondLine: i, mid1: a, mid2: o })=>{
                const s = [
                    a,
                    o
                ], c = xh(r, s), l = xh(i, s), f = c > 90 ? 1 : 0, u = l > 90 ? 0 : 1, g = Vc(s[0], s[1]), h = Math.sqrt((s[1][0] - s[0][0]) ** 2 + (s[1][1] - s[0][1]) ** 2), v = .1, m = Vc(r[0], r[1]), y = Vc(i[0], i[1]), C = [
                    r[f][0] - m[0],
                    r[f][1] - m[1]
                ], T = Math.sqrt(C[0] ** 2 + C[1] ** 2), x = [
                    C[0] / T,
                    C[1] / T
                ], S = [
                    m[0] + x[0] * h * v,
                    m[1] + x[1] * h * v
                ], D = [
                    g[0] - a[0],
                    g[1] - a[1]
                ], _ = Math.sqrt(D[0] ** 2 + D[1] ** 2), M = [
                    D[0] / _,
                    D[1] / _
                ], P = [
                    a[0] + M[0] * h * v,
                    a[1] + M[1] * h * v
                ], F = [
                    i[u][0] - y[0],
                    i[u][1] - y[1]
                ], N = Math.sqrt(F[0] ** 2 + F[1] ** 2), B = [
                    F[0] / N,
                    F[1] / N
                ], G = [
                    y[0] + B[0] * h * v,
                    y[1] + B[1] * h * v
                ], Z = [
                    g[0] - o[0],
                    g[1] - o[1]
                ], H = Math.sqrt(Z[0] ** 2 + Z[1] ** 2), ne = [
                    Z[0] / H,
                    Z[1] / H
                ], ae = [
                    o[0] + ne[0] * h * v,
                    o[1] + ne[1] * h * v
                ];
                return {
                    arc1Start: S,
                    arc1End: P,
                    arc2Start: G,
                    arc2End: ae,
                    arc1Angle: c > 90 ? 180 - c : c,
                    arc2Angle: l > 90 ? 180 - l : l
                };
            }, this._throttledCalculateCachedStats = tl(this._calculateCachedStats, 25, {
                trailing: !0
            });
        }
        handleSelectedCallback(e, n, r, i = "mouse") {
            const a = e.detail, { element: o } = a, { data: s } = n;
            n.highlighted = !0;
            let c = !1, l;
            r.worldPosition ? c = !0 : l = s.handles.points.findIndex((u)=>u === r);
            const f = rn(o, this.getToolName());
            this.editData = {
                annotation: n,
                viewportIdsToRender: f,
                handleIndex: l,
                movingTextBox: c
            }, this._activateModify(o), Mn(o), it(f), e.preventDefault();
        }
        _calculateCachedStats(e, n, r) {
            const i = e.data;
            if (i.handles.points.length !== 4) return;
            const a = [
                null,
                null
            ], o = [
                null,
                null
            ];
            let s = Number.MAX_VALUE;
            for(let P = 0; P < 2; P += 1)for(let F = 2; F < 4; F += 1){
                const N = rc(i.handles.points[P], i.handles.points[F]);
                N < s && (s = N, a[1] = i.handles.points[P], a[0] = i.handles.points[(P + 1) % 2], o[0] = i.handles.points[F], o[1] = i.handles.points[2 + (F - 1) % 2]);
            }
            const { viewport: c } = r, { element: l } = c, f = i.handles.points.map((P)=>c.worldToCanvas(P)), u = [
                f[0],
                f[1]
            ], g = [
                f[2],
                f[3]
            ], h = Vc(u[0], u[1]), v = Vc(g[0], g[1]), { arc1Start: m, arc1End: y, arc2End: C, arc2Start: T, arc1Angle: x, arc2Angle: S } = this.getArcsStartEndPoints({
                firstLine: u,
                secondLine: g,
                mid1: h,
                mid2: v
            }), { cachedStats: D } = i, _ = Object.keys(D);
            for(let P = 0; P < _.length; P++){
                const F = _[P];
                D[F] = {
                    angle: xh(a, o),
                    arc1Angle: x,
                    arc2Angle: S,
                    points: {
                        canvas: {
                            arc1Start: m,
                            arc1End: y,
                            arc2End: C,
                            arc2Start: T
                        },
                        world: {
                            arc1Start: c.canvasToWorld(m),
                            arc1End: c.canvasToWorld(y),
                            arc2End: c.canvasToWorld(C),
                            arc2Start: c.canvasToWorld(T)
                        }
                    }
                };
            }
            const M = e.invalidated;
            return e.invalidated = !1, M && yn(e, l, Jt.StatsUpdated), D;
        }
    }
    function Rne(t, e) {
        const n = t.cachedStats[e], { angle: r } = n;
        return r === void 0 ? void 0 : [
            `${r.toFixed(2)} °`
        ];
    }
    class Vu {
        static instance;
        logs = [];
        static getInstance() {
            return Vu.instance || (Vu.instance = new Vu), Vu.instance;
        }
        formatTimestamp() {
            return new Date().toISOString().split("T")[1].slice(0, -1);
        }
        log(e, n) {
            const r = {
                timestamp: this.formatTimestamp(),
                level: "INFO",
                message: e,
                data: n
            };
            this.logs.push(r), console.log(`🔍 [${r.timestamp}] ${e}`, n || "");
        }
        error(e, n) {
            const r = {
                timestamp: this.formatTimestamp(),
                level: "ERROR",
                message: e,
                data: n
            };
            this.logs.push(r), console.error(`❌ [${r.timestamp}] ${e}`, n || ""), n && (n instanceof Error ? console.error("Error details:", {
                name: n.name,
                message: n.message,
                stack: n.stack
            }) : console.error("Error object:", n));
        }
        warn(e, n) {
            const r = {
                timestamp: this.formatTimestamp(),
                level: "WARN",
                message: e,
                data: n
            };
            this.logs.push(r), console.warn(`⚠️ [${r.timestamp}] ${e}`, n || "");
        }
        success(e, n) {
            const r = {
                timestamp: this.formatTimestamp(),
                level: "SUCCESS",
                message: e,
                data: n
            };
            this.logs.push(r), console.log(`✅ [${r.timestamp}] ${e}`, n || "");
        }
        progress(e, n, r, i) {
            const a = Math.round(n / r * 100), o = `${e}: ${n}/${r} (${a}%)${i ? ` - ${i}` : ""}`;
            this.log(o);
        }
        dumpLogs() {
            console.group("🔍 DICOM 렌더링 디버그 로그"), this.logs.forEach((e)=>{
                this.getLogStyle(e.level), console.log(`[${e.timestamp}] ${e.level}: ${e.message}`, e.data || "");
            }), console.groupEnd();
        }
        dumpErrors() {
            const e = this.logs.filter((n)=>n.level === "ERROR");
            e.length > 0 && (console.group("❌ DICOM 렌더링 오류 요약"), e.forEach((n)=>{
                console.error(`[${n.timestamp}] ${n.message}`, n.data || "");
            }), console.groupEnd());
        }
        getRecentLogs(e = 10) {
            return this.logs.slice(-e);
        }
        clear() {
            this.logs = [], console.clear(), this.log("디버그 로그가 초기화되었습니다");
        }
        getLogStyle(e) {
            switch(e){
                case "ERROR":
                    return "color: #ef4444; font-weight: bold;";
                case "WARN":
                    return "color: #f59e0b; font-weight: bold;";
                case "SUCCESS":
                    return "color: #10b981; font-weight: bold;";
                default:
                    return "color: #6b7280;";
            }
        }
        time(e) {
            console.time(`⏱️ ${e}`), this.log(`시간 측정 시작: ${e}`);
        }
        timeEnd(e) {
            console.timeEnd(`⏱️ ${e}`), this.log(`시간 측정 종료: ${e}`);
        }
        logMemoryUsage() {
            if (performance.memory) {
                const e = {
                    used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                    total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                };
                this.log("메모리 사용량", e);
            }
        }
    }
    const st = Vu.getInstance();
    typeof window < "u" && (window.dicomDebugLogger = st);
    const One = "modulepreload", Ine = function(t) {
        return "/" + t;
    }, s7 = {}, y2 = function(e, n, r) {
        let i = Promise.resolve();
        if (n && n.length > 0) {
            let c = function(l) {
                return Promise.all(l.map((f)=>Promise.resolve(f).then((u)=>({
                            status: "fulfilled",
                            value: u
                        }), (u)=>({
                            status: "rejected",
                            reason: u
                        }))));
            };
            document.getElementsByTagName("link");
            const o = document.querySelector("meta[property=csp-nonce]"), s = o?.nonce || o?.getAttribute("nonce");
            i = c(n.map((l)=>{
                if (l = Ine(l), l in s7) return;
                s7[l] = !0;
                const f = l.endsWith(".css"), u = f ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${l}"]${u}`)) return;
                const g = document.createElement("link");
                if (g.rel = f ? "stylesheet" : One, f || (g.as = "script"), g.crossOrigin = "", g.href = l, s && g.setAttribute("nonce", s), document.head.appendChild(g), f) return new Promise((h, v)=>{
                    g.addEventListener("load", h), g.addEventListener("error", ()=>v(new Error(`Unable to preload CSS for ${l}`)));
                });
            }));
        }
        function a(o) {
            const s = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (s.payload = o, window.dispatchEvent(s), !s.defaultPrevented) throw o;
        }
        return i.then((o)=>{
            for (const s of o || [])s.status === "rejected" && a(s.reason);
            return e().catch(a);
        });
    };
    function kO(t, e, n) {
        if (t === void 0) throw new Error("decodeRGB: rgbBuffer must be defined");
        if (t.length % 3 !== 0) throw new Error(`decodeRGB: rgbBuffer length ${t.length} must be divisible by 3`);
        const r = t.length / 3;
        let i = 0, a = 0;
        if (n) {
            for(let o = 0; o < r; o++)e[a++] = t[i++], e[a++] = t[i++], e[a++] = t[i++], e[a++] = 255;
            return;
        }
        e.set(t);
    }
    function UO(t, e, n) {
        if (t === void 0) throw new Error("decodeRGB: rgbBuffer must be defined");
        if (t.length % 3 !== 0) throw new Error(`decodeRGB: rgbBuffer length ${t.length} must be divisible by 3`);
        const r = t.length / 3;
        let i = 0, a = 0, o = r, s = r * 2;
        if (n) for(let c = 0; c < r; c++)e[i++] = t[a++], e[i++] = t[o++], e[i++] = t[s++], e[i++] = 255;
        else for(let c = 0; c < r; c++)e[i++] = t[a++], e[i++] = t[o++], e[i++] = t[s++];
    }
    function FO(t, e, n) {
        if (t === void 0) throw new Error("convertYBRFullByPixel: ybrBuffer must be defined");
        if (t.length % 3 !== 0) throw new Error(`convertYBRFullByPixel: ybrBuffer length ${t.length} must be divisible by 3`);
        const r = t.length / 3;
        let i = 0, a = 0;
        if (n) {
            for(let o = 0; o < r; o++){
                const s = t[i++], c = t[i++], l = t[i++];
                e[a++] = s + 1.402 * (l - 128), e[a++] = s - .34414 * (c - 128) - .71414 * (l - 128), e[a++] = s + 1.772 * (c - 128), e[a++] = 255;
            }
            return;
        }
        for(let o = 0; o < r; o++){
            const s = t[i++], c = t[i++], l = t[i++];
            e[a++] = s + 1.402 * (l - 128), e[a++] = s - .34414 * (c - 128) - .71414 * (l - 128), e[a++] = s + 1.772 * (c - 128);
        }
    }
    function BO(t, e, n) {
        if (t === void 0) throw new Error("convertYBRFullByPlane: ybrBuffer must be defined");
        if (t.length % 3 !== 0) throw new Error(`convertYBRFullByPlane: ybrBuffer length ${t.length} must be divisible by 3`);
        const r = t.length / 3;
        let i = 0, a = 0, o = r, s = r * 2;
        if (n) {
            for(let c = 0; c < r; c++){
                const l = t[a++], f = t[o++], u = t[s++];
                e[i++] = l + 1.402 * (u - 128), e[i++] = l - .34414 * (f - 128) - .71414 * (u - 128), e[i++] = l + 1.772 * (f - 128), e[i++] = 255;
            }
            return;
        }
        for(let c = 0; c < r; c++){
            const l = t[a++], f = t[o++], u = t[s++];
            e[i++] = l + 1.402 * (u - 128), e[i++] = l - .34414 * (f - 128) - .71414 * (u - 128), e[i++] = l + 1.772 * (f - 128);
        }
    }
    function Mne(t, e, n) {
        if (t === void 0) throw new Error("convertYBRFull422ByPixel: ybrBuffer must be defined");
        if (t.length % 2 !== 0) throw new Error(`convertYBRFull422ByPixel: ybrBuffer length ${t.length} must be divisible by 2`);
        const r = t.length / 2;
        let i = 0, a = 0;
        if (n) {
            for(let o = 0; o < r; o += 2){
                const s = t[i++], c = t[i++], l = t[i++], f = t[i++];
                e[a++] = s + 1.402 * (f - 128), e[a++] = s - .34414 * (l - 128) - .71414 * (f - 128), e[a++] = s + 1.772 * (l - 128), e[a++] = 255, e[a++] = c + 1.402 * (f - 128), e[a++] = c - .34414 * (l - 128) - .71414 * (f - 128), e[a++] = c + 1.772 * (l - 128), e[a++] = 255;
            }
            return;
        }
        for(let o = 0; o < r; o += 2){
            const s = t[i++], c = t[i++], l = t[i++], f = t[i++];
            e[a++] = s + 1.402 * (f - 128), e[a++] = s - .34414 * (l - 128) - .71414 * (f - 128), e[a++] = s + 1.772 * (l - 128), e[a++] = c + 1.402 * (f - 128), e[a++] = c - .34414 * (l - 128) - .71414 * (f - 128), e[a++] = c + 1.772 * (l - 128);
        }
    }
    function q5(t, e) {
        const n = t.length, r = new Uint8ClampedArray(n);
        for(let i = 0; i < n; ++i)r[i] = t[i] >> e;
        return r;
    }
    function X5(t, e, n) {
        const r = t[`${e}PaletteColorLookupTableData`];
        if (r) return Promise.resolve(r);
        const i = ct("imagePixelModule", t.imageId);
        return i && typeof i.then == "function" ? i.then((a)=>a ? a[`${e}PaletteColorLookupTableData`] : n) : Promise.resolve(i ? i[`${e}PaletteColorLookupTableData`] : n);
    }
    function GO(t, e, n) {
        const r = t.columns * t.rows, i = t.pixelData;
        Promise.all([
            X5(t, "red", null),
            X5(t, "green", null),
            X5(t, "blue", null)
        ]).then(([a, o, s])=>{
            if (!a || !o || !s) throw new Error("The image does not have a complete color palette. R, G, and B palette data are required.");
            const c = a.length;
            let l = 0, f = 0;
            const u = t.redPaletteColorLookupTableDescriptor[1], g = t.redPaletteColorLookupTableDescriptor[2] === 8 ? 0 : 8, h = q5(a, g), v = q5(o, g), m = q5(s, g);
            if (n) {
                for(let y = 0; y < r; ++y){
                    let C = i[l++];
                    C < u ? C = 0 : C > u + c - 1 ? C = c - 1 : C -= u, e[f++] = h[C], e[f++] = v[C], e[f++] = m[C], e[f++] = 255;
                }
                return;
            }
            for(let y = 0; y < r; ++y){
                let C = i[l++];
                C < u ? C = 0 : C > u + c - 1 ? C = c - 1 : C -= u, e[f++] = h[C], e[f++] = v[C], e[f++] = m[C];
            }
        });
    }
    function Y5(t, e) {
        if (!(!t.elements[e] || t.elements[e].length !== 6)) return [
            t.uint16(e, 0),
            t.uint16(e, 1),
            t.uint16(e, 2)
        ];
    }
    function Z5(t, e, n) {
        const r = [], i = t.elements[e];
        for(let a = 0; a < n[0]; a++)n[2] === 16 ? r[a] = t.uint16(e, a) : r[a] = t.byteArray[a + i.dataOffset];
        return r;
    }
    function bne(t, e) {
        e.redPaletteColorLookupTableDescriptor = Y5(t, "x00281101"), e.greenPaletteColorLookupTableDescriptor = Y5(t, "x00281102"), e.bluePaletteColorLookupTableDescriptor = Y5(t, "x00281103"), e.redPaletteColorLookupTableDescriptor[0] === 0 && (e.redPaletteColorLookupTableDescriptor[0] = 65536, e.greenPaletteColorLookupTableDescriptor[0] = 65536, e.bluePaletteColorLookupTableDescriptor[0] = 65536);
        const n = e.redPaletteColorLookupTableDescriptor[0], i = t.elements.x00281201.length === n ? 8 : 16;
        e.redPaletteColorLookupTableDescriptor[2] !== i && (e.redPaletteColorLookupTableDescriptor[2] = i, e.greenPaletteColorLookupTableDescriptor[2] = i, e.bluePaletteColorLookupTableDescriptor[2] = i), e.redPaletteColorLookupTableData = Z5(t, "x00281201", e.redPaletteColorLookupTableDescriptor), e.greenPaletteColorLookupTableData = Z5(t, "x00281202", e.greenPaletteColorLookupTableDescriptor), e.bluePaletteColorLookupTableData = Z5(t, "x00281203", e.bluePaletteColorLookupTableDescriptor);
    }
    function Lne(t, e) {
        t.uint16("x00280103") === 0 ? (e.smallestPixelValue = t.uint16("x00280106"), e.largestPixelValue = t.uint16("x00280107")) : (e.smallestPixelValue = t.int16("x00280106"), e.largestPixelValue = t.int16("x00280107"));
    }
    function WO(t) {
        const e = {
            samplesPerPixel: t.uint16("x00280002"),
            photometricInterpretation: t.string("x00280004"),
            rows: t.uint16("x00280010"),
            columns: t.uint16("x00280011"),
            bitsAllocated: t.uint16("x00280100"),
            bitsStored: t.uint16("x00280101"),
            highBit: t.uint16("x00280102"),
            pixelRepresentation: t.uint16("x00280103"),
            planarConfiguration: t.uint16("x00280006"),
            pixelAspectRatio: t.string("x00280034")
        };
        return Lne(t, e), e.photometricInterpretation === "PALETTE COLOR" && t.elements.x00281101 && bne(t, e), e;
    }
    function Pne(t, e) {
        let n = e.uint16("x00283002", 0);
        n === 0 && (n = 65535);
        let r = 0;
        t === 0 ? r = e.uint16("x00283002", 1) : r = e.int16("x00283002", 1);
        const i = e.uint16("x00283002", 2), a = {
            id: "1",
            firstValueMapped: r,
            numBitsPerEntry: i,
            lut: []
        };
        for(let o = 0; o < n; o++)t === 0 ? a.lut[o] = e.uint16("x00283006", o) : a.lut[o] = e.int16("x00283006", o);
        return a;
    }
    function a3(t, e) {
        if (!e || !e.items || !e.items.length) return;
        const n = [];
        for(let r = 0; r < e.items.length; r++){
            const i = e.items[r].dataSet, a = Pne(t, i);
            a && n.push(a);
        }
        return n;
    }
    function Vne(t) {
        const e = t.uint16("x00280103"), n = t.uint16("x00280101");
        return e === 0 ? 0 : -1 << n - 1;
    }
    function $O(t) {
        const e = t.string("x00080016");
        if (e === "1.2.840.10008.5.1.4.1.1.2" || e === "1.2.840.10008.5.1.4.1.1.2.1") return 1;
        const n = t.floatString("x00281052"), r = t.floatString("x00281053");
        return n !== void 0 && r !== void 0 ? Vne(t) * r + n < 0 ? 1 : 0 : t.elements.x00283000 && t.elements.x00283000.length > 0 ? 0 : t.uint16("x00280103");
    }
    function Ss(t, e, n) {
        const r = [], i = t.string(e);
        if (!i) return;
        const a = i.split("\\");
        if (!(n && a.length < n)) {
            for(let o = 0; o < a.length; o++)r.push(parseFloat(a[o]));
            return r;
        }
    }
    var Eh = {
        exports: {}
    };
    var Nne = Eh.exports, c7;
    function Ane() {
        return c7 || (c7 = 1, function(t, e) {
            (function(n, r) {
                t.exports = r(ec);
            })(Nne, function(n) {
                return i = [
                    function(o, s) {
                        o.exports = n;
                    },
                    function(o, s, c) {
                        c.r(s), c.d(s, "isStringVr", function() {
                            return f;
                        }), c.d(s, "isPrivateTag", function() {
                            return u;
                        }), c.d(s, "parsePN", function() {
                            return g;
                        }), c.d(s, "parseTM", function() {
                            return h;
                        }), c.d(s, "parseDA", function() {
                            return m;
                        }), c.d(s, "explicitElementToString", function() {
                            return y;
                        }), c.d(s, "explicitDataSetToJS", function() {
                            return C;
                        }), c.d(s, "createJPEGBasicOffsetTable", function() {
                            return S;
                        }), c.d(s, "parseDicomDataSetExplicit", function() {
                            return ie;
                        }), c.d(s, "parseDicomDataSetImplicit", function() {
                            return he;
                        }), c.d(s, "readFixedString", function() {
                            return P;
                        }), c.d(s, "alloc", function() {
                            return $e;
                        }), c.d(s, "version", function() {
                            return je;
                        }), c.d(s, "bigEndianByteArrayParser", function() {
                            return He;
                        }), c.d(s, "ByteStream", function() {
                            return et;
                        }), c.d(s, "sharedCopy", function() {
                            return rt;
                        }), c.d(s, "DataSet", function() {
                            return B;
                        }), c.d(s, "findAndSetUNElementLength", function() {
                            return M;
                        }), c.d(s, "findEndOfEncapsulatedElement", function() {
                            return _;
                        }), c.d(s, "findItemDelimitationItemAndSetElementLength", function() {
                            return G;
                        }), c.d(s, "littleEndianByteArrayParser", function() {
                            return St;
                        }), c.d(s, "parseDicom", function() {
                            return zt;
                        }), c.d(s, "readDicomElementExplicit", function() {
                            return X;
                        }), c.d(s, "readDicomElementImplicit", function() {
                            return H;
                        }), c.d(s, "readEncapsulatedImageFrame", function() {
                            return ln;
                        }), c.d(s, "readEncapsulatedPixelData", function() {
                            return Un;
                        }), c.d(s, "readEncapsulatedPixelDataFromFragments", function() {
                            return Ct;
                        }), c.d(s, "readPart10Header", function() {
                            return Ln;
                        }), c.d(s, "readSequenceItemsExplicit", function() {
                            return oe;
                        }), c.d(s, "readSequenceItemsImplicit", function() {
                            return ue;
                        }), c.d(s, "readSequenceItem", function() {
                            return ne;
                        }), c.d(s, "readTag", function() {
                            return D;
                        });
                        var l = {
                            AE: !0,
                            AS: !0,
                            AT: !1,
                            CS: !0,
                            DA: !0,
                            DS: !0,
                            DT: !0,
                            FL: !1,
                            FD: !1,
                            IS: !0,
                            LO: !0,
                            LT: !0,
                            OB: !1,
                            OD: !1,
                            OF: !1,
                            OW: !1,
                            PN: !0,
                            SH: !0,
                            SL: !1,
                            SQ: !1,
                            SS: !1,
                            ST: !0,
                            TM: !0,
                            UI: !0,
                            UL: !1,
                            UN: void 0,
                            UR: !0,
                            US: !1,
                            UT: !0
                        }, f = function(q) {
                            return l[q];
                        }, u = function(q) {
                            if (q = parseInt(q[4], 16), isNaN(q)) throw "dicomParser.isPrivateTag: cannot parse last character of group";
                            return q % 2 == 1;
                        }, g = function(q) {
                            if (q !== void 0) return q = q.split("^"), {
                                familyName: q[0],
                                givenName: q[1],
                                middleName: q[2],
                                prefix: q[3],
                                suffix: q[4]
                            };
                        };
                        function h(q, Q) {
                            if (2 <= q.length) {
                                var me = parseInt(q.substring(0, 2), 10), J = 4 <= q.length ? parseInt(q.substring(2, 4), 10) : void 0, Ce = 6 <= q.length ? parseInt(q.substring(4, 6), 10) : void 0, Ue = 8 <= q.length ? q.substring(7, 13) : void 0, Ue = Ue ? parseInt(Ue, 10) * Math.pow(10, 6 - Ue.length) : void 0;
                                if (Q && (isNaN(me) || J !== void 0 && isNaN(J) || Ce !== void 0 && isNaN(Ce) || Ue !== void 0 && isNaN(Ue) || me < 0 || 23 < me || J && (J < 0 || 59 < J) || Ce && (Ce < 0 || 59 < Ce) || Ue && (Ue < 0 || 999999 < Ue))) throw "invalid TM '".concat(q, "'");
                                return {
                                    hours: me,
                                    minutes: J,
                                    seconds: Ce,
                                    fractionalSeconds: Ue
                                };
                            }
                            if (Q) throw "invalid TM '".concat(q, "'");
                        }
                        function v(q, Q, me) {
                            return !isNaN(me) && 0 < Q && Q <= 12 && 0 < q && q <= function(J, Ce) {
                                switch(J){
                                    case 2:
                                        return Ce % 4 == 0 && Ce % 100 || Ce % 400 == 0 ? 29 : 28;
                                    case 9:
                                    case 4:
                                    case 6:
                                    case 11:
                                        return 30;
                                    default:
                                        return 31;
                                }
                            }(Q, me);
                        }
                        function m(q, Q) {
                            if (q && q.length === 8) {
                                var me = parseInt(q.substring(0, 4), 10), J = parseInt(q.substring(4, 6), 10), Ce = parseInt(q.substring(6, 8), 10);
                                if (Q && v(Ce, J, me) !== !0) throw "invalid DA '".concat(q, "'");
                                return {
                                    year: me,
                                    month: J,
                                    day: Ce
                                };
                            }
                            if (Q) throw "invalid DA '".concat(q, "'");
                        }
                        function y(q, Q) {
                            if (q === void 0 || Q === void 0) throw "dicomParser.explicitElementToString: missing required parameters";
                            if (Q.vr === void 0) throw "dicomParser.explicitElementToString: cannot convert implicit element to string";
                            var me, J = Q.vr, Ce = Q.tag;
                            function Ue(Mt, jt) {
                                for(var Cn = "", tn = 0; tn < Mt; tn++)tn !== 0 && (Cn += "/"), Cn += jt.call(q, Ce, tn).toString();
                                return Cn;
                            }
                            if (f(J) === !0) me = q.string(Ce);
                            else {
                                if (J === "AT") {
                                    var lt = q.uint32(Ce);
                                    return lt === void 0 ? void 0 : "x".concat((lt = lt < 0 ? 4294967295 + lt + 1 : lt).toString(16).toUpperCase());
                                }
                                J === "US" ? me = Ue(Q.length / 2, q.uint16) : J === "SS" ? me = Ue(Q.length / 2, q.int16) : J === "UL" ? me = Ue(Q.length / 4, q.uint32) : J === "SL" ? me = Ue(Q.length / 4, q.int32) : J === "FD" ? me = Ue(Q.length / 8, q.double) : J === "FL" && (me = Ue(Q.length / 4, q.float));
                            }
                            return me;
                        }
                        function C(q, Q) {
                            if (q === void 0) throw "dicomParser.explicitDataSetToJS: missing required parameter dataSet";
                            Q = Q || {
                                omitPrivateAttibutes: !0,
                                maxElementLength: 128
                            };
                            var me, J = {};
                            for(me in q.elements){
                                var Ce = q.elements[me];
                                if (Q.omitPrivateAttibutes !== !0 || !u(me)) if (Ce.items) {
                                    for(var Ue = [], lt = 0; lt < Ce.items.length; lt++)Ue.push(C(Ce.items[lt].dataSet, Q));
                                    J[me] = Ue;
                                } else {
                                    var Mt = void 0;
                                    Ce.length < Q.maxElementLength && (Mt = y(q, Ce)), J[me] = Mt !== void 0 ? Mt : {
                                        dataOffset: Ce.dataOffset,
                                        length: Ce.length
                                    };
                                }
                            }
                            return J;
                        }
                        function T(q, Q) {
                            return q.byteArray[Q] === 255 && q.byteArray[Q + 1] === 217;
                        }
                        function x(q, Q, me) {
                            for(var J, Ce, Ue = me; Ue < Q.fragments.length; Ue++)if (J = q, Ce = Ue, Ce = Q.fragments[Ce], !(!T(J, Ce.position + Ce.length - 2) && !T(J, Ce.position + Ce.length - 3))) return Ue;
                        }
                        function S(q, Q, me) {
                            if (q === void 0) throw "dicomParser.createJPEGBasicOffsetTable: missing required parameter dataSet";
                            if (Q === void 0) throw "dicomParser.createJPEGBasicOffsetTable: missing required parameter pixelDataElement";
                            if (Q.tag !== "x7fe00010") throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010'";
                            if (Q.encapsulatedPixelData !== !0 || Q.hadUndefinedLength !== !0 || Q.basicOffsetTable === void 0 || Q.fragments === void 0 || Q.fragments.length <= 0) throw "dicomParser.createJPEGBasicOffsetTable: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
                            if (me && me.length <= 0) throw "dicomParser.createJPEGBasicOffsetTable: parameter 'fragments' must not be zero length";
                            me = me || Q.fragments;
                            for(var J = [], Ce = 0;;){
                                J.push(Q.fragments[Ce].offset);
                                var Ue = x(q, Q, Ce);
                                if (Ue === void 0 || Ue === Q.fragments.length - 1) return J;
                                Ce = Ue + 1;
                            }
                        }
                        function D(me) {
                            if (me === void 0) throw "dicomParser.readTag: missing required parameter 'byteStream'";
                            var Q = 256 * me.readUint16() * 256, me = me.readUint16();
                            return "x".concat("00000000".concat((Q + me).toString(16)).substr(-8));
                        }
                        function _(q, Q, me) {
                            if (q === void 0) throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'byteStream'";
                            if (Q === void 0) throw "dicomParser.findEndOfEncapsulatedElement: missing required parameter 'element'";
                            if (Q.encapsulatedPixelData = !0, Q.basicOffsetTable = [], Q.fragments = [], D(q) !== "xfffee000") throw "dicomParser.findEndOfEncapsulatedElement: basic offset table not found";
                            for(var J = q.readUint32() / 4, Ce = 0; Ce < J; Ce++){
                                var Ue = q.readUint32();
                                Q.basicOffsetTable.push(Ue);
                            }
                            for(var lt = q.position; q.position < q.byteArray.length;){
                                var Mt = D(q), jt = q.readUint32();
                                if (Mt === "xfffee0dd") return q.seek(jt), void (Q.length = q.position - Q.dataOffset);
                                if (Mt !== "xfffee000") return me && me.push("unexpected tag ".concat(Mt, " while searching for end of pixel data element with undefined length")), jt > q.byteArray.length - q.position && (jt = q.byteArray.length - q.position), Q.fragments.push({
                                    offset: q.position - lt - 8,
                                    position: q.position,
                                    length: jt
                                }), q.seek(jt), void (Q.length = q.position - Q.dataOffset);
                                Q.fragments.push({
                                    offset: q.position - lt - 8,
                                    position: q.position,
                                    length: jt
                                }), q.seek(jt);
                            }
                            me && me.push("pixel data element ".concat(Q.tag, " missing sequence delimiter tag xfffee0dd"));
                        }
                        function M(q, Q) {
                            if (q === void 0) throw "dicomParser.findAndSetUNElementLength: missing required parameter 'byteStream'";
                            for(var me = q.byteArray.length - 8; q.position <= me;)if (q.readUint16() === 65534) {
                                var J = q.readUint16();
                                if (J === 57565) return q.readUint32() !== 0 && q.warnings("encountered non zero length following item delimiter at position ".concat(q.position - 4, " while reading element of undefined length with tag ").concat(Q.tag)), void (Q.length = q.position - Q.dataOffset);
                            }
                            Q.length = q.byteArray.length - Q.dataOffset, q.seek(q.byteArray.length - q.position);
                        }
                        function P(q, Q, me) {
                            if (me < 0) throw "dicomParser.readFixedString - length cannot be less than 0";
                            if (Q + me > q.length) throw "dicomParser.readFixedString: attempt to read past end of buffer";
                            for(var J, Ce = "", Ue = 0; Ue < me; Ue++){
                                if ((J = q[Q + Ue]) === 0) return Q += me, Ce;
                                Ce += String.fromCharCode(J);
                            }
                            return Ce;
                        }
                        function F(q, Q) {
                            for(var me = 0; me < Q.length; me++){
                                var J = Q[me];
                                J.enumerable = J.enumerable || !1, J.configurable = !0, "value" in J && (J.writable = !0), Object.defineProperty(q, J.key, J);
                            }
                        }
                        function N(q, Q) {
                            return q.parser !== void 0 ? q.parser : Q;
                        }
                        var B = function() {
                            function q(J, Ce, Ue) {
                                (function(lt, Mt) {
                                    if (!(lt instanceof Mt)) throw new TypeError("Cannot call a class as a function");
                                })(this, q), this.byteArrayParser = J, this.byteArray = Ce, this.elements = Ue;
                            }
                            var Q, me;
                            return Q = q, (me = [
                                {
                                    key: "uint16",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readUint16(this.byteArray, J.dataOffset + 2 * Ce);
                                    }
                                },
                                {
                                    key: "int16",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readInt16(this.byteArray, J.dataOffset + 2 * Ce);
                                    }
                                },
                                {
                                    key: "uint32",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readUint32(this.byteArray, J.dataOffset + 4 * Ce);
                                    }
                                },
                                {
                                    key: "int32",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readInt32(this.byteArray, J.dataOffset + 4 * Ce);
                                    }
                                },
                                {
                                    key: "float",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readFloat(this.byteArray, J.dataOffset + 4 * Ce);
                                    }
                                },
                                {
                                    key: "double",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], Ce = Ce !== void 0 ? Ce : 0, J && J.length !== 0) return N(J, this.byteArrayParser).readDouble(this.byteArray, J.dataOffset + 8 * Ce);
                                    }
                                },
                                {
                                    key: "numStringValues",
                                    value: function(J) {
                                        if (J = this.elements[J], J && 0 < J.length) return J = P(this.byteArray, J.dataOffset, J.length).match(/\\/g), J === null ? 1 : J.length + 1;
                                    }
                                },
                                {
                                    key: "string",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], J && J.Value) return J.Value;
                                        if (J && 0 < J.length) return J = P(this.byteArray, J.dataOffset, J.length), 0 <= Ce ? J.split("\\")[Ce].trim() : J.trim();
                                    }
                                },
                                {
                                    key: "text",
                                    value: function(J, Ce) {
                                        if (J = this.elements[J], J && 0 < J.length) return J = P(this.byteArray, J.dataOffset, J.length), 0 <= Ce ? J.split("\\")[Ce].replace(/ +$/, "") : J.replace(/ +$/, "");
                                    }
                                },
                                {
                                    key: "floatString",
                                    value: function(J, Ce) {
                                        var Ue = this.elements[J];
                                        if (Ue && 0 < Ue.length && (Ce = this.string(J, Ce = Ce !== void 0 ? Ce : 0), Ce !== void 0)) return parseFloat(Ce);
                                    }
                                },
                                {
                                    key: "intString",
                                    value: function(J, Ce) {
                                        var Ue = this.elements[J];
                                        if (Ue && 0 < Ue.length && (Ce = this.string(J, Ce = Ce !== void 0 ? Ce : 0), Ce !== void 0)) return parseInt(Ce);
                                    }
                                },
                                {
                                    key: "attributeTag",
                                    value: function(J) {
                                        var Ce = this.elements[J];
                                        if (Ce && Ce.length === 4) {
                                            var Ue = N(Ce, this.byteArrayParser).readUint16, J = this.byteArray, Ce = Ce.dataOffset;
                                            return "x".concat("00000000".concat((256 * Ue(J, Ce) * 256 + Ue(J, Ce + 2)).toString(16)).substr(-8));
                                        }
                                    }
                                }
                            ]) && F(Q.prototype, me), Object.defineProperty(Q, "prototype", {
                                writable: !1
                            }), q;
                        }();
                        function G(q, Q) {
                            if (q === void 0) throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
                            for(var me = q.byteArray.length - 8; q.position <= me;)if (q.readUint16() === 65534) {
                                var J = q.readUint16();
                                if (J === 57357) return q.readUint32() !== 0 && q.warnings("encountered non zero length following item delimiter at position ".concat(q.position - 4, " while reading element of undefined length with tag ").concat(Q.tag)), void (Q.length = q.position - Q.dataOffset);
                            }
                            Q.length = q.byteArray.length - Q.dataOffset, q.seek(q.byteArray.length - q.position);
                        }
                        var Z = function(q, Q) {
                            return q.vr !== void 0 ? q.vr === "SQ" : Q.position + 4 <= Q.byteArray.length ? (q = D(Q), Q.seek(-4), q === "xfffee000" || q === "xfffee0dd") : (Q.warnings.push("eof encountered before finding sequence item tag or sequence delimiter tag in peeking to determine VR"), !1);
                        };
                        function H(q, Q, me) {
                            if (q === void 0) throw "dicomParser.readDicomElementImplicit: missing required parameter 'byteStream'";
                            var J = D(q), J = {
                                tag: J,
                                vr: me !== void 0 ? me(J) : void 0,
                                length: q.readUint32(),
                                dataOffset: q.position
                            };
                            return J.length === 4294967295 && (J.hadUndefinedLength = !0), J.tag === Q || (!Z(J, q) || u(J.tag) && !J.hadUndefinedLength ? J.hadUndefinedLength ? G(q, J) : q.seek(J.length) : (ue(q, J, me), u(J.tag) && (J.items = void 0))), J;
                        }
                        function ne(q) {
                            if (q === void 0) throw "dicomParser.readSequenceItem: missing required parameter 'byteStream'";
                            var Q = {
                                tag: D(q),
                                length: q.readUint32(),
                                dataOffset: q.position
                            };
                            if (Q.tag !== "xfffee000") throw "dicomParser.readSequenceItem: item tag (FFFE,E000) not found at offset ".concat(q.position);
                            return Q;
                        }
                        function ae(q, Q) {
                            var me = ne(q);
                            return me.length === 4294967295 ? (me.hadUndefinedLength = !0, me.dataSet = function(J, Ce) {
                                for(var Ue = {}; J.position < J.byteArray.length;){
                                    var lt = H(J, void 0, Ce);
                                    if ((Ue[lt.tag] = lt).tag === "xfffee00d") return new B(J.byteArrayParser, J.byteArray, Ue);
                                }
                                return J.warnings.push("eof encountered before finding sequence item delimiter in sequence item of undefined length"), new B(J.byteArrayParser, J.byteArray, Ue);
                            }(q, Q), me.length = q.position - me.dataOffset) : (me.dataSet = new B(q.byteArrayParser, q.byteArray, {}), he(me.dataSet, q, q.position + me.length, {
                                vrCallback: Q
                            })), me;
                        }
                        function ue(q, Q, me) {
                            if (q === void 0) throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'byteStream'";
                            if (Q === void 0) throw "dicomParser.readSequenceItemsImplicit: missing required parameter 'element'";
                            Q.items = [], (Q.length === 4294967295 ? function(J, Ce, Ue) {
                                for(; J.position + 4 <= J.byteArray.length;){
                                    var lt = D(J);
                                    if (J.seek(-4), lt === "xfffee0dd") return Ce.length = J.position - Ce.dataOffset, J.seek(8);
                                    lt = ae(J, Ue), Ce.items.push(lt);
                                }
                                J.warnings.push("eof encountered before finding sequence delimiter in sequence of undefined length"), Ce.length = J.byteArray.length - Ce.dataOffset;
                            } : function(J, Ce, Ue) {
                                for(var lt = Ce.dataOffset + Ce.length; J.position < lt;){
                                    var Mt = ae(J, Ue);
                                    Ce.items.push(Mt);
                                }
                            })(q, Q, me);
                        }
                        function le(q, Q) {
                            var me = ne(q);
                            return me.length === 4294967295 ? (me.hadUndefinedLength = !0, me.dataSet = function(J, Ce) {
                                for(var Ue = {}; J.position < J.byteArray.length;){
                                    var lt = X(J, Ce);
                                    if ((Ue[lt.tag] = lt).tag === "xfffee00d") return new B(J.byteArrayParser, J.byteArray, Ue);
                                }
                                return Ce.push("eof encountered before finding item delimiter tag while reading sequence item of undefined length"), new B(J.byteArrayParser, J.byteArray, Ue);
                            }(q, Q), me.length = q.position - me.dataOffset) : (me.dataSet = new B(q.byteArrayParser, q.byteArray, {}), ie(me.dataSet, q, q.position + me.length)), me;
                        }
                        function oe(q, Q, me) {
                            if (q === void 0) throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'byteStream'";
                            if (Q === void 0) throw "dicomParser.readSequenceItemsExplicit: missing required parameter 'element'";
                            Q.items = [], (Q.length === 4294967295 ? function(J, Ce, Ue) {
                                for(; J.position + 4 <= J.byteArray.length;){
                                    var lt = D(J);
                                    if (J.seek(-4), lt === "xfffee0dd") return Ce.length = J.position - Ce.dataOffset, J.seek(8);
                                    lt = le(J, Ue), Ce.items.push(lt);
                                }
                                Ue.push("eof encountered before finding sequence delimitation tag while reading sequence of undefined length"), Ce.length = J.position - Ce.dataOffset;
                            } : function(J, Ce, Ue) {
                                for(var lt = Ce.dataOffset + Ce.length; J.position < lt;){
                                    var Mt = le(J, Ue);
                                    Ce.items.push(Mt);
                                }
                            })(q, Q, me);
                        }
                        var re = function(q) {
                            return q === "OB" || q === "OD" || q === "OL" || q === "OW" || q === "SQ" || q === "OF" || q === "UC" || q === "UR" || q === "UT" || q === "UN" ? 4 : 2;
                        };
                        function X(q, Q, me) {
                            if (q === void 0) throw "dicomParser.readDicomElementExplicit: missing required parameter 'byteStream'";
                            var J = {
                                tag: D(q),
                                vr: q.readFixedString(2)
                            };
                            return re(J.vr) === 2 ? J.length = q.readUint16() : (q.seek(2), J.length = q.readUint32()), J.dataOffset = q.position, J.length === 4294967295 && (J.hadUndefinedLength = !0), J.tag === me || (J.vr === "SQ" ? oe(q, J, Q) : J.length === 4294967295 ? J.tag === "x7fe00010" ? _(q, J, Q) : (J.vr === "UN" ? ue : G)(q, J) : q.seek(J.length)), J;
                        }
                        function ie(q, Q, me) {
                            var J = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : {};
                            if (me = me === void 0 ? Q.byteArray.length : me, Q === void 0) throw "dicomParser.parseDicomDataSetExplicit: missing required parameter 'byteStream'";
                            if (me < Q.position || me > Q.byteArray.length) throw "dicomParser.parseDicomDataSetExplicit: invalid value for parameter 'maxP osition'";
                            for(var Ce = q.elements; Q.position < me;){
                                var Ue = X(Q, q.warnings, J.untilTag);
                                if ((Ce[Ue.tag] = Ue).tag === J.untilTag) return;
                            }
                            if (Q.position > me) throw "dicomParser:parseDicomDataSetExplicit: buffer overrun";
                        }
                        function he(q, Q, me) {
                            var J = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : {};
                            if (me = me === void 0 ? q.byteArray.length : me, Q === void 0) throw "dicomParser.parseDicomDataSetImplicit: missing required parameter 'byteStream'";
                            if (me < Q.position || me > Q.byteArray.length) throw "dicomParser.parseDicomDataSetImplicit: invalid value for parameter 'maxPosition'";
                            for(var Ce = q.elements; Q.position < me;){
                                var Ue = H(Q, J.untilTag, J.vrCallback);
                                if ((Ce[Ue.tag] = Ue).tag === J.untilTag) return;
                            }
                        }
                        function $e(q, Q) {
                            if (typeof Buffer < "u" && q instanceof Buffer) return Buffer.alloc(Q);
                            if (q instanceof Uint8Array) return new Uint8Array(Q);
                            throw "dicomParser.alloc: unknown type for byteArray";
                        }
                        var je = "1.8.12", He = {
                            readUint16: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readUint16: position cannot be less than 0";
                                if (Q + 2 > q.length) throw "bigEndianByteArrayParser.readUint16: attempt to read past end of buffer";
                                return (q[Q] << 8) + q[Q + 1];
                            },
                            readInt16: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readInt16: position cannot be less than 0";
                                if (Q + 2 > q.length) throw "bigEndianByteArrayParser.readInt16: attempt to read past end of buffer";
                                return Q = (q[Q] << 8) + q[Q + 1], Q = 32768 & Q ? Q - 65535 - 1 : Q;
                            },
                            readUint32: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readUint32: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "bigEndianByteArrayParser.readUint32: attempt to read past end of buffer";
                                return 256 * (256 * (256 * q[Q] + q[Q + 1]) + q[Q + 2]) + q[Q + 3];
                            },
                            readInt32: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readInt32: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "bigEndianByteArrayParser.readInt32: attempt to read past end of buffer";
                                return (q[Q] << 24) + (q[Q + 1] << 16) + (q[Q + 2] << 8) + q[Q + 3];
                            },
                            readFloat: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readFloat: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "bigEndianByteArrayParser.readFloat: attempt to read past end of buffer";
                                var me = new Uint8Array(4);
                                return me[3] = q[Q], me[2] = q[Q + 1], me[1] = q[Q + 2], me[0] = q[Q + 3], new Float32Array(me.buffer)[0];
                            },
                            readDouble: function(q, Q) {
                                if (Q < 0) throw "bigEndianByteArrayParser.readDouble: position cannot be less than 0";
                                if (Q + 8 > q.length) throw "bigEndianByteArrayParser.readDouble: attempt to read past end of buffer";
                                var me = new Uint8Array(8);
                                return me[7] = q[Q], me[6] = q[Q + 1], me[5] = q[Q + 2], me[4] = q[Q + 3], me[3] = q[Q + 4], me[2] = q[Q + 5], me[1] = q[Q + 6], me[0] = q[Q + 7], new Float64Array(me.buffer)[0];
                            }
                        };
                        function rt(q, Q, me) {
                            if (typeof Buffer < "u" && q instanceof Buffer) return q.slice(Q, Q + me);
                            if (q instanceof Uint8Array) return new Uint8Array(q.buffer, q.byteOffset + Q, me);
                            throw "dicomParser.from: unknown type for byteArray";
                        }
                        function Qe(q, Q) {
                            for(var me = 0; me < Q.length; me++){
                                var J = Q[me];
                                J.enumerable = J.enumerable || !1, J.configurable = !0, "value" in J && (J.writable = !0), Object.defineProperty(q, J.key, J);
                            }
                        }
                        var et = function() {
                            function q(J, Ce, Ue) {
                                if (function(lt, Mt) {
                                    if (!(lt instanceof Mt)) throw new TypeError("Cannot call a class as a function");
                                }(this, q), J === void 0) throw "dicomParser.ByteStream: missing required parameter 'byteArrayParser'";
                                if (Ce === void 0) throw "dicomParser.ByteStream: missing required parameter 'byteArray'";
                                if (!(Ce instanceof Uint8Array) && (typeof Buffer > "u" || !(Ce instanceof Buffer))) throw "dicomParser.ByteStream: parameter byteArray is not of type Uint8Array or Buffer";
                                if (Ue < 0) throw "dicomParser.ByteStream: parameter 'position' cannot be less than 0";
                                if (Ue >= Ce.length) throw "dicomParser.ByteStream: parameter 'position' cannot be greater than or equal to 'byteArray' length";
                                this.byteArrayParser = J, this.byteArray = Ce, this.position = Ue || 0, this.warnings = [];
                            }
                            var Q, me;
                            return Q = q, (me = [
                                {
                                    key: "seek",
                                    value: function(J) {
                                        if (this.position + J < 0) throw "dicomParser.ByteStream.prototype.seek: cannot seek to position < 0";
                                        this.position += J;
                                    }
                                },
                                {
                                    key: "readByteStream",
                                    value: function(J) {
                                        if (this.position + J > this.byteArray.length) throw "dicomParser.ByteStream.prototype.readByteStream: readByteStream - buffer overread";
                                        var Ce = rt(this.byteArray, this.position, J);
                                        return this.position += J, new q(this.byteArrayParser, Ce);
                                    }
                                },
                                {
                                    key: "getSize",
                                    value: function() {
                                        return this.byteArray.length;
                                    }
                                },
                                {
                                    key: "readUint16",
                                    value: function() {
                                        var J = this.byteArrayParser.readUint16(this.byteArray, this.position);
                                        return this.position += 2, J;
                                    }
                                },
                                {
                                    key: "readUint32",
                                    value: function() {
                                        var J = this.byteArrayParser.readUint32(this.byteArray, this.position);
                                        return this.position += 4, J;
                                    }
                                },
                                {
                                    key: "readFixedString",
                                    value: function(J) {
                                        var Ce = P(this.byteArray, this.position, J);
                                        return this.position += J, Ce;
                                    }
                                }
                            ]) && Qe(Q.prototype, me), Object.defineProperty(Q, "prototype", {
                                writable: !1
                            }), q;
                        }(), St = {
                            readUint16: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readUint16: position cannot be less than 0";
                                if (Q + 2 > q.length) throw "littleEndianByteArrayParser.readUint16: attempt to read past end of buffer";
                                return q[Q] + 256 * q[Q + 1];
                            },
                            readInt16: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readInt16: position cannot be less than 0";
                                if (Q + 2 > q.length) throw "littleEndianByteArrayParser.readInt16: attempt to read past end of buffer";
                                return Q = q[Q] + (q[Q + 1] << 8), Q = 32768 & Q ? Q - 65535 - 1 : Q;
                            },
                            readUint32: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readUint32: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "littleEndianByteArrayParser.readUint32: attempt to read past end of buffer";
                                return q[Q] + 256 * q[Q + 1] + 256 * q[Q + 2] * 256 + 256 * q[Q + 3] * 256 * 256;
                            },
                            readInt32: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readInt32: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "littleEndianByteArrayParser.readInt32: attempt to read past end of buffer";
                                return q[Q] + (q[Q + 1] << 8) + (q[Q + 2] << 16) + (q[Q + 3] << 24);
                            },
                            readFloat: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readFloat: position cannot be less than 0";
                                if (Q + 4 > q.length) throw "littleEndianByteArrayParser.readFloat: attempt to read past end of buffer";
                                var me = new Uint8Array(4);
                                return me[0] = q[Q], me[1] = q[Q + 1], me[2] = q[Q + 2], me[3] = q[Q + 3], new Float32Array(me.buffer)[0];
                            },
                            readDouble: function(q, Q) {
                                if (Q < 0) throw "littleEndianByteArrayParser.readDouble: position cannot be less than 0";
                                if (Q + 8 > q.length) throw "littleEndianByteArrayParser.readDouble: attempt to read past end of buffer";
                                var me = new Uint8Array(8);
                                return me[0] = q[Q], me[1] = q[Q + 1], me[2] = q[Q + 2], me[3] = q[Q + 3], me[4] = q[Q + 4], me[5] = q[Q + 5], me[6] = q[Q + 6], me[7] = q[Q + 7], new Float64Array(me.buffer)[0];
                            }
                        };
                        function Ln(q) {
                            var Q = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
                            if (q === void 0) throw "dicomParser.readPart10Header: missing required parameter 'byteArray'";
                            var me = Q.TransferSyntaxUID, J = new et(St, q);
                            return function() {
                                var Ce = function() {
                                    if (J.getSize() <= 132 && me) return !1;
                                    if (J.seek(128), J.readFixedString(4) === "DICM") return !0;
                                    if (!(Q || {}).TransferSyntaxUID) throw "dicomParser.readPart10Header: DICM prefix not found at location 132 - this is not a valid DICOM P10 file.";
                                    return J.seek(0), !1;
                                }(), Ue = [], lt = {};
                                if (!Ce) return J.position = 0, {
                                    elements: {
                                        x00020010: {
                                            tag: "x00020010",
                                            vr: "UI",
                                            Value: me
                                        }
                                    },
                                    warnings: Ue
                                };
                                for(; J.position < J.byteArray.length;){
                                    var Mt = J.position, jt = X(J, Ue);
                                    if ("x0002ffff" < jt.tag) {
                                        J.position = Mt;
                                        break;
                                    }
                                    jt.parser = St, lt[jt.tag] = jt;
                                }
                                return (Ce = new B(J.byteArrayParser, J.byteArray, lt)).warnings = J.warnings, Ce.position = J.position, Ce;
                            }();
                        }
                        var Nn = "1.2.840.10008.1.2.2";
                        function zt(q) {
                            var Q = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
                            if (q === void 0) throw new Error("dicomParser.parseDicom: missing required parameter 'byteArray'");
                            var me, J = function(Ue) {
                                if (Ue.elements.x00020010 === void 0) throw new Error("dicomParser.parseDicom: missing required meta header attribute 0002,0010");
                                return Ue = Ue.elements.x00020010, Ue && Ue.Value || P(q, Ue.dataOffset, Ue.length);
                            };
                            function Ce(jt) {
                                var Mt = J(jt), lt = Mt !== "1.2.840.10008.1.2", Mt = function(Cn, tn) {
                                    var Mr = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
                                    if (Cn !== "1.2.840.10008.1.2.1.99") return new et(Cn === Nn ? He : St, q, tn);
                                    if (Q && Q.inflater) return Cn = Q.inflater(q, tn), new et(St, Cn, 0);
                                    if (Mr == !0) {
                                        var Yt = c(0), mn = rt(q, tn, q.length - tn), Yt = Yt.inflateRawSync(mn), mn = $e(q, Yt.length + tn);
                                        return q.copy(mn, 0, 0, tn), Yt.copy(mn, tn), new et(St, mn, 0);
                                    }
                                    if (typeof pako > "u") throw "dicomParser.parseDicom: no inflater available to handle deflate transfer syntax";
                                    return Yt = q.slice(tn), mn = pako.inflateRaw(Yt), (Yt = $e(q, mn.length + tn)).set(q.slice(0, tn), 0), Yt.set(mn, tn), new et(St, Yt, 0);
                                }(Mt, jt.position), jt = new B(Mt.byteArrayParser, Mt.byteArray, {});
                                jt.warnings = Mt.warnings;
                                try {
                                    (lt ? ie : he)(jt, Mt, Mt.byteArray.length, Q);
                                } catch (Cn) {
                                    throw {
                                        exception: Cn,
                                        dataSet: jt
                                    };
                                }
                                return jt;
                            }
                            return function(Ue, lt) {
                                for(var Mt in Ue.elements)Ue.elements.hasOwnProperty(Mt) && (lt.elements[Mt] = Ue.elements[Mt]);
                                return Ue.warnings !== void 0 && (lt.warnings = Ue.warnings.concat(lt.warnings)), lt;
                            }(me = Ln(q, Q), Ce(me));
                        }
                        var Pe = function(q, Q, me) {
                            for(var J = 0, Ce = Q; Ce < Q + me; Ce++)J += q[Ce].length;
                            return J;
                        };
                        function Ct(q, lt, me, J, Ce) {
                            if (Ce = Ce || lt.fragments, q === void 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'dataSet'";
                            if (lt === void 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'pixelDataElement'";
                            if (me === void 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'startFragmentIndex'";
                            if ((J = J || 1) === void 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: missing required parameter 'numFragments'";
                            if (lt.tag !== "x7fe00010") throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010";
                            if (lt.encapsulatedPixelData !== !0 || lt.hadUndefinedLength !== !0 || lt.basicOffsetTable === void 0 || lt.fragments === void 0 || lt.fragments.length <= 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
                            if (me < 0) throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be >= 0";
                            if (me >= lt.fragments.length) throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragmentIndex' must be < number of fragments";
                            if (J < 1) throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'numFragments' must be > 0";
                            if (me + J > lt.fragments.length) throw "dicomParser.readEncapsulatedPixelDataFromFragments: parameter 'startFragment' + 'numFragments' < number of fragments";
                            var Ue = new et(q.byteArrayParser, q.byteArray, lt.dataOffset), lt = ne(Ue);
                            if (lt.tag !== "xfffee000") throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
                            Ue.seek(lt.length);
                            var Mt = Ue.position;
                            if (J === 1) return rt(Ue.byteArray, Mt + Ce[me].offset + 8, Ce[me].length);
                            for(var lt = Pe(Ce, me, J), jt = $e(Ue.byteArray, lt), Cn = 0, tn = me; tn < me + J; tn++)for(var Mr = Mt + Ce[tn].offset + 8, Yt = 0; Yt < Ce[tn].length; Yt++)jt[Cn++] = Ue.byteArray[Mr++];
                            return jt;
                        }
                        var yt = function(q, Q) {
                            for(var me = 0; me < q.length; me++)if (q[me].offset === Q) return me;
                        }, En = function(q, Q, me, J) {
                            if (q === Q.length - 1) return me.length - J;
                            for(var Ce = Q[q + 1], Ue = J + 1; Ue < me.length; Ue++)if (me[Ue].offset === Ce) return Ue - J;
                            throw "dicomParser.calculateNumberOfFragmentsForFrame: could not find fragment with offset matching basic offset table";
                        };
                        function ln(q, Q, me, J, Ce) {
                            if (J = J || Q.basicOffsetTable, Ce = Ce || Q.fragments, q === void 0) throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'dataSet'";
                            if (Q === void 0) throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'pixelDataElement'";
                            if (me === void 0) throw "dicomParser.readEncapsulatedImageFrame: missing required parameter 'frameIndex'";
                            if (J === void 0) throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' does not have basicOffsetTable";
                            if (Q.tag !== "x7fe00010") throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to non pixel data tag (expected tag = x7fe00010)";
                            if (Q.encapsulatedPixelData !== !0) throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have encapsulated pixel data";
                            if (Q.hadUndefinedLength !== !0) throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have undefined length";
                            if (Q.fragments === void 0) throw "dicomParser.readEncapsulatedImageFrame: parameter 'pixelDataElement' refers to pixel data element that does not have fragments";
                            if (J.length === 0) throw "dicomParser.readEncapsulatedImageFrame: basicOffsetTable has zero entries";
                            if (me < 0) throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be >= 0";
                            if (me >= J.length) throw "dicomParser.readEncapsulatedImageFrame: parameter 'frameIndex' must be < basicOffsetTable.length";
                            var Ue = J[me], Ue = yt(Ce, Ue);
                            if (Ue === void 0) throw "dicomParser.readEncapsulatedImageFrame: unable to find fragment that matches basic offset table entry";
                            return Ct(q, Q, Ue, En(me, J, Ce, Ue), Ce);
                        }
                        var Hn = !1;
                        function Un(q, Q, me) {
                            if (Hn || (Hn = !0, console && console.log && console.log("WARNING: dicomParser.readEncapsulatedPixelData() has been deprecated")), q === void 0) throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'dataSet'";
                            if (Q === void 0) throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'element'";
                            if (me === void 0) throw "dicomParser.readEncapsulatedPixelData: missing required parameter 'frame'";
                            if (Q.tag !== "x7fe00010") throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to non pixel data tag (expected tag = x7fe00010)";
                            if (Q.encapsulatedPixelData !== !0 || Q.hadUndefinedLength !== !0 || Q.basicOffsetTable === void 0 || Q.fragments === void 0) throw "dicomParser.readEncapsulatedPixelData: parameter 'element' refers to pixel data element that does not have encapsulated pixel data";
                            if (me < 0) throw "dicomParser.readEncapsulatedPixelData: parameter 'frame' must be >= 0";
                            return Q.basicOffsetTable.length !== 0 ? ln(q, Q, me) : Ct(q, Q, 0, Q.fragments.length);
                        }
                        s.default = {
                            isStringVr: f,
                            isPrivateTag: u,
                            parsePN: g,
                            parseTM: h,
                            parseDA: m,
                            explicitElementToString: y,
                            explicitDataSetToJS: C,
                            createJPEGBasicOffsetTable: S,
                            parseDicomDataSetExplicit: ie,
                            parseDicomDataSetImplicit: he,
                            readFixedString: P,
                            alloc: $e,
                            version: je,
                            bigEndianByteArrayParser: He,
                            ByteStream: et,
                            sharedCopy: rt,
                            DataSet: B,
                            findAndSetUNElementLength: M,
                            findEndOfEncapsulatedElement: _,
                            findItemDelimitationItemAndSetElementLength: G,
                            littleEndianByteArrayParser: St,
                            parseDicom: zt,
                            readDicomElementExplicit: X,
                            readDicomElementImplicit: H,
                            readEncapsulatedImageFrame: ln,
                            readEncapsulatedPixelData: Un,
                            readEncapsulatedPixelDataFromFragments: Ct,
                            readPart10Header: Ln,
                            readSequenceItemsExplicit: oe,
                            readSequenceItemsImplicit: ue,
                            readSequenceItem: ne,
                            readTag: D,
                            LEI: "1.2.840.10008.1.2",
                            LEE: "1.2.840.10008.1.2.1"
                        };
                    }
                ], a = {}, r.m = i, r.c = a, r.d = function(o, s, c) {
                    r.o(o, s) || Object.defineProperty(o, s, {
                        enumerable: !0,
                        get: c
                    });
                }, r.r = function(o) {
                    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(o, "__esModule", {
                        value: !0
                    });
                }, r.t = function(o, s) {
                    if (1 & s && (o = r(o)), 8 & s || 4 & s && typeof o == "object" && o && o.__esModule) return o;
                    var c = Object.create(null);
                    if (r.r(c), Object.defineProperty(c, "default", {
                        enumerable: !0,
                        value: o
                    }), 2 & s && typeof o != "string") for(var l in o)r.d(c, l, function(f) {
                        return o[f];
                    }.bind(null, l));
                    return c;
                }, r.n = function(o) {
                    var s = o && o.__esModule ? function() {
                        return o.default;
                    } : function() {
                        return o;
                    };
                    return r.d(s, "a", s), s;
                }, r.o = function(o, s) {
                    return Object.prototype.hasOwnProperty.call(o, s);
                }, r.p = "", r(r.s = 1);
                function r(o) {
                    if (a[o]) return a[o].exports;
                    var s = a[o] = {
                        i: o,
                        l: !1,
                        exports: {}
                    };
                    return i[o].call(s.exports, s, s.exports, r), s.l = !0, s.exports;
                }
                var i, a;
            });
        }(Eh)), Eh.exports;
    }
    var Rr = Ane();
    const zO = Qa(Rr);
    function hg(t) {
        const e = t.indexOf(":");
        let n = t.substring(e + 1);
        const r = n.indexOf("frame=");
        let i;
        if (r !== -1) {
            const s = n.substring(r + 6);
            i = parseInt(s, 10), n = n.substring(0, r - 1);
        }
        const a = t.substring(0, e), o = i !== void 0 ? i - 1 : void 0;
        return {
            scheme: a,
            url: n,
            frame: i,
            pixelDataFrame: o
        };
    }
    let o3 = {
        open (t, e) {
            t.open("get", e, !0);
        },
        beforeSend () {},
        beforeProcessing (t) {
            return Promise.resolve(t.response);
        },
        imageCreated () {},
        strict: !1
    };
    function jO(t) {
        o3 = Object.assign(o3, t);
    }
    function pg() {
        return o3;
    }
    function C2(t, e, n = {}, r = {}) {
        const i = pg(), a = (c)=>{
            if (typeof i.errorInterceptor == "function") {
                const l = new Error("request failed");
                l.request = c, l.response = c.response, l.status = c.status, i.errorInterceptor(l);
            }
        }, o = new XMLHttpRequest, s = new Promise((c, l)=>{
            i.open(o, t, n, r);
            const f = i.beforeSend(o, e, n, r);
            o.responseType = "arraybuffer";
            const u = Object.assign({}, n, f);
            Object.keys(u).forEach(function(g) {
                u[g] !== null && (g === "Accept" && t.indexOf("accept=") !== -1 || o.setRequestHeader(g, u[g]));
            }), r.deferred = {
                resolve: c,
                reject: l
            }, r.url = t, r.imageId = e, o.onloadstart = function(g) {
                i.onloadstart && i.onloadstart(g, r), We(Ke, "cornerstoneimageloadstart", {
                    url: t,
                    imageId: e
                });
            }, o.onloadend = function(g) {
                i.onloadend && i.onloadend(g, r), We(Ke, "cornerstoneimageloadend", {
                    url: t,
                    imageId: e
                });
            }, o.onreadystatechange = function(g) {
                i.onreadystatechange && i.onreadystatechange(g, r), o.readyState === 4 && (o.status === 200 || o.status === 206 ? i.beforeProcessing(o).then(c).catch(()=>{
                    a(o), l(o);
                }) : (a(o), l(o)));
            }, o.onprogress = function(g) {
                const h = g.loaded;
                let v, m;
                g.lengthComputable && (v = g.total, m = Math.round(h / v * 100)), We(Ke, "cornerstoneimageloadprogress", {
                    url: t,
                    imageId: e,
                    loaded: h,
                    total: v,
                    percentComplete: m
                }), i.onprogress && i.onprogress(g, r);
            }, o.onerror = function() {
                a(o), l(o);
            }, o.onabort = function() {
                a(o), l(o);
            }, o.send();
        });
        return s.xhr = o, s;
    }
    function kne(t, e, n) {
        if (n + t.length > e.length) return !1;
        let r = n;
        for(let i = 0; i < t.length; i++)if (t[i] !== e[r++]) return !1;
        return !0;
    }
    function Une(t) {
        const e = new Uint8Array(t.length);
        for(let n = 0, r = t.length; n < r; n++)e[n] = t.charCodeAt(n);
        return e;
    }
    function s3(t, e, n) {
        n = n || 0;
        const r = Une(e);
        for(let i = n; i < t.length; i++)if (r[0] === t[i] && kne(r, t, i)) return i;
        return -1;
    }
    const { ImageQualityStatus: l7 } = sc;
    function xy(t, e, n) {
        n ||= {};
        const r = new Uint8Array(e), i = !!n?.isPartial;
        if (t.indexOf("multipart") === -1) return {
            contentType: t,
            imageQualityStatus: i ? l7.SUBRESOLUTION : l7.FULL_RESOLUTION,
            pixelData: r
        };
        let { tokenIndex: a, responseHeaders: o, boundary: s, multipartContentType: c } = n;
        if (a ||= s3(r, `\r
\r
`), a === -1) throw new Error("invalid response - no multipart mime header");
        if (!s && (o = Gne(r, 0, a).split(`\r
`), s = Fne(o), !s)) throw new Error("invalid response - no boundary marker");
        const l = a + 4, f = s3(r, s, l);
        if (f === -1 && !i) throw new Error("invalid response - terminating boundary not found");
        return c ||= Bne(o), n.tokenIndex = a, n.boundary = s, n.responseHeaders = o, n.multipartContentType = c, n.isPartial = f === -1, {
            contentType: c,
            extractDone: !i || f !== -1,
            tokenIndex: a,
            responseHeaders: o,
            boundary: s,
            multipartContentType: c,
            pixelData: e.slice(l, f - 2)
        };
    }
    function Fne(t) {
        for(let e = 0; e < t.length; e++)if (t[e].substr(0, 2) === "--") return t[e];
    }
    function Bne(t) {
        for(let e = 0; e < t.length; e++)if (t[e].substr(0, 13) === "Content-Type:") return t[e].substr(13).trim();
    }
    function Gne(t, e, n) {
        e = e || 0, n = n || t.length - e;
        let r = "";
        for(let i = e; i < e + n; i++)r += String.fromCharCode(t[i]);
        return r;
    }
    const { ImageQualityStatus: u7 } = sc;
    function Sy(t, e = !0) {
        return e ? t.imageQualityStatus ?? u7.FULL_RESOLUTION : u7.SUBRESOLUTION;
    }
    const { ProgressiveIterator: Wne } = ga;
    function HO(t, e, n = {}, r = {}) {
        const i = pg(), { retrieveOptions: a = {}, streamingData: o = {} } = r, s = a.minChunkSize || 128 * 1024, c = (f)=>{
            if (typeof i.errorInterceptor == "function") {
                const u = new Error("request failed");
                i.errorInterceptor(u);
            }
        }, l = new Wne("streamRequest");
        return l.generate(async (f, u)=>{
            const g = i.beforeSend?.(null, t, n, {}), h = Object.assign({}, n, g);
            Object.keys(h).forEach(function(v) {
                h[v] === null && (h[v] = void 0), v === "Accept" && t.indexOf("accept=") !== -1 && (h[v] = void 0);
            });
            try {
                const v = await fetch(t, {
                    headers: h,
                    signal: void 0
                });
                if (v.status !== 200) throw new Error(`Couldn't retrieve ${t} got status ${v.status}`);
                const m = v.body.getReader(), y = v.headers, C = y.get("content-type"), T = Number(y.get("Content-Length"));
                let x = !1, S = o.encodedData, D = o.lastSize || 0;
                for(o.isPartial = !0; !x;){
                    const { done: _, value: M } = await m.read();
                    if (S = $ne(S, M), !S) {
                        if (x) throw new Error(`Done but no image frame available ${e}`);
                        continue;
                    }
                    if (x = _ || S.byteLength === T, !x && S.length < D + s) continue;
                    D = S.length, o.isPartial = !_;
                    const P = xy(C, S, o), F = Sy(a, x), N = {
                        url: t,
                        imageId: e,
                        ...P,
                        percentComplete: _ ? 100 : P.pixelData?.length * 100 / T,
                        imageQualityStatus: F,
                        done: x
                    };
                    f.add(N, x);
                }
            } catch (v) {
                c(), console.error(v), u(v);
            }
        }), l.getNextPromise();
    }
    function $ne(t, e) {
        if (!t) return e;
        if (!e) return t;
        const n = new Uint8Array(t.length + e.length);
        return n.set(t, 0), n.set(e, t.length), n;
    }
    const zne = {
        xhrRequest: C2,
        streamRequest: HO,
        setOptions: jO,
        getOptions: pg
    };
    function jne(t) {
        const e = t.elements.x7fe00010.fragments, n = t.byteArray.length;
        for (const r of e){
            const { position: i, length: a } = r;
            a > n - i && (console.log(`Truncated fragment, changing fragment length from ${r.length} to ${n - i}`), r.length = n - i);
        }
        return t;
    }
    function Hne(t) {
        let e = Rr.parseDicom(t, {
            untilTag: "x7fe00010"
        });
        e.elements.x7fe00010 || console.warn("Pixel data not found!");
        let n;
        try {
            n = Rr.parseDicom(t);
        } catch (r) {
            console.error(r), console.log("pixel data dataset:", r.dataSet), n = r.dataSet;
        }
        return e.elements.x7fe00010 = n.elements.x7fe00010, e = jne(e), e;
    }
    async function KO(t, e, n) {
        const r = Hne(t), { uri: i, imageId: a, fileTotalLength: o } = n;
        return r.fetchMore = async function(s) {
            const c = Object.assign({
                uri: i,
                imageId: a,
                fetchedLength: t.length,
                lengthToFetch: o - t.length
            }, s), { fetchedLength: l, lengthToFetch: f } = c, { arrayBuffer: u } = await e(i, a, {
                byteRange: `${l}-${l + f}`
            }), g = new Uint8Array(u), h = new Uint8Array(r.byteArray.length + g.length);
            return h.set(r.byteArray), h.set(g, r.byteArray.length), KO(h, e, n);
        }, r;
    }
    function Kne(t, e) {
        if (!t) return;
        const { NumberOfFrames: n, PerFrameFunctionalGroupsSequence: r, SharedFunctionalGroupsSequence: i } = XO(t);
        if (r || n > 1) {
            const { shared: a, perFrame: o } = qO(r, i, e);
            return {
                NumberOfFrames: n,
                PerFrameFunctionalInformation: o,
                SharedFunctionalInformation: a
            };
        }
        return {
            NumberOfFrames: n
        };
    }
    function qO(t, e, n) {
        const r = {};
        (e ? Object.values(e.items[0].dataSet.elements) : []).map((a)=>r[a.tag] = a);
        const i = {};
        return (t ? Object.values(t.items[n - 1].dataSet.elements) : []).map((a)=>i[a.tag] = a), {
            shared: r,
            perFrame: i
        };
    }
    function XO(t) {
        if (!t) return;
        const { elements: e, ...n } = t, { x52009230: r, x52009229: i, ...a } = e;
        return {
            NumberOfFrames: t.intString("x00280008"),
            PerFrameFunctionalGroupsSequence: r,
            SharedFunctionalGroupsSequence: i,
            otherElements: a,
            otherAttributtes: n
        };
    }
    function qne(t, e) {
        if (!e) return;
        const { NumberOfFrames: n, PerFrameFunctionalGroupsSequence: r, SharedFunctionalGroupsSequence: i, otherElements: a } = XO(e);
        if (r || n > 1) {
            const { shared: o, perFrame: s } = qO(r, i, t), c = {
                elements: {
                    ...a,
                    ...o,
                    ...s
                }
            }, l = Object.create(e);
            return Object.assign(l, c);
        }
        return e;
    }
    let Ci = {};
    const Xne = ()=>{
        Ci = {};
    };
    function Ey(t) {
        if (Ci[t]) return Ci[t];
    }
    function Yne(t) {
        const e = Ey(t);
        return YO(e);
    }
    function YO(t) {
        if (!t) return !1;
        const e = t.intString("x00280008");
        return e && e > 1;
    }
    function Zne(t) {
        return t.indexOf("&frame=");
    }
    function Jne(t) {
        const e = Zne(t), n = e === -1 ? t : t.slice(0, e), r = parseInt(t.slice(e + 7), 10) || 1;
        let i;
        return Ci[n] ? i = Ci[n].dataSet : i = void 0, {
            dataSet: i,
            frame: r
        };
    }
    function Qne(t) {
        const e = [], n = Ey(t);
        if (YO(n)) {
            const r = n.intString("x00280008");
            for(let i = 1; i <= r; i++)e.push(`${t}&frame=${i}`);
        } else e.push(t);
        return e;
    }
    const ZO = {
        _get: Ey,
        generateMultiframeWADOURIs: Qne,
        retrieveMultiframeDataset: Jne,
        isMultiframeDataset: Yne
    };
    let ef = 0, E0 = {};
    function ere(t) {
        return Ci[t] !== void 0;
    }
    function tre(t) {
        let e;
        if (t.includes("&frame=")) {
            const { frame: n, dataSet: r } = ZO.retrieveMultiframeDataset(t);
            e = qne(n, r);
        } else Ci[t] && (e = Ci[t].dataSet);
        return e;
    }
    function nre(t, e) {
        const n = Ci[t];
        if (!n) {
            console.error(`No loaded dataSet for uri ${t}`);
            return;
        }
        ef -= n.dataSet.byteArray.length, n.dataSet = e, ef += e.byteArray.length, We(Ke, "datasetscachechanged", {
            uri: t,
            action: "updated",
            cacheInfo: w2()
        });
    }
    function rre(t, e = C2, n) {
        if (Ci[t]) return new Promise((a)=>{
            Ci[t].cacheCount++, a(Ci[t].dataSet);
        });
        if (E0[t]) return E0[t].cacheCount++, E0[t];
        const r = e(t, n), i = new Promise((a, o)=>{
            r.then(async function(s) {
                const c = {
                    isPartialContent: !1,
                    fileTotalLength: null
                };
                if (!(s instanceof ArrayBuffer)) {
                    if (!s.arrayBuffer) return o(new Error("If not returning ArrayBuffer, must return object with `arrayBuffer` parameter"));
                    c.isPartialContent = s.flags.isPartialContent, c.fileTotalLength = s.flags.fileTotalLength, s = s.arrayBuffer;
                }
                const l = new Uint8Array(s);
                let f;
                try {
                    c.isPartialContent ? f = await KO(l, e, {
                        uri: t,
                        imageId: n,
                        fileTotalLength: c.fileTotalLength
                    }) : f = Rr.parseDicom(l);
                } catch (u) {
                    return o(u);
                }
                Ci[t] = {
                    dataSet: f,
                    cacheCount: i.cacheCount
                }, ef += f.byteArray.length, a(f), We(Ke, "datasetscachechanged", {
                    uri: t,
                    action: "loaded",
                    cacheInfo: w2()
                });
            }, o).then(()=>{
                delete E0[t];
            }, ()=>{
                delete E0[t];
            });
        });
        return i.cacheCount = 1, E0[t] = i, i;
    }
    function ire(t) {
        Ci[t] && (Ci[t].cacheCount--, Ci[t].cacheCount === 0 && (ef -= Ci[t].dataSet.byteArray.length, delete Ci[t], We(Ke, "datasetscachechanged", {
            uri: t,
            action: "unloaded",
            cacheInfo: w2()
        })));
    }
    function w2() {
        return {
            cacheSizeInBytes: ef,
            numberOfDataSetsCached: Object.keys(Ci).length
        };
    }
    function are() {
        Xne(), E0 = {}, ef = 0;
    }
    const ju = {
        isLoaded: ere,
        load: rre,
        unload: ire,
        getInfo: w2,
        purge: are,
        get: tre,
        update: nre
    };
    function ore(t) {
        const e = [];
        for(let n = 0; n <= 30; n += 2){
            let r = `x60${n.toString(16)}`;
            r.length === 4 && (r = `x600${n.toString(16)}`);
            const i = t.elements[`${r}3000`];
            if (!i) continue;
            const a = [];
            for(let o = 0; o < i.length; o++)for(let s = 0; s < 8; s++){
                const c = t.byteArray[i.dataOffset + o];
                a[o * 8 + s] = c >> s & 1;
            }
            e.push({
                rows: t.uint16(`${r}0010`),
                columns: t.uint16(`${r}0011`),
                type: t.string(`${r}0040`),
                x: t.int16(`${r}0050`, 1) - 1,
                y: t.int16(`${r}0050`, 0) - 1,
                pixelData: a,
                description: t.string(`${r}0022`),
                label: t.string(`${r}1500`),
                roiArea: t.string(`${r}1301`),
                roiMean: t.string(`${r}1302`),
                roiStandardDeviation: t.string(`${r}1303`)
            });
        }
        return {
            overlays: e
        };
    }
    function mf(t) {
        return t === "RECON TOMO" || t === "RECON GATED TOMO";
    }
    function Dy(t, e) {
        const n = t.string("x00080008");
        if (n) {
            const r = n.split("\\");
            if (r.length > e) return r[e];
        }
    }
    function sre(t) {
        let e;
        if (t.string("x00080060")?.includes("NM")) {
            const r = Dy(t, 2);
            r && mf(r) && t.elements.x00540022 && (e = Ss(t.elements.x00540022.items[0].dataSet, "x00200037", 6));
        }
        return e;
    }
    function cre(t) {
        let e;
        if (t.string("x00080060")?.includes("NM")) {
            const r = Dy(t, 2);
            r && mf(r) && t.elements.x00540022 && (e = Ss(t.elements.x00540022.items[0].dataSet, "x00200032", 3));
        }
        return e;
    }
    function f7(t) {
        let e = Ss(t, "x00200037", 6);
        return !e && t.elements.x00209116 && (e = Ss(t.elements.x00209116.items[0].dataSet, "x00200037", 6)), e || (e = sre(t)), e;
    }
    function d7(t) {
        let e = Ss(t, "x00200032", 3);
        return !e && t.elements.x00209113 && (e = Ss(t.elements.x00209113.items[0].dataSet, "x00200032", 3)), e || (e = cre(t)), e;
    }
    function g7(t) {
        let e = Ss(t, "x00280030", 2);
        return !e && t.elements.x00289110 && (e = Ss(t.elements.x00289110.items[0].dataSet, "x00280030", 2)), e;
    }
    function h7(t) {
        let e;
        return t.elements.x00180050 ? e = t.floatString("x00180050") : t.elements.x00289110 && t.elements.x00289110.items.length && t.elements.x00289110.items[0].dataSet.elements.x00180050 && (e = t.elements.x00289110.items[0].dataSet.floatString("x00180050")), e;
    }
    function JO(t, e, n) {
        const r = {};
        for (const i of n)try {
            const a = e(i, t);
            if (a) {
                const o = {};
                for(const s in a)if (s in a) {
                    const c = lre(s);
                    o[c] = a[s];
                }
                Object.assign(r, o);
            }
        } catch (a) {
            console.error(`Error retrieving ${i} data:`, a);
        }
        return r;
    }
    const lre = (t)=>t.charAt(0).toUpperCase() + t.slice(1), QO = [
        "multiframeModule",
        "generalSeriesModule",
        "patientStudyModule",
        "imagePlaneModule",
        "nmMultiframeGeometryModule",
        "imagePixelModule",
        "modalityLutModule",
        "voiLutModule",
        "sopCommonModule",
        "petIsotopeModule",
        "overlayPlaneModule",
        "transferSyntax",
        "petSeriesModule",
        "petImageModule"
    ];
    function p7(t) {
        const e = t.elements.x00186011;
        return !e || !e.items ? [] : e.items.map((r)=>{
            const i = r.dataSet.double("x0018602c"), a = r.dataSet.double("x0018602e"), o = r.dataSet.uint16("x00186024"), s = r.dataSet.uint16("x00186026"), c = r.dataSet.uint16("x0018601a"), l = r.dataSet.uint16("x0018601e"), f = r.dataSet.uint16("x00186018"), u = r.dataSet.uint16("x0018601c"), g = r.dataSet.int32("x00186020") || null, h = r.dataSet.int32("x00186022") || null, v = r.dataSet.uint16("x0018602a"), m = r.dataSet.uint16("x00186028"), y = r.dataSet.uint16("x00186012"), C = r.dataSet.uint16("x00186014"), T = r.dataSet.uint16("x00186016"), x = r.dataSet.uint16("x00186030");
            return {
                regionLocationMinY0: c,
                regionLocationMaxY1: l,
                regionLocationMinX0: f,
                regionLocationMaxX1: u,
                referencePixelX0: g,
                referencePixelY0: h,
                physicalDeltaX: i,
                physicalDeltaY: a,
                physicalUnitsXDirection: o,
                physicalUnitsYDirection: s,
                referencePhysicalPixelValueY: v,
                referencePhysicalPixelValueX: m,
                regionSpatialFormat: y,
                regionDataType: C,
                regionFlags: T,
                transducerFrequency: x
            };
        });
    }
    function _y(t, e) {
        const { MetadataModules: n } = sc;
        if (Array.isArray(e)) return;
        const r = hg(e);
        if (t === n.MULTIFRAME) {
            const o = ZO.retrieveMultiframeDataset(r.url);
            return o.dataSet ? Kne(o.dataSet, o.frame) : void 0;
        }
        let i = r.url;
        r.frame && (i = `${i}&frame=${r.frame}`);
        const a = ju.get(i);
        if (a) return eI(t, e, a);
    }
    function eI(t, e, n) {
        const { MetadataModules: r } = sc;
        if (t === r.GENERAL_STUDY) return {
            studyDescription: n.string("x00081030"),
            studyDate: Rr.parseDA(n.string("x00080020")),
            studyTime: Rr.parseTM(n.string("x00080030") || ""),
            accessionNumber: n.string("x00080050")
        };
        if (t === r.GENERAL_SERIES) return {
            modality: n.string("x00080060"),
            seriesInstanceUID: n.string("x0020000e"),
            seriesDescription: n.string("x0008103e"),
            seriesNumber: n.intString("x00200011"),
            studyInstanceUID: n.string("x0020000d"),
            seriesDate: Rr.parseDA(n.string("x00080021")),
            seriesTime: Rr.parseTM(n.string("x00080031") || ""),
            acquisitionDate: Rr.parseDA(n.string("x00080022")),
            acquisitionTime: Rr.parseTM(n.string("x00080032") || "")
        };
        if (t === r.GENERAL_IMAGE) return {
            sopInstanceUID: n.string("x00080018"),
            instanceNumber: n.intString("x00200013"),
            lossyImageCompression: n.string("x00282110"),
            lossyImageCompressionRatio: n.floatString("x00282112"),
            lossyImageCompressionMethod: n.string("x00282114")
        };
        if (t === r.PATIENT) return {
            patientID: n.string("x00100020"),
            patientName: n.string("x00100010")
        };
        if (t === r.PATIENT_STUDY) return {
            patientAge: n.intString("x00101010"),
            patientSize: n.floatString("x00101020"),
            patientSex: n.string("x00100040"),
            patientWeight: n.floatString("x00101030")
        };
        if (t === r.NM_MULTIFRAME_GEOMETRY) {
            const i = n.string("x00080060"), a = Dy(n, 2);
            return {
                modality: i,
                imageType: n.string("x00080008"),
                imageSubType: a,
                imageOrientationPatient: f7(n),
                imagePositionPatient: d7(n),
                sliceThickness: h7(n),
                pixelSpacing: g7(n),
                numberOfFrames: n.uint16("x00280008"),
                isNMReconstructable: mf(a) && i.includes("NM")
            };
        }
        if (t === r.IMAGE_PLANE) {
            const i = f7(n), a = d7(n), o = g7(n), s = h7(n);
            let c = null, l = null;
            o && (l = o[0], c = o[1]);
            let f = null, u = null;
            return i && (f = [
                parseFloat(i[0]),
                parseFloat(i[1]),
                parseFloat(i[2])
            ], u = [
                parseFloat(i[3]),
                parseFloat(i[4]),
                parseFloat(i[5])
            ]), {
                frameOfReferenceUID: n.string("x00200052"),
                rows: n.uint16("x00280010"),
                columns: n.uint16("x00280011"),
                imageOrientationPatient: i,
                rowCosines: f,
                columnCosines: u,
                imagePositionPatient: a,
                sliceThickness: s,
                sliceLocation: n.floatString("x00201041"),
                pixelSpacing: o,
                rowPixelSpacing: l,
                columnPixelSpacing: c
            };
        }
        if (t === r.CINE) return {
            frameTime: n.floatString("x00181063")
        };
        if (t === r.IMAGE_PIXEL) return WO(n);
        if (t === r.VOI_LUT) {
            const i = $O(n);
            return {
                windowCenter: Ss(n, "x00281050", 1),
                windowWidth: Ss(n, "x00281051", 1),
                voiLUTSequence: a3(i, n.elements.x00283010),
                voiLUTFunction: n.string("x00281056")
            };
        }
        if (t === r.MODALITY_LUT) return {
            rescaleIntercept: n.floatString("x00281052"),
            rescaleSlope: n.floatString("x00281053"),
            rescaleType: n.string("x00281054"),
            modalityLUTSequence: a3(n.uint16("x00280103"), n.elements.x00283000)
        };
        if (t === r.SOP_COMMON) return {
            sopClassUID: n.string("x00080016"),
            sopInstanceUID: n.string("x00080018")
        };
        if (t === r.PET_ISOTOPE) {
            const i = n.elements.x00540016;
            if (i === void 0) return;
            const a = i.items[0].dataSet;
            return {
                radiopharmaceuticalInfo: {
                    radiopharmaceuticalStartTime: Rr.parseTM(a.string("x00181072") || ""),
                    radionuclideTotalDose: a.floatString("x00181074"),
                    radionuclideHalfLife: a.floatString("x00181075")
                }
            };
        }
        if (t === r.OVERLAY_PLANE) return ore(n);
        if (t === "transferSyntax") {
            let i;
            try {
                i = n.string("x00020010");
            } catch  {}
            return {
                transferSyntaxUID: i
            };
        }
        if (t === r.PET_SERIES) return {
            correctedImage: n.string("x00280051"),
            units: n.string("x00541001"),
            decayCorrection: n.string("x00541102")
        };
        if (t === r.PET_IMAGE) return {
            frameReferenceTime: n.floatString(n.string("x00541300") || ""),
            actualFrameDuration: n.intString(n.string("x00181242"))
        };
        if (t === r.ULTRASOUND_ENHANCED_REGION) return p7(n);
        if (t === r.CALIBRATION && n.string("x00080060") === "US") return {
            sequenceOfUltrasoundRegions: p7(n)
        };
        if (t === "instance") return JO(e, _y, QO);
    }
    let T2 = [];
    function ure(t) {
        return `dicomfile:${T2.push(t) - 1}`;
    }
    function fre(t) {
        return T2[t];
    }
    function dre(t) {
        T2[t] = void 0;
    }
    function gre() {
        T2 = [];
    }
    const tI = {
        add: ure,
        get: fre,
        remove: dre,
        purge: gre
    };
    function hre(t) {
        const e = t.intString("x00280008"), n = t.elements.x7fe00010;
        return e !== n.fragments.length;
    }
    function nI(t, e) {
        if (t.elements.x7fe00010 && t.elements.x7fe00010.basicOffsetTable.length) return Rr.readEncapsulatedImageFrame(t, t.elements.x7fe00010, e);
        if (hre(t)) {
            const l = Rr.createJPEGBasicOffsetTable(t, t.elements.x7fe00010);
            return Rr.readEncapsulatedImageFrame(t, t.elements.x7fe00010, e, l);
        }
        const n = t.elements.x7fe00010.fragments, r = new Rr.ByteStream(t.byteArrayParser, t.byteArray, t.elements.x7fe00010.dataOffset), i = Rr.readSequenceItem(r);
        if (i.tag !== "xfffee000") throw "dicomParser.readEncapsulatedPixelData: missing basic offset table xfffee000";
        r.seek(i.length);
        const a = r.position;
        if (e + 1 > n.length) throw "dicomParser.readEncapsulatedPixelData: frame exceeds number of fragments";
        const s = a + n[e].offset + 8, c = n[e].length;
        return new Uint8Array(r.byteArray.buffer.slice(r.byteArray.byteOffset + s, r.byteArray.byteOffset + s + c));
    }
    function pre(t, e) {
        return t & 1 << e;
    }
    function rI(t, e, n) {
        const r = new Uint8Array(n);
        for(let i = 0; i < n; i++){
            const a = Math.floor(i / 8), o = t[a + e], s = i % 8;
            r[i] = pre(o, s) ? 1 : 0;
        }
        return r;
    }
    function iI(t, e) {
        const n = t.elements.x7fe00010 || t.elements.x7fe00008, r = t.uint16("x00280100"), i = t.uint16("x00280010"), a = t.uint16("x00280011");
        let o = t.uint16("x00280002");
        t.string("x00280004") === "YBR_FULL_422" && (o = 2, console.warn(`Using SamplesPerPixel of 2 for YBR_FULL_422 photometric interpretation.
      See http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.7.6.3.html for more information.`));
        const c = n.dataOffset, l = i * a * o;
        let f;
        if (r === 8) {
            if (f = c + e * l, f >= t.byteArray.length) throw new Error("frame exceeds size of pixelData");
            return new Uint8Array(t.byteArray.buffer.slice(f, f + l));
        } else if (r === 16) {
            if (f = c + e * l * 2, f >= t.byteArray.length) throw new Error("frame exceeds size of pixelData");
            return new Uint8Array(t.byteArray.buffer.slice(f, f + l * 2));
        } else if (r === 1) {
            if (f = c + e * l * .125, f >= t.byteArray.length) throw new Error("frame exceeds size of pixelData");
            return rI(t.byteArray, f, l);
        } else if (r === 32) {
            if (f = c + e * l * 4, f >= t.byteArray.length) throw new Error("frame exceeds size of pixelData");
            return new Uint8Array(t.byteArray.buffer.slice(f, f + l * 4));
        }
        throw new Error("unsupported pixel format");
    }
    function aI(t) {
        const e = hg(t), n = parseInt(e.url, 10), r = tI.get(n);
        return new Promise((i, a)=>{
            const o = new FileReader;
            o.onload = (s)=>{
                const c = s.target.result;
                i(c);
            }, o.onerror = a, o.readAsArrayBuffer(r);
        });
    }
    function Ry(t, e = 0) {
        const n = t.elements.x7fe00010 || t.elements.x7fe00008;
        return n ? n.encapsulatedPixelData ? nI(t, e) : iI(t, e) : null;
    }
    function x2(t) {
        let e = t[0], n = t[0], r;
        const i = t.length;
        for(let a = 1; a < i; a++)r = t[a], e = Math.min(e, r), n = Math.max(n, r);
        return {
            min: e,
            max: n
        };
    }
    function J5(t, e, n) {
        t.planarConfiguration === 0 ? kO(t.pixelData, e, n) : UO(t.pixelData, e, n);
    }
    function mre(t, e, n) {
        t.planarConfiguration === 0 ? FO(t.pixelData, e, n) : BO(t.pixelData, e, n);
    }
    function oI(t, e, n) {
        if (t.photometricInterpretation === "RGB") J5(t, e, n);
        else if (t.photometricInterpretation === "YBR_RCT") J5(t, e, n);
        else if (t.photometricInterpretation === "YBR_ICT") J5(t, e, n);
        else if (t.photometricInterpretation === "PALETTE COLOR") GO(t, e, n);
        else if (t.photometricInterpretation === "YBR_FULL_422") Mne(t.pixelData, e, n);
        else if (t.photometricInterpretation === "YBR_FULL") mre(t, e, n);
        else throw new Error(`No color space conversion for photometric interpretation ${t.photometricInterpretation}`);
    }
    function vre(t) {
        if (t === void 0) return !1;
        const { rows: e, columns: n, photometricInterpretation: r, pixelDataLength: i, planarConfiguration: a } = t;
        return i === 4 * n * e ? !1 : r === "PALETTE COLOR" ? !0 : r.endsWith("420") ? i === (3 * Math.ceil(n / 2) + Math.floor(n / 2)) * e : r.endsWith("422") ? i === (3 * Math.ceil(n / 2) + Math.floor(n / 2)) * Math.ceil(e / 2) + Math.floor(e / 2) * n : r !== "RGB" || a === 1;
    }
    function yre(t) {
        return Cre(String.fromCharCode.apply(null, Array.prototype.slice.apply(new Uint8Array(t))));
    }
    function Cre(t) {
        let e;
        try {
            return decodeURIComponent(escape(t));
        } catch (n) {
            if (e = n, e instanceof URIError) return t;
            throw e;
        }
    }
    function sI(t, e, n) {
        const r = new Date().getTime(), i = new Blob([
            e
        ], {
            type: "image/jpeg"
        });
        return new Promise((a, o)=>{
            const s = new FileReader;
            s.readAsBinaryString === void 0 ? s.readAsArrayBuffer(i) : s.readAsBinaryString(i), s.onload = function() {
                const c = new Image;
                c.onload = function() {
                    n.height = c.height, n.width = c.width, t.rows = c.height, t.columns = c.width;
                    const l = n.getContext("2d");
                    l.drawImage(this, 0, 0);
                    const f = l.getImageData(0, 0, c.width, c.height), u = new Date().getTime();
                    t.pixelData = new Uint8Array(f.data.buffer), t.imageData = f, t.decodeTimeInMS = u - r;
                    const g = x2(t.pixelData);
                    t.smallestPixelValue = g.min, t.largestPixelValue = g.max, t.pixelDataLength = t.pixelData.length, a(t);
                }, c.onerror = function(l) {
                    o(l);
                }, s.readAsBinaryString === void 0 ? c.src = `data:image/jpeg;base64,${window.btoa(yre(s.result))}` : c.src = `data:image/jpeg;base64,${window.btoa(s.result)}`;
            }, s.onerror = (c)=>{
                o(c);
            };
        });
    }
    function qa(t, e, n, r, i) {
        const a = {
            ...r
        };
        delete a.loader, delete a.streamingData;
        const o = rT(), s = a.priority || void 0;
        return a.transferPixelData && n.buffer, o.executeTask("dicomImageLoader", "decodeTask", {
            imageFrame: t,
            transferSyntax: e,
            pixelData: n,
            options: a,
            decodeConfig: i
        }, {
            priority: s,
            requestType: a?.requestType
        });
    }
    function wre(t, e, n, r, i = {}, a) {
        switch(e){
            case "1.2.840.10008.1.2":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.1":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.2":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.1.99":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.5":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.50":
                return t.bitsAllocated === 8 && (t.samplesPerPixel === 3 || t.samplesPerPixel === 4) ? sI(t, n, r) : qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.51":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.57":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.70":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.80":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.81":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.90":
                return qa(t, e, n, i, a);
            case "1.2.840.10008.1.2.4.91":
                return qa(t, e, n, i, a);
            case "3.2.840.10008.1.2.4.96":
            case "1.2.840.10008.1.2.4.201":
            case "1.2.840.10008.1.2.4.202":
            case "1.2.840.10008.1.2.4.203":
                return qa(t, e, n, i, a);
        }
        return Promise.reject(new Error(`No decoder for transfer syntax ${e}`));
    }
    function cI(t) {
        const e = ct("imagePixelModule", t);
        return {
            samplesPerPixel: e.samplesPerPixel,
            photometricInterpretation: e.photometricInterpretation,
            planarConfiguration: e.planarConfiguration,
            rows: e.rows,
            columns: e.columns,
            bitsAllocated: e.bitsAllocated,
            bitsStored: e.bitsStored,
            pixelRepresentation: e.pixelRepresentation,
            smallestPixelValue: e.smallestPixelValue,
            largestPixelValue: e.largestPixelValue,
            redPaletteColorLookupTableDescriptor: e.redPaletteColorLookupTableDescriptor,
            greenPaletteColorLookupTableDescriptor: e.greenPaletteColorLookupTableDescriptor,
            bluePaletteColorLookupTableDescriptor: e.bluePaletteColorLookupTableDescriptor,
            redPaletteColorLookupTableData: e.redPaletteColorLookupTableData,
            greenPaletteColorLookupTableData: e.greenPaletteColorLookupTableData,
            bluePaletteColorLookupTableData: e.bluePaletteColorLookupTableData,
            pixelData: void 0,
            imageId: t
        };
    }
    function Tre(t, e) {
        const n = t.get("modalityLutModule", e) || {}, r = t.get("generalSeriesModule", e) || {}, { modality: i } = r, a = {
            rescaleSlope: n.rescaleSlope,
            rescaleIntercept: n.rescaleIntercept,
            modality: i
        }, o = t.get("scalingModule", e) || {};
        return {
            ...a,
            ...i === "PT" && {
                suvbw: o.suvbw
            },
            ...i === "RTDOSE" && {
                doseGridScaling: o.DoseGridScaling,
                doseSummation: o.DoseSummation,
                doseType: o.DoseType,
                doseUnit: o.DoseUnit
            }
        };
    }
    function Oy(t) {
        return t === "RGB" || t === "PALETTE COLOR" || t === "YBR_FULL" || t === "YBR_FULL_422" || t === "YBR_PARTIAL_422" || t === "YBR_PARTIAL_420" || t === "YBR_RCT" || t === "YBR_ICT";
    }
    function xre(t, e) {
        const n = t.length / 4;
        let r = 0, i = 0;
        for(let a = 0; a < n; a++)e[i++] = t[r++], e[i++] = t[r++], e[i++] = t[r++], r++;
        return e;
    }
    function Sre(t) {
        return t !== "1.2.840.10008.5.1.4.1.1.12.1" && t !== "1.2.840.10008.5.1.4.1.1.12.2.1";
    }
    function Iy(t, e) {
        let n;
        return Number.isInteger(t) && Number.isInteger(e) && (t >= 0 ? e <= 255 ? n = Uint8Array : e <= 65535 ? n = Uint16Array : e <= 4294967295 && (n = Uint32Array) : t >= -128 && e <= 127 ? n = Int8Array : t >= -32768 && e <= 32767 && (n = Int16Array)), n || Float32Array;
    }
    function Ere(t, e, n) {
        return Iy(t, e) === n;
    }
    function Dre(t) {
        const e = t.smallestPixelValue, n = t.largestPixelValue, r = Iy(e, n);
        if (r) {
            const i = new r(t.pixelData);
            t.pixelData = i;
        } else throw new Error("Could not apply a typed array to the pixel data");
    }
    let m7 = "";
    function S2(t, e, n, r = {}) {
        const i = r.useRGBA;
        if (r.preScale = {
            enabled: r.preScale && r.preScale.enabled !== void 0 ? r.preScale.enabled : !0
        }, !e?.length) return Promise.reject(new Error("The pixel data is missing"));
        const { MetadataModules: a } = sc, o = document.createElement("canvas"), s = cI(t);
        if (s.decodeLevel = r.decodeLevel, r.allowFloatRendering = g3(), r.preScale.enabled) {
            const u = Tre(oj, t);
            u && (r.preScale = {
                ...r.preScale,
                scalingParameters: u
            });
        }
        const { decodeConfig: c } = pg();
        Object.keys(s).forEach((u)=>{
            (typeof s[u] == "function" || s[u] instanceof Promise) && delete s[u];
        });
        const l = wre(s, n, e, o, r, c), f = Oy(s.photometricInterpretation);
        return new Promise((u, g)=>{
            l.then(function(h) {
                let v = !1;
                if (r.targetBuffer && r.targetBuffer.type && !f) {
                    const { arrayBuffer: F, type: N, offset: B = 0, length: G } = r.targetBuffer, Z = h.pixelDataLength, H = B, ne = G ?? Z - H, ae = {
                        Uint8Array,
                        Uint16Array,
                        Int16Array,
                        Float32Array,
                        Uint32Array
                    };
                    if (ne !== h.pixelDataLength) throw new Error(`target array for image does not have the same length (${ne}) as the decoded image length (${h.pixelDataLength}).`);
                    const ue = ae[N], le = F ? new ue(F, H, ne) : new ue(h.pixelData);
                    if (ne !== h.pixelDataLength) throw new Error("target array for image does not have the same length as the decoded image length.");
                    h.pixelData = le, v = !0;
                }
                v || Dre(h);
                const m = ct(a.IMAGE_PLANE, t) || {}, y = ct(a.VOI_LUT, t) || {}, C = ct(a.MODALITY_LUT, t) || {}, T = ct(a.SOP_COMMON, t) || {}, x = ct(a.CALIBRATION, t) || {}, { rows: S, columns: D } = h;
                if (f) {
                    if (vre(h)) {
                        o.height = h.rows, o.width = h.columns;
                        let B = o.getContext("2d").createImageData(h.columns, h.rows);
                        i || (B = {
                            ...B,
                            data: new Uint8ClampedArray(3 * h.columns * h.rows)
                        }), oI(h, B.data, i), h.imageData = B, h.pixelData = B.data, h.pixelDataLength = B.data.length;
                    } else if (!i && h.pixelDataLength === 4 * S * D) {
                        const N = new Uint8Array(h.pixelData.length / 4 * 3);
                        h.pixelData = xre(h.pixelData, N), h.pixelDataLength = h.pixelData.length;
                    }
                    const F = x2(h.pixelData);
                    h.smallestPixelValue = F.min, h.largestPixelValue = F.max;
                }
                let _ = h.samplesPerPixel;
                h.photometricInterpretation === "PALETTE COLOR" && (_ = i ? 4 : 3);
                const M = $n.createImageVoxelManager({
                    scalarData: h.pixelData,
                    width: h.columns,
                    height: h.rows,
                    numberOfComponents: _
                }), P = {
                    imageId: t,
                    dataType: h.pixelData.constructor.name,
                    color: f,
                    calibration: x,
                    columnPixelSpacing: m.columnPixelSpacing,
                    columns: h.columns,
                    height: h.rows,
                    preScale: h.preScale,
                    intercept: C.rescaleIntercept ? C.rescaleIntercept : 0,
                    slope: C.rescaleSlope ? C.rescaleSlope : 1,
                    invert: h.photometricInterpretation === "MONOCHROME1",
                    minPixelValue: h.smallestPixelValue,
                    maxPixelValue: h.largestPixelValue,
                    rowPixelSpacing: m.rowPixelSpacing,
                    rows: h.rows,
                    sizeInBytes: h.pixelData.byteLength,
                    width: h.columns,
                    windowCenter: y.windowCenter ? y.windowCenter[0] : void 0,
                    windowWidth: y.windowWidth ? y.windowWidth[0] : void 0,
                    voiLUTFunction: y.voiLUTFunction ? y.voiLUTFunction : void 0,
                    decodeTimeInMS: h.decodeTimeInMS,
                    floatPixelData: void 0,
                    imageFrame: h,
                    voxelManager: M,
                    rgba: f && i,
                    getPixelData: ()=>h.pixelData,
                    getCanvas: void 0,
                    numberOfComponents: _
                };
                if (P.color && (P.getCanvas = function() {
                    if (m7 === t) return o;
                    const F = P.columns, N = P.rows;
                    o.height = N, o.width = F;
                    const B = o.getContext("2d"), G = B.createImageData(F, N), Z = h.pixelData;
                    if (Z.length === F * N * 4) for(let H = 0; H < Z.length; H++)G.data[H] = Z[H];
                    else if (Z.length === F * N * 3) {
                        let H = 0;
                        for(let ne = 0; ne < Z.length; ne += 3)G.data[H++] = Z[ne], G.data[H++] = Z[ne + 1], G.data[H++] = Z[ne + 2], G.data[H++] = 255;
                    }
                    return h.pixelData = G.data, h.pixelDataLength = G.data.length, h.imageData = G, B.putImageData(h.imageData, 0, 0), m7 = t, o;
                }), C.modalityLUTSequence && C.modalityLUTSequence.length > 0 && Sre(T.sopClassUID) && (P.modalityLUT = C.modalityLUTSequence[0]), y.voiLUTSequence && y.voiLUTSequence.length > 0 && (P.voiLUT = y.voiLUTSequence[0]), P.color && (P.windowWidth = 256, P.windowCenter = 128), P.windowCenter === void 0 || P.windowWidth === void 0) {
                    const F = Zd(P.imageFrame.smallestPixelValue, P.imageFrame.largestPixelValue);
                    P.windowWidth = F.windowWidth, P.windowCenter = F.windowCenter;
                }
                u(P);
            }, g);
        });
    }
    const { ImageQualityStatus: lI } = sc;
    function _re(t, e) {
        t.decache = function() {
            const n = hg(e);
            ju.unload(n.url);
        };
    }
    function uI(t, e, n = 0, r, i, a) {
        const o = new Date().getTime(), s = {
            cancelFn: void 0,
            promise: void 0
        };
        return s.promise = new Promise((c, l)=>{
            t.then((f)=>{
                const u = Ry(f, n), g = f.string("x00020010"), h = new Date().getTime(), v = S2(e, u, g, i);
                _re(s, e), v.then((m)=>{
                    m = m, m.data = f, m.sharedCacheKey = r;
                    const y = new Date().getTime();
                    m.loadTimeInMS = h - o, m.totalTimeInMS = y - o, m.imageQualityStatus = lI.FULL_RESOLUTION, a !== void 0 && a.imageDoneCallback !== void 0 && a.imageDoneCallback(m), c(m);
                }, function(m) {
                    l({
                        error: m,
                        dataSet: f
                    });
                });
            }, function(f) {
                l({
                    error: f
                });
            });
        }), s;
    }
    function Rre(t, e, n = 0, r, i) {
        const a = new Date().getTime();
        return {
            promise: new Promise((s, c)=>{
                const l = new Date().getTime();
                let f;
                try {
                    const u = Ry(t, n), g = t.string("x00020010");
                    f = S2(e, u, g, i);
                } catch (u) {
                    c({
                        error: u,
                        dataSet: t
                    });
                    return;
                }
                f.then((u)=>{
                    u = u, u.data = t;
                    const g = new Date().getTime();
                    u.loadTimeInMS = l - a, u.totalTimeInMS = g - a, u.imageQualityStatus = lI.FULL_RESOLUTION, s(u);
                }, c);
            }),
            cancelFn: void 0
        };
    }
    function fI(t) {
        if (t === "dicomweb" || t === "wadouri") return C2;
        if (t === "dicomfile") return aI;
    }
    function Dh(t, e = {}) {
        const n = hg(t);
        e = Object.assign({}, e), delete e.loader;
        const r = fI(n.scheme);
        if (ju.isLoaded(n.url)) {
            const a = ju.get(n.url, r, t);
            return Rre(a, t, n.pixelDataFrame, n.url, e);
        }
        const i = ju.load(n.url, r, t);
        return uI(i, t, n.frame, n.url, e);
    }
    function dI() {
        L0("dicomweb", Dh), L0("wadouri", Dh), L0("dicomfile", Dh), cf(_y);
    }
    const Ore = {
        getImagePixelModule: WO,
        getLUTs: a3,
        getModalityLUTOutputPixelRepresentation: $O,
        getNumberValues: Ss,
        metaDataProvider: _y,
        metadataForDataset: eI
    }, Ire = {
        metaData: Ore,
        dataSetCacheManager: ju,
        fileManager: tI,
        getEncapsulatedImageFrame: nI,
        getUncompressedImageFrame: iI,
        loadFileRequest: aI,
        loadImageFromPromise: uI,
        getLoaderForScheme: fI,
        getPixelData: Ry,
        loadImage: Dh,
        parseImageId: hg,
        unpackBinaryFrame: rI,
        register: dI
    };
    function Vt(t, e, n) {
        return e = e || 0, !t || !t.Value || Array.isArray(t.Value) && t.Value.length <= e ? n : t.Value[e];
    }
    function Mre(t, e, n) {
        const r = Vt(t, e, n);
        if (r !== void 0) return parseFloat(String(r));
    }
    function wn(t, e) {
        const n = Vt(t, e);
        if (n !== void 0) return parseFloat(n);
    }
    function oa(t, e) {
        if (!t || !t.Value || !Array.isArray(t.Value) || e && t.Value.length < e) return;
        const n = [];
        for(let r = 0; r < t.Value.length; r++)n.push(parseFloat(t.Value[r]));
        return n;
    }
    function bre(t) {
        const e = [];
        for(let n = 0; n <= 30; n += 2){
            let r = `x60${n.toString(16)}`;
            r.length === 4 && (r = `x600${n.toString(16)}`);
            const i = Vt(t[`${r}3000`]);
            if (!i) continue;
            const a = [];
            for(let o = 0; o < i.length; o++)for(let s = 0; s < 8; s++){
                const c = t.Value[i.dataOffset + o];
                a[o * 8 + s] = c >> s & 1;
            }
            e.push({
                rows: wn(t[`${r}0010`]),
                columns: wn(t[`${r}0011`]),
                type: Vt(t[`${r}0040`]),
                x: wn(t[`${r}0050`], 1) - 1,
                y: wn(t[`${r}0050`], 0) - 1,
                pixelData: a,
                description: Vt(t[`${r}0022`]),
                label: Vt(t[`${r}1500`]),
                roiArea: Vt(t[`${r}1301`]),
                roiMean: Vt(t[`${r}1302`]),
                roiStandardDeviation: Vt(t[`${r}1303`])
            });
        }
        return {
            overlays: e
        };
    }
    function E2(t) {
        const e = t.indexOf(":");
        return t.substring(e + 1);
    }
    function Hu(t, e = !0) {
        return t && t.Value ? t.Value[0] && e ? t.Value[0] : t.Value : t;
    }
    function gI(t, e, n) {
        const r = (e ? Object.values(e[0]) : []).map((a)=>a.Value?.[0]).filter((a)=>a !== void 0 && typeof a == "object"), i = (t ? Object.values(t[n - 1]) : []).map((a)=>a.Value?.[0]).filter((a)=>a !== void 0 && typeof a == "object");
        return {
            shared: r,
            perFrame: i
        };
    }
    function hI(t) {
        let { 52009230: e, 52009229: n, "00280008": r, ...i } = t;
        return e = Hu(e, !1), n = Hu(n, !1), r = Hu(r), {
            PerFrameFunctionalGroupsSequence: e,
            SharedFunctionalGroupsSequence: n,
            NumberOfFrames: r,
            rest: i
        };
    }
    function Lre(t, e) {
        const { PerFrameFunctionalGroupsSequence: n, SharedFunctionalGroupsSequence: r, NumberOfFrames: i, rest: a } = hI(e);
        if (n || i > 1) {
            const { shared: o, perFrame: s } = gI(n, r, t), c = Object.assign(e, {
                frameNumber: t
            });
            return [
                ...o,
                ...s
            ].forEach((l)=>{
                Object.entries(l).forEach(([f, u])=>{
                    c[f] = u;
                });
            }), Object.assign(a, {
                "00280008": i
            }, c);
        }
        return e;
    }
    let mg = [], Ep = {};
    function pI(t) {
        const e = t.indexOf("/frames/") + 8, n = t.slice(0, e), r = parseInt(t.slice(e), 10);
        return {
            metadata: mg[`${n}1`],
            frame: r
        };
    }
    function Pre(t) {
        const e = E2(t);
        return pI(e);
    }
    function Vre(t) {
        if (t[52009230] !== void 0 || t[52009229] !== void 0) return !0;
        const e = Vt(t["00280008"]);
        return e && e > 1;
    }
    function Nre(t, e) {
        const n = E2(t);
        Object.defineProperty(e, "isMultiframe", {
            value: Vre(e),
            enumerable: !1
        }), mg[n] = e;
    }
    function Are(t) {
        const e = E2(t), n = mg[e];
        if (n && !n?.isMultiframe) return n;
        const r = Ep[e];
        if (r) return r;
        const i = pI(e);
        if (!i || !i.metadata) return;
        const { metadata: a, frame: o } = i;
        if (a) {
            const s = Lre(o, a);
            return Ep[e] = s, s;
        }
    }
    function kre(t) {
        const e = E2(t);
        mg[e] = void 0, Ep[e] = void 0;
    }
    function Ure() {
        mg = [], Ep = {};
    }
    const My = {
        add: Nre,
        get: Are,
        remove: kre,
        purge: Ure
    };
    function mI(t) {
        return Vt(t["00080060"]).includes("NM");
    }
    function by(t, e) {
        const n = Hu(t["00080008"], !1);
        if (n) return n[e];
    }
    function Fre(t) {
        let e;
        const n = by(t, 2);
        if (n && mf(n)) {
            const r = Hu(t["00540022"]);
            r && (e = oa(r["00200037"], 6));
        }
        return e;
    }
    function Bre(t) {
        let e;
        const n = by(t, 2);
        if (n && mf(n)) {
            const r = Hu(t["00540022"]);
            r && (e = oa(r["00200032"], 3));
        }
        return e;
    }
    function v7(t) {
        let e = oa(t["00200037"], 6);
        return !e && mI(t) && (e = Fre(t)), e;
    }
    function y7(t) {
        let e = oa(t["00200032"], 3);
        return !e && mI(t) && (e = Bre(t)), e;
    }
    function ra(t, e) {
        const n = oa(t[e]);
        return n ? n[0] : null;
    }
    function Gre(t) {
        return t?.Value?.length ? Array.isArray(t.Value) ? t.Value : typeof t.Value == "object" ? (console.warn("Warning: Value should be an array, but an object was found. Encapsulating the object in an array."), [
            t.Value
        ]) : [] : [];
    }
    function C7(t) {
        const e = Gre(t["00186011"]);
        return !e || !e.length ? null : e.map((r)=>{
            const i = ra(r, "0018602C"), a = ra(r, "0018602E"), o = ra(r, "00186024"), s = ra(r, "00186026"), c = ra(r, "0018601A"), l = ra(r, "0018601E"), f = ra(r, "00186018"), u = ra(r, "0018601C"), g = ra(r, "00186020"), h = ra(r, "00186022"), v = ra(r, "0018602A"), m = ra(r, "00186028"), y = ra(r, "00186012"), C = ra(r, "00186014"), T = ra(r, "00186016"), x = ra(r, "00186030");
            return {
                regionLocationMinY0: c,
                regionLocationMaxY1: l,
                regionLocationMinX0: f,
                regionLocationMaxX1: u,
                referencePixelX0: g,
                referencePixelY0: h,
                physicalDeltaX: i,
                physicalDeltaY: a,
                physicalUnitsXDirection: o,
                physicalUnitsYDirection: s,
                referencePhysicalPixelValueY: v,
                referencePhysicalPixelValueX: m,
                regionSpatialFormat: y,
                regionDataType: C,
                regionFlags: T,
                transducerFrequency: x
            };
        });
    }
    function Ly(t, e) {
        const { MetadataModules: n } = sc;
        if (t === n.MULTIFRAME) {
            const { metadata: i, frame: a } = Pre(e);
            if (!i) return;
            const { PerFrameFunctionalGroupsSequence: o, SharedFunctionalGroupsSequence: s, NumberOfFrames: c } = hI(i);
            if (o || c > 1) {
                const { shared: l, perFrame: f } = gI(o, s, a);
                return {
                    NumberOfFrames: c,
                    PerFrameFunctionalInformation: f,
                    SharedFunctionalInformation: l
                };
            }
            return {
                NumberOfFrames: c
            };
        }
        const r = My.get(e);
        if (r) {
            if (t === n.GENERAL_STUDY) return {
                studyDescription: Vt(r["00081030"]),
                studyDate: Rr.parseDA(Vt(r["00080020"])),
                studyTime: Rr.parseTM(Vt(r["00080030"], 0, "")),
                accessionNumber: Vt(r["00080050"])
            };
            if (t === n.GENERAL_SERIES) return {
                modality: Vt(r["00080060"]),
                seriesInstanceUID: Vt(r["0020000E"]),
                seriesDescription: Vt(r["0008103E"]),
                seriesNumber: wn(r["00200011"]),
                studyInstanceUID: Vt(r["0020000D"]),
                seriesDate: Rr.parseDA(Vt(r["00080021"])),
                seriesTime: Rr.parseTM(Vt(r["00080031"], 0, "")),
                acquisitionDate: Rr.parseDA(Vt(r["00080022"])),
                acquisitionTime: Rr.parseTM(Vt(r["00080032"], 0, ""))
            };
            if (t === n.GENERAL_IMAGE) return {
                sopInstanceUID: Vt(r["00080018"]),
                instanceNumber: wn(r["00200013"]),
                lossyImageCompression: Vt(r["00282110"]),
                lossyImageCompressionRatio: wn(r["00282112"]),
                lossyImageCompressionMethod: Vt(r["00282114"])
            };
            if (t === n.PATIENT) return {
                patientID: Vt(r["00100020"]),
                patientName: Vt(r["00100010"])
            };
            if (t === n.PATIENT_STUDY) return {
                patientAge: wn(r["00101010"]),
                patientSize: wn(r["00101020"]),
                patientSex: Vt(r["00100040"]),
                patientWeight: wn(r["00101030"])
            };
            if (t === n.NM_MULTIFRAME_GEOMETRY) {
                const i = Vt(r["00080060"]), a = by(r, 2);
                return {
                    modality: i,
                    imageType: Vt(r["00080008"]),
                    imageSubType: a,
                    imageOrientationPatient: v7(r),
                    imagePositionPatient: y7(r),
                    sliceThickness: wn(r["00180050"]),
                    spacingBetweenSlices: wn(r["00180088"]),
                    pixelSpacing: oa(r["00280030"], 2),
                    numberOfFrames: wn(r["00280008"]),
                    isNMReconstructable: mf(a) && i.includes("NM")
                };
            }
            if (t === n.IMAGE_PLANE) {
                let i = v7(r), a = y7(r);
                const o = oa(r["00280030"], 2);
                let s = null, c = null, l = null, f = null, u = !1;
                return o ? (c = o[0], s = o[1]) : (u = !0, c = 1, s = 1), i ? (l = [
                    parseFloat(i[0]),
                    parseFloat(i[1]),
                    parseFloat(i[2])
                ], f = [
                    parseFloat(i[3]),
                    parseFloat(i[4]),
                    parseFloat(i[5])
                ]) : (l = [
                    1,
                    0,
                    0
                ], f = [
                    0,
                    1,
                    0
                ], u = !0, i = [
                    ...l,
                    ...f
                ]), a || (a = [
                    0,
                    0,
                    0
                ], u = !0), {
                    frameOfReferenceUID: Vt(r["00200052"]),
                    rows: wn(r["00280010"]),
                    columns: wn(r["00280011"]),
                    imageOrientationPatient: i,
                    rowCosines: l,
                    columnCosines: f,
                    imagePositionPatient: a,
                    sliceThickness: wn(r["00180050"]),
                    sliceLocation: wn(r["00201041"]),
                    pixelSpacing: o,
                    rowPixelSpacing: c,
                    columnPixelSpacing: s,
                    usingDefaultValues: u
                };
            }
            if (t === n.ULTRASOUND_ENHANCED_REGION) return C7(r);
            if (t === n.CALIBRATION && Vt(r["00080060"]) === "US") return {
                sequenceOfUltrasoundRegions: C7(r)
            };
            if (t === n.IMAGE_URL) return Wre(e, r);
            if (t === n.CINE) return $re(e, r);
            if (t === n.IMAGE_PIXEL) return {
                samplesPerPixel: wn(r["00280002"]),
                photometricInterpretation: Vt(r["00280004"]),
                rows: wn(r["00280010"]),
                columns: wn(r["00280011"]),
                bitsAllocated: wn(r["00280100"]),
                bitsStored: wn(r["00280101"]),
                highBit: Vt(r["00280102"]),
                pixelRepresentation: wn(r["00280103"]),
                planarConfiguration: wn(r["00280006"]),
                pixelAspectRatio: Vt(r["00280034"]),
                smallestPixelValue: wn(r["00280106"]),
                largestPixelValue: wn(r["00280107"]),
                redPaletteColorLookupTableDescriptor: oa(r["00281101"]),
                greenPaletteColorLookupTableDescriptor: oa(r["00281102"]),
                bluePaletteColorLookupTableDescriptor: oa(r["00281103"]),
                redPaletteColorLookupTableData: oa(r["00281201"]),
                greenPaletteColorLookupTableData: oa(r["00281202"]),
                bluePaletteColorLookupTableData: oa(r["00281203"])
            };
            if (t === n.VOI_LUT) return {
                windowCenter: oa(r["00281050"], 1),
                windowWidth: oa(r["00281051"], 1),
                voiLUTFunction: Vt(r["00281056"])
            };
            if (t === n.MODALITY_LUT) return {
                rescaleIntercept: wn(r["00281052"]),
                rescaleSlope: wn(r["00281053"]),
                rescaleType: Vt(r["00281054"])
            };
            if (t === n.SOP_COMMON) return {
                sopClassUID: Vt(r["00080016"]),
                sopInstanceUID: Vt(r["00080018"])
            };
            if (t === n.PET_ISOTOPE) {
                const i = Vt(r["00540016"]);
                return i === void 0 ? void 0 : {
                    radiopharmaceuticalInfo: {
                        radiopharmaceuticalStartTime: Rr.parseTM(Vt(i["00181072"], 0, "")),
                        radiopharmaceuticalStartDateTime: Vt(i["00181078"], 0, ""),
                        radionuclideTotalDose: wn(i["00181074"]),
                        radionuclideHalfLife: wn(i["00181075"])
                    }
                };
            }
            if (t === n.OVERLAY_PLANE) return bre(r);
            if (t === "transferSyntax") return vI(e, r);
            if (t === n.PET_SERIES) return {
                correctedImage: Vt(r["00280051"]),
                units: Vt(r["00541001"]),
                decayCorrection: Vt(r["00541102"])
            };
            if (t === n.PET_IMAGE) return {
                frameReferenceTime: wn(r["00541300"]),
                actualFrameDuration: wn(r["00181242"])
            };
            if (t === "instance") return JO(e, Ly, QO);
        }
    }
    function Wre(t, e) {
        const { transferSyntaxUID: n } = vI(t, e), r = y_(n), i = t.substring(7), a = i.replace("/frames/", "/thumbnail/");
        let o = i.replace("/frames/", "/rendered/");
        return r && (o = o.replace("/rendered/1", "/rendered")), {
            isVideo: r,
            rendered: o,
            thumbnail: a
        };
    }
    function $re(t, e) {
        return {
            cineRate: Vt(e["00180040"]),
            numberOfFrames: wn(e["00280008"])
        };
    }
    function vI(t, e) {
        return {
            transferSyntaxUID: Vt(e["00020010"]) || Vt(e["00083002"])
        };
    }
    function zre(t, e, n = {}, r = {}) {
        const i = pg(), { retrieveOptions: a = {}, streamingData: o } = r, s = o.chunkSize || Hre(e, a, "chunkSize") || 65536, c = (f)=>{
            if (typeof i.errorInterceptor == "function") {
                const u = new Error("request failed");
                i.errorInterceptor(u);
            } else console.warn("rangeRequest:Caught", f);
        };
        return new Promise(async (f, u)=>{
            const g = Object.assign({}, n);
            Object.keys(g).forEach(function(h) {
                (g[h] === null || g[h] === void 0) && delete g[h];
            });
            try {
                o.encodedData || (o.chunkSize = s, o.rangesFetched = 0);
                const h = Kre(o, a), { encodedData: v, responseHeaders: m } = await jre(t, g, h, o), y = m.get("content-type"), { totalBytes: C } = o, T = C === v.byteLength, x = xy(y, v, {
                    isPartial: !0
                }), S = Sy(a, T || x.extractDone);
                f({
                    ...x,
                    imageQualityStatus: S,
                    percentComplete: x.extractDone ? 100 : s * 100 / C
                });
            } catch (h) {
                c(h), console.error(h), u(h);
            }
        });
    }
    async function jre(t, e, n, r) {
        n && (e = Object.assign(e, {
            Range: `bytes=${n[0]}-${n[1]}`
        }));
        let { encodedData: i } = r;
        if (n[1] && i?.byteLength > n[1]) return r;
        const a = await fetch(t, {
            headers: e,
            signal: void 0
        }), o = await a.arrayBuffer(), s = new Uint8Array(o), { status: c } = a;
        let l;
        i ? (l = new Uint8Array(i.length + s.length), l.set(i, 0), l.set(s, i.length), r.rangesFetched = 1) : (l = new Uint8Array(s.length), l.set(s, 0), r.rangesFetched++), r.encodedData = i = l, r.responseHeaders = a.headers;
        const f = a.headers.get("Content-Range");
        return f ? r.totalBytes = Number(f.split("/")[1]) : c !== 206 || !n ? r.totalBytes = i?.byteLength : n[1] === "" || i?.length < n[1] ? r.totalBytes = i.byteLength : r.totalBytes = Number.MAX_SAFE_INTEGER, r;
    }
    function Hre(t, e, n) {
        const r = e[n];
        if (typeof r != "function") return r;
        const i = My.get(t);
        return r(i, t);
    }
    function Kre(t, e) {
        const { totalBytes: n, encodedData: r, chunkSize: i = 65536 } = t, { rangeIndex: a = 0 } = e;
        return a === -1 && (!n || !r) ? [
            0,
            ""
        ] : a === -1 || r?.byteLength > n - i ? [
            r?.byteLength || 0,
            ""
        ] : [
            r?.byteLength || 0,
            i * (a + 1) - 1
        ];
    }
    function Py(t, e, n = "application/octet-stream", r) {
        const { streamingData: i, retrieveOptions: a = {} } = r || {}, o = {
            Accept: n
        };
        let s = a.urlArguments ? `${t}${t.indexOf("?") === -1 ? "?" : "&"}${a.urlArguments}` : t;
        if (a.framesPath && (s = s.replace("/frames/", a.framesPath)), i?.url !== s && (r.streamingData = {
            url: s
        }), a.rangeIndex !== void 0) return zre(s, e, o, r);
        if (a.streaming) return HO(s, e, o, r);
        const c = C2(s, e, o), { xhr: l } = c;
        return c.then(function(f) {
            const u = l.getResponseHeader("Content-Type") || "application/octet-stream", g = xy(u, new Uint8Array(f));
            return g.imageQualityStatus = Sy(a, !0), g;
        });
    }
    const { ProgressiveIterator: w7 } = ga, { ImageQualityStatus: T7 } = sc, qre = new Set([
        "3.2.840.10008.1.2.4.96",
        "1.2.840.10008.1.2.4.202",
        "1.2.840.10008.1.2.4.203"
    ]);
    function Xre(t) {
        const e = "1.2.840.10008.1.2";
        if (!t) return e;
        const n = t.split(";"), r = {};
        n.forEach((a)=>{
            const o = a.split("=");
            if (o.length !== 2) return;
            const s = o[1].trim().replace(/"/g, "");
            r[o[0].trim()] = s;
        });
        const i = {
            "image/jpeg": "1.2.840.10008.1.2.4.50",
            "image/x-dicom-rle": "1.2.840.10008.1.2.5",
            "image/x-jls": "1.2.840.10008.1.2.4.80",
            "image/jls": "1.2.840.10008.1.2.4.80",
            "image/jll": "1.2.840.10008.1.2.4.70",
            "image/jp2": "1.2.840.10008.1.2.4.90",
            "image/jpx": "1.2.840.10008.1.2.4.92",
            "image/jphc": "3.2.840.10008.1.2.4.96",
            "image/jxl": "1.2.840.10008.1.2.4.140"
        };
        return r["transfer-syntax"] ? r["transfer-syntax"] : t && !Object.keys(r).length && i[t] ? i[t] : r.type && i[r.type] ? i[r.type] : i[t] ? i[t] : e;
    }
    function Yre() {
        return ig;
    }
    const Zre = "multipart/related; type=application/octet-stream; transfer-syntax=*";
    function yI(t, e = {}) {
        const n = Yre(), r = new Date().getTime(), i = new w7("decompress");
        async function a(f, u, g) {
            i.generate(async (h)=>{
                const v = w7.as(Py(f, u, g, e));
                let m = 10;
                for await (const y of v){
                    const { pixelData: C, imageQualityStatus: T = T7.FULL_RESOLUTION, percentComplete: x, done: S = !0, extractDone: D = !0 } = y, _ = Xre(y.contentType);
                    if (!D && !qre.has(_)) continue;
                    const M = y.decodeLevel ?? (T === T7.FULL_RESOLUTION ? 0 : Jre(x, e.retrieveOptions?.decodeLevel));
                    if (!(!S && m <= M)) try {
                        const P = {
                            ...e,
                            decodeLevel: M
                        }, F = await S2(u, C, _, P), N = new Date().getTime();
                        F.loadTimeInMS = N - r, F.transferSyntaxUID = _, F.imageQualityStatus = T, h.add(F, S), m = M;
                    } catch (P) {
                        if (D) throw console.warn("Couldn't decode", P), P;
                    }
                }
            });
        }
        const o = e.requestType || Gt.Interaction, s = e.additionalDetails || {
            imageId: t
        }, c = e.priority === void 0 ? 5 : e.priority, l = t.substring(7);
        return n.addRequest(a.bind(this, l, t, Zre), o, s, c), {
            promise: i.getDonePromise(),
            cancelFn: void 0
        };
    }
    function Jre(t, e = 4) {
        const n = t / 100 - .02;
        return n > 1 / 4 ? Math.min(e, 0) : n > 1 / 16 ? Math.min(e, 1) : n > 1 / 64 ? Math.min(e, 2) : Math.min(e, 3);
    }
    function CI() {
        L0("wadors", yI), cf(Ly);
    }
    const Qre = {
        getNumberString: Mre,
        getNumberValue: wn,
        getNumberValues: oa,
        getValue: Vt,
        metaDataProvider: Ly
    }, eie = {
        metaData: Qre,
        findIndexOfString: s3,
        getPixelData: Py,
        loadImage: yI,
        metaDataManager: My,
        register: CI
    };
    function tie() {
        CI(), dI();
    }
    const nie = ()=>new Worker(new URL("/assets/decodeImageFrameWorker-ByFdCM-s.js", import.meta.url), {
            type: "module"
        });
    function rie(t = {}) {
        jO(t), tie();
        const e = rT(), n = t?.maxWebWorkers || iie();
        e.registerWorker("dicomImageLoader", nie, {
            maxWorkerInstances: n
        });
    }
    function iie() {
        return typeof navigator < "u" && navigator.hardwareConcurrency ? Math.max(1, Math.floor(navigator.hardwareConcurrency / 2)) : 1;
    }
    function aie(t, e) {
        if (e = e || t.transferSyntax, t.bitsAllocated === 8 && e === "1.2.840.10008.1.2.4.50" && (t.samplesPerPixel === 3 || t.samplesPerPixel === 4)) return !0;
    }
    const oie = {
        IMPLICIT_VR_LITTLE_ENDIAN: "1.2.840.10008.1.2",
        EXPLICIT_VR_LITTLE_ENDIAN: "1.2.840.10008.1.2.1",
        DEFLATED_EXPLICIT_VR_LITTLE_ENDIAN: "1.2.840.10008.1.2.1.99",
        EXPLICIT_VR_BIG_ENDIAN: "1.2.840.10008.1.2.2",
        JPEG_BASELINE_PROCESS_1: "1.2.840.10008.1.2.4.50",
        JPEG_EXTENDED_PROCESS_2_4: "1.2.840.10008.1.2.4.51",
        JPEG_EXTENDED_PROCESSES_3_5: "1.2.840.10008.1.2.4.52",
        JPEG_SPECTRAL_SELECTION_NONHIERARCHICAL_PROCESSES_6_8: "1.2.840.10008.1.2.4.53",
        JPEG_SPECTRAL_SELECTION_NONHIERARCHICAL_PROCESSES_7_9: "1.2.840.10008.1.2.4.54",
        JPEG_FULL_PROGRESSION_NONHIERARCHICAL_PROCESSES_10_12: "1.2.840.10008.1.2.4.55",
        JPEG_FULL_PROGRESSION_NONHIERARCHICAL_PROCESSES_11_13: "1.2.840.10008.1.2.4.56",
        JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS_14: "1.2.840.10008.1.2.4.57",
        JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS_15: "1.2.840.10008.1.2.4.58",
        JPEG_EXTENDED_HIERARCHICAL_PROCESSES_16_18: "1.2.840.10008.1.2.4.59",
        JPEG_EXTENDED_HIERARCHICAL_PROCESSES_17_19: "1.2.840.10008.1.2.4.60",
        JPEG_SPECTRAL_SELECTION_HIERARCHICAL_PROCESSES_20_22: "1.2.840.10008.1.2.4.61",
        JPEG_SPECTRAL_SELECTION_HIERARCHICAL_PROCESSES_21_23: "1.2.840.10008.1.2.4.62",
        JPEG_FULL_PROGRESSION_HIERARCHICAL_PROCESSES_24_26: "1.2.840.10008.1.2.4.63",
        JPEG_FULL_PROGRESSION_HIERARCHICAL_PROCESSES_25_27: "1.2.840.10008.1.2.4.64",
        JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS_28: "1.2.840.10008.1.2.4.65",
        JPEG_LOSSLESS_NONHIERARCHICAL_PROCESS_29: "1.2.840.10008.1.2.4.66",
        JPEG_LOSSLESS_NONHIERARCHICAL_FIRST_ORDER_PREDICTION_PROCESS_14: "1.2.840.10008.1.2.4.70",
        JPEG_LS_LOSSLESS_IMAGE_COMPRESSION: "1.2.840.10008.1.2.4.80",
        JPEG_LS_LOSSY_NEAR_LOSSLESS_IMAGE_COMPRESSION: "1.2.840.10008.1.2.4.81",
        JPEG_2000_IMAGE_COMPRESSION_LOSSLESS_ONLY: "1.2.840.10008.1.2.4.90",
        JPEG_2000_IMAGE_COMPRESSION: "1.2.840.10008.1.2.4.91",
        JPEG_2000_PART_2_MULTICOMPONENT_IMAGE_COMPRESSION_LOSSLESS_ONLY: "1.2.840.10008.1.2.4.92",
        JPEG_2000_PART_2_MULTICOMPONENT_IMAGE_COMPRESSION: "1.2.840.10008.1.2.4.93",
        JPIP_REFERENCED: "1.2.840.10008.1.2.4.94",
        JPIP_REFERENCED_DEFLATE: "1.2.840.10008.1.2.4.95",
        MPEG2_MAIN_PROFILE_MAIN_LEVEL: "1.2.840.10008.1.2.4.100",
        MPEG4_AVC_H264_HIGH_PROFILE_LEVEL_4_1: "1.2.840.10008.1.2.4.101",
        MPEG4_AVC_H264_BD_COMPATIBLE_HIGH_PROFILE_LEVEL_4_1: "1.2.840.10008.1.2.4.102",
        MPEG4_AVC_H264_HIGH_PROFILE_FOR_2D_VIDEO: "1.2.840.10008.1.2.4.103",
        MPEG4_AVC_H264_HIGH_PROFILE_FOR_3D_VIDEO: "1.2.840.10008.1.2.4.104",
        JPIP_LOSSLESS: "1.2.840.10008.1.2.4.96",
        JPIP_PART2_MULTICOMPONENT_IMAGE_COMPRESSION: "1.2.840.10008.1.2.4.97",
        RFC_2557_MIME_ENCAPSULATION: "1.2.840.10008.1.2.6.1",
        JPEG_XR_IMAGE_COMPRESSION: "1.2.840.10008.1.2.6.2",
        JPEG_2000_IMAGE_COMPRESSION_LOSSLESS_ONLY_RETIRED: "1.2.840.10008.1.2.4.90R",
        JPEG_2000_IMAGE_COMPRESSION_RETIRED: "1.2.840.10008.1.2.4.91R",
        JPEG_2000_PART_2_MULTICOMPONENT_IMAGE_COMPRESSION_LOSSLESS_ONLY_RETIRED: "1.2.840.10008.1.2.4.92R",
        JPEG_2000_PART_2_MULTICOMPONENT_IMAGE_COMPRESSION_RETIRED: "1.2.840.10008.1.2.4.93R"
    }, sie = Object.freeze(Object.defineProperty({
        __proto__: null,
        transferSyntaxes: oie
    }, Symbol.toStringTag, {
        value: "Module"
    }));
    function cie(t, e) {
        const { rows: n, columns: r, data: i } = t, { rows: a, columns: o, data: s } = e, c = [], l = [], f = [];
        for(let u = 0; u < o; u++){
            const g = u * (r - 1) / (o - 1);
            c[u] = Math.floor(g), l[u] = Math.min(c[u] + 1, r - 1), f[u] = g - c[u];
        }
        for(let u = 0; u < a; u++){
            const g = u * (n - 1) / (a - 1), h = Math.floor(g) * r, v = Math.min(h + r, (n - 1) * r), m = g - Math.floor(g), y = 1 - m, C = u * o;
            for(let T = 0; T < o; T++){
                const x = i[h + c[T]], S = i[h + l[T]], D = i[v + c[T]], _ = i[v + l[T]], M = 1 - f[T];
                s[C + T] = (x * M + S * f[T]) * y + (D * M + _ * f[T]) * m;
            }
        }
        return s;
    }
    function lie(t, e) {
        const { rows: n, columns: r, pixelData: i, samplesPerPixel: a = 1 } = t, { rows: o, columns: s, pixelData: c } = e, l = [];
        for(let f = 0; f < s; f++){
            const u = f * (r - 1) / (s - 1);
            l[f] = Math.floor(u) * a;
        }
        for(let f = 0; f < o; f++){
            const u = f * (n - 1) / (o - 1), g = Math.floor(u) * r * a, h = f * s;
            for(let v = 0; v < s; v++)for(let m = 0; m < a; m++)c[h + v + m] = i[g + l[v] + m];
        }
        return c;
    }
    async function x7(t, e) {
        let n = e.buffer, r = e.byteOffset;
        const i = e.length;
        if (t.bitsAllocated === 16) r % 2 && (n = n.slice(r), r = 0), t.pixelRepresentation === 0 ? t.pixelData = new Uint16Array(n, r, i / 2) : t.pixelData = new Int16Array(n, r, i / 2);
        else if (t.bitsAllocated === 8 || t.bitsAllocated === 1) t.pixelData = e;
        else if (t.bitsAllocated === 32) {
            if (r % 2 && (n = n.slice(r), r = 0), t.floatPixelData || t.doubleFloatPixelData) throw new Error("Float pixel data is not supported for parsing into ImageFrame");
            t.pixelRepresentation === 0 ? t.pixelData = new Uint32Array(n, r, i / 4) : t.pixelRepresentation === 1 ? t.pixelData = new Int32Array(n, r, i / 4) : t.pixelData = new Float32Array(n, r, i / 4);
        }
        return t;
    }
    function uie(t) {
        return (t & 255) << 8 | t >> 8 & 255;
    }
    async function fie(t, e) {
        if (t.bitsAllocated === 16) {
            let n = e.buffer, r = e.byteOffset;
            const i = e.length;
            r % 2 && (n = n.slice(r), r = 0), t.pixelRepresentation === 0 ? t.pixelData = new Uint16Array(n, r, i / 2) : t.pixelData = new Int16Array(n, r, i / 2);
            for(let a = 0; a < t.pixelData.length; a++)t.pixelData[a] = uie(t.pixelData[a]);
        } else t.bitsAllocated === 8 && (t.pixelData = e);
        return t;
    }
    async function die(t, e) {
        if (t.bitsAllocated === 8) return t.planarConfiguration ? hie(t, e) : gie(t, e);
        if (t.bitsAllocated === 16) return pie(t, e);
        throw new Error("unsupported pixel format for RLE");
    }
    function gie(t, e) {
        const n = e, r = t.rows * t.columns, i = new ArrayBuffer(r * t.samplesPerPixel), a = new DataView(n.buffer, n.byteOffset), o = new Int8Array(n.buffer, n.byteOffset), s = new Int8Array(i);
        let c = 0;
        const l = a.getInt32(0, !0);
        for(let f = 0; f < l; ++f){
            c = f;
            let u = a.getInt32((f + 1) * 4, !0), g = a.getInt32((f + 2) * 4, !0);
            g === 0 && (g = n.length);
            const h = r * l;
            for(; u < g;){
                const v = o[u++];
                if (v >= 0 && v <= 127) for(let m = 0; m < v + 1 && c < h; ++m)s[c] = o[u++], c += t.samplesPerPixel;
                else if (v <= -1 && v >= -127) {
                    const m = o[u++];
                    for(let y = 0; y < -v + 1 && c < h; ++y)s[c] = m, c += t.samplesPerPixel;
                }
            }
        }
        return t.pixelData = new Uint8Array(i), t;
    }
    function hie(t, e) {
        const n = e, r = t.rows * t.columns, i = new ArrayBuffer(r * t.samplesPerPixel), a = new DataView(n.buffer, n.byteOffset), o = new Int8Array(n.buffer, n.byteOffset), s = new Int8Array(i);
        let c = 0;
        const l = a.getInt32(0, !0);
        for(let f = 0; f < l; ++f){
            c = f * r;
            let u = a.getInt32((f + 1) * 4, !0), g = a.getInt32((f + 2) * 4, !0);
            g === 0 && (g = n.length);
            const h = r * l;
            for(; u < g;){
                const v = o[u++];
                if (v >= 0 && v <= 127) for(let m = 0; m < v + 1 && c < h; ++m)s[c] = o[u++], c++;
                else if (v <= -1 && v >= -127) {
                    const m = o[u++];
                    for(let y = 0; y < -v + 1 && c < h; ++y)s[c] = m, c++;
                }
            }
        }
        return t.pixelData = new Uint8Array(i), t;
    }
    function pie(t, e) {
        const n = e, r = t.rows * t.columns, i = new ArrayBuffer(r * t.samplesPerPixel * 2), a = new DataView(n.buffer, n.byteOffset), o = new Int8Array(n.buffer, n.byteOffset), s = new Int8Array(i), c = a.getInt32(0, !0);
        for(let l = 0; l < c; ++l){
            let f = 0;
            const u = l === 0 ? 1 : 0;
            let g = a.getInt32((l + 1) * 4, !0), h = a.getInt32((l + 2) * 4, !0);
            for(h === 0 && (h = n.length); g < h;){
                const v = o[g++];
                if (v >= 0 && v <= 127) for(let m = 0; m < v + 1 && f < r; ++m)s[f * 2 + u] = o[g++], f++;
                else if (v <= -1 && v >= -127) {
                    const m = o[g++];
                    for(let y = 0; y < -v + 1 && f < r; ++y)s[f * 2 + u] = m, f++;
                }
            }
        }
        return t.pixelRepresentation === 0 ? t.pixelData = new Uint16Array(i) : t.pixelData = new Int16Array(i), t;
    }
    var Q5 = {
        exports: {}
    }, S7;
    function mie() {
        return S7 || (S7 = 1, function(t, e) {
            var n = (()=>{
                var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
                return typeof __filename < "u" && (r = r || __filename), function(i) {
                    i = i || {};
                    var a = typeof i < "u" ? i : {}, o, s;
                    a.ready = new Promise(function(R, I) {
                        o = R, s = I;
                    });
                    var c = Object.assign({}, a), l = "./this.program", f = (R, I)=>{
                        throw I;
                    }, u = typeof window == "object", g = typeof importScripts == "function", h = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", v = "";
                    function m(R) {
                        return a.locateFile ? a.locateFile(R, v) : v + R;
                    }
                    var y, C, T;
                    if (h) {
                        var x = ec, S = ec;
                        g ? v = S.dirname(v) + "/" : v = __dirname + "/", y = (R, I)=>(R = J(R) ? new URL(R) : S.normalize(R), x.readFileSync(R, I ? void 0 : "utf8")), T = (R)=>{
                            var I = y(R, !0);
                            return I.buffer || (I = new Uint8Array(I)), I;
                        }, C = (R, I, A)=>{
                            R = J(R) ? new URL(R) : S.normalize(R), x.readFile(R, function(Y, te) {
                                Y ? A(Y) : I(te.buffer);
                            });
                        }, process.argv.length > 1 && (l = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(R) {
                            if (!(R instanceof jt)) throw R;
                        }), process.on("unhandledRejection", function(R) {
                            throw R;
                        }), f = (R, I)=>{
                            throw process.exitCode = R, I;
                        }, a.inspect = function() {
                            return "[Emscripten Module object]";
                        };
                    } else (u || g) && (g ? v = self.location.href : typeof document < "u" && document.currentScript && (v = document.currentScript.src), r && (v = r), v.indexOf("blob:") !== 0 ? v = v.substr(0, v.replace(/[?#].*/, "").lastIndexOf("/") + 1) : v = "", y = (R)=>{
                        var I = new XMLHttpRequest;
                        return I.open("GET", R, !1), I.send(null), I.responseText;
                    }, g && (T = (R)=>{
                        var I = new XMLHttpRequest;
                        return I.open("GET", R, !1), I.responseType = "arraybuffer", I.send(null), new Uint8Array(I.response);
                    }), C = (R, I, A)=>{
                        var Y = new XMLHttpRequest;
                        Y.open("GET", R, !0), Y.responseType = "arraybuffer", Y.onload = ()=>{
                            if (Y.status == 200 || Y.status == 0 && Y.response) {
                                I(Y.response);
                                return;
                            }
                            A();
                        }, Y.onerror = A, Y.send(null);
                    });
                    var D = a.print || console.log.bind(console), _ = a.printErr || console.warn.bind(console);
                    Object.assign(a, c), c = null, a.arguments && a.arguments, a.thisProgram && (l = a.thisProgram), a.quit && (f = a.quit);
                    var M;
                    a.wasmBinary && (M = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && q("no native wasm support detected");
                    var P, F = !1;
                    function N(R, I) {
                        R || q(I);
                    }
                    var B = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function G(R, I, A) {
                        for(var Y = I + A, te = I; R[te] && !(te >= Y);)++te;
                        if (te - I > 16 && R.buffer && B) return B.decode(R.subarray(I, te));
                        for(var se = ""; I < te;){
                            var de = R[I++];
                            if (!(de & 128)) {
                                se += String.fromCharCode(de);
                                continue;
                            }
                            var pe = R[I++] & 63;
                            if ((de & 224) == 192) {
                                se += String.fromCharCode((de & 31) << 6 | pe);
                                continue;
                            }
                            var Se = R[I++] & 63;
                            if ((de & 240) == 224 ? de = (de & 15) << 12 | pe << 6 | Se : de = (de & 7) << 18 | pe << 12 | Se << 6 | R[I++] & 63, de < 65536) se += String.fromCharCode(de);
                            else {
                                var Le = de - 65536;
                                se += String.fromCharCode(55296 | Le >> 10, 56320 | Le & 1023);
                            }
                        }
                        return se;
                    }
                    function Z(R, I) {
                        return R ? G(oe, R, I) : "";
                    }
                    function H(R, I, A, Y) {
                        if (!(Y > 0)) return 0;
                        for(var te = A, se = A + Y - 1, de = 0; de < R.length; ++de){
                            var pe = R.charCodeAt(de);
                            if (pe >= 55296 && pe <= 57343) {
                                var Se = R.charCodeAt(++de);
                                pe = 65536 + ((pe & 1023) << 10) | Se & 1023;
                            }
                            if (pe <= 127) {
                                if (A >= se) break;
                                I[A++] = pe;
                            } else if (pe <= 2047) {
                                if (A + 1 >= se) break;
                                I[A++] = 192 | pe >> 6, I[A++] = 128 | pe & 63;
                            } else if (pe <= 65535) {
                                if (A + 2 >= se) break;
                                I[A++] = 224 | pe >> 12, I[A++] = 128 | pe >> 6 & 63, I[A++] = 128 | pe & 63;
                            } else {
                                if (A + 3 >= se) break;
                                I[A++] = 240 | pe >> 18, I[A++] = 128 | pe >> 12 & 63, I[A++] = 128 | pe >> 6 & 63, I[A++] = 128 | pe & 63;
                            }
                        }
                        return I[A] = 0, A - te;
                    }
                    function ne(R, I, A) {
                        return H(R, oe, I, A);
                    }
                    function ae(R) {
                        for(var I = 0, A = 0; A < R.length; ++A){
                            var Y = R.charCodeAt(A);
                            Y <= 127 ? I++ : Y <= 2047 ? I += 2 : Y >= 55296 && Y <= 57343 ? (I += 4, ++A) : I += 3;
                        }
                        return I;
                    }
                    var ue, le, oe, re, X, ie, he, $e, je;
                    function He(R) {
                        ue = R, a.HEAP8 = le = new Int8Array(R), a.HEAP16 = re = new Int16Array(R), a.HEAP32 = ie = new Int32Array(R), a.HEAPU8 = oe = new Uint8Array(R), a.HEAPU16 = X = new Uint16Array(R), a.HEAPU32 = he = new Uint32Array(R), a.HEAPF32 = $e = new Float32Array(R), a.HEAPF64 = je = new Float64Array(R);
                    }
                    a.INITIAL_MEMORY;
                    var rt, Qe = [], et = [], St = [];
                    function Ln() {
                        if (a.preRun) for(typeof a.preRun == "function" && (a.preRun = [
                            a.preRun
                        ]); a.preRun.length;)Pe(a.preRun.shift());
                        Cn(Qe);
                    }
                    function Nn() {
                        Cn(et);
                    }
                    function zt() {
                        if (a.postRun) for(typeof a.postRun == "function" && (a.postRun = [
                            a.postRun
                        ]); a.postRun.length;)yt(a.postRun.shift());
                        Cn(St);
                    }
                    function Pe(R) {
                        Qe.unshift(R);
                    }
                    function Ct(R) {
                        et.unshift(R);
                    }
                    function yt(R) {
                        St.unshift(R);
                    }
                    var En = 0, ln = null;
                    function Hn(R) {
                        En++, a.monitorRunDependencies && a.monitorRunDependencies(En);
                    }
                    function Un(R) {
                        if (En--, a.monitorRunDependencies && a.monitorRunDependencies(En), En == 0 && ln) {
                            var I = ln;
                            ln = null, I();
                        }
                    }
                    function q(R) {
                        a.onAbort && a.onAbort(R), R = "Aborted(" + R + ")", _(R), F = !0, R += ". Build with -sASSERTIONS for more info.";
                        var I = new WebAssembly.RuntimeError(R);
                        throw s(I), I;
                    }
                    var Q = "data:application/octet-stream;base64,";
                    function me(R) {
                        return R.startsWith(Q);
                    }
                    function J(R) {
                        return R.startsWith("file://");
                    }
                    var Ce;
                    Ce = "libjpegturbowasm_decode.wasm", me(Ce) || (Ce = m(Ce));
                    function Ue(R) {
                        try {
                            if (R == Ce && M) return new Uint8Array(M);
                            if (T) return T(R);
                            throw "both async and sync fetching of the wasm failed";
                        } catch (I) {
                            q(I);
                        }
                    }
                    function lt() {
                        if (!M && (u || g)) {
                            if (typeof fetch == "function" && !J(Ce)) return fetch(Ce, {
                                credentials: "same-origin"
                            }).then(function(R) {
                                if (!R.ok) throw "failed to load wasm binary file at '" + Ce + "'";
                                return R.arrayBuffer();
                            }).catch(function() {
                                return Ue(Ce);
                            });
                            if (C) return new Promise(function(R, I) {
                                C(Ce, function(A) {
                                    R(new Uint8Array(A));
                                }, I);
                            });
                        }
                        return Promise.resolve().then(function() {
                            return Ue(Ce);
                        });
                    }
                    function Mt() {
                        var R = {
                            a: Me
                        };
                        function I(de, pe) {
                            var Se = de.exports;
                            a.asm = Se, P = a.asm.K, He(P.buffer), rt = a.asm.M, Ct(a.asm.L), Un();
                        }
                        Hn();
                        function A(de) {
                            I(de.instance);
                        }
                        function Y(de) {
                            return lt().then(function(pe) {
                                return WebAssembly.instantiate(pe, R);
                            }).then(function(pe) {
                                return pe;
                            }).then(de, function(pe) {
                                _("failed to asynchronously prepare wasm: " + pe), q(pe);
                            });
                        }
                        function te() {
                            return !M && typeof WebAssembly.instantiateStreaming == "function" && !me(Ce) && !J(Ce) && !h && typeof fetch == "function" ? fetch(Ce, {
                                credentials: "same-origin"
                            }).then(function(de) {
                                var pe = WebAssembly.instantiateStreaming(de, R);
                                return pe.then(A, function(Se) {
                                    return _("wasm streaming compile failed: " + Se), _("falling back to ArrayBuffer instantiation"), Y(A);
                                });
                            }) : Y(A);
                        }
                        if (a.instantiateWasm) try {
                            var se = a.instantiateWasm(R, I);
                            return se;
                        } catch (de) {
                            _("Module.instantiateWasm callback failed with error: " + de), s(de);
                        }
                        return te().catch(s), {};
                    }
                    function jt(R) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + R + ")", this.status = R;
                    }
                    function Cn(R) {
                        for(; R.length > 0;)R.shift()(a);
                    }
                    function tn(R) {
                        this.excPtr = R, this.ptr = R - 24, this.set_type = function(I) {
                            he[this.ptr + 4 >> 2] = I;
                        }, this.get_type = function() {
                            return he[this.ptr + 4 >> 2];
                        }, this.set_destructor = function(I) {
                            he[this.ptr + 8 >> 2] = I;
                        }, this.get_destructor = function() {
                            return he[this.ptr + 8 >> 2];
                        }, this.set_refcount = function(I) {
                            ie[this.ptr >> 2] = I;
                        }, this.set_caught = function(I) {
                            I = I ? 1 : 0, le[this.ptr + 12 >> 0] = I;
                        }, this.get_caught = function() {
                            return le[this.ptr + 12 >> 0] != 0;
                        }, this.set_rethrown = function(I) {
                            I = I ? 1 : 0, le[this.ptr + 13 >> 0] = I;
                        }, this.get_rethrown = function() {
                            return le[this.ptr + 13 >> 0] != 0;
                        }, this.init = function(I, A) {
                            this.set_adjusted_ptr(0), this.set_type(I), this.set_destructor(A), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
                        }, this.add_ref = function() {
                            var I = ie[this.ptr >> 2];
                            ie[this.ptr >> 2] = I + 1;
                        }, this.release_ref = function() {
                            var I = ie[this.ptr >> 2];
                            return ie[this.ptr >> 2] = I - 1, I === 1;
                        }, this.set_adjusted_ptr = function(I) {
                            he[this.ptr + 16 >> 2] = I;
                        }, this.get_adjusted_ptr = function() {
                            return he[this.ptr + 16 >> 2];
                        }, this.get_exception_ptr = function() {
                            var I = ee(this.get_type());
                            if (I) return he[this.excPtr >> 2];
                            var A = this.get_adjusted_ptr();
                            return A !== 0 ? A : this.excPtr;
                        };
                    }
                    function Mr(R, I, A) {
                        var Y = new tn(R);
                        throw Y.init(I, A), R;
                    }
                    var Yt = {};
                    function mn(R) {
                        for(; R.length;){
                            var I = R.pop(), A = R.pop();
                            A(I);
                        }
                    }
                    function Tn(R) {
                        return this.fromWireType(ie[R >> 2]);
                    }
                    var De = {}, ze = {}, ft = {}, nn = 48, Gr = 57;
                    function ir(R) {
                        if (R === void 0) return "_unknown";
                        R = R.replace(/[^a-zA-Z0-9_]/g, "$");
                        var I = R.charCodeAt(0);
                        return I >= nn && I <= Gr ? "_" + R : R;
                    }
                    function dr(R, I) {
                        return R = ir(R), new Function("body", "return function " + R + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(I);
                    }
                    function br(R, I) {
                        var A = dr(I, function(Y) {
                            this.name = I, this.message = Y;
                            var te = new Error(Y).stack;
                            te !== void 0 && (this.stack = this.toString() + `
` + te.replace(/^Error(:[^\n]*)?\n/, ""));
                        });
                        return A.prototype = Object.create(R.prototype), A.prototype.constructor = A, A.prototype.toString = function() {
                            return this.message === void 0 ? this.name : this.name + ": " + this.message;
                        }, A;
                    }
                    var pa = void 0;
                    function Lr(R) {
                        throw new pa(R);
                    }
                    function Pr(R, I, A) {
                        R.forEach(function(pe) {
                            ft[pe] = I;
                        });
                        function Y(pe) {
                            var Se = A(pe);
                            Se.length !== R.length && Lr("Mismatched type converter count");
                            for(var Le = 0; Le < R.length; ++Le)pr(R[Le], Se[Le]);
                        }
                        var te = new Array(I.length), se = [], de = 0;
                        I.forEach((pe, Se)=>{
                            ze.hasOwnProperty(pe) ? te[Se] = ze[pe] : (se.push(pe), De.hasOwnProperty(pe) || (De[pe] = []), De[pe].push(()=>{
                                te[Se] = ze[pe], ++de, de === se.length && Y(te);
                            }));
                        }), se.length === 0 && Y(te);
                    }
                    function Hi(R) {
                        var I = Yt[R];
                        delete Yt[R];
                        var A = I.rawConstructor, Y = I.rawDestructor, te = I.fields, se = te.map((de)=>de.getterReturnType).concat(te.map((de)=>de.setterArgumentType));
                        Pr([
                            R
                        ], se, (de)=>{
                            var pe = {};
                            return te.forEach((Se, Le)=>{
                                var Ze = Se.fieldName, gt = de[Le], ut = Se.getter, At = Se.getterContext, Nt = de[Le + te.length], Bt = Se.setter, Wn = Se.setterContext;
                                pe[Ze] = {
                                    read: (wr)=>gt.fromWireType(ut(At, wr)),
                                    write: (wr, Us)=>{
                                        var xa = [];
                                        Bt(Wn, wr, Nt.toWireType(xa, Us)), mn(xa);
                                    }
                                };
                            }), [
                                {
                                    name: I.name,
                                    fromWireType: function(Se) {
                                        var Le = {};
                                        for(var Ze in pe)Le[Ze] = pe[Ze].read(Se);
                                        return Y(Se), Le;
                                    },
                                    toWireType: function(Se, Le) {
                                        for(var Ze in pe)if (!(Ze in Le)) throw new TypeError('Missing field:  "' + Ze + '"');
                                        var gt = A();
                                        for(Ze in pe)pe[Ze].write(gt, Le[Ze]);
                                        return Se !== null && Se.push(Y, gt), gt;
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Tn,
                                    destructorFunction: Y
                                }
                            ];
                        });
                    }
                    function Li(R, I, A, Y, te) {}
                    function Fn(R) {
                        switch(R){
                            case 1:
                                return 0;
                            case 2:
                                return 1;
                            case 4:
                                return 2;
                            case 8:
                                return 3;
                            default:
                                throw new TypeError("Unknown type size: " + R);
                        }
                    }
                    function ci() {
                        for(var R = new Array(256), I = 0; I < 256; ++I)R[I] = String.fromCharCode(I);
                        _t = R;
                    }
                    var _t = void 0;
                    function Ht(R) {
                        for(var I = "", A = R; oe[A];)I += _t[oe[A++]];
                        return I;
                    }
                    var kt = void 0;
                    function It(R) {
                        throw new kt(R);
                    }
                    function pr(R, I, A = {}) {
                        if (!("argPackAdvance" in I)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                        var Y = I.name;
                        if (R || It('type "' + Y + '" must have a positive integer typeid pointer'), ze.hasOwnProperty(R)) {
                            if (A.ignoreDuplicateRegistrations) return;
                            It("Cannot register type '" + Y + "' twice");
                        }
                        if (ze[R] = I, delete ft[R], De.hasOwnProperty(R)) {
                            var te = De[R];
                            delete De[R], te.forEach((se)=>se());
                        }
                    }
                    function Zr(R, I, A, Y, te) {
                        var se = Fn(A);
                        I = Ht(I), pr(R, {
                            name: I,
                            fromWireType: function(de) {
                                return !!de;
                            },
                            toWireType: function(de, pe) {
                                return pe ? Y : te;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: function(de) {
                                var pe;
                                if (A === 1) pe = le;
                                else if (A === 2) pe = re;
                                else if (A === 4) pe = ie;
                                else throw new TypeError("Unknown boolean type size: " + I);
                                return this.fromWireType(pe[de >> se]);
                            },
                            destructorFunction: null
                        });
                    }
                    function to(R) {
                        if (!(this instanceof Ni) || !(R instanceof Ni)) return !1;
                        for(var I = this.$$.ptrType.registeredClass, A = this.$$.ptr, Y = R.$$.ptrType.registeredClass, te = R.$$.ptr; I.baseClass;)A = I.upcast(A), I = I.baseClass;
                        for(; Y.baseClass;)te = Y.upcast(te), Y = Y.baseClass;
                        return I === Y && A === te;
                    }
                    function _o(R) {
                        return {
                            count: R.count,
                            deleteScheduled: R.deleteScheduled,
                            preservePointerOnDelete: R.preservePointerOnDelete,
                            ptr: R.ptr,
                            ptrType: R.ptrType,
                            smartPtr: R.smartPtr,
                            smartPtrType: R.smartPtrType
                        };
                    }
                    function ma(R) {
                        function I(A) {
                            return A.$$.ptrType.registeredClass.name;
                        }
                        It(I(R) + " instance already deleted");
                    }
                    var no = !1;
                    function xi(R) {}
                    function Kn(R) {
                        R.smartPtr ? R.smartPtrType.rawDestructor(R.smartPtr) : R.ptrType.registeredClass.rawDestructor(R.ptr);
                    }
                    function Pi(R) {
                        R.count.value -= 1;
                        var I = R.count.value === 0;
                        I && Kn(R);
                    }
                    function Kt(R, I, A) {
                        if (I === A) return R;
                        if (A.baseClass === void 0) return null;
                        var Y = Kt(R, I, A.baseClass);
                        return Y === null ? null : A.downcast(Y);
                    }
                    var mr = {};
                    function Ro() {
                        return Object.keys(ui).length;
                    }
                    function Si() {
                        var R = [];
                        for(var I in ui)ui.hasOwnProperty(I) && R.push(ui[I]);
                        return R;
                    }
                    var Ki = [];
                    function Vi() {
                        for(; Ki.length;){
                            var R = Ki.pop();
                            R.$$.deleteScheduled = !1, R.delete();
                        }
                    }
                    var li = void 0;
                    function Pn(R) {
                        li = R, Ki.length && li && li(Vi);
                    }
                    function ro() {
                        a.getInheritedInstanceCount = Ro, a.getLiveInheritedInstances = Si, a.flushPendingDeletes = Vi, a.setDelayFunction = Pn;
                    }
                    var ui = {};
                    function Qo(R, I) {
                        for(I === void 0 && It("ptr should not be undefined"); R.baseClass;)I = R.upcast(I), R = R.baseClass;
                        return I;
                    }
                    function Jr(R, I) {
                        return I = Qo(R, I), ui[I];
                    }
                    function Oo(R, I) {
                        (!I.ptrType || !I.ptr) && Lr("makeClassHandle requires ptr and ptrType");
                        var A = !!I.smartPtrType, Y = !!I.smartPtr;
                        return A !== Y && Lr("Both smartPtrType and smartPtr must be specified"), I.count = {
                            value: 1
                        }, Qr(Object.create(R, {
                            $$: {
                                value: I
                            }
                        }));
                    }
                    function Pa(R) {
                        var I = this.getPointee(R);
                        if (!I) return this.destructor(R), null;
                        var A = Jr(this.registeredClass, I);
                        if (A !== void 0) {
                            if (A.$$.count.value === 0) return A.$$.ptr = I, A.$$.smartPtr = R, A.clone();
                            var Y = A.clone();
                            return this.destructor(R), Y;
                        }
                        function te() {
                            return this.isSmartPointer ? Oo(this.registeredClass.instancePrototype, {
                                ptrType: this.pointeeType,
                                ptr: I,
                                smartPtrType: this,
                                smartPtr: R
                            }) : Oo(this.registeredClass.instancePrototype, {
                                ptrType: this,
                                ptr: R
                            });
                        }
                        var se = this.registeredClass.getActualType(I), de = mr[se];
                        if (!de) return te.call(this);
                        var pe;
                        this.isConst ? pe = de.constPointerType : pe = de.pointerType;
                        var Se = Kt(I, this.registeredClass, pe.registeredClass);
                        return Se === null ? te.call(this) : this.isSmartPointer ? Oo(pe.registeredClass.instancePrototype, {
                            ptrType: pe,
                            ptr: Se,
                            smartPtrType: this,
                            smartPtr: R
                        }) : Oo(pe.registeredClass.instancePrototype, {
                            ptrType: pe,
                            ptr: Se
                        });
                    }
                    function Qr(R) {
                        return typeof FinalizationRegistry > "u" ? (Qr = (I)=>I, R) : (no = new FinalizationRegistry((I)=>{
                            Pi(I.$$);
                        }), Qr = (I)=>{
                            var A = I.$$, Y = !!A.smartPtr;
                            if (Y) {
                                var te = {
                                    $$: A
                                };
                                no.register(I, te, I);
                            }
                            return I;
                        }, xi = (I)=>no.unregister(I), Qr(R));
                    }
                    function ei() {
                        if (this.$$.ptr || ma(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                        var R = Qr(Object.create(Object.getPrototypeOf(this), {
                            $$: {
                                value: _o(this.$$)
                            }
                        }));
                        return R.$$.count.value += 1, R.$$.deleteScheduled = !1, R;
                    }
                    function io() {
                        this.$$.ptr || ma(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && It("Object already scheduled for deletion"), xi(this), Pi(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
                    }
                    function qn() {
                        return !this.$$.ptr;
                    }
                    function _s() {
                        return this.$$.ptr || ma(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && It("Object already scheduled for deletion"), Ki.push(this), Ki.length === 1 && li && li(Vi), this.$$.deleteScheduled = !0, this;
                    }
                    function Wr() {
                        Ni.prototype.isAliasOf = to, Ni.prototype.clone = ei, Ni.prototype.delete = io, Ni.prototype.isDeleted = qn, Ni.prototype.deleteLater = _s;
                    }
                    function Ni() {}
                    function va(R, I, A) {
                        if (R[I].overloadTable === void 0) {
                            var Y = R[I];
                            R[I] = function() {
                                return R[I].overloadTable.hasOwnProperty(arguments.length) || It("Function '" + A + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + R[I].overloadTable + ")!"), R[I].overloadTable[arguments.length].apply(this, arguments);
                            }, R[I].overloadTable = [], R[I].overloadTable[Y.argCount] = Y;
                        }
                    }
                    function ya(R, I, A) {
                        a.hasOwnProperty(R) ? (It("Cannot register public name '" + R + "' twice"), va(a, R, R), a.hasOwnProperty(A) && It("Cannot register multiple overloads of a function with the same number of arguments (" + A + ")!"), a[R].overloadTable[A] = I) : a[R] = I;
                    }
                    function Ca(R, I, A, Y, te, se, de, pe) {
                        this.name = R, this.constructor = I, this.instancePrototype = A, this.rawDestructor = Y, this.baseClass = te, this.getActualType = se, this.upcast = de, this.downcast = pe, this.pureVirtualFunctions = [];
                    }
                    function Ei(R, I, A) {
                        for(; I !== A;)I.upcast || It("Expected null or instance of " + A.name + ", got an instance of " + I.name), R = I.upcast(R), I = I.baseClass;
                        return R;
                    }
                    function dc(R, I) {
                        if (I === null) return this.isReference && It("null is not a valid " + this.name), 0;
                        I.$$ || It('Cannot pass "' + Ui(I) + '" as a ' + this.name), I.$$.ptr || It("Cannot pass deleted object as a pointer of type " + this.name);
                        var A = I.$$.ptrType.registeredClass, Y = Ei(I.$$.ptr, A, this.registeredClass);
                        return Y;
                    }
                    function gc(R, I) {
                        var A;
                        if (I === null) return this.isReference && It("null is not a valid " + this.name), this.isSmartPointer ? (A = this.rawConstructor(), R !== null && R.push(this.rawDestructor, A), A) : 0;
                        I.$$ || It('Cannot pass "' + Ui(I) + '" as a ' + this.name), I.$$.ptr || It("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && I.$$.ptrType.isConst && It("Cannot convert argument of type " + (I.$$.smartPtrType ? I.$$.smartPtrType.name : I.$$.ptrType.name) + " to parameter type " + this.name);
                        var Y = I.$$.ptrType.registeredClass;
                        if (A = Ei(I.$$.ptr, Y, this.registeredClass), this.isSmartPointer) switch(I.$$.smartPtr === void 0 && It("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy){
                            case 0:
                                I.$$.smartPtrType === this ? A = I.$$.smartPtr : It("Cannot convert argument of type " + (I.$$.smartPtrType ? I.$$.smartPtrType.name : I.$$.ptrType.name) + " to parameter type " + this.name);
                                break;
                            case 1:
                                A = I.$$.smartPtr;
                                break;
                            case 2:
                                if (I.$$.smartPtrType === this) A = I.$$.smartPtr;
                                else {
                                    var te = I.clone();
                                    A = this.rawShare(A, Xi.toHandle(function() {
                                        te.delete();
                                    })), R !== null && R.push(this.rawDestructor, A);
                                }
                                break;
                            default:
                                It("Unsupporting sharing policy");
                        }
                        return A;
                    }
                    function es(R, I) {
                        if (I === null) return this.isReference && It("null is not a valid " + this.name), 0;
                        I.$$ || It('Cannot pass "' + Ui(I) + '" as a ' + this.name), I.$$.ptr || It("Cannot pass deleted object as a pointer of type " + this.name), I.$$.ptrType.isConst && It("Cannot convert argument of type " + I.$$.ptrType.name + " to parameter type " + this.name);
                        var A = I.$$.ptrType.registeredClass, Y = Ei(I.$$.ptr, A, this.registeredClass);
                        return Y;
                    }
                    function Rs(R) {
                        return this.rawGetPointee && (R = this.rawGetPointee(R)), R;
                    }
                    function fi(R) {
                        this.rawDestructor && this.rawDestructor(R);
                    }
                    function $r(R) {
                        R !== null && R.delete();
                    }
                    function Di() {
                        vr.prototype.getPointee = Rs, vr.prototype.destructor = fi, vr.prototype.argPackAdvance = 8, vr.prototype.readValueFromPointer = Tn, vr.prototype.deleteObject = $r, vr.prototype.fromWireType = Pa;
                    }
                    function vr(R, I, A, Y, te, se, de, pe, Se, Le, Ze) {
                        this.name = R, this.registeredClass = I, this.isReference = A, this.isConst = Y, this.isSmartPointer = te, this.pointeeType = se, this.sharingPolicy = de, this.rawGetPointee = pe, this.rawConstructor = Se, this.rawShare = Le, this.rawDestructor = Ze, !te && I.baseClass === void 0 ? Y ? (this.toWireType = dc, this.destructorFunction = null) : (this.toWireType = es, this.destructorFunction = null) : this.toWireType = gc;
                    }
                    function an(R, I, A) {
                        a.hasOwnProperty(R) || Lr("Replacing nonexistant public symbol"), a[R].overloadTable !== void 0 && A !== void 0 || (a[R] = I, a[R].argCount = A);
                    }
                    function wa(R, I, A) {
                        var Y = a["dynCall_" + R];
                        return A && A.length ? Y.apply(null, [
                            I
                        ].concat(A)) : Y.call(null, I);
                    }
                    var Va = [];
                    function Bn(R) {
                        var I = Va[R];
                        return I || (R >= Va.length && (Va.length = R + 1), Va[R] = I = rt.get(R)), I;
                    }
                    function ts(R, I, A) {
                        if (R.includes("j")) return wa(R, I, A);
                        var Y = Bn(I).apply(null, A);
                        return Y;
                    }
                    function ti(R, I) {
                        var A = [];
                        return function() {
                            return A.length = 0, Object.assign(A, arguments), ts(R, I, A);
                        };
                    }
                    function yr(R, I) {
                        R = Ht(R);
                        function A() {
                            return R.includes("j") ? ti(R, I) : Bn(I);
                        }
                        var Y = A();
                        return typeof Y != "function" && It("unknown function pointer with signature " + R + ": " + I), Y;
                    }
                    var ao = void 0;
                    function Ai(R) {
                        var I = mt(R), A = Ht(I);
                        return Je(I), A;
                    }
                    function Xn(R, I) {
                        var A = [], Y = {};
                        function te(se) {
                            if (!Y[se] && !ze[se]) {
                                if (ft[se]) {
                                    ft[se].forEach(te);
                                    return;
                                }
                                A.push(se), Y[se] = !0;
                            }
                        }
                        throw I.forEach(te), new ao(R + ": " + A.map(Ai).join([
                            ", "
                        ]));
                    }
                    function ni(R, I, A, Y, te, se, de, pe, Se, Le, Ze, gt, ut) {
                        Ze = Ht(Ze), se = yr(te, se), pe && (pe = yr(de, pe)), Le && (Le = yr(Se, Le)), ut = yr(gt, ut);
                        var At = ir(Ze);
                        ya(At, function() {
                            Xn("Cannot construct " + Ze + " due to unbound types", [
                                Y
                            ]);
                        }), Pr([
                            R,
                            I,
                            A
                        ], Y ? [
                            Y
                        ] : [], function(Nt) {
                            Nt = Nt[0];
                            var Bt, Wn;
                            Y ? (Bt = Nt.registeredClass, Wn = Bt.instancePrototype) : Wn = Ni.prototype;
                            var wr = dr(At, function() {
                                if (Object.getPrototypeOf(this) !== Us) throw new kt("Use 'new' to construct " + Ze);
                                if (xa.constructor_body === void 0) throw new kt(Ze + " has no accessible constructor");
                                var yg = xa.constructor_body[arguments.length];
                                if (yg === void 0) throw new kt("Tried to invoke ctor of " + Ze + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(xa.constructor_body).toString() + ") parameters instead!");
                                return yg.apply(this, arguments);
                            }), Us = Object.create(Wn, {
                                constructor: {
                                    value: wr
                                }
                            });
                            wr.prototype = Us;
                            var xa = new Ca(Ze, wr, Us, ut, Bt, se, pe, Le), Ql = new vr(Ze, xa, !0, !1, !1), Tc = new vr(Ze + "*", xa, !1, !1, !1), vg = new vr(Ze + " const*", xa, !1, !0, !1);
                            return mr[R] = {
                                pointerType: Tc,
                                constPointerType: vg
                            }, an(At, wr), [
                                Ql,
                                Tc,
                                vg
                            ];
                        });
                    }
                    function ki(R, I) {
                        for(var A = [], Y = 0; Y < R; Y++)A.push(he[I + Y * 4 >> 2]);
                        return A;
                    }
                    function Na(R, I) {
                        if (!(R instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof R + " which is not a function");
                        var A = dr(R.name || "unknownFunctionName", function() {});
                        A.prototype = R.prototype;
                        var Y = new A, te = R.apply(Y, I);
                        return te instanceof Object ? te : Y;
                    }
                    function qi(R, I, A, Y, te) {
                        var se = I.length;
                        se < 2 && It("argTypes array size mismatch! Must at least get return value and 'this' types!");
                        for(var de = I[1] !== null && A !== null, pe = !1, Se = 1; Se < I.length; ++Se)if (I[Se] !== null && I[Se].destructorFunction === void 0) {
                            pe = !0;
                            break;
                        }
                        for(var Le = I[0].name !== "void", Ze = "", gt = "", Se = 0; Se < se - 2; ++Se)Ze += (Se !== 0 ? ", " : "") + "arg" + Se, gt += (Se !== 0 ? ", " : "") + "arg" + Se + "Wired";
                        var ut = "return function " + ir(R) + "(" + Ze + `) {
if (arguments.length !== ` + (se - 2) + `) {
throwBindingError('function ` + R + " called with ' + arguments.length + ' arguments, expected " + (se - 2) + ` args!');
}
`;
                        pe && (ut += `var destructors = [];
`);
                        var At = pe ? "destructors" : "null", Nt = [
                            "throwBindingError",
                            "invoker",
                            "fn",
                            "runDestructors",
                            "retType",
                            "classParam"
                        ], Bt = [
                            It,
                            Y,
                            te,
                            mn,
                            I[0],
                            I[1]
                        ];
                        de && (ut += "var thisWired = classParam.toWireType(" + At + `, this);
`);
                        for(var Se = 0; Se < se - 2; ++Se)ut += "var arg" + Se + "Wired = argType" + Se + ".toWireType(" + At + ", arg" + Se + "); // " + I[Se + 2].name + `
`, Nt.push("argType" + Se), Bt.push(I[Se + 2]);
                        if (de && (gt = "thisWired" + (gt.length > 0 ? ", " : "") + gt), ut += (Le ? "var rv = " : "") + "invoker(fn" + (gt.length > 0 ? ", " : "") + gt + `);
`, pe) ut += `runDestructors(destructors);
`;
                        else for(var Se = de ? 1 : 2; Se < I.length; ++Se){
                            var Wn = Se === 1 ? "thisWired" : "arg" + (Se - 2) + "Wired";
                            I[Se].destructorFunction !== null && (ut += Wn + "_dtor(" + Wn + "); // " + I[Se].name + `
`, Nt.push(Wn + "_dtor"), Bt.push(I[Se].destructorFunction));
                        }
                        Le && (ut += `var ret = retType.fromWireType(rv);
return ret;
`), ut += `}
`, Nt.push(ut);
                        var wr = Na(Function, Nt).apply(null, Bt);
                        return wr;
                    }
                    function un(R, I, A, Y, te, se) {
                        N(I > 0);
                        var de = ki(I, A);
                        te = yr(Y, te), Pr([], [
                            R
                        ], function(pe) {
                            pe = pe[0];
                            var Se = "constructor " + pe.name;
                            if (pe.registeredClass.constructor_body === void 0 && (pe.registeredClass.constructor_body = []), pe.registeredClass.constructor_body[I - 1] !== void 0) throw new kt("Cannot register multiple constructors with identical number of parameters (" + (I - 1) + ") for class '" + pe.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                            return pe.registeredClass.constructor_body[I - 1] = ()=>{
                                Xn("Cannot construct " + pe.name + " due to unbound types", de);
                            }, Pr([], de, function(Le) {
                                return Le.splice(1, 0, null), pe.registeredClass.constructor_body[I - 1] = qi(Se, Le, null, te, se), [];
                            }), [];
                        });
                    }
                    function oo(R, I, A, Y, te, se, de, pe) {
                        var Se = ki(A, Y);
                        I = Ht(I), se = yr(te, se), Pr([], [
                            R
                        ], function(Le) {
                            Le = Le[0];
                            var Ze = Le.name + "." + I;
                            I.startsWith("@@") && (I = Symbol[I.substring(2)]), pe && Le.registeredClass.pureVirtualFunctions.push(I);
                            function gt() {
                                Xn("Cannot call " + Ze + " due to unbound types", Se);
                            }
                            var ut = Le.registeredClass.instancePrototype, At = ut[I];
                            return At === void 0 || At.overloadTable === void 0 && At.className !== Le.name && At.argCount === A - 2 ? (gt.argCount = A - 2, gt.className = Le.name, ut[I] = gt) : (va(ut, I, Ze), ut[I].overloadTable[A - 2] = gt), Pr([], Se, function(Nt) {
                                var Bt = qi(Ze, Nt, Le, se, de);
                                return ut[I].overloadTable === void 0 ? (Bt.argCount = A - 2, ut[I] = Bt) : ut[I].overloadTable[A - 2] = Bt, [];
                            }), [];
                        });
                    }
                    var Cr = [], Gn = [
                        {},
                        {
                            value: void 0
                        },
                        {
                            value: null
                        },
                        {
                            value: !0
                        },
                        {
                            value: !1
                        }
                    ];
                    function Os(R) {
                        R > 4 && --Gn[R].refcount === 0 && (Gn[R] = void 0, Cr.push(R));
                    }
                    function di() {
                        for(var R = 0, I = 5; I < Gn.length; ++I)Gn[I] !== void 0 && ++R;
                        return R;
                    }
                    function Io() {
                        for(var R = 5; R < Gn.length; ++R)if (Gn[R] !== void 0) return Gn[R];
                        return null;
                    }
                    function zr() {
                        a.count_emval_handles = di, a.get_first_emval = Io;
                    }
                    var Xi = {
                        toValue: (R)=>(R || It("Cannot use deleted val. handle = " + R), Gn[R].value),
                        toHandle: (R)=>{
                            switch(R){
                                case void 0:
                                    return 1;
                                case null:
                                    return 2;
                                case !0:
                                    return 3;
                                case !1:
                                    return 4;
                                default:
                                    {
                                        var I = Cr.length ? Cr.pop() : Gn.length;
                                        return Gn[I] = {
                                            refcount: 1,
                                            value: R
                                        }, I;
                                    }
                            }
                        }
                    };
                    function Ta(R, I) {
                        I = Ht(I), pr(R, {
                            name: I,
                            fromWireType: function(A) {
                                var Y = Xi.toValue(A);
                                return Os(A), Y;
                            },
                            toWireType: function(A, Y) {
                                return Xi.toHandle(Y);
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Tn,
                            destructorFunction: null
                        });
                    }
                    function Ui(R) {
                        if (R === null) return "null";
                        var I = typeof R;
                        return I === "object" || I === "array" || I === "function" ? R.toString() : "" + R;
                    }
                    function gr(R, I) {
                        switch(I){
                            case 2:
                                return function(A) {
                                    return this.fromWireType($e[A >> 2]);
                                };
                            case 3:
                                return function(A) {
                                    return this.fromWireType(je[A >> 3]);
                                };
                            default:
                                throw new TypeError("Unknown float type: " + R);
                        }
                    }
                    function so(R, I, A) {
                        var Y = Fn(A);
                        I = Ht(I), pr(R, {
                            name: I,
                            fromWireType: function(te) {
                                return te;
                            },
                            toWireType: function(te, se) {
                                return se;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: gr(I, Y),
                            destructorFunction: null
                        });
                    }
                    function hc(R, I, A) {
                        switch(I){
                            case 0:
                                return A ? function(te) {
                                    return le[te];
                                } : function(te) {
                                    return oe[te];
                                };
                            case 1:
                                return A ? function(te) {
                                    return re[te >> 1];
                                } : function(te) {
                                    return X[te >> 1];
                                };
                            case 2:
                                return A ? function(te) {
                                    return ie[te >> 2];
                                } : function(te) {
                                    return he[te >> 2];
                                };
                            default:
                                throw new TypeError("Unknown integer type: " + R);
                        }
                    }
                    function pc(R, I, A, Y, te) {
                        I = Ht(I);
                        var se = Fn(A), de = (gt)=>gt;
                        if (Y === 0) {
                            var pe = 32 - 8 * A;
                            de = (gt)=>gt << pe >>> pe;
                        }
                        var Se = I.includes("unsigned"), Le = (gt, ut)=>{}, Ze;
                        Se ? Ze = function(gt, ut) {
                            return Le(ut, this.name), ut >>> 0;
                        } : Ze = function(gt, ut) {
                            return Le(ut, this.name), ut;
                        }, pr(R, {
                            name: I,
                            fromWireType: de,
                            toWireType: Ze,
                            argPackAdvance: 8,
                            readValueFromPointer: hc(I, se, Y !== 0),
                            destructorFunction: null
                        });
                    }
                    function Mo(R, I, A) {
                        var Y = [
                            Int8Array,
                            Uint8Array,
                            Int16Array,
                            Uint16Array,
                            Int32Array,
                            Uint32Array,
                            Float32Array,
                            Float64Array
                        ], te = Y[I];
                        function se(de) {
                            de = de >> 2;
                            var pe = he, Se = pe[de], Le = pe[de + 1];
                            return new te(ue, Le, Se);
                        }
                        A = Ht(A), pr(R, {
                            name: A,
                            fromWireType: se,
                            argPackAdvance: 8,
                            readValueFromPointer: se
                        }, {
                            ignoreDuplicateRegistrations: !0
                        });
                    }
                    function Yi(R, I) {
                        I = Ht(I);
                        var A = I === "std::string";
                        pr(R, {
                            name: I,
                            fromWireType: function(Y) {
                                var te = he[Y >> 2], se = Y + 4, de;
                                if (A) for(var pe = se, Se = 0; Se <= te; ++Se){
                                    var Le = se + Se;
                                    if (Se == te || oe[Le] == 0) {
                                        var Ze = Le - pe, gt = Z(pe, Ze);
                                        de === void 0 ? de = gt : (de += "\0", de += gt), pe = Le + 1;
                                    }
                                }
                                else {
                                    for(var ut = new Array(te), Se = 0; Se < te; ++Se)ut[Se] = String.fromCharCode(oe[se + Se]);
                                    de = ut.join("");
                                }
                                return Je(Y), de;
                            },
                            toWireType: function(Y, te) {
                                te instanceof ArrayBuffer && (te = new Uint8Array(te));
                                var se, de = typeof te == "string";
                                de || te instanceof Uint8Array || te instanceof Uint8ClampedArray || te instanceof Int8Array || It("Cannot pass non-string to std::string"), A && de ? se = ae(te) : se = te.length;
                                var pe = ke(4 + se + 1), Se = pe + 4;
                                if (he[pe >> 2] = se, A && de) ne(te, Se, se + 1);
                                else if (de) for(var Le = 0; Le < se; ++Le){
                                    var Ze = te.charCodeAt(Le);
                                    Ze > 255 && (Je(Se), It("String has UTF-16 code units that do not fit in 8 bits")), oe[Se + Le] = Ze;
                                }
                                else for(var Le = 0; Le < se; ++Le)oe[Se + Le] = te[Le];
                                return Y !== null && Y.push(Je, pe), pe;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Tn,
                            destructorFunction: function(Y) {
                                Je(Y);
                            }
                        });
                    }
                    var bo = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
                    function Lo(R, I) {
                        for(var A = R, Y = A >> 1, te = Y + I / 2; !(Y >= te) && X[Y];)++Y;
                        if (A = Y << 1, A - R > 32 && bo) return bo.decode(oe.subarray(R, A));
                        for(var se = "", de = 0; !(de >= I / 2); ++de){
                            var pe = re[R + de * 2 >> 1];
                            if (pe == 0) break;
                            se += String.fromCharCode(pe);
                        }
                        return se;
                    }
                    function Zi(R, I, A) {
                        if (A === void 0 && (A = 2147483647), A < 2) return 0;
                        A -= 2;
                        for(var Y = I, te = A < R.length * 2 ? A / 2 : R.length, se = 0; se < te; ++se){
                            var de = R.charCodeAt(se);
                            re[I >> 1] = de, I += 2;
                        }
                        return re[I >> 1] = 0, I - Y;
                    }
                    function ns(R) {
                        return R.length * 2;
                    }
                    function Po(R, I) {
                        for(var A = 0, Y = ""; !(A >= I / 4);){
                            var te = ie[R + A * 4 >> 2];
                            if (te == 0) break;
                            if (++A, te >= 65536) {
                                var se = te - 65536;
                                Y += String.fromCharCode(55296 | se >> 10, 56320 | se & 1023);
                            } else Y += String.fromCharCode(te);
                        }
                        return Y;
                    }
                    function Is(R, I, A) {
                        if (A === void 0 && (A = 2147483647), A < 4) return 0;
                        for(var Y = I, te = Y + A - 4, se = 0; se < R.length; ++se){
                            var de = R.charCodeAt(se);
                            if (de >= 55296 && de <= 57343) {
                                var pe = R.charCodeAt(++se);
                                de = 65536 + ((de & 1023) << 10) | pe & 1023;
                            }
                            if (ie[I >> 2] = de, I += 4, I + 4 > te) break;
                        }
                        return ie[I >> 2] = 0, I - Y;
                    }
                    function Vo(R) {
                        for(var I = 0, A = 0; A < R.length; ++A){
                            var Y = R.charCodeAt(A);
                            Y >= 55296 && Y <= 57343 && ++A, I += 4;
                        }
                        return I;
                    }
                    function No(R, I, A) {
                        A = Ht(A);
                        var Y, te, se, de, pe;
                        I === 2 ? (Y = Lo, te = Zi, de = ns, se = ()=>X, pe = 1) : I === 4 && (Y = Po, te = Is, de = Vo, se = ()=>he, pe = 2), pr(R, {
                            name: A,
                            fromWireType: function(Se) {
                                for(var Le = he[Se >> 2], Ze = se(), gt, ut = Se + 4, At = 0; At <= Le; ++At){
                                    var Nt = Se + 4 + At * I;
                                    if (At == Le || Ze[Nt >> pe] == 0) {
                                        var Bt = Nt - ut, Wn = Y(ut, Bt);
                                        gt === void 0 ? gt = Wn : (gt += "\0", gt += Wn), ut = Nt + I;
                                    }
                                }
                                return Je(Se), gt;
                            },
                            toWireType: function(Se, Le) {
                                typeof Le != "string" && It("Cannot pass non-string to C++ string type " + A);
                                var Ze = de(Le), gt = ke(4 + Ze + I);
                                return he[gt >> 2] = Ze >> pe, te(Le, gt + 4, Ze + I), Se !== null && Se.push(Je, gt), gt;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Tn,
                            destructorFunction: function(Se) {
                                Je(Se);
                            }
                        });
                    }
                    function Ms(R, I, A, Y, te, se) {
                        Yt[R] = {
                            name: Ht(I),
                            rawConstructor: yr(A, Y),
                            rawDestructor: yr(te, se),
                            fields: []
                        };
                    }
                    function Vr(R, I, A, Y, te, se, de, pe, Se, Le) {
                        Yt[R].fields.push({
                            fieldName: Ht(I),
                            getterReturnType: A,
                            getter: yr(Y, te),
                            getterContext: se,
                            setterArgumentType: de,
                            setter: yr(pe, Se),
                            setterContext: Le
                        });
                    }
                    function Aa(R, I) {
                        I = Ht(I), pr(R, {
                            isVoid: !0,
                            name: I,
                            argPackAdvance: 0,
                            fromWireType: function() {},
                            toWireType: function(A, Y) {}
                        });
                    }
                    function Ao() {
                        throw 1 / 0;
                    }
                    var ka = {};
                    function mc(R) {
                        var I = ka[R];
                        return I === void 0 ? Ht(R) : I;
                    }
                    function co() {
                        return typeof globalThis == "object" ? globalThis : function() {
                            return Function;
                        }()("return this")();
                    }
                    function ko(R) {
                        return R === 0 ? Xi.toHandle(co()) : (R = mc(R), Xi.toHandle(co()[R]));
                    }
                    function Ua(R) {
                        R > 4 && (Gn[R].refcount += 1);
                    }
                    function Fa(R, I) {
                        var A = ze[R];
                        return A === void 0 && It(I + " has unknown type " + Ai(R)), A;
                    }
                    function bs(R) {
                        for(var I = "", A = 0; A < R; ++A)I += (A !== 0 ? ", " : "") + "arg" + A;
                        for(var Y = ()=>he, te = "return function emval_allocator_" + R + `(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`, A = 0; A < R; ++A)te += "var argType" + A + " = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter " + A + `');
var arg` + A + " = argType" + A + `.readValueFromPointer(args);
args += argType` + A + `['argPackAdvance'];
argTypes += 4;
`;
                        return te += "var obj = new constructor(" + I + `);
return valueToHandle(obj);
}
`, new Function("requireRegisteredType", "Module", "valueToHandle", "getMemory", te)(Fa, a, Xi.toHandle, Y);
                    }
                    var Ls = {};
                    function vc(R, I, A, Y) {
                        R = Xi.toValue(R);
                        var te = Ls[I];
                        return te || (te = bs(I), Ls[I] = te), te(R, A, Y);
                    }
                    function Ps(R, I) {
                        R = Fa(R, "_emval_take_value");
                        var A = R.readValueFromPointer(I);
                        return Xi.toHandle(A);
                    }
                    function rs() {
                        q("");
                    }
                    function yc(R, I, A) {
                        oe.copyWithin(R, I, I + A);
                    }
                    function Cc() {
                        return 2147483648;
                    }
                    function wc(R) {
                        try {
                            return P.grow(R - ue.byteLength + 65535 >>> 16), He(P.buffer), 1;
                        } catch  {}
                    }
                    function is(R) {
                        var I = oe.length;
                        R = R >>> 0;
                        var A = Cc();
                        if (R > A) return !1;
                        let Y = (Se, Le)=>Se + (Le - Se % Le) % Le;
                        for(var te = 1; te <= 4; te *= 2){
                            var se = I * (1 + .2 / te);
                            se = Math.min(se, R + 100663296);
                            var de = Math.min(A, Y(Math.max(R, se), 65536)), pe = wc(de);
                            if (pe) return !0;
                        }
                        return !1;
                    }
                    var as = {};
                    function Ji() {
                        return l || "./this.program";
                    }
                    function Ba() {
                        if (!Ba.strings) {
                            var R = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", I = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: R,
                                _: Ji()
                            };
                            for(var A in as)as[A] === void 0 ? delete I[A] : I[A] = as[A];
                            var Y = [];
                            for(var A in I)Y.push(A + "=" + I[A]);
                            Ba.strings = Y;
                        }
                        return Ba.strings;
                    }
                    function Fi(R, I, A) {
                        for(var Y = 0; Y < R.length; ++Y)le[I++ >> 0] = R.charCodeAt(Y);
                        le[I >> 0] = 0;
                    }
                    function Vs(R, I) {
                        var A = 0;
                        return Ba().forEach(function(Y, te) {
                            var se = I + A;
                            he[R + te * 4 >> 2] = se, Fi(Y, se), A += Y.length + 1;
                        }), 0;
                    }
                    function Ns(R, I) {
                        var A = Ba();
                        he[R >> 2] = A.length;
                        var Y = 0;
                        return A.forEach(function(te) {
                            Y += te.length + 1;
                        }), he[I >> 2] = Y, 0;
                    }
                    function lo(R) {
                        f(R, new jt(R));
                    }
                    function As(R, I) {
                        lo(R);
                    }
                    var Uo = As;
                    function ks(R) {
                        return 52;
                    }
                    function W(R, I, A, Y, te) {
                        return 70;
                    }
                    var $ = [
                        null,
                        [],
                        []
                    ];
                    function ce(R, I) {
                        var A = $[R];
                        I === 0 || I === 10 ? ((R === 1 ? D : _)(G(A, 0)), A.length = 0) : A.push(I);
                    }
                    function xe(R, I, A, Y) {
                        for(var te = 0, se = 0; se < A; se++){
                            var de = he[I >> 2], pe = he[I + 4 >> 2];
                            I += 8;
                            for(var Se = 0; Se < pe; Se++)ce(R, oe[de + Se]);
                            te += pe;
                        }
                        return he[Y >> 2] = te, 0;
                    }
                    function Oe(R) {
                        var I = a["_" + R];
                        return I;
                    }
                    function Ve(R, I) {
                        le.set(R, I);
                    }
                    function Ne(R, I, A, Y, te) {
                        var se = {
                            string: (Nt)=>{
                                var Bt = 0;
                                if (Nt != null && Nt !== 0) {
                                    var Wn = (Nt.length << 2) + 1;
                                    Bt = k(Wn), ne(Nt, Bt, Wn);
                                }
                                return Bt;
                            },
                            array: (Nt)=>{
                                var Bt = k(Nt.length);
                                return Ve(Nt, Bt), Bt;
                            }
                        };
                        function de(Nt) {
                            return I === "string" ? Z(Nt) : I === "boolean" ? !!Nt : Nt;
                        }
                        var pe = Oe(R), Se = [], Le = 0;
                        if (Y) for(var Ze = 0; Ze < Y.length; Ze++){
                            var gt = se[A[Ze]];
                            gt ? (Le === 0 && (Le = Rt()), Se[Ze] = gt(Y[Ze])) : Se[Ze] = Y[Ze];
                        }
                        var ut = pe.apply(null, Se);
                        function At(Nt) {
                            return Le !== 0 && U(Le), de(Nt);
                        }
                        return ut = At(ut), ut;
                    }
                    pa = a.InternalError = br(Error, "InternalError"), ci(), kt = a.BindingError = br(Error, "BindingError"), Wr(), ro(), Di(), ao = a.UnboundTypeError = br(Error, "UnboundTypeError"), zr();
                    var Me = {
                        g: Mr,
                        A: Hi,
                        w: Li,
                        F: Zr,
                        u: ni,
                        t: un,
                        c: oo,
                        E: Ta,
                        m: so,
                        b: pc,
                        a: Mo,
                        l: Yi,
                        h: No,
                        J: Ms,
                        d: Vr,
                        G: Aa,
                        x: Ao,
                        i: Os,
                        r: ko,
                        p: Ua,
                        q: vc,
                        s: Ps,
                        j: rs,
                        D: yc,
                        y: is,
                        z: Vs,
                        B: Ns,
                        I: Uo,
                        C: ks,
                        v: W,
                        k: xe,
                        o: _e,
                        n: be,
                        H: Ae,
                        f: ye,
                        e: Be
                    };
                    Mt(), a.___wasm_call_ctors = function() {
                        return (a.___wasm_call_ctors = a.asm.L).apply(null, arguments);
                    };
                    var ke = a._malloc = function() {
                        return (ke = a._malloc = a.asm.N).apply(null, arguments);
                    }, Je = a._free = function() {
                        return (Je = a._free = a.asm.O).apply(null, arguments);
                    }, mt = a.___getTypeName = function() {
                        return (mt = a.___getTypeName = a.asm.P).apply(null, arguments);
                    };
                    a.__embind_initialize_bindings = function() {
                        return (a.__embind_initialize_bindings = a.asm.Q).apply(null, arguments);
                    };
                    var Et = a._setThrew = function() {
                        return (Et = a._setThrew = a.asm.R).apply(null, arguments);
                    }, Rt = a.stackSave = function() {
                        return (Rt = a.stackSave = a.asm.S).apply(null, arguments);
                    }, U = a.stackRestore = function() {
                        return (U = a.stackRestore = a.asm.T).apply(null, arguments);
                    }, k = a.stackAlloc = function() {
                        return (k = a.stackAlloc = a.asm.U).apply(null, arguments);
                    }, ee = a.___cxa_is_pointer_type = function() {
                        return (ee = a.___cxa_is_pointer_type = a.asm.V).apply(null, arguments);
                    };
                    a.dynCall_jiji = function() {
                        return (a.dynCall_jiji = a.asm.W).apply(null, arguments);
                    };
                    function ye(R, I) {
                        var A = Rt();
                        try {
                            Bn(R)(I);
                        } catch (Y) {
                            if (U(A), Y !== Y + 0) throw Y;
                            Et(1, 0);
                        }
                    }
                    function _e(R, I) {
                        var A = Rt();
                        try {
                            return Bn(R)(I);
                        } catch (Y) {
                            if (U(A), Y !== Y + 0) throw Y;
                            Et(1, 0);
                        }
                    }
                    function Be(R, I, A, Y) {
                        var te = Rt();
                        try {
                            Bn(R)(I, A, Y);
                        } catch (se) {
                            if (U(te), se !== se + 0) throw se;
                            Et(1, 0);
                        }
                    }
                    function Ae(R, I, A, Y) {
                        var te = Rt();
                        try {
                            return Bn(R)(I, A, Y);
                        } catch (se) {
                            if (U(te), se !== se + 0) throw se;
                            Et(1, 0);
                        }
                    }
                    function be(R, I, A) {
                        var Y = Rt();
                        try {
                            return Bn(R)(I, A);
                        } catch (te) {
                            if (U(Y), te !== te + 0) throw te;
                            Et(1, 0);
                        }
                    }
                    a.ccall = Ne;
                    var L;
                    ln = function R() {
                        L || V(), L || (ln = R);
                    };
                    function V(R) {
                        if (En > 0 || (Ln(), En > 0)) return;
                        function I() {
                            L || (L = !0, a.calledRun = !0, !F && (Nn(), o(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), zt()));
                        }
                        a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                a.setStatus("");
                            }, 1), I();
                        }, 1)) : I();
                    }
                    if (a.preInit) for(typeof a.preInit == "function" && (a.preInit = [
                        a.preInit
                    ]); a.preInit.length > 0;)a.preInit.pop()();
                    return V(), i.ready;
                };
            })();
            t.exports = n;
        }(Q5)), Q5.exports;
    }
    var vie = mie();
    const yie = Qa(vie), Cie = new URL("/assets/libjpegturbowasm_decode-daqMmuVl.wasm", import.meta.url), _h = {
        codec: void 0,
        decoder: void 0
    };
    function wie() {
        if (_h.codec) return Promise.resolve();
        const t = yie({
            locateFile: (e)=>e.endsWith(".wasm") ? Cie.toString() : e
        });
        return new Promise((e, n)=>{
            t.then((r)=>{
                _h.codec = r, _h.decoder = new r.JPEGDecoder, e();
            }, n);
        });
    }
    async function Tie(t, e) {
        await wie();
        const n = _h.decoder;
        n.getEncodedBuffer(t.length).set(t), n.decode();
        const i = n.getFrameInfo(), a = n.getDecodedBuffer(), o = {
            columns: i.width,
            rows: i.height,
            bitsPerPixel: i.bitsPerSample,
            signed: e.signed,
            bytesPerPixel: e.bytesPerPixel,
            componentsPerPixel: i.componentCount
        }, s = xie(i, a), c = {
            frameInfo: i
        };
        return {
            ...e,
            pixelData: s,
            imageInfo: o,
            encodeOptions: c,
            ...c,
            ...o
        };
    }
    function xie(t, e) {
        return t.isSigned ? new Int8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    }
    const Ed = {
        JpegImage: void 0,
        decodeConfig: {}
    };
    function Sie(t) {
        return Ed.decodeConfig = t, Ed.JpegImage ? Promise.resolve() : new Promise((e, n)=>{
            y2(()=>import("./jpeg-CB7_OXod.js"), []).then((r)=>{
                Ed.JpegImage = r.default, e();
            }).catch(n);
        });
    }
    async function Eie(t, e) {
        if (await Sie(), typeof Ed.JpegImage > "u") throw new Error("No JPEG Baseline decoder loaded");
        const n = new Ed.JpegImage;
        if (n.parse(e), n.colorTransform = !1, t.bitsAllocated === 8) return t.pixelData = n.getData(t.columns, t.rows), t;
        if (t.bitsAllocated === 16) return t.pixelData = n.getData16(t.columns, t.rows), t;
    }
    const Dd = {
        jpeg: void 0,
        decodeConfig: {}
    };
    function Die(t) {
        return Dd.decodeConfig = t, Dd.jpeg ? Promise.resolve() : new Promise((e, n)=>{
            y2(async ()=>{
                const { Decoder: r } = await import("./lossless-DVKeooSO.js");
                return {
                    Decoder: r
                };
            }, []).then(({ Decoder: r })=>{
                const i = new r;
                Dd.jpeg = i, e();
            }, n);
        });
    }
    async function E7(t, e) {
        if (await Die(), typeof Dd.jpeg > "u") throw new Error("No JPEG Lossless decoder loaded");
        const n = t.bitsAllocated <= 8 ? 1 : 2, r = e.buffer, i = Dd.jpeg.decode(r, e.byteOffset, e.length, n);
        return t.pixelRepresentation === 0 ? t.bitsAllocated === 16 ? (t.pixelData = new Uint16Array(i.buffer), t) : (t.pixelData = new Uint8Array(i.buffer), t) : (t.pixelData = new Int16Array(i.buffer), t);
    }
    var ev = {
        exports: {}
    }, D7;
    function _ie() {
        return D7 || (D7 = 1, function(t, e) {
            var n = (()=>{
                var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
                return typeof __filename < "u" && (r = r || __filename), function(i) {
                    i = i || {};
                    var a = typeof i < "u" ? i : {}, o, s;
                    a.ready = new Promise(function(W, $) {
                        o = W, s = $;
                    });
                    var c = Object.assign({}, a), l = typeof window == "object", f = typeof importScripts == "function", u = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g = "";
                    function h(W) {
                        return a.locateFile ? a.locateFile(W, g) : g + W;
                    }
                    var v, m, y;
                    if (u) {
                        var C = ec, T = ec;
                        f ? g = T.dirname(g) + "/" : g = __dirname + "/", v = (W, $)=>(W = q(W) ? new URL(W) : T.normalize(W), C.readFileSync(W, $ ? void 0 : "utf8")), y = (W)=>{
                            var $ = v(W, !0);
                            return $.buffer || ($ = new Uint8Array($)), $;
                        }, m = (W, $, ce)=>{
                            W = q(W) ? new URL(W) : T.normalize(W), C.readFile(W, function(xe, Oe) {
                                xe ? ce(xe) : $(Oe.buffer);
                            });
                        }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(W) {
                            if (!(W instanceof Ue)) throw W;
                        }), process.on("unhandledRejection", function(W) {
                            throw W;
                        }), a.inspect = function() {
                            return "[Emscripten Module object]";
                        };
                    } else (l || f) && (f ? g = self.location.href : typeof document < "u" && document.currentScript && (g = document.currentScript.src), r && (g = r), g.indexOf("blob:") !== 0 ? g = g.substr(0, g.replace(/[?#].*/, "").lastIndexOf("/") + 1) : g = "", v = (W)=>{
                        var $ = new XMLHttpRequest;
                        return $.open("GET", W, !1), $.send(null), $.responseText;
                    }, f && (y = (W)=>{
                        var $ = new XMLHttpRequest;
                        return $.open("GET", W, !1), $.responseType = "arraybuffer", $.send(null), new Uint8Array($.response);
                    }), m = (W, $, ce)=>{
                        var xe = new XMLHttpRequest;
                        xe.open("GET", W, !0), xe.responseType = "arraybuffer", xe.onload = ()=>{
                            if (xe.status == 200 || xe.status == 0 && xe.response) {
                                $(xe.response);
                                return;
                            }
                            ce();
                        }, xe.onerror = ce, xe.send(null);
                    });
                    a.print || console.log.bind(console);
                    var x = a.printErr || console.warn.bind(console);
                    Object.assign(a, c), c = null, a.arguments && a.arguments, a.thisProgram && a.thisProgram, a.quit && a.quit;
                    var S;
                    a.wasmBinary && (S = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && ln("no native wasm support detected");
                    var D, _ = !1;
                    function M(W, $) {
                        W || ln($);
                    }
                    var P = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function F(W, $, ce) {
                        for(var xe = $ + ce, Oe = $; W[Oe] && !(Oe >= xe);)++Oe;
                        if (Oe - $ > 16 && W.buffer && P) return P.decode(W.subarray($, Oe));
                        for(var Ve = ""; $ < Oe;){
                            var Ne = W[$++];
                            if (!(Ne & 128)) {
                                Ve += String.fromCharCode(Ne);
                                continue;
                            }
                            var Me = W[$++] & 63;
                            if ((Ne & 224) == 192) {
                                Ve += String.fromCharCode((Ne & 31) << 6 | Me);
                                continue;
                            }
                            var ke = W[$++] & 63;
                            if ((Ne & 240) == 224 ? Ne = (Ne & 15) << 12 | Me << 6 | ke : Ne = (Ne & 7) << 18 | Me << 12 | ke << 6 | W[$++] & 63, Ne < 65536) Ve += String.fromCharCode(Ne);
                            else {
                                var Je = Ne - 65536;
                                Ve += String.fromCharCode(55296 | Je >> 10, 56320 | Je & 1023);
                            }
                        }
                        return Ve;
                    }
                    function N(W, $) {
                        return W ? F(ae, W, $) : "";
                    }
                    function B(W, $, ce, xe) {
                        if (!(xe > 0)) return 0;
                        for(var Oe = ce, Ve = ce + xe - 1, Ne = 0; Ne < W.length; ++Ne){
                            var Me = W.charCodeAt(Ne);
                            if (Me >= 55296 && Me <= 57343) {
                                var ke = W.charCodeAt(++Ne);
                                Me = 65536 + ((Me & 1023) << 10) | ke & 1023;
                            }
                            if (Me <= 127) {
                                if (ce >= Ve) break;
                                $[ce++] = Me;
                            } else if (Me <= 2047) {
                                if (ce + 1 >= Ve) break;
                                $[ce++] = 192 | Me >> 6, $[ce++] = 128 | Me & 63;
                            } else if (Me <= 65535) {
                                if (ce + 2 >= Ve) break;
                                $[ce++] = 224 | Me >> 12, $[ce++] = 128 | Me >> 6 & 63, $[ce++] = 128 | Me & 63;
                            } else {
                                if (ce + 3 >= Ve) break;
                                $[ce++] = 240 | Me >> 18, $[ce++] = 128 | Me >> 12 & 63, $[ce++] = 128 | Me >> 6 & 63, $[ce++] = 128 | Me & 63;
                            }
                        }
                        return $[ce] = 0, ce - Oe;
                    }
                    function G(W, $, ce) {
                        return B(W, ae, $, ce);
                    }
                    function Z(W) {
                        for(var $ = 0, ce = 0; ce < W.length; ++ce){
                            var xe = W.charCodeAt(ce);
                            xe <= 127 ? $++ : xe <= 2047 ? $ += 2 : xe >= 55296 && xe <= 57343 ? ($ += 4, ++ce) : $ += 3;
                        }
                        return $;
                    }
                    var H, ne, ae, ue, le, oe, re, X, ie;
                    function he(W) {
                        H = W, a.HEAP8 = ne = new Int8Array(W), a.HEAP16 = ue = new Int16Array(W), a.HEAP32 = oe = new Int32Array(W), a.HEAPU8 = ae = new Uint8Array(W), a.HEAPU16 = le = new Uint16Array(W), a.HEAPU32 = re = new Uint32Array(W), a.HEAPF32 = X = new Float32Array(W), a.HEAPF64 = ie = new Float64Array(W);
                    }
                    a.INITIAL_MEMORY;
                    var $e, je = [], He = [], rt = [];
                    function Qe() {
                        if (a.preRun) for(typeof a.preRun == "function" && (a.preRun = [
                            a.preRun
                        ]); a.preRun.length;)Ln(a.preRun.shift());
                        lt(je);
                    }
                    function et() {
                        lt(He);
                    }
                    function St() {
                        if (a.postRun) for(typeof a.postRun == "function" && (a.postRun = [
                            a.postRun
                        ]); a.postRun.length;)zt(a.postRun.shift());
                        lt(rt);
                    }
                    function Ln(W) {
                        je.unshift(W);
                    }
                    function Nn(W) {
                        He.unshift(W);
                    }
                    function zt(W) {
                        rt.unshift(W);
                    }
                    var Pe = 0, Ct = null;
                    function yt(W) {
                        Pe++, a.monitorRunDependencies && a.monitorRunDependencies(Pe);
                    }
                    function En(W) {
                        if (Pe--, a.monitorRunDependencies && a.monitorRunDependencies(Pe), Pe == 0 && Ct) {
                            var $ = Ct;
                            Ct = null, $();
                        }
                    }
                    function ln(W) {
                        a.onAbort && a.onAbort(W), W = "Aborted(" + W + ")", x(W), _ = !0, W += ". Build with -sASSERTIONS for more info.";
                        var $ = new WebAssembly.RuntimeError(W);
                        throw s($), $;
                    }
                    var Hn = "data:application/octet-stream;base64,";
                    function Un(W) {
                        return W.startsWith(Hn);
                    }
                    function q(W) {
                        return W.startsWith("file://");
                    }
                    var Q;
                    Q = "charlswasm_decode.wasm", Un(Q) || (Q = h(Q));
                    function me(W) {
                        try {
                            if (W == Q && S) return new Uint8Array(S);
                            if (y) return y(W);
                            throw "both async and sync fetching of the wasm failed";
                        } catch ($) {
                            ln($);
                        }
                    }
                    function J() {
                        if (!S && (l || f)) {
                            if (typeof fetch == "function" && !q(Q)) return fetch(Q, {
                                credentials: "same-origin"
                            }).then(function(W) {
                                if (!W.ok) throw "failed to load wasm binary file at '" + Q + "'";
                                return W.arrayBuffer();
                            }).catch(function() {
                                return me(Q);
                            });
                            if (m) return new Promise(function(W, $) {
                                m(Q, function(ce) {
                                    W(new Uint8Array(ce));
                                }, $);
                            });
                        }
                        return Promise.resolve().then(function() {
                            return me(Q);
                        });
                    }
                    function Ce() {
                        var W = {
                            a: as
                        };
                        function $(Ne, Me) {
                            var ke = Ne.exports;
                            a.asm = ke, D = a.asm.z, he(D.buffer), $e = a.asm.C, Nn(a.asm.A), En();
                        }
                        yt();
                        function ce(Ne) {
                            $(Ne.instance);
                        }
                        function xe(Ne) {
                            return J().then(function(Me) {
                                return WebAssembly.instantiate(Me, W);
                            }).then(function(Me) {
                                return Me;
                            }).then(Ne, function(Me) {
                                x("failed to asynchronously prepare wasm: " + Me), ln(Me);
                            });
                        }
                        function Oe() {
                            return !S && typeof WebAssembly.instantiateStreaming == "function" && !Un(Q) && !q(Q) && !u && typeof fetch == "function" ? fetch(Q, {
                                credentials: "same-origin"
                            }).then(function(Ne) {
                                var Me = WebAssembly.instantiateStreaming(Ne, W);
                                return Me.then(ce, function(ke) {
                                    return x("wasm streaming compile failed: " + ke), x("falling back to ArrayBuffer instantiation"), xe(ce);
                                });
                            }) : xe(ce);
                        }
                        if (a.instantiateWasm) try {
                            var Ve = a.instantiateWasm(W, $);
                            return Ve;
                        } catch (Ne) {
                            x("Module.instantiateWasm callback failed with error: " + Ne), s(Ne);
                        }
                        return Oe().catch(s), {};
                    }
                    function Ue(W) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + W + ")", this.status = W;
                    }
                    function lt(W) {
                        for(; W.length > 0;)W.shift()(a);
                    }
                    function Mt(W) {
                        this.excPtr = W, this.ptr = W - 24, this.set_type = function($) {
                            re[this.ptr + 4 >> 2] = $;
                        }, this.get_type = function() {
                            return re[this.ptr + 4 >> 2];
                        }, this.set_destructor = function($) {
                            re[this.ptr + 8 >> 2] = $;
                        }, this.get_destructor = function() {
                            return re[this.ptr + 8 >> 2];
                        }, this.set_refcount = function($) {
                            oe[this.ptr >> 2] = $;
                        }, this.set_caught = function($) {
                            $ = $ ? 1 : 0, ne[this.ptr + 12 >> 0] = $;
                        }, this.get_caught = function() {
                            return ne[this.ptr + 12 >> 0] != 0;
                        }, this.set_rethrown = function($) {
                            $ = $ ? 1 : 0, ne[this.ptr + 13 >> 0] = $;
                        }, this.get_rethrown = function() {
                            return ne[this.ptr + 13 >> 0] != 0;
                        }, this.init = function($, ce) {
                            this.set_adjusted_ptr(0), this.set_type($), this.set_destructor(ce), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
                        }, this.add_ref = function() {
                            var $ = oe[this.ptr >> 2];
                            oe[this.ptr >> 2] = $ + 1;
                        }, this.release_ref = function() {
                            var $ = oe[this.ptr >> 2];
                            return oe[this.ptr >> 2] = $ - 1, $ === 1;
                        }, this.set_adjusted_ptr = function($) {
                            re[this.ptr + 16 >> 2] = $;
                        }, this.get_adjusted_ptr = function() {
                            return re[this.ptr + 16 >> 2];
                        }, this.get_exception_ptr = function() {
                            var $ = As(this.get_type());
                            if ($) return re[this.excPtr >> 2];
                            var ce = this.get_adjusted_ptr();
                            return ce !== 0 ? ce : this.excPtr;
                        };
                    }
                    function jt(W, $, ce) {
                        var xe = new Mt(W);
                        throw xe.init($, ce), W;
                    }
                    var Cn = {};
                    function tn(W) {
                        for(; W.length;){
                            var $ = W.pop(), ce = W.pop();
                            ce($);
                        }
                    }
                    function Mr(W) {
                        return this.fromWireType(oe[W >> 2]);
                    }
                    var Yt = {}, mn = {}, Tn = {}, De = 48, ze = 57;
                    function ft(W) {
                        if (W === void 0) return "_unknown";
                        W = W.replace(/[^a-zA-Z0-9_]/g, "$");
                        var $ = W.charCodeAt(0);
                        return $ >= De && $ <= ze ? "_" + W : W;
                    }
                    function nn(W, $) {
                        return W = ft(W), new Function("body", "return function " + W + `() {
    "use strict";    return body.apply(this, arguments);
};
`)($);
                    }
                    function Gr(W, $) {
                        var ce = nn($, function(xe) {
                            this.name = $, this.message = xe;
                            var Oe = new Error(xe).stack;
                            Oe !== void 0 && (this.stack = this.toString() + `
` + Oe.replace(/^Error(:[^\n]*)?\n/, ""));
                        });
                        return ce.prototype = Object.create(W.prototype), ce.prototype.constructor = ce, ce.prototype.toString = function() {
                            return this.message === void 0 ? this.name : this.name + ": " + this.message;
                        }, ce;
                    }
                    var ir = void 0;
                    function dr(W) {
                        throw new ir(W);
                    }
                    function br(W, $, ce) {
                        W.forEach(function(Me) {
                            Tn[Me] = $;
                        });
                        function xe(Me) {
                            var ke = ce(Me);
                            ke.length !== W.length && dr("Mismatched type converter count");
                            for(var Je = 0; Je < W.length; ++Je)Ht(W[Je], ke[Je]);
                        }
                        var Oe = new Array($.length), Ve = [], Ne = 0;
                        $.forEach((Me, ke)=>{
                            mn.hasOwnProperty(Me) ? Oe[ke] = mn[Me] : (Ve.push(Me), Yt.hasOwnProperty(Me) || (Yt[Me] = []), Yt[Me].push(()=>{
                                Oe[ke] = mn[Me], ++Ne, Ne === Ve.length && xe(Oe);
                            }));
                        }), Ve.length === 0 && xe(Oe);
                    }
                    function pa(W) {
                        var $ = Cn[W];
                        delete Cn[W];
                        var ce = $.rawConstructor, xe = $.rawDestructor, Oe = $.fields, Ve = Oe.map((Ne)=>Ne.getterReturnType).concat(Oe.map((Ne)=>Ne.setterArgumentType));
                        br([
                            W
                        ], Ve, (Ne)=>{
                            var Me = {};
                            return Oe.forEach((ke, Je)=>{
                                var mt = ke.fieldName, Et = Ne[Je], Rt = ke.getter, U = ke.getterContext, k = Ne[Je + Oe.length], ee = ke.setter, ye = ke.setterContext;
                                Me[mt] = {
                                    read: (_e)=>Et.fromWireType(Rt(U, _e)),
                                    write: (_e, Be)=>{
                                        var Ae = [];
                                        ee(ye, _e, k.toWireType(Ae, Be)), tn(Ae);
                                    }
                                };
                            }), [
                                {
                                    name: $.name,
                                    fromWireType: function(ke) {
                                        var Je = {};
                                        for(var mt in Me)Je[mt] = Me[mt].read(ke);
                                        return xe(ke), Je;
                                    },
                                    toWireType: function(ke, Je) {
                                        for(var mt in Me)if (!(mt in Je)) throw new TypeError('Missing field:  "' + mt + '"');
                                        var Et = ce();
                                        for(mt in Me)Me[mt].write(Et, Je[mt]);
                                        return ke !== null && ke.push(xe, Et), Et;
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Mr,
                                    destructorFunction: xe
                                }
                            ];
                        });
                    }
                    function Lr(W, $, ce, xe, Oe) {}
                    function Pr(W) {
                        switch(W){
                            case 1:
                                return 0;
                            case 2:
                                return 1;
                            case 4:
                                return 2;
                            case 8:
                                return 3;
                            default:
                                throw new TypeError("Unknown type size: " + W);
                        }
                    }
                    function Hi() {
                        for(var W = new Array(256), $ = 0; $ < 256; ++$)W[$] = String.fromCharCode($);
                        Li = W;
                    }
                    var Li = void 0;
                    function Fn(W) {
                        for(var $ = "", ce = W; ae[ce];)$ += Li[ae[ce++]];
                        return $;
                    }
                    var ci = void 0;
                    function _t(W) {
                        throw new ci(W);
                    }
                    function Ht(W, $, ce = {}) {
                        if (!("argPackAdvance" in $)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                        var xe = $.name;
                        if (W || _t('type "' + xe + '" must have a positive integer typeid pointer'), mn.hasOwnProperty(W)) {
                            if (ce.ignoreDuplicateRegistrations) return;
                            _t("Cannot register type '" + xe + "' twice");
                        }
                        if (mn[W] = $, delete Tn[W], Yt.hasOwnProperty(W)) {
                            var Oe = Yt[W];
                            delete Yt[W], Oe.forEach((Ve)=>Ve());
                        }
                    }
                    function kt(W, $, ce, xe, Oe) {
                        var Ve = Pr(ce);
                        $ = Fn($), Ht(W, {
                            name: $,
                            fromWireType: function(Ne) {
                                return !!Ne;
                            },
                            toWireType: function(Ne, Me) {
                                return Me ? xe : Oe;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: function(Ne) {
                                var Me;
                                if (ce === 1) Me = ne;
                                else if (ce === 2) Me = ue;
                                else if (ce === 4) Me = oe;
                                else throw new TypeError("Unknown boolean type size: " + $);
                                return this.fromWireType(Me[Ne >> Ve]);
                            },
                            destructorFunction: null
                        });
                    }
                    function It(W) {
                        if (!(this instanceof qn) || !(W instanceof qn)) return !1;
                        for(var $ = this.$$.ptrType.registeredClass, ce = this.$$.ptr, xe = W.$$.ptrType.registeredClass, Oe = W.$$.ptr; $.baseClass;)ce = $.upcast(ce), $ = $.baseClass;
                        for(; xe.baseClass;)Oe = xe.upcast(Oe), xe = xe.baseClass;
                        return $ === xe && ce === Oe;
                    }
                    function pr(W) {
                        return {
                            count: W.count,
                            deleteScheduled: W.deleteScheduled,
                            preservePointerOnDelete: W.preservePointerOnDelete,
                            ptr: W.ptr,
                            ptrType: W.ptrType,
                            smartPtr: W.smartPtr,
                            smartPtrType: W.smartPtrType
                        };
                    }
                    function Zr(W) {
                        function $(ce) {
                            return ce.$$.ptrType.registeredClass.name;
                        }
                        _t($(W) + " instance already deleted");
                    }
                    var to = !1;
                    function _o(W) {}
                    function ma(W) {
                        W.smartPtr ? W.smartPtrType.rawDestructor(W.smartPtr) : W.ptrType.registeredClass.rawDestructor(W.ptr);
                    }
                    function no(W) {
                        W.count.value -= 1;
                        var $ = W.count.value === 0;
                        $ && ma(W);
                    }
                    function xi(W, $, ce) {
                        if ($ === ce) return W;
                        if (ce.baseClass === void 0) return null;
                        var xe = xi(W, $, ce.baseClass);
                        return xe === null ? null : ce.downcast(xe);
                    }
                    var Kn = {};
                    function Pi() {
                        return Object.keys(li).length;
                    }
                    function Kt() {
                        var W = [];
                        for(var $ in li)li.hasOwnProperty($) && W.push(li[$]);
                        return W;
                    }
                    var mr = [];
                    function Ro() {
                        for(; mr.length;){
                            var W = mr.pop();
                            W.$$.deleteScheduled = !1, W.delete();
                        }
                    }
                    var Si = void 0;
                    function Ki(W) {
                        Si = W, mr.length && Si && Si(Ro);
                    }
                    function Vi() {
                        a.getInheritedInstanceCount = Pi, a.getLiveInheritedInstances = Kt, a.flushPendingDeletes = Ro, a.setDelayFunction = Ki;
                    }
                    var li = {};
                    function Pn(W, $) {
                        for($ === void 0 && _t("ptr should not be undefined"); W.baseClass;)$ = W.upcast($), W = W.baseClass;
                        return $;
                    }
                    function ro(W, $) {
                        return $ = Pn(W, $), li[$];
                    }
                    function ui(W, $) {
                        (!$.ptrType || !$.ptr) && dr("makeClassHandle requires ptr and ptrType");
                        var ce = !!$.smartPtrType, xe = !!$.smartPtr;
                        return ce !== xe && dr("Both smartPtrType and smartPtr must be specified"), $.count = {
                            value: 1
                        }, Jr(Object.create(W, {
                            $$: {
                                value: $
                            }
                        }));
                    }
                    function Qo(W) {
                        var $ = this.getPointee(W);
                        if (!$) return this.destructor(W), null;
                        var ce = ro(this.registeredClass, $);
                        if (ce !== void 0) {
                            if (ce.$$.count.value === 0) return ce.$$.ptr = $, ce.$$.smartPtr = W, ce.clone();
                            var xe = ce.clone();
                            return this.destructor(W), xe;
                        }
                        function Oe() {
                            return this.isSmartPointer ? ui(this.registeredClass.instancePrototype, {
                                ptrType: this.pointeeType,
                                ptr: $,
                                smartPtrType: this,
                                smartPtr: W
                            }) : ui(this.registeredClass.instancePrototype, {
                                ptrType: this,
                                ptr: W
                            });
                        }
                        var Ve = this.registeredClass.getActualType($), Ne = Kn[Ve];
                        if (!Ne) return Oe.call(this);
                        var Me;
                        this.isConst ? Me = Ne.constPointerType : Me = Ne.pointerType;
                        var ke = xi($, this.registeredClass, Me.registeredClass);
                        return ke === null ? Oe.call(this) : this.isSmartPointer ? ui(Me.registeredClass.instancePrototype, {
                            ptrType: Me,
                            ptr: ke,
                            smartPtrType: this,
                            smartPtr: W
                        }) : ui(Me.registeredClass.instancePrototype, {
                            ptrType: Me,
                            ptr: ke
                        });
                    }
                    function Jr(W) {
                        return typeof FinalizationRegistry > "u" ? (Jr = ($)=>$, W) : (to = new FinalizationRegistry(($)=>{
                            no($.$$);
                        }), Jr = ($)=>{
                            var ce = $.$$, xe = !!ce.smartPtr;
                            if (xe) {
                                var Oe = {
                                    $$: ce
                                };
                                to.register($, Oe, $);
                            }
                            return $;
                        }, _o = ($)=>to.unregister($), Jr(W));
                    }
                    function Oo() {
                        if (this.$$.ptr || Zr(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                        var W = Jr(Object.create(Object.getPrototypeOf(this), {
                            $$: {
                                value: pr(this.$$)
                            }
                        }));
                        return W.$$.count.value += 1, W.$$.deleteScheduled = !1, W;
                    }
                    function Pa() {
                        this.$$.ptr || Zr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && _t("Object already scheduled for deletion"), _o(this), no(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
                    }
                    function Qr() {
                        return !this.$$.ptr;
                    }
                    function ei() {
                        return this.$$.ptr || Zr(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && _t("Object already scheduled for deletion"), mr.push(this), mr.length === 1 && Si && Si(Ro), this.$$.deleteScheduled = !0, this;
                    }
                    function io() {
                        qn.prototype.isAliasOf = It, qn.prototype.clone = Oo, qn.prototype.delete = Pa, qn.prototype.isDeleted = Qr, qn.prototype.deleteLater = ei;
                    }
                    function qn() {}
                    function _s(W, $, ce) {
                        if (W[$].overloadTable === void 0) {
                            var xe = W[$];
                            W[$] = function() {
                                return W[$].overloadTable.hasOwnProperty(arguments.length) || _t("Function '" + ce + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + W[$].overloadTable + ")!"), W[$].overloadTable[arguments.length].apply(this, arguments);
                            }, W[$].overloadTable = [], W[$].overloadTable[xe.argCount] = xe;
                        }
                    }
                    function Wr(W, $, ce) {
                        a.hasOwnProperty(W) ? ((ce === void 0 || a[W].overloadTable !== void 0 && a[W].overloadTable[ce] !== void 0) && _t("Cannot register public name '" + W + "' twice"), _s(a, W, W), a.hasOwnProperty(ce) && _t("Cannot register multiple overloads of a function with the same number of arguments (" + ce + ")!"), a[W].overloadTable[ce] = $) : (a[W] = $, ce !== void 0 && (a[W].numArguments = ce));
                    }
                    function Ni(W, $, ce, xe, Oe, Ve, Ne, Me) {
                        this.name = W, this.constructor = $, this.instancePrototype = ce, this.rawDestructor = xe, this.baseClass = Oe, this.getActualType = Ve, this.upcast = Ne, this.downcast = Me, this.pureVirtualFunctions = [];
                    }
                    function va(W, $, ce) {
                        for(; $ !== ce;)$.upcast || _t("Expected null or instance of " + ce.name + ", got an instance of " + $.name), W = $.upcast(W), $ = $.baseClass;
                        return W;
                    }
                    function ya(W, $) {
                        if ($ === null) return this.isReference && _t("null is not a valid " + this.name), 0;
                        $.$$ || _t('Cannot pass "' + zr($) + '" as a ' + this.name), $.$$.ptr || _t("Cannot pass deleted object as a pointer of type " + this.name);
                        var ce = $.$$.ptrType.registeredClass, xe = va($.$$.ptr, ce, this.registeredClass);
                        return xe;
                    }
                    function Ca(W, $) {
                        var ce;
                        if ($ === null) return this.isReference && _t("null is not a valid " + this.name), this.isSmartPointer ? (ce = this.rawConstructor(), W !== null && W.push(this.rawDestructor, ce), ce) : 0;
                        $.$$ || _t('Cannot pass "' + zr($) + '" as a ' + this.name), $.$$.ptr || _t("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && $.$$.ptrType.isConst && _t("Cannot convert argument of type " + ($.$$.smartPtrType ? $.$$.smartPtrType.name : $.$$.ptrType.name) + " to parameter type " + this.name);
                        var xe = $.$$.ptrType.registeredClass;
                        if (ce = va($.$$.ptr, xe, this.registeredClass), this.isSmartPointer) switch($.$$.smartPtr === void 0 && _t("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy){
                            case 0:
                                $.$$.smartPtrType === this ? ce = $.$$.smartPtr : _t("Cannot convert argument of type " + ($.$$.smartPtrType ? $.$$.smartPtrType.name : $.$$.ptrType.name) + " to parameter type " + this.name);
                                break;
                            case 1:
                                ce = $.$$.smartPtr;
                                break;
                            case 2:
                                if ($.$$.smartPtrType === this) ce = $.$$.smartPtr;
                                else {
                                    var Oe = $.clone();
                                    ce = this.rawShare(ce, di.toHandle(function() {
                                        Oe.delete();
                                    })), W !== null && W.push(this.rawDestructor, ce);
                                }
                                break;
                            default:
                                _t("Unsupporting sharing policy");
                        }
                        return ce;
                    }
                    function Ei(W, $) {
                        if ($ === null) return this.isReference && _t("null is not a valid " + this.name), 0;
                        $.$$ || _t('Cannot pass "' + zr($) + '" as a ' + this.name), $.$$.ptr || _t("Cannot pass deleted object as a pointer of type " + this.name), $.$$.ptrType.isConst && _t("Cannot convert argument of type " + $.$$.ptrType.name + " to parameter type " + this.name);
                        var ce = $.$$.ptrType.registeredClass, xe = va($.$$.ptr, ce, this.registeredClass);
                        return xe;
                    }
                    function dc(W) {
                        return this.rawGetPointee && (W = this.rawGetPointee(W)), W;
                    }
                    function gc(W) {
                        this.rawDestructor && this.rawDestructor(W);
                    }
                    function es(W) {
                        W !== null && W.delete();
                    }
                    function Rs() {
                        fi.prototype.getPointee = dc, fi.prototype.destructor = gc, fi.prototype.argPackAdvance = 8, fi.prototype.readValueFromPointer = Mr, fi.prototype.deleteObject = es, fi.prototype.fromWireType = Qo;
                    }
                    function fi(W, $, ce, xe, Oe, Ve, Ne, Me, ke, Je, mt) {
                        this.name = W, this.registeredClass = $, this.isReference = ce, this.isConst = xe, this.isSmartPointer = Oe, this.pointeeType = Ve, this.sharingPolicy = Ne, this.rawGetPointee = Me, this.rawConstructor = ke, this.rawShare = Je, this.rawDestructor = mt, !Oe && $.baseClass === void 0 ? xe ? (this.toWireType = ya, this.destructorFunction = null) : (this.toWireType = Ei, this.destructorFunction = null) : this.toWireType = Ca;
                    }
                    function $r(W, $, ce) {
                        a.hasOwnProperty(W) || dr("Replacing nonexistant public symbol"), a[W].overloadTable !== void 0 && ce !== void 0 ? a[W].overloadTable[ce] = $ : (a[W] = $, a[W].argCount = ce);
                    }
                    function Di(W, $, ce) {
                        var xe = a["dynCall_" + W];
                        return ce && ce.length ? xe.apply(null, [
                            $
                        ].concat(ce)) : xe.call(null, $);
                    }
                    var vr = [];
                    function an(W) {
                        var $ = vr[W];
                        return $ || (W >= vr.length && (vr.length = W + 1), vr[W] = $ = $e.get(W)), $;
                    }
                    function wa(W, $, ce) {
                        if (W.includes("j")) return Di(W, $, ce);
                        var xe = an($).apply(null, ce);
                        return xe;
                    }
                    function Va(W, $) {
                        var ce = [];
                        return function() {
                            return ce.length = 0, Object.assign(ce, arguments), wa(W, $, ce);
                        };
                    }
                    function Bn(W, $) {
                        W = Fn(W);
                        function ce() {
                            return W.includes("j") ? Va(W, $) : an($);
                        }
                        var xe = ce();
                        return typeof xe != "function" && _t("unknown function pointer with signature " + W + ": " + $), xe;
                    }
                    var ts = void 0;
                    function ti(W) {
                        var $ = Ba(W), ce = Fn($);
                        return Fi($), ce;
                    }
                    function yr(W, $) {
                        var ce = [], xe = {};
                        function Oe(Ve) {
                            if (!xe[Ve] && !mn[Ve]) {
                                if (Tn[Ve]) {
                                    Tn[Ve].forEach(Oe);
                                    return;
                                }
                                ce.push(Ve), xe[Ve] = !0;
                            }
                        }
                        throw $.forEach(Oe), new ts(W + ": " + ce.map(ti).join([
                            ", "
                        ]));
                    }
                    function ao(W, $, ce, xe, Oe, Ve, Ne, Me, ke, Je, mt, Et, Rt) {
                        mt = Fn(mt), Ve = Bn(Oe, Ve), Me && (Me = Bn(Ne, Me)), Je && (Je = Bn(ke, Je)), Rt = Bn(Et, Rt);
                        var U = ft(mt);
                        Wr(U, function() {
                            yr("Cannot construct " + mt + " due to unbound types", [
                                xe
                            ]);
                        }), br([
                            W,
                            $,
                            ce
                        ], xe ? [
                            xe
                        ] : [], function(k) {
                            k = k[0];
                            var ee, ye;
                            xe ? (ee = k.registeredClass, ye = ee.instancePrototype) : ye = qn.prototype;
                            var _e = nn(U, function() {
                                if (Object.getPrototypeOf(this) !== Be) throw new ci("Use 'new' to construct " + mt);
                                if (Ae.constructor_body === void 0) throw new ci(mt + " has no accessible constructor");
                                var R = Ae.constructor_body[arguments.length];
                                if (R === void 0) throw new ci("Tried to invoke ctor of " + mt + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(Ae.constructor_body).toString() + ") parameters instead!");
                                return R.apply(this, arguments);
                            }), Be = Object.create(ye, {
                                constructor: {
                                    value: _e
                                }
                            });
                            _e.prototype = Be;
                            var Ae = new Ni(mt, _e, Be, Rt, ee, Ve, Me, Je), be = new fi(mt, Ae, !0, !1, !1), L = new fi(mt + "*", Ae, !1, !1, !1), V = new fi(mt + " const*", Ae, !1, !0, !1);
                            return Kn[W] = {
                                pointerType: L,
                                constPointerType: V
                            }, $r(U, _e), [
                                be,
                                L,
                                V
                            ];
                        });
                    }
                    function Ai(W, $) {
                        for(var ce = [], xe = 0; xe < W; xe++)ce.push(re[$ + xe * 4 >> 2]);
                        return ce;
                    }
                    function Xn(W, $) {
                        if (!(W instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof W + " which is not a function");
                        var ce = nn(W.name || "unknownFunctionName", function() {});
                        ce.prototype = W.prototype;
                        var xe = new ce, Oe = W.apply(xe, $);
                        return Oe instanceof Object ? Oe : xe;
                    }
                    function ni(W, $, ce, xe, Oe) {
                        var Ve = $.length;
                        Ve < 2 && _t("argTypes array size mismatch! Must at least get return value and 'this' types!");
                        for(var Ne = $[1] !== null && ce !== null, Me = !1, ke = 1; ke < $.length; ++ke)if ($[ke] !== null && $[ke].destructorFunction === void 0) {
                            Me = !0;
                            break;
                        }
                        for(var Je = $[0].name !== "void", mt = "", Et = "", ke = 0; ke < Ve - 2; ++ke)mt += (ke !== 0 ? ", " : "") + "arg" + ke, Et += (ke !== 0 ? ", " : "") + "arg" + ke + "Wired";
                        var Rt = "return function " + ft(W) + "(" + mt + `) {
if (arguments.length !== ` + (Ve - 2) + `) {
throwBindingError('function ` + W + " called with ' + arguments.length + ' arguments, expected " + (Ve - 2) + ` args!');
}
`;
                        Me && (Rt += `var destructors = [];
`);
                        var U = Me ? "destructors" : "null", k = [
                            "throwBindingError",
                            "invoker",
                            "fn",
                            "runDestructors",
                            "retType",
                            "classParam"
                        ], ee = [
                            _t,
                            xe,
                            Oe,
                            tn,
                            $[0],
                            $[1]
                        ];
                        Ne && (Rt += "var thisWired = classParam.toWireType(" + U + `, this);
`);
                        for(var ke = 0; ke < Ve - 2; ++ke)Rt += "var arg" + ke + "Wired = argType" + ke + ".toWireType(" + U + ", arg" + ke + "); // " + $[ke + 2].name + `
`, k.push("argType" + ke), ee.push($[ke + 2]);
                        if (Ne && (Et = "thisWired" + (Et.length > 0 ? ", " : "") + Et), Rt += (Je ? "var rv = " : "") + "invoker(fn" + (Et.length > 0 ? ", " : "") + Et + `);
`, Me) Rt += `runDestructors(destructors);
`;
                        else for(var ke = Ne ? 1 : 2; ke < $.length; ++ke){
                            var ye = ke === 1 ? "thisWired" : "arg" + (ke - 2) + "Wired";
                            $[ke].destructorFunction !== null && (Rt += ye + "_dtor(" + ye + "); // " + $[ke].name + `
`, k.push(ye + "_dtor"), ee.push($[ke].destructorFunction));
                        }
                        Je && (Rt += `var ret = retType.fromWireType(rv);
return ret;
`), Rt += `}
`, k.push(Rt);
                        var _e = Xn(Function, k).apply(null, ee);
                        return _e;
                    }
                    function ki(W, $, ce, xe, Oe, Ve) {
                        M($ > 0);
                        var Ne = Ai($, ce);
                        Oe = Bn(xe, Oe), br([], [
                            W
                        ], function(Me) {
                            Me = Me[0];
                            var ke = "constructor " + Me.name;
                            if (Me.registeredClass.constructor_body === void 0 && (Me.registeredClass.constructor_body = []), Me.registeredClass.constructor_body[$ - 1] !== void 0) throw new ci("Cannot register multiple constructors with identical number of parameters (" + ($ - 1) + ") for class '" + Me.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                            return Me.registeredClass.constructor_body[$ - 1] = ()=>{
                                yr("Cannot construct " + Me.name + " due to unbound types", Ne);
                            }, br([], Ne, function(Je) {
                                return Je.splice(1, 0, null), Me.registeredClass.constructor_body[$ - 1] = ni(ke, Je, null, Oe, Ve), [];
                            }), [];
                        });
                    }
                    function Na(W, $, ce, xe, Oe, Ve, Ne, Me) {
                        var ke = Ai(ce, xe);
                        $ = Fn($), Ve = Bn(Oe, Ve), br([], [
                            W
                        ], function(Je) {
                            Je = Je[0];
                            var mt = Je.name + "." + $;
                            $.startsWith("@@") && ($ = Symbol[$.substring(2)]), Me && Je.registeredClass.pureVirtualFunctions.push($);
                            function Et() {
                                yr("Cannot call " + mt + " due to unbound types", ke);
                            }
                            var Rt = Je.registeredClass.instancePrototype, U = Rt[$];
                            return U === void 0 || U.overloadTable === void 0 && U.className !== Je.name && U.argCount === ce - 2 ? (Et.argCount = ce - 2, Et.className = Je.name, Rt[$] = Et) : (_s(Rt, $, mt), Rt[$].overloadTable[ce - 2] = Et), br([], ke, function(k) {
                                var ee = ni(mt, k, Je, Ve, Ne);
                                return Rt[$].overloadTable === void 0 ? (ee.argCount = ce - 2, Rt[$] = ee) : Rt[$].overloadTable[ce - 2] = ee, [];
                            }), [];
                        });
                    }
                    var qi = [], un = [
                        {},
                        {
                            value: void 0
                        },
                        {
                            value: null
                        },
                        {
                            value: !0
                        },
                        {
                            value: !1
                        }
                    ];
                    function oo(W) {
                        W > 4 && --un[W].refcount === 0 && (un[W] = void 0, qi.push(W));
                    }
                    function Cr() {
                        for(var W = 0, $ = 5; $ < un.length; ++$)un[$] !== void 0 && ++W;
                        return W;
                    }
                    function Gn() {
                        for(var W = 5; W < un.length; ++W)if (un[W] !== void 0) return un[W];
                        return null;
                    }
                    function Os() {
                        a.count_emval_handles = Cr, a.get_first_emval = Gn;
                    }
                    var di = {
                        toValue: (W)=>(W || _t("Cannot use deleted val. handle = " + W), un[W].value),
                        toHandle: (W)=>{
                            switch(W){
                                case void 0:
                                    return 1;
                                case null:
                                    return 2;
                                case !0:
                                    return 3;
                                case !1:
                                    return 4;
                                default:
                                    {
                                        var $ = qi.length ? qi.pop() : un.length;
                                        return un[$] = {
                                            refcount: 1,
                                            value: W
                                        }, $;
                                    }
                            }
                        }
                    };
                    function Io(W, $) {
                        $ = Fn($), Ht(W, {
                            name: $,
                            fromWireType: function(ce) {
                                var xe = di.toValue(ce);
                                return oo(ce), xe;
                            },
                            toWireType: function(ce, xe) {
                                return di.toHandle(xe);
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Mr,
                            destructorFunction: null
                        });
                    }
                    function zr(W) {
                        if (W === null) return "null";
                        var $ = typeof W;
                        return $ === "object" || $ === "array" || $ === "function" ? W.toString() : "" + W;
                    }
                    function Xi(W, $) {
                        switch($){
                            case 2:
                                return function(ce) {
                                    return this.fromWireType(X[ce >> 2]);
                                };
                            case 3:
                                return function(ce) {
                                    return this.fromWireType(ie[ce >> 3]);
                                };
                            default:
                                throw new TypeError("Unknown float type: " + W);
                        }
                    }
                    function Ta(W, $, ce) {
                        var xe = Pr(ce);
                        $ = Fn($), Ht(W, {
                            name: $,
                            fromWireType: function(Oe) {
                                return Oe;
                            },
                            toWireType: function(Oe, Ve) {
                                return Ve;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Xi($, xe),
                            destructorFunction: null
                        });
                    }
                    function Ui(W, $, ce, xe, Oe, Ve) {
                        var Ne = Ai($, ce);
                        W = Fn(W), Oe = Bn(xe, Oe), Wr(W, function() {
                            yr("Cannot call " + W + " due to unbound types", Ne);
                        }, $ - 1), br([], Ne, function(Me) {
                            var ke = [
                                Me[0],
                                null
                            ].concat(Me.slice(1));
                            return $r(W, ni(W, ke, null, Oe, Ve), $ - 1), [];
                        });
                    }
                    function gr(W, $, ce) {
                        switch($){
                            case 0:
                                return ce ? function(Oe) {
                                    return ne[Oe];
                                } : function(Oe) {
                                    return ae[Oe];
                                };
                            case 1:
                                return ce ? function(Oe) {
                                    return ue[Oe >> 1];
                                } : function(Oe) {
                                    return le[Oe >> 1];
                                };
                            case 2:
                                return ce ? function(Oe) {
                                    return oe[Oe >> 2];
                                } : function(Oe) {
                                    return re[Oe >> 2];
                                };
                            default:
                                throw new TypeError("Unknown integer type: " + W);
                        }
                    }
                    function so(W, $, ce, xe, Oe) {
                        $ = Fn($);
                        var Ve = Pr(ce), Ne = (Et)=>Et;
                        if (xe === 0) {
                            var Me = 32 - 8 * ce;
                            Ne = (Et)=>Et << Me >>> Me;
                        }
                        var ke = $.includes("unsigned"), Je = (Et, Rt)=>{}, mt;
                        ke ? mt = function(Et, Rt) {
                            return Je(Rt, this.name), Rt >>> 0;
                        } : mt = function(Et, Rt) {
                            return Je(Rt, this.name), Rt;
                        }, Ht(W, {
                            name: $,
                            fromWireType: Ne,
                            toWireType: mt,
                            argPackAdvance: 8,
                            readValueFromPointer: gr($, Ve, xe !== 0),
                            destructorFunction: null
                        });
                    }
                    function hc(W, $, ce) {
                        var xe = [
                            Int8Array,
                            Uint8Array,
                            Int16Array,
                            Uint16Array,
                            Int32Array,
                            Uint32Array,
                            Float32Array,
                            Float64Array
                        ], Oe = xe[$];
                        function Ve(Ne) {
                            Ne = Ne >> 2;
                            var Me = re, ke = Me[Ne], Je = Me[Ne + 1];
                            return new Oe(H, Je, ke);
                        }
                        ce = Fn(ce), Ht(W, {
                            name: ce,
                            fromWireType: Ve,
                            argPackAdvance: 8,
                            readValueFromPointer: Ve
                        }, {
                            ignoreDuplicateRegistrations: !0
                        });
                    }
                    function pc(W, $) {
                        $ = Fn($);
                        var ce = $ === "std::string";
                        Ht(W, {
                            name: $,
                            fromWireType: function(xe) {
                                var Oe = re[xe >> 2], Ve = xe + 4, Ne;
                                if (ce) for(var Me = Ve, ke = 0; ke <= Oe; ++ke){
                                    var Je = Ve + ke;
                                    if (ke == Oe || ae[Je] == 0) {
                                        var mt = Je - Me, Et = N(Me, mt);
                                        Ne === void 0 ? Ne = Et : (Ne += "\0", Ne += Et), Me = Je + 1;
                                    }
                                }
                                else {
                                    for(var Rt = new Array(Oe), ke = 0; ke < Oe; ++ke)Rt[ke] = String.fromCharCode(ae[Ve + ke]);
                                    Ne = Rt.join("");
                                }
                                return Fi(xe), Ne;
                            },
                            toWireType: function(xe, Oe) {
                                Oe instanceof ArrayBuffer && (Oe = new Uint8Array(Oe));
                                var Ve, Ne = typeof Oe == "string";
                                Ne || Oe instanceof Uint8Array || Oe instanceof Uint8ClampedArray || Oe instanceof Int8Array || _t("Cannot pass non-string to std::string"), ce && Ne ? Ve = Z(Oe) : Ve = Oe.length;
                                var Me = Ji(4 + Ve + 1), ke = Me + 4;
                                if (re[Me >> 2] = Ve, ce && Ne) G(Oe, ke, Ve + 1);
                                else if (Ne) for(var Je = 0; Je < Ve; ++Je){
                                    var mt = Oe.charCodeAt(Je);
                                    mt > 255 && (Fi(ke), _t("String has UTF-16 code units that do not fit in 8 bits")), ae[ke + Je] = mt;
                                }
                                else for(var Je = 0; Je < Ve; ++Je)ae[ke + Je] = Oe[Je];
                                return xe !== null && xe.push(Fi, Me), Me;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Mr,
                            destructorFunction: function(xe) {
                                Fi(xe);
                            }
                        });
                    }
                    var Mo = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
                    function Yi(W, $) {
                        for(var ce = W, xe = ce >> 1, Oe = xe + $ / 2; !(xe >= Oe) && le[xe];)++xe;
                        if (ce = xe << 1, ce - W > 32 && Mo) return Mo.decode(ae.subarray(W, ce));
                        for(var Ve = "", Ne = 0; !(Ne >= $ / 2); ++Ne){
                            var Me = ue[W + Ne * 2 >> 1];
                            if (Me == 0) break;
                            Ve += String.fromCharCode(Me);
                        }
                        return Ve;
                    }
                    function bo(W, $, ce) {
                        if (ce === void 0 && (ce = 2147483647), ce < 2) return 0;
                        ce -= 2;
                        for(var xe = $, Oe = ce < W.length * 2 ? ce / 2 : W.length, Ve = 0; Ve < Oe; ++Ve){
                            var Ne = W.charCodeAt(Ve);
                            ue[$ >> 1] = Ne, $ += 2;
                        }
                        return ue[$ >> 1] = 0, $ - xe;
                    }
                    function Lo(W) {
                        return W.length * 2;
                    }
                    function Zi(W, $) {
                        for(var ce = 0, xe = ""; !(ce >= $ / 4);){
                            var Oe = oe[W + ce * 4 >> 2];
                            if (Oe == 0) break;
                            if (++ce, Oe >= 65536) {
                                var Ve = Oe - 65536;
                                xe += String.fromCharCode(55296 | Ve >> 10, 56320 | Ve & 1023);
                            } else xe += String.fromCharCode(Oe);
                        }
                        return xe;
                    }
                    function ns(W, $, ce) {
                        if (ce === void 0 && (ce = 2147483647), ce < 4) return 0;
                        for(var xe = $, Oe = xe + ce - 4, Ve = 0; Ve < W.length; ++Ve){
                            var Ne = W.charCodeAt(Ve);
                            if (Ne >= 55296 && Ne <= 57343) {
                                var Me = W.charCodeAt(++Ve);
                                Ne = 65536 + ((Ne & 1023) << 10) | Me & 1023;
                            }
                            if (oe[$ >> 2] = Ne, $ += 4, $ + 4 > Oe) break;
                        }
                        return oe[$ >> 2] = 0, $ - xe;
                    }
                    function Po(W) {
                        for(var $ = 0, ce = 0; ce < W.length; ++ce){
                            var xe = W.charCodeAt(ce);
                            xe >= 55296 && xe <= 57343 && ++ce, $ += 4;
                        }
                        return $;
                    }
                    function Is(W, $, ce) {
                        ce = Fn(ce);
                        var xe, Oe, Ve, Ne, Me;
                        $ === 2 ? (xe = Yi, Oe = bo, Ne = Lo, Ve = ()=>le, Me = 1) : $ === 4 && (xe = Zi, Oe = ns, Ne = Po, Ve = ()=>re, Me = 2), Ht(W, {
                            name: ce,
                            fromWireType: function(ke) {
                                for(var Je = re[ke >> 2], mt = Ve(), Et, Rt = ke + 4, U = 0; U <= Je; ++U){
                                    var k = ke + 4 + U * $;
                                    if (U == Je || mt[k >> Me] == 0) {
                                        var ee = k - Rt, ye = xe(Rt, ee);
                                        Et === void 0 ? Et = ye : (Et += "\0", Et += ye), Rt = k + $;
                                    }
                                }
                                return Fi(ke), Et;
                            },
                            toWireType: function(ke, Je) {
                                typeof Je != "string" && _t("Cannot pass non-string to C++ string type " + ce);
                                var mt = Ne(Je), Et = Ji(4 + mt + $);
                                return re[Et >> 2] = mt >> Me, Oe(Je, Et + 4, mt + $), ke !== null && ke.push(Fi, Et), Et;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Mr,
                            destructorFunction: function(ke) {
                                Fi(ke);
                            }
                        });
                    }
                    function Vo(W, $, ce, xe, Oe, Ve) {
                        Cn[W] = {
                            name: Fn($),
                            rawConstructor: Bn(ce, xe),
                            rawDestructor: Bn(Oe, Ve),
                            fields: []
                        };
                    }
                    function No(W, $, ce, xe, Oe, Ve, Ne, Me, ke, Je) {
                        Cn[W].fields.push({
                            fieldName: Fn($),
                            getterReturnType: ce,
                            getter: Bn(xe, Oe),
                            getterContext: Ve,
                            setterArgumentType: Ne,
                            setter: Bn(Me, ke),
                            setterContext: Je
                        });
                    }
                    function Ms(W, $) {
                        $ = Fn($), Ht(W, {
                            isVoid: !0,
                            name: $,
                            argPackAdvance: 0,
                            fromWireType: function() {},
                            toWireType: function(ce, xe) {}
                        });
                    }
                    var Vr = {};
                    function Aa(W) {
                        var $ = Vr[W];
                        return $ === void 0 ? Fn(W) : $;
                    }
                    function Ao() {
                        return typeof globalThis == "object" ? globalThis : function() {
                            return Function;
                        }()("return this")();
                    }
                    function ka(W) {
                        return W === 0 ? di.toHandle(Ao()) : (W = Aa(W), di.toHandle(Ao()[W]));
                    }
                    function mc(W) {
                        W > 4 && (un[W].refcount += 1);
                    }
                    function co(W, $) {
                        var ce = mn[W];
                        return ce === void 0 && _t($ + " has unknown type " + ti(W)), ce;
                    }
                    function ko(W) {
                        for(var $ = "", ce = 0; ce < W; ++ce)$ += (ce !== 0 ? ", " : "") + "arg" + ce;
                        for(var xe = ()=>re, Oe = "return function emval_allocator_" + W + `(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`, ce = 0; ce < W; ++ce)Oe += "var argType" + ce + " = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter " + ce + `');
var arg` + ce + " = argType" + ce + `.readValueFromPointer(args);
args += argType` + ce + `['argPackAdvance'];
argTypes += 4;
`;
                        return Oe += "var obj = new constructor(" + $ + `);
return valueToHandle(obj);
}
`, new Function("requireRegisteredType", "Module", "valueToHandle", "getMemory", Oe)(co, a, di.toHandle, xe);
                    }
                    var Ua = {};
                    function Fa(W, $, ce, xe) {
                        W = di.toValue(W);
                        var Oe = Ua[$];
                        return Oe || (Oe = ko($), Ua[$] = Oe), Oe(W, ce, xe);
                    }
                    function bs(W, $) {
                        W = co(W, "_emval_take_value");
                        var ce = W.readValueFromPointer($);
                        return di.toHandle(ce);
                    }
                    function Ls() {
                        ln("");
                    }
                    function vc(W, $, ce) {
                        ae.copyWithin(W, $, $ + ce);
                    }
                    function Ps() {
                        return 2147483648;
                    }
                    function rs(W) {
                        try {
                            return D.grow(W - H.byteLength + 65535 >>> 16), he(D.buffer), 1;
                        } catch  {}
                    }
                    function yc(W) {
                        var $ = ae.length;
                        W = W >>> 0;
                        var ce = Ps();
                        if (W > ce) return !1;
                        let xe = (ke, Je)=>ke + (Je - ke % Je) % Je;
                        for(var Oe = 1; Oe <= 4; Oe *= 2){
                            var Ve = $ * (1 + .2 / Oe);
                            Ve = Math.min(Ve, W + 100663296);
                            var Ne = Math.min(ce, xe(Math.max(W, Ve), 65536)), Me = rs(Ne);
                            if (Me) return !0;
                        }
                        return !1;
                    }
                    function Cc(W) {
                        var $ = a["_" + W];
                        return $;
                    }
                    function wc(W, $) {
                        ne.set(W, $);
                    }
                    function is(W, $, ce, xe, Oe) {
                        var Ve = {
                            string: (k)=>{
                                var ee = 0;
                                if (k != null && k !== 0) {
                                    var ye = (k.length << 2) + 1;
                                    ee = lo(ye), G(k, ee, ye);
                                }
                                return ee;
                            },
                            array: (k)=>{
                                var ee = lo(k.length);
                                return wc(k, ee), ee;
                            }
                        };
                        function Ne(k) {
                            return $ === "string" ? N(k) : $ === "boolean" ? !!k : k;
                        }
                        var Me = Cc(W), ke = [], Je = 0;
                        if (xe) for(var mt = 0; mt < xe.length; mt++){
                            var Et = Ve[ce[mt]];
                            Et ? (Je === 0 && (Je = Vs()), ke[mt] = Et(xe[mt])) : ke[mt] = xe[mt];
                        }
                        var Rt = Me.apply(null, ke);
                        function U(k) {
                            return Je !== 0 && Ns(Je), Ne(k);
                        }
                        return Rt = U(Rt), Rt;
                    }
                    ir = a.InternalError = Gr(Error, "InternalError"), Hi(), ci = a.BindingError = Gr(Error, "BindingError"), io(), Vi(), Rs(), ts = a.UnboundTypeError = Gr(Error, "UnboundTypeError"), Os();
                    var as = {
                        h: jt,
                        q: pa,
                        r: Lr,
                        w: kt,
                        p: ao,
                        o: ki,
                        c: Na,
                        v: Io,
                        k: Ta,
                        e: Ui,
                        b: so,
                        a: hc,
                        j: pc,
                        g: Is,
                        u: Vo,
                        d: No,
                        x: Ms,
                        i: oo,
                        m: ka,
                        l: mc,
                        y: Fa,
                        n: bs,
                        f: Ls,
                        t: vc,
                        s: yc
                    };
                    Ce(), a.___wasm_call_ctors = function() {
                        return (a.___wasm_call_ctors = a.asm.A).apply(null, arguments);
                    };
                    var Ji = a._malloc = function() {
                        return (Ji = a._malloc = a.asm.B).apply(null, arguments);
                    }, Ba = a.___getTypeName = function() {
                        return (Ba = a.___getTypeName = a.asm.D).apply(null, arguments);
                    };
                    a.__embind_initialize_bindings = function() {
                        return (a.__embind_initialize_bindings = a.asm.E).apply(null, arguments);
                    };
                    var Fi = a._free = function() {
                        return (Fi = a._free = a.asm.F).apply(null, arguments);
                    }, Vs = a.stackSave = function() {
                        return (Vs = a.stackSave = a.asm.G).apply(null, arguments);
                    }, Ns = a.stackRestore = function() {
                        return (Ns = a.stackRestore = a.asm.H).apply(null, arguments);
                    }, lo = a.stackAlloc = function() {
                        return (lo = a.stackAlloc = a.asm.I).apply(null, arguments);
                    }, As = a.___cxa_is_pointer_type = function() {
                        return (As = a.___cxa_is_pointer_type = a.asm.J).apply(null, arguments);
                    };
                    a.ccall = is;
                    var Uo;
                    Ct = function W() {
                        Uo || ks(), Uo || (Ct = W);
                    };
                    function ks(W) {
                        if (Pe > 0 || (Qe(), Pe > 0)) return;
                        function $() {
                            Uo || (Uo = !0, a.calledRun = !0, !_ && (et(), o(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), St()));
                        }
                        a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                a.setStatus("");
                            }, 1), $();
                        }, 1)) : $();
                    }
                    if (a.preInit) for(typeof a.preInit == "function" && (a.preInit = [
                        a.preInit
                    ]); a.preInit.length > 0;)a.preInit.pop()();
                    return ks(), i.ready;
                };
            })();
            t.exports = n;
        }(ev)), ev.exports;
    }
    var Rie = _ie();
    const Oie = Qa(Rie), Iie = new URL("/assets/charlswasm_decode-484ovEoR.wasm", import.meta.url), Nu = {
        codec: void 0,
        decoder: void 0,
        decodeConfig: {}
    };
    function Mie(t) {
        return typeof t == "number" ? Nu.codec.getExceptionMessage(t) : t;
    }
    function bie(t) {
        if (Nu.decodeConfig = t, Nu.codec) return Promise.resolve();
        const e = Oie({
            locateFile: (n)=>n.endsWith(".wasm") ? Iie.toString() : n
        });
        return new Promise((n, r)=>{
            e.then((i)=>{
                Nu.codec = i, Nu.decoder = new i.JpegLSDecoder, n();
            }, r);
        });
    }
    async function _7(t, e) {
        try {
            await bie();
            const n = Nu.decoder;
            n.getEncodedBuffer(t.length).set(t), n.decode();
            const i = n.getFrameInfo(), a = n.getInterleaveMode(), o = n.getNearLossless(), s = n.getDecodedBuffer(), c = {
                columns: i.width,
                rows: i.height,
                bitsPerPixel: i.bitsPerSample,
                signed: e.signed,
                bytesPerPixel: e.bytesPerPixel,
                componentsPerPixel: i.componentCount
            }, l = Lie(i, s, e.signed), f = {
                nearLossless: o,
                interleaveMode: a,
                frameInfo: i
            };
            return {
                ...e,
                pixelData: l,
                imageInfo: c,
                encodeOptions: f,
                ...f,
                ...c
            };
        } catch (n) {
            throw Mie(n);
        }
    }
    function Lie(t, e, n) {
        return t.bitsPerSample > 8 ? n ? new Int16Array(e.buffer, e.byteOffset, e.byteLength / 2) : new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2) : n ? new Int8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    }
    var tv = {
        exports: {}
    }, R7;
    function Pie() {
        return R7 || (R7 = 1, function(t, e) {
            var n = (()=>{
                var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
                return typeof __filename < "u" && (r = r || __filename), function(i) {
                    i = i || {};
                    var a = typeof i < "u" ? i : {}, o, s;
                    a.ready = new Promise(function(U, k) {
                        o = U, s = k;
                    });
                    var c = Object.assign({}, a), l = "./this.program", f = typeof window == "object", u = typeof importScripts == "function", g = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", h = "";
                    function v(U) {
                        return a.locateFile ? a.locateFile(U, h) : h + U;
                    }
                    var m, y, C;
                    if (g) {
                        var T = ec, x = ec;
                        u ? h = x.dirname(h) + "/" : h = __dirname + "/", m = (U, k)=>(U = me(U) ? new URL(U) : x.normalize(U), T.readFileSync(U, k ? void 0 : "utf8")), C = (U)=>{
                            var k = m(U, !0);
                            return k.buffer || (k = new Uint8Array(k)), k;
                        }, y = (U, k, ee)=>{
                            U = me(U) ? new URL(U) : x.normalize(U), T.readFile(U, function(ye, _e) {
                                ye ? ee(ye) : k(_e.buffer);
                            });
                        }, process.argv.length > 1 && (l = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(U) {
                            if (!(U instanceof Mt)) throw U;
                        }), process.on("unhandledRejection", function(U) {
                            throw U;
                        }), a.inspect = function() {
                            return "[Emscripten Module object]";
                        };
                    } else (f || u) && (u ? h = self.location.href : typeof document < "u" && document.currentScript && (h = document.currentScript.src), r && (h = r), h.indexOf("blob:") !== 0 ? h = h.substr(0, h.replace(/[?#].*/, "").lastIndexOf("/") + 1) : h = "", m = (U)=>{
                        var k = new XMLHttpRequest;
                        return k.open("GET", U, !1), k.send(null), k.responseText;
                    }, u && (C = (U)=>{
                        var k = new XMLHttpRequest;
                        return k.open("GET", U, !1), k.responseType = "arraybuffer", k.send(null), new Uint8Array(k.response);
                    }), y = (U, k, ee)=>{
                        var ye = new XMLHttpRequest;
                        ye.open("GET", U, !0), ye.responseType = "arraybuffer", ye.onload = ()=>{
                            if (ye.status == 200 || ye.status == 0 && ye.response) {
                                k(ye.response);
                                return;
                            }
                            ee();
                        }, ye.onerror = ee, ye.send(null);
                    });
                    var S = a.print || console.log.bind(console), D = a.printErr || console.warn.bind(console);
                    Object.assign(a, c), c = null, a.arguments && a.arguments, a.thisProgram && (l = a.thisProgram), a.quit && a.quit;
                    var _;
                    a.wasmBinary && (_ = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && Un("no native wasm support detected");
                    var M, P = !1;
                    function F(U, k) {
                        U || Un(k);
                    }
                    var N = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function B(U, k, ee) {
                        for(var ye = k + ee, _e = k; U[_e] && !(_e >= ye);)++_e;
                        if (_e - k > 16 && U.buffer && N) return N.decode(U.subarray(k, _e));
                        for(var Be = ""; k < _e;){
                            var Ae = U[k++];
                            if (!(Ae & 128)) {
                                Be += String.fromCharCode(Ae);
                                continue;
                            }
                            var be = U[k++] & 63;
                            if ((Ae & 224) == 192) {
                                Be += String.fromCharCode((Ae & 31) << 6 | be);
                                continue;
                            }
                            var L = U[k++] & 63;
                            if ((Ae & 240) == 224 ? Ae = (Ae & 15) << 12 | be << 6 | L : Ae = (Ae & 7) << 18 | be << 12 | L << 6 | U[k++] & 63, Ae < 65536) Be += String.fromCharCode(Ae);
                            else {
                                var V = Ae - 65536;
                                Be += String.fromCharCode(55296 | V >> 10, 56320 | V & 1023);
                            }
                        }
                        return Be;
                    }
                    function G(U, k) {
                        return U ? B(le, U, k) : "";
                    }
                    function Z(U, k, ee, ye) {
                        if (!(ye > 0)) return 0;
                        for(var _e = ee, Be = ee + ye - 1, Ae = 0; Ae < U.length; ++Ae){
                            var be = U.charCodeAt(Ae);
                            if (be >= 55296 && be <= 57343) {
                                var L = U.charCodeAt(++Ae);
                                be = 65536 + ((be & 1023) << 10) | L & 1023;
                            }
                            if (be <= 127) {
                                if (ee >= Be) break;
                                k[ee++] = be;
                            } else if (be <= 2047) {
                                if (ee + 1 >= Be) break;
                                k[ee++] = 192 | be >> 6, k[ee++] = 128 | be & 63;
                            } else if (be <= 65535) {
                                if (ee + 2 >= Be) break;
                                k[ee++] = 224 | be >> 12, k[ee++] = 128 | be >> 6 & 63, k[ee++] = 128 | be & 63;
                            } else {
                                if (ee + 3 >= Be) break;
                                k[ee++] = 240 | be >> 18, k[ee++] = 128 | be >> 12 & 63, k[ee++] = 128 | be >> 6 & 63, k[ee++] = 128 | be & 63;
                            }
                        }
                        return k[ee] = 0, ee - _e;
                    }
                    function H(U, k, ee) {
                        return Z(U, le, k, ee);
                    }
                    function ne(U) {
                        for(var k = 0, ee = 0; ee < U.length; ++ee){
                            var ye = U.charCodeAt(ee);
                            ye <= 127 ? k++ : ye <= 2047 ? k += 2 : ye >= 55296 && ye <= 57343 ? (k += 4, ++ee) : k += 3;
                        }
                        return k;
                    }
                    var ae, ue, le, oe, re, X, ie, he, $e;
                    function je(U) {
                        ae = U, a.HEAP8 = ue = new Int8Array(U), a.HEAP16 = oe = new Int16Array(U), a.HEAP32 = X = new Int32Array(U), a.HEAPU8 = le = new Uint8Array(U), a.HEAPU16 = re = new Uint16Array(U), a.HEAPU32 = ie = new Uint32Array(U), a.HEAPF32 = he = new Float32Array(U), a.HEAPF64 = $e = new Float64Array(U);
                    }
                    a.INITIAL_MEMORY;
                    var He, rt = [], Qe = [], et = [];
                    function St() {
                        if (a.preRun) for(typeof a.preRun == "function" && (a.preRun = [
                            a.preRun
                        ]); a.preRun.length;)zt(a.preRun.shift());
                        jt(rt);
                    }
                    function Ln() {
                        jt(Qe);
                    }
                    function Nn() {
                        if (a.postRun) for(typeof a.postRun == "function" && (a.postRun = [
                            a.postRun
                        ]); a.postRun.length;)Ct(a.postRun.shift());
                        jt(et);
                    }
                    function zt(U) {
                        rt.unshift(U);
                    }
                    function Pe(U) {
                        Qe.unshift(U);
                    }
                    function Ct(U) {
                        et.unshift(U);
                    }
                    var yt = 0, En = null;
                    function ln(U) {
                        yt++, a.monitorRunDependencies && a.monitorRunDependencies(yt);
                    }
                    function Hn(U) {
                        if (yt--, a.monitorRunDependencies && a.monitorRunDependencies(yt), yt == 0 && En) {
                            var k = En;
                            En = null, k();
                        }
                    }
                    function Un(U) {
                        a.onAbort && a.onAbort(U), U = "Aborted(" + U + ")", D(U), P = !0, U += ". Build with -sASSERTIONS for more info.";
                        var k = new WebAssembly.RuntimeError(U);
                        throw s(k), k;
                    }
                    var q = "data:application/octet-stream;base64,";
                    function Q(U) {
                        return U.startsWith(q);
                    }
                    function me(U) {
                        return U.startsWith("file://");
                    }
                    var J;
                    J = "openjpegwasm_decode.wasm", Q(J) || (J = v(J));
                    function Ce(U) {
                        try {
                            if (U == J && _) return new Uint8Array(_);
                            if (C) return C(U);
                            throw "both async and sync fetching of the wasm failed";
                        } catch (k) {
                            Un(k);
                        }
                    }
                    function Ue() {
                        if (!_ && (f || u)) {
                            if (typeof fetch == "function" && !me(J)) return fetch(J, {
                                credentials: "same-origin"
                            }).then(function(U) {
                                if (!U.ok) throw "failed to load wasm binary file at '" + J + "'";
                                return U.arrayBuffer();
                            }).catch(function() {
                                return Ce(J);
                            });
                            if (y) return new Promise(function(U, k) {
                                y(J, function(ee) {
                                    U(new Uint8Array(ee));
                                }, k);
                            });
                        }
                        return Promise.resolve().then(function() {
                            return Ce(J);
                        });
                    }
                    function lt() {
                        var U = {
                            a: xe
                        };
                        function k(Ae, be) {
                            var L = Ae.exports;
                            a.asm = L, M = a.asm.E, je(M.buffer), He = a.asm.G, Pe(a.asm.F), Hn();
                        }
                        ln();
                        function ee(Ae) {
                            k(Ae.instance);
                        }
                        function ye(Ae) {
                            return Ue().then(function(be) {
                                return WebAssembly.instantiate(be, U);
                            }).then(function(be) {
                                return be;
                            }).then(Ae, function(be) {
                                D("failed to asynchronously prepare wasm: " + be), Un(be);
                            });
                        }
                        function _e() {
                            return !_ && typeof WebAssembly.instantiateStreaming == "function" && !Q(J) && !me(J) && !g && typeof fetch == "function" ? fetch(J, {
                                credentials: "same-origin"
                            }).then(function(Ae) {
                                var be = WebAssembly.instantiateStreaming(Ae, U);
                                return be.then(ee, function(L) {
                                    return D("wasm streaming compile failed: " + L), D("falling back to ArrayBuffer instantiation"), ye(ee);
                                });
                            }) : ye(ee);
                        }
                        if (a.instantiateWasm) try {
                            var Be = a.instantiateWasm(U, k);
                            return Be;
                        } catch (Ae) {
                            D("Module.instantiateWasm callback failed with error: " + Ae), s(Ae);
                        }
                        return _e().catch(s), {};
                    }
                    function Mt(U) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + U + ")", this.status = U;
                    }
                    function jt(U) {
                        for(; U.length > 0;)U.shift()(a);
                    }
                    function Cn(U) {
                        this.excPtr = U, this.ptr = U - 24, this.set_type = function(k) {
                            ie[this.ptr + 4 >> 2] = k;
                        }, this.get_type = function() {
                            return ie[this.ptr + 4 >> 2];
                        }, this.set_destructor = function(k) {
                            ie[this.ptr + 8 >> 2] = k;
                        }, this.get_destructor = function() {
                            return ie[this.ptr + 8 >> 2];
                        }, this.set_refcount = function(k) {
                            X[this.ptr >> 2] = k;
                        }, this.set_caught = function(k) {
                            k = k ? 1 : 0, ue[this.ptr + 12 >> 0] = k;
                        }, this.get_caught = function() {
                            return ue[this.ptr + 12 >> 0] != 0;
                        }, this.set_rethrown = function(k) {
                            k = k ? 1 : 0, ue[this.ptr + 13 >> 0] = k;
                        }, this.get_rethrown = function() {
                            return ue[this.ptr + 13 >> 0] != 0;
                        }, this.init = function(k, ee) {
                            this.set_adjusted_ptr(0), this.set_type(k), this.set_destructor(ee), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
                        }, this.add_ref = function() {
                            var k = X[this.ptr >> 2];
                            X[this.ptr >> 2] = k + 1;
                        }, this.release_ref = function() {
                            var k = X[this.ptr >> 2];
                            return X[this.ptr >> 2] = k - 1, k === 1;
                        }, this.set_adjusted_ptr = function(k) {
                            ie[this.ptr + 16 >> 2] = k;
                        }, this.get_adjusted_ptr = function() {
                            return ie[this.ptr + 16 >> 2];
                        }, this.get_exception_ptr = function() {
                            var k = mt(this.get_type());
                            if (k) return ie[this.excPtr >> 2];
                            var ee = this.get_adjusted_ptr();
                            return ee !== 0 ? ee : this.excPtr;
                        };
                    }
                    function tn(U, k, ee) {
                        var ye = new Cn(U);
                        throw ye.init(k, ee), U;
                    }
                    var Mr = {};
                    function Yt(U) {
                        for(; U.length;){
                            var k = U.pop(), ee = U.pop();
                            ee(k);
                        }
                    }
                    function mn(U) {
                        return this.fromWireType(X[U >> 2]);
                    }
                    var Tn = {}, De = {}, ze = {}, ft = 48, nn = 57;
                    function Gr(U) {
                        if (U === void 0) return "_unknown";
                        U = U.replace(/[^a-zA-Z0-9_]/g, "$");
                        var k = U.charCodeAt(0);
                        return k >= ft && k <= nn ? "_" + U : U;
                    }
                    function ir(U, k) {
                        return U = Gr(U), new Function("body", "return function " + U + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(k);
                    }
                    function dr(U, k) {
                        var ee = ir(k, function(ye) {
                            this.name = k, this.message = ye;
                            var _e = new Error(ye).stack;
                            _e !== void 0 && (this.stack = this.toString() + `
` + _e.replace(/^Error(:[^\n]*)?\n/, ""));
                        });
                        return ee.prototype = Object.create(U.prototype), ee.prototype.constructor = ee, ee.prototype.toString = function() {
                            return this.message === void 0 ? this.name : this.name + ": " + this.message;
                        }, ee;
                    }
                    var br = void 0;
                    function pa(U) {
                        throw new br(U);
                    }
                    function Lr(U, k, ee) {
                        U.forEach(function(be) {
                            ze[be] = k;
                        });
                        function ye(be) {
                            var L = ee(be);
                            L.length !== U.length && pa("Mismatched type converter count");
                            for(var V = 0; V < U.length; ++V)It(U[V], L[V]);
                        }
                        var _e = new Array(k.length), Be = [], Ae = 0;
                        k.forEach((be, L)=>{
                            De.hasOwnProperty(be) ? _e[L] = De[be] : (Be.push(be), Tn.hasOwnProperty(be) || (Tn[be] = []), Tn[be].push(()=>{
                                _e[L] = De[be], ++Ae, Ae === Be.length && ye(_e);
                            }));
                        }), Be.length === 0 && ye(_e);
                    }
                    function Pr(U) {
                        var k = Mr[U];
                        delete Mr[U];
                        var ee = k.rawConstructor, ye = k.rawDestructor, _e = k.fields, Be = _e.map((Ae)=>Ae.getterReturnType).concat(_e.map((Ae)=>Ae.setterArgumentType));
                        Lr([
                            U
                        ], Be, (Ae)=>{
                            var be = {};
                            return _e.forEach((L, V)=>{
                                var R = L.fieldName, I = Ae[V], A = L.getter, Y = L.getterContext, te = Ae[V + _e.length], se = L.setter, de = L.setterContext;
                                be[R] = {
                                    read: (pe)=>I.fromWireType(A(Y, pe)),
                                    write: (pe, Se)=>{
                                        var Le = [];
                                        se(de, pe, te.toWireType(Le, Se)), Yt(Le);
                                    }
                                };
                            }), [
                                {
                                    name: k.name,
                                    fromWireType: function(L) {
                                        var V = {};
                                        for(var R in be)V[R] = be[R].read(L);
                                        return ye(L), V;
                                    },
                                    toWireType: function(L, V) {
                                        for(var R in be)if (!(R in V)) throw new TypeError('Missing field:  "' + R + '"');
                                        var I = ee();
                                        for(R in be)be[R].write(I, V[R]);
                                        return L !== null && L.push(ye, I), I;
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: mn,
                                    destructorFunction: ye
                                }
                            ];
                        });
                    }
                    function Hi(U, k, ee, ye, _e) {}
                    function Li(U) {
                        switch(U){
                            case 1:
                                return 0;
                            case 2:
                                return 1;
                            case 4:
                                return 2;
                            case 8:
                                return 3;
                            default:
                                throw new TypeError("Unknown type size: " + U);
                        }
                    }
                    function Fn() {
                        for(var U = new Array(256), k = 0; k < 256; ++k)U[k] = String.fromCharCode(k);
                        ci = U;
                    }
                    var ci = void 0;
                    function _t(U) {
                        for(var k = "", ee = U; le[ee];)k += ci[le[ee++]];
                        return k;
                    }
                    var Ht = void 0;
                    function kt(U) {
                        throw new Ht(U);
                    }
                    function It(U, k, ee = {}) {
                        if (!("argPackAdvance" in k)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                        var ye = k.name;
                        if (U || kt('type "' + ye + '" must have a positive integer typeid pointer'), De.hasOwnProperty(U)) {
                            if (ee.ignoreDuplicateRegistrations) return;
                            kt("Cannot register type '" + ye + "' twice");
                        }
                        if (De[U] = k, delete ze[U], Tn.hasOwnProperty(U)) {
                            var _e = Tn[U];
                            delete Tn[U], _e.forEach((Be)=>Be());
                        }
                    }
                    function pr(U, k, ee, ye, _e) {
                        var Be = Li(ee);
                        k = _t(k), It(U, {
                            name: k,
                            fromWireType: function(Ae) {
                                return !!Ae;
                            },
                            toWireType: function(Ae, be) {
                                return be ? ye : _e;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: function(Ae) {
                                var be;
                                if (ee === 1) be = ue;
                                else if (ee === 2) be = oe;
                                else if (ee === 4) be = X;
                                else throw new TypeError("Unknown boolean type size: " + k);
                                return this.fromWireType(be[Ae >> Be]);
                            },
                            destructorFunction: null
                        });
                    }
                    function Zr(U) {
                        if (!(this instanceof Wr) || !(U instanceof Wr)) return !1;
                        for(var k = this.$$.ptrType.registeredClass, ee = this.$$.ptr, ye = U.$$.ptrType.registeredClass, _e = U.$$.ptr; k.baseClass;)ee = k.upcast(ee), k = k.baseClass;
                        for(; ye.baseClass;)_e = ye.upcast(_e), ye = ye.baseClass;
                        return k === ye && ee === _e;
                    }
                    function to(U) {
                        return {
                            count: U.count,
                            deleteScheduled: U.deleteScheduled,
                            preservePointerOnDelete: U.preservePointerOnDelete,
                            ptr: U.ptr,
                            ptrType: U.ptrType,
                            smartPtr: U.smartPtr,
                            smartPtrType: U.smartPtrType
                        };
                    }
                    function _o(U) {
                        function k(ee) {
                            return ee.$$.ptrType.registeredClass.name;
                        }
                        kt(k(U) + " instance already deleted");
                    }
                    var ma = !1;
                    function no(U) {}
                    function xi(U) {
                        U.smartPtr ? U.smartPtrType.rawDestructor(U.smartPtr) : U.ptrType.registeredClass.rawDestructor(U.ptr);
                    }
                    function Kn(U) {
                        U.count.value -= 1;
                        var k = U.count.value === 0;
                        k && xi(U);
                    }
                    function Pi(U, k, ee) {
                        if (k === ee) return U;
                        if (ee.baseClass === void 0) return null;
                        var ye = Pi(U, k, ee.baseClass);
                        return ye === null ? null : ee.downcast(ye);
                    }
                    var Kt = {};
                    function mr() {
                        return Object.keys(ro).length;
                    }
                    function Ro() {
                        var U = [];
                        for(var k in ro)ro.hasOwnProperty(k) && U.push(ro[k]);
                        return U;
                    }
                    var Si = [];
                    function Ki() {
                        for(; Si.length;){
                            var U = Si.pop();
                            U.$$.deleteScheduled = !1, U.delete();
                        }
                    }
                    var Vi = void 0;
                    function li(U) {
                        Vi = U, Si.length && Vi && Vi(Ki);
                    }
                    function Pn() {
                        a.getInheritedInstanceCount = mr, a.getLiveInheritedInstances = Ro, a.flushPendingDeletes = Ki, a.setDelayFunction = li;
                    }
                    var ro = {};
                    function ui(U, k) {
                        for(k === void 0 && kt("ptr should not be undefined"); U.baseClass;)k = U.upcast(k), U = U.baseClass;
                        return k;
                    }
                    function Qo(U, k) {
                        return k = ui(U, k), ro[k];
                    }
                    function Jr(U, k) {
                        (!k.ptrType || !k.ptr) && pa("makeClassHandle requires ptr and ptrType");
                        var ee = !!k.smartPtrType, ye = !!k.smartPtr;
                        return ee !== ye && pa("Both smartPtrType and smartPtr must be specified"), k.count = {
                            value: 1
                        }, Pa(Object.create(U, {
                            $$: {
                                value: k
                            }
                        }));
                    }
                    function Oo(U) {
                        var k = this.getPointee(U);
                        if (!k) return this.destructor(U), null;
                        var ee = Qo(this.registeredClass, k);
                        if (ee !== void 0) {
                            if (ee.$$.count.value === 0) return ee.$$.ptr = k, ee.$$.smartPtr = U, ee.clone();
                            var ye = ee.clone();
                            return this.destructor(U), ye;
                        }
                        function _e() {
                            return this.isSmartPointer ? Jr(this.registeredClass.instancePrototype, {
                                ptrType: this.pointeeType,
                                ptr: k,
                                smartPtrType: this,
                                smartPtr: U
                            }) : Jr(this.registeredClass.instancePrototype, {
                                ptrType: this,
                                ptr: U
                            });
                        }
                        var Be = this.registeredClass.getActualType(k), Ae = Kt[Be];
                        if (!Ae) return _e.call(this);
                        var be;
                        this.isConst ? be = Ae.constPointerType : be = Ae.pointerType;
                        var L = Pi(k, this.registeredClass, be.registeredClass);
                        return L === null ? _e.call(this) : this.isSmartPointer ? Jr(be.registeredClass.instancePrototype, {
                            ptrType: be,
                            ptr: L,
                            smartPtrType: this,
                            smartPtr: U
                        }) : Jr(be.registeredClass.instancePrototype, {
                            ptrType: be,
                            ptr: L
                        });
                    }
                    function Pa(U) {
                        return typeof FinalizationRegistry > "u" ? (Pa = (k)=>k, U) : (ma = new FinalizationRegistry((k)=>{
                            Kn(k.$$);
                        }), Pa = (k)=>{
                            var ee = k.$$, ye = !!ee.smartPtr;
                            if (ye) {
                                var _e = {
                                    $$: ee
                                };
                                ma.register(k, _e, k);
                            }
                            return k;
                        }, no = (k)=>ma.unregister(k), Pa(U));
                    }
                    function Qr() {
                        if (this.$$.ptr || _o(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                        var U = Pa(Object.create(Object.getPrototypeOf(this), {
                            $$: {
                                value: to(this.$$)
                            }
                        }));
                        return U.$$.count.value += 1, U.$$.deleteScheduled = !1, U;
                    }
                    function ei() {
                        this.$$.ptr || _o(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && kt("Object already scheduled for deletion"), no(this), Kn(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
                    }
                    function io() {
                        return !this.$$.ptr;
                    }
                    function qn() {
                        return this.$$.ptr || _o(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && kt("Object already scheduled for deletion"), Si.push(this), Si.length === 1 && Vi && Vi(Ki), this.$$.deleteScheduled = !0, this;
                    }
                    function _s() {
                        Wr.prototype.isAliasOf = Zr, Wr.prototype.clone = Qr, Wr.prototype.delete = ei, Wr.prototype.isDeleted = io, Wr.prototype.deleteLater = qn;
                    }
                    function Wr() {}
                    function Ni(U, k, ee) {
                        if (U[k].overloadTable === void 0) {
                            var ye = U[k];
                            U[k] = function() {
                                return U[k].overloadTable.hasOwnProperty(arguments.length) || kt("Function '" + ee + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + U[k].overloadTable + ")!"), U[k].overloadTable[arguments.length].apply(this, arguments);
                            }, U[k].overloadTable = [], U[k].overloadTable[ye.argCount] = ye;
                        }
                    }
                    function va(U, k, ee) {
                        a.hasOwnProperty(U) ? (kt("Cannot register public name '" + U + "' twice"), Ni(a, U, U), a.hasOwnProperty(ee) && kt("Cannot register multiple overloads of a function with the same number of arguments (" + ee + ")!"), a[U].overloadTable[ee] = k) : a[U] = k;
                    }
                    function ya(U, k, ee, ye, _e, Be, Ae, be) {
                        this.name = U, this.constructor = k, this.instancePrototype = ee, this.rawDestructor = ye, this.baseClass = _e, this.getActualType = Be, this.upcast = Ae, this.downcast = be, this.pureVirtualFunctions = [];
                    }
                    function Ca(U, k, ee) {
                        for(; k !== ee;)k.upcast || kt("Expected null or instance of " + ee.name + ", got an instance of " + k.name), U = k.upcast(U), k = k.baseClass;
                        return U;
                    }
                    function Ei(U, k) {
                        if (k === null) return this.isReference && kt("null is not a valid " + this.name), 0;
                        k.$$ || kt('Cannot pass "' + Ta(k) + '" as a ' + this.name), k.$$.ptr || kt("Cannot pass deleted object as a pointer of type " + this.name);
                        var ee = k.$$.ptrType.registeredClass, ye = Ca(k.$$.ptr, ee, this.registeredClass);
                        return ye;
                    }
                    function dc(U, k) {
                        var ee;
                        if (k === null) return this.isReference && kt("null is not a valid " + this.name), this.isSmartPointer ? (ee = this.rawConstructor(), U !== null && U.push(this.rawDestructor, ee), ee) : 0;
                        k.$$ || kt('Cannot pass "' + Ta(k) + '" as a ' + this.name), k.$$.ptr || kt("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && k.$$.ptrType.isConst && kt("Cannot convert argument of type " + (k.$$.smartPtrType ? k.$$.smartPtrType.name : k.$$.ptrType.name) + " to parameter type " + this.name);
                        var ye = k.$$.ptrType.registeredClass;
                        if (ee = Ca(k.$$.ptr, ye, this.registeredClass), this.isSmartPointer) switch(k.$$.smartPtr === void 0 && kt("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy){
                            case 0:
                                k.$$.smartPtrType === this ? ee = k.$$.smartPtr : kt("Cannot convert argument of type " + (k.$$.smartPtrType ? k.$$.smartPtrType.name : k.$$.ptrType.name) + " to parameter type " + this.name);
                                break;
                            case 1:
                                ee = k.$$.smartPtr;
                                break;
                            case 2:
                                if (k.$$.smartPtrType === this) ee = k.$$.smartPtr;
                                else {
                                    var _e = k.clone();
                                    ee = this.rawShare(ee, zr.toHandle(function() {
                                        _e.delete();
                                    })), U !== null && U.push(this.rawDestructor, ee);
                                }
                                break;
                            default:
                                kt("Unsupporting sharing policy");
                        }
                        return ee;
                    }
                    function gc(U, k) {
                        if (k === null) return this.isReference && kt("null is not a valid " + this.name), 0;
                        k.$$ || kt('Cannot pass "' + Ta(k) + '" as a ' + this.name), k.$$.ptr || kt("Cannot pass deleted object as a pointer of type " + this.name), k.$$.ptrType.isConst && kt("Cannot convert argument of type " + k.$$.ptrType.name + " to parameter type " + this.name);
                        var ee = k.$$.ptrType.registeredClass, ye = Ca(k.$$.ptr, ee, this.registeredClass);
                        return ye;
                    }
                    function es(U) {
                        return this.rawGetPointee && (U = this.rawGetPointee(U)), U;
                    }
                    function Rs(U) {
                        this.rawDestructor && this.rawDestructor(U);
                    }
                    function fi(U) {
                        U !== null && U.delete();
                    }
                    function $r() {
                        Di.prototype.getPointee = es, Di.prototype.destructor = Rs, Di.prototype.argPackAdvance = 8, Di.prototype.readValueFromPointer = mn, Di.prototype.deleteObject = fi, Di.prototype.fromWireType = Oo;
                    }
                    function Di(U, k, ee, ye, _e, Be, Ae, be, L, V, R) {
                        this.name = U, this.registeredClass = k, this.isReference = ee, this.isConst = ye, this.isSmartPointer = _e, this.pointeeType = Be, this.sharingPolicy = Ae, this.rawGetPointee = be, this.rawConstructor = L, this.rawShare = V, this.rawDestructor = R, !_e && k.baseClass === void 0 ? ye ? (this.toWireType = Ei, this.destructorFunction = null) : (this.toWireType = gc, this.destructorFunction = null) : this.toWireType = dc;
                    }
                    function vr(U, k, ee) {
                        a.hasOwnProperty(U) || pa("Replacing nonexistant public symbol"), a[U].overloadTable !== void 0 && ee !== void 0 || (a[U] = k, a[U].argCount = ee);
                    }
                    function an(U, k, ee) {
                        var ye = a["dynCall_" + U];
                        return ee && ee.length ? ye.apply(null, [
                            k
                        ].concat(ee)) : ye.call(null, k);
                    }
                    var wa = [];
                    function Va(U) {
                        var k = wa[U];
                        return k || (U >= wa.length && (wa.length = U + 1), wa[U] = k = He.get(U)), k;
                    }
                    function Bn(U, k, ee) {
                        if (U.includes("j")) return an(U, k, ee);
                        var ye = Va(k).apply(null, ee);
                        return ye;
                    }
                    function ts(U, k) {
                        var ee = [];
                        return function() {
                            return ee.length = 0, Object.assign(ee, arguments), Bn(U, k, ee);
                        };
                    }
                    function ti(U, k) {
                        U = _t(U);
                        function ee() {
                            return U.includes("j") ? ts(U, k) : Va(k);
                        }
                        var ye = ee();
                        return typeof ye != "function" && kt("unknown function pointer with signature " + U + ": " + k), ye;
                    }
                    var yr = void 0;
                    function ao(U) {
                        var k = Ne(U), ee = _t(k);
                        return Ve(k), ee;
                    }
                    function Ai(U, k) {
                        var ee = [], ye = {};
                        function _e(Be) {
                            if (!ye[Be] && !De[Be]) {
                                if (ze[Be]) {
                                    ze[Be].forEach(_e);
                                    return;
                                }
                                ee.push(Be), ye[Be] = !0;
                            }
                        }
                        throw k.forEach(_e), new yr(U + ": " + ee.map(ao).join([
                            ", "
                        ]));
                    }
                    function Xn(U, k, ee, ye, _e, Be, Ae, be, L, V, R, I, A) {
                        R = _t(R), Be = ti(_e, Be), be && (be = ti(Ae, be)), V && (V = ti(L, V)), A = ti(I, A);
                        var Y = Gr(R);
                        va(Y, function() {
                            Ai("Cannot construct " + R + " due to unbound types", [
                                ye
                            ]);
                        }), Lr([
                            U,
                            k,
                            ee
                        ], ye ? [
                            ye
                        ] : [], function(te) {
                            te = te[0];
                            var se, de;
                            ye ? (se = te.registeredClass, de = se.instancePrototype) : de = Wr.prototype;
                            var pe = ir(Y, function() {
                                if (Object.getPrototypeOf(this) !== Se) throw new Ht("Use 'new' to construct " + R);
                                if (Le.constructor_body === void 0) throw new Ht(R + " has no accessible constructor");
                                var At = Le.constructor_body[arguments.length];
                                if (At === void 0) throw new Ht("Tried to invoke ctor of " + R + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(Le.constructor_body).toString() + ") parameters instead!");
                                return At.apply(this, arguments);
                            }), Se = Object.create(de, {
                                constructor: {
                                    value: pe
                                }
                            });
                            pe.prototype = Se;
                            var Le = new ya(R, pe, Se, A, se, Be, be, V), Ze = new Di(R, Le, !0, !1, !1), gt = new Di(R + "*", Le, !1, !1, !1), ut = new Di(R + " const*", Le, !1, !0, !1);
                            return Kt[U] = {
                                pointerType: gt,
                                constPointerType: ut
                            }, vr(Y, pe), [
                                Ze,
                                gt,
                                ut
                            ];
                        });
                    }
                    function ni(U, k) {
                        for(var ee = [], ye = 0; ye < U; ye++)ee.push(ie[k + ye * 4 >> 2]);
                        return ee;
                    }
                    function ki(U, k) {
                        if (!(U instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof U + " which is not a function");
                        var ee = ir(U.name || "unknownFunctionName", function() {});
                        ee.prototype = U.prototype;
                        var ye = new ee, _e = U.apply(ye, k);
                        return _e instanceof Object ? _e : ye;
                    }
                    function Na(U, k, ee, ye, _e) {
                        var Be = k.length;
                        Be < 2 && kt("argTypes array size mismatch! Must at least get return value and 'this' types!");
                        for(var Ae = k[1] !== null && ee !== null, be = !1, L = 1; L < k.length; ++L)if (k[L] !== null && k[L].destructorFunction === void 0) {
                            be = !0;
                            break;
                        }
                        for(var V = k[0].name !== "void", R = "", I = "", L = 0; L < Be - 2; ++L)R += (L !== 0 ? ", " : "") + "arg" + L, I += (L !== 0 ? ", " : "") + "arg" + L + "Wired";
                        var A = "return function " + Gr(U) + "(" + R + `) {
if (arguments.length !== ` + (Be - 2) + `) {
throwBindingError('function ` + U + " called with ' + arguments.length + ' arguments, expected " + (Be - 2) + ` args!');
}
`;
                        be && (A += `var destructors = [];
`);
                        var Y = be ? "destructors" : "null", te = [
                            "throwBindingError",
                            "invoker",
                            "fn",
                            "runDestructors",
                            "retType",
                            "classParam"
                        ], se = [
                            kt,
                            ye,
                            _e,
                            Yt,
                            k[0],
                            k[1]
                        ];
                        Ae && (A += "var thisWired = classParam.toWireType(" + Y + `, this);
`);
                        for(var L = 0; L < Be - 2; ++L)A += "var arg" + L + "Wired = argType" + L + ".toWireType(" + Y + ", arg" + L + "); // " + k[L + 2].name + `
`, te.push("argType" + L), se.push(k[L + 2]);
                        if (Ae && (I = "thisWired" + (I.length > 0 ? ", " : "") + I), A += (V ? "var rv = " : "") + "invoker(fn" + (I.length > 0 ? ", " : "") + I + `);
`, be) A += `runDestructors(destructors);
`;
                        else for(var L = Ae ? 1 : 2; L < k.length; ++L){
                            var de = L === 1 ? "thisWired" : "arg" + (L - 2) + "Wired";
                            k[L].destructorFunction !== null && (A += de + "_dtor(" + de + "); // " + k[L].name + `
`, te.push(de + "_dtor"), se.push(k[L].destructorFunction));
                        }
                        V && (A += `var ret = retType.fromWireType(rv);
return ret;
`), A += `}
`, te.push(A);
                        var pe = ki(Function, te).apply(null, se);
                        return pe;
                    }
                    function qi(U, k, ee, ye, _e, Be) {
                        F(k > 0);
                        var Ae = ni(k, ee);
                        _e = ti(ye, _e), Lr([], [
                            U
                        ], function(be) {
                            be = be[0];
                            var L = "constructor " + be.name;
                            if (be.registeredClass.constructor_body === void 0 && (be.registeredClass.constructor_body = []), be.registeredClass.constructor_body[k - 1] !== void 0) throw new Ht("Cannot register multiple constructors with identical number of parameters (" + (k - 1) + ") for class '" + be.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                            return be.registeredClass.constructor_body[k - 1] = ()=>{
                                Ai("Cannot construct " + be.name + " due to unbound types", Ae);
                            }, Lr([], Ae, function(V) {
                                return V.splice(1, 0, null), be.registeredClass.constructor_body[k - 1] = Na(L, V, null, _e, Be), [];
                            }), [];
                        });
                    }
                    function un(U, k, ee, ye, _e, Be, Ae, be) {
                        var L = ni(ee, ye);
                        k = _t(k), Be = ti(_e, Be), Lr([], [
                            U
                        ], function(V) {
                            V = V[0];
                            var R = V.name + "." + k;
                            k.startsWith("@@") && (k = Symbol[k.substring(2)]), be && V.registeredClass.pureVirtualFunctions.push(k);
                            function I() {
                                Ai("Cannot call " + R + " due to unbound types", L);
                            }
                            var A = V.registeredClass.instancePrototype, Y = A[k];
                            return Y === void 0 || Y.overloadTable === void 0 && Y.className !== V.name && Y.argCount === ee - 2 ? (I.argCount = ee - 2, I.className = V.name, A[k] = I) : (Ni(A, k, R), A[k].overloadTable[ee - 2] = I), Lr([], L, function(te) {
                                var se = Na(R, te, V, Be, Ae);
                                return A[k].overloadTable === void 0 ? (se.argCount = ee - 2, A[k] = se) : A[k].overloadTable[ee - 2] = se, [];
                            }), [];
                        });
                    }
                    var oo = [], Cr = [
                        {},
                        {
                            value: void 0
                        },
                        {
                            value: null
                        },
                        {
                            value: !0
                        },
                        {
                            value: !1
                        }
                    ];
                    function Gn(U) {
                        U > 4 && --Cr[U].refcount === 0 && (Cr[U] = void 0, oo.push(U));
                    }
                    function Os() {
                        for(var U = 0, k = 5; k < Cr.length; ++k)Cr[k] !== void 0 && ++U;
                        return U;
                    }
                    function di() {
                        for(var U = 5; U < Cr.length; ++U)if (Cr[U] !== void 0) return Cr[U];
                        return null;
                    }
                    function Io() {
                        a.count_emval_handles = Os, a.get_first_emval = di;
                    }
                    var zr = {
                        toValue: (U)=>(U || kt("Cannot use deleted val. handle = " + U), Cr[U].value),
                        toHandle: (U)=>{
                            switch(U){
                                case void 0:
                                    return 1;
                                case null:
                                    return 2;
                                case !0:
                                    return 3;
                                case !1:
                                    return 4;
                                default:
                                    {
                                        var k = oo.length ? oo.pop() : Cr.length;
                                        return Cr[k] = {
                                            refcount: 1,
                                            value: U
                                        }, k;
                                    }
                            }
                        }
                    };
                    function Xi(U, k) {
                        k = _t(k), It(U, {
                            name: k,
                            fromWireType: function(ee) {
                                var ye = zr.toValue(ee);
                                return Gn(ee), ye;
                            },
                            toWireType: function(ee, ye) {
                                return zr.toHandle(ye);
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: mn,
                            destructorFunction: null
                        });
                    }
                    function Ta(U) {
                        if (U === null) return "null";
                        var k = typeof U;
                        return k === "object" || k === "array" || k === "function" ? U.toString() : "" + U;
                    }
                    function Ui(U, k) {
                        switch(k){
                            case 2:
                                return function(ee) {
                                    return this.fromWireType(he[ee >> 2]);
                                };
                            case 3:
                                return function(ee) {
                                    return this.fromWireType($e[ee >> 3]);
                                };
                            default:
                                throw new TypeError("Unknown float type: " + U);
                        }
                    }
                    function gr(U, k, ee) {
                        var ye = Li(ee);
                        k = _t(k), It(U, {
                            name: k,
                            fromWireType: function(_e) {
                                return _e;
                            },
                            toWireType: function(_e, Be) {
                                return Be;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Ui(k, ye),
                            destructorFunction: null
                        });
                    }
                    function so(U, k, ee) {
                        switch(k){
                            case 0:
                                return ee ? function(_e) {
                                    return ue[_e];
                                } : function(_e) {
                                    return le[_e];
                                };
                            case 1:
                                return ee ? function(_e) {
                                    return oe[_e >> 1];
                                } : function(_e) {
                                    return re[_e >> 1];
                                };
                            case 2:
                                return ee ? function(_e) {
                                    return X[_e >> 2];
                                } : function(_e) {
                                    return ie[_e >> 2];
                                };
                            default:
                                throw new TypeError("Unknown integer type: " + U);
                        }
                    }
                    function hc(U, k, ee, ye, _e) {
                        k = _t(k);
                        var Be = Li(ee), Ae = (I)=>I;
                        if (ye === 0) {
                            var be = 32 - 8 * ee;
                            Ae = (I)=>I << be >>> be;
                        }
                        var L = k.includes("unsigned"), V = (I, A)=>{}, R;
                        L ? R = function(I, A) {
                            return V(A, this.name), A >>> 0;
                        } : R = function(I, A) {
                            return V(A, this.name), A;
                        }, It(U, {
                            name: k,
                            fromWireType: Ae,
                            toWireType: R,
                            argPackAdvance: 8,
                            readValueFromPointer: so(k, Be, ye !== 0),
                            destructorFunction: null
                        });
                    }
                    function pc(U, k, ee) {
                        var ye = [
                            Int8Array,
                            Uint8Array,
                            Int16Array,
                            Uint16Array,
                            Int32Array,
                            Uint32Array,
                            Float32Array,
                            Float64Array
                        ], _e = ye[k];
                        function Be(Ae) {
                            Ae = Ae >> 2;
                            var be = ie, L = be[Ae], V = be[Ae + 1];
                            return new _e(ae, V, L);
                        }
                        ee = _t(ee), It(U, {
                            name: ee,
                            fromWireType: Be,
                            argPackAdvance: 8,
                            readValueFromPointer: Be
                        }, {
                            ignoreDuplicateRegistrations: !0
                        });
                    }
                    function Mo(U, k) {
                        k = _t(k);
                        var ee = k === "std::string";
                        It(U, {
                            name: k,
                            fromWireType: function(ye) {
                                var _e = ie[ye >> 2], Be = ye + 4, Ae;
                                if (ee) for(var be = Be, L = 0; L <= _e; ++L){
                                    var V = Be + L;
                                    if (L == _e || le[V] == 0) {
                                        var R = V - be, I = G(be, R);
                                        Ae === void 0 ? Ae = I : (Ae += "\0", Ae += I), be = V + 1;
                                    }
                                }
                                else {
                                    for(var A = new Array(_e), L = 0; L < _e; ++L)A[L] = String.fromCharCode(le[Be + L]);
                                    Ae = A.join("");
                                }
                                return Ve(ye), Ae;
                            },
                            toWireType: function(ye, _e) {
                                _e instanceof ArrayBuffer && (_e = new Uint8Array(_e));
                                var Be, Ae = typeof _e == "string";
                                Ae || _e instanceof Uint8Array || _e instanceof Uint8ClampedArray || _e instanceof Int8Array || kt("Cannot pass non-string to std::string"), ee && Ae ? Be = ne(_e) : Be = _e.length;
                                var be = Oe(4 + Be + 1), L = be + 4;
                                if (ie[be >> 2] = Be, ee && Ae) H(_e, L, Be + 1);
                                else if (Ae) for(var V = 0; V < Be; ++V){
                                    var R = _e.charCodeAt(V);
                                    R > 255 && (Ve(L), kt("String has UTF-16 code units that do not fit in 8 bits")), le[L + V] = R;
                                }
                                else for(var V = 0; V < Be; ++V)le[L + V] = _e[V];
                                return ye !== null && ye.push(Ve, be), be;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: mn,
                            destructorFunction: function(ye) {
                                Ve(ye);
                            }
                        });
                    }
                    var Yi = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
                    function bo(U, k) {
                        for(var ee = U, ye = ee >> 1, _e = ye + k / 2; !(ye >= _e) && re[ye];)++ye;
                        if (ee = ye << 1, ee - U > 32 && Yi) return Yi.decode(le.subarray(U, ee));
                        for(var Be = "", Ae = 0; !(Ae >= k / 2); ++Ae){
                            var be = oe[U + Ae * 2 >> 1];
                            if (be == 0) break;
                            Be += String.fromCharCode(be);
                        }
                        return Be;
                    }
                    function Lo(U, k, ee) {
                        if (ee === void 0 && (ee = 2147483647), ee < 2) return 0;
                        ee -= 2;
                        for(var ye = k, _e = ee < U.length * 2 ? ee / 2 : U.length, Be = 0; Be < _e; ++Be){
                            var Ae = U.charCodeAt(Be);
                            oe[k >> 1] = Ae, k += 2;
                        }
                        return oe[k >> 1] = 0, k - ye;
                    }
                    function Zi(U) {
                        return U.length * 2;
                    }
                    function ns(U, k) {
                        for(var ee = 0, ye = ""; !(ee >= k / 4);){
                            var _e = X[U + ee * 4 >> 2];
                            if (_e == 0) break;
                            if (++ee, _e >= 65536) {
                                var Be = _e - 65536;
                                ye += String.fromCharCode(55296 | Be >> 10, 56320 | Be & 1023);
                            } else ye += String.fromCharCode(_e);
                        }
                        return ye;
                    }
                    function Po(U, k, ee) {
                        if (ee === void 0 && (ee = 2147483647), ee < 4) return 0;
                        for(var ye = k, _e = ye + ee - 4, Be = 0; Be < U.length; ++Be){
                            var Ae = U.charCodeAt(Be);
                            if (Ae >= 55296 && Ae <= 57343) {
                                var be = U.charCodeAt(++Be);
                                Ae = 65536 + ((Ae & 1023) << 10) | be & 1023;
                            }
                            if (X[k >> 2] = Ae, k += 4, k + 4 > _e) break;
                        }
                        return X[k >> 2] = 0, k - ye;
                    }
                    function Is(U) {
                        for(var k = 0, ee = 0; ee < U.length; ++ee){
                            var ye = U.charCodeAt(ee);
                            ye >= 55296 && ye <= 57343 && ++ee, k += 4;
                        }
                        return k;
                    }
                    function Vo(U, k, ee) {
                        ee = _t(ee);
                        var ye, _e, Be, Ae, be;
                        k === 2 ? (ye = bo, _e = Lo, Ae = Zi, Be = ()=>re, be = 1) : k === 4 && (ye = ns, _e = Po, Ae = Is, Be = ()=>ie, be = 2), It(U, {
                            name: ee,
                            fromWireType: function(L) {
                                for(var V = ie[L >> 2], R = Be(), I, A = L + 4, Y = 0; Y <= V; ++Y){
                                    var te = L + 4 + Y * k;
                                    if (Y == V || R[te >> be] == 0) {
                                        var se = te - A, de = ye(A, se);
                                        I === void 0 ? I = de : (I += "\0", I += de), A = te + k;
                                    }
                                }
                                return Ve(L), I;
                            },
                            toWireType: function(L, V) {
                                typeof V != "string" && kt("Cannot pass non-string to C++ string type " + ee);
                                var R = Ae(V), I = Oe(4 + R + k);
                                return ie[I >> 2] = R >> be, _e(V, I + 4, R + k), L !== null && L.push(Ve, I), I;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: mn,
                            destructorFunction: function(L) {
                                Ve(L);
                            }
                        });
                    }
                    function No(U, k, ee, ye, _e, Be) {
                        Mr[U] = {
                            name: _t(k),
                            rawConstructor: ti(ee, ye),
                            rawDestructor: ti(_e, Be),
                            fields: []
                        };
                    }
                    function Ms(U, k, ee, ye, _e, Be, Ae, be, L, V) {
                        Mr[U].fields.push({
                            fieldName: _t(k),
                            getterReturnType: ee,
                            getter: ti(ye, _e),
                            getterContext: Be,
                            setterArgumentType: Ae,
                            setter: ti(be, L),
                            setterContext: V
                        });
                    }
                    function Vr(U, k) {
                        k = _t(k), It(U, {
                            isVoid: !0,
                            name: k,
                            argPackAdvance: 0,
                            fromWireType: function() {},
                            toWireType: function(ee, ye) {}
                        });
                    }
                    var Aa = {};
                    function Ao(U) {
                        var k = Aa[U];
                        return k === void 0 ? _t(U) : k;
                    }
                    function ka() {
                        return typeof globalThis == "object" ? globalThis : function() {
                            return Function;
                        }()("return this")();
                    }
                    function mc(U) {
                        return U === 0 ? zr.toHandle(ka()) : (U = Ao(U), zr.toHandle(ka()[U]));
                    }
                    function co(U) {
                        U > 4 && (Cr[U].refcount += 1);
                    }
                    function ko(U, k) {
                        var ee = De[U];
                        return ee === void 0 && kt(k + " has unknown type " + ao(U)), ee;
                    }
                    function Ua(U) {
                        for(var k = "", ee = 0; ee < U; ++ee)k += (ee !== 0 ? ", " : "") + "arg" + ee;
                        for(var ye = ()=>ie, _e = "return function emval_allocator_" + U + `(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`, ee = 0; ee < U; ++ee)_e += "var argType" + ee + " = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter " + ee + `');
var arg` + ee + " = argType" + ee + `.readValueFromPointer(args);
args += argType` + ee + `['argPackAdvance'];
argTypes += 4;
`;
                        return _e += "var obj = new constructor(" + k + `);
return valueToHandle(obj);
}
`, new Function("requireRegisteredType", "Module", "valueToHandle", "getMemory", _e)(ko, a, zr.toHandle, ye);
                    }
                    var Fa = {};
                    function bs(U, k, ee, ye) {
                        U = zr.toValue(U);
                        var _e = Fa[k];
                        return _e || (_e = Ua(k), Fa[k] = _e), _e(U, ee, ye);
                    }
                    function Ls(U, k) {
                        U = ko(U, "_emval_take_value");
                        var ee = U.readValueFromPointer(k);
                        return zr.toHandle(ee);
                    }
                    function vc() {
                        Un("");
                    }
                    function Ps() {
                        return 2147483648;
                    }
                    function rs() {
                        return Ps();
                    }
                    function yc(U, k, ee) {
                        le.copyWithin(U, k, k + ee);
                    }
                    function Cc(U) {
                        try {
                            return M.grow(U - ae.byteLength + 65535 >>> 16), je(M.buffer), 1;
                        } catch  {}
                    }
                    function wc(U) {
                        var k = le.length;
                        U = U >>> 0;
                        var ee = Ps();
                        if (U > ee) return !1;
                        let ye = (L, V)=>L + (V - L % V) % V;
                        for(var _e = 1; _e <= 4; _e *= 2){
                            var Be = k * (1 + .2 / _e);
                            Be = Math.min(Be, U + 100663296);
                            var Ae = Math.min(ee, ye(Math.max(U, Be), 65536)), be = Cc(Ae);
                            if (be) return !0;
                        }
                        return !1;
                    }
                    var is = {};
                    function as() {
                        return l || "./this.program";
                    }
                    function Ji() {
                        if (!Ji.strings) {
                            var U = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", k = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: U,
                                _: as()
                            };
                            for(var ee in is)is[ee] === void 0 ? delete k[ee] : k[ee] = is[ee];
                            var ye = [];
                            for(var ee in k)ye.push(ee + "=" + k[ee]);
                            Ji.strings = ye;
                        }
                        return Ji.strings;
                    }
                    function Ba(U, k, ee) {
                        for(var ye = 0; ye < U.length; ++ye)ue[k++ >> 0] = U.charCodeAt(ye);
                        ue[k >> 0] = 0;
                    }
                    function Fi(U, k) {
                        var ee = 0;
                        return Ji().forEach(function(ye, _e) {
                            var Be = k + ee;
                            ie[U + _e * 4 >> 2] = Be, Ba(ye, Be), ee += ye.length + 1;
                        }), 0;
                    }
                    function Vs(U, k) {
                        var ee = Ji();
                        ie[U >> 2] = ee.length;
                        var ye = 0;
                        return ee.forEach(function(_e) {
                            ye += _e.length + 1;
                        }), ie[k >> 2] = ye, 0;
                    }
                    function Ns(U) {
                        return 52;
                    }
                    function lo(U, k, ee, ye, _e) {
                        return 70;
                    }
                    var As = [
                        null,
                        [],
                        []
                    ];
                    function Uo(U, k) {
                        var ee = As[U];
                        k === 0 || k === 10 ? ((U === 1 ? S : D)(B(ee, 0)), ee.length = 0) : ee.push(k);
                    }
                    function ks(U, k, ee, ye) {
                        for(var _e = 0, Be = 0; Be < ee; Be++){
                            var Ae = ie[k >> 2], be = ie[k + 4 >> 2];
                            k += 8;
                            for(var L = 0; L < be; L++)Uo(U, le[Ae + L]);
                            _e += be;
                        }
                        return ie[ye >> 2] = _e, 0;
                    }
                    function W(U) {
                        var k = a["_" + U];
                        return k;
                    }
                    function $(U, k) {
                        ue.set(U, k);
                    }
                    function ce(U, k, ee, ye, _e) {
                        var Be = {
                            string: (te)=>{
                                var se = 0;
                                if (te != null && te !== 0) {
                                    var de = (te.length << 2) + 1;
                                    se = Je(de), H(te, se, de);
                                }
                                return se;
                            },
                            array: (te)=>{
                                var se = Je(te.length);
                                return $(te, se), se;
                            }
                        };
                        function Ae(te) {
                            return k === "string" ? G(te) : k === "boolean" ? !!te : te;
                        }
                        var be = W(U), L = [], V = 0;
                        if (ye) for(var R = 0; R < ye.length; R++){
                            var I = Be[ee[R]];
                            I ? (V === 0 && (V = Me()), L[R] = I(ye[R])) : L[R] = ye[R];
                        }
                        var A = be.apply(null, L);
                        function Y(te) {
                            return V !== 0 && ke(V), Ae(te);
                        }
                        return A = Y(A), A;
                    }
                    br = a.InternalError = dr(Error, "InternalError"), Fn(), Ht = a.BindingError = dr(Error, "BindingError"), _s(), Pn(), $r(), yr = a.UnboundTypeError = dr(Error, "UnboundTypeError"), Io();
                    var xe = {
                        D: tn,
                        e: Pr,
                        t: Hi,
                        B: pr,
                        r: Xn,
                        q: qi,
                        b: un,
                        A: Xi,
                        l: gr,
                        d: hc,
                        a: pc,
                        k: Mo,
                        f: Vo,
                        g: No,
                        c: Ms,
                        C: Vr,
                        h: Gn,
                        o: mc,
                        m: co,
                        n: bs,
                        p: Ls,
                        i: vc,
                        v: rs,
                        z: yc,
                        u: wc,
                        w: Fi,
                        x: Vs,
                        y: Ns,
                        s: lo,
                        j: ks
                    };
                    lt(), a.___wasm_call_ctors = function() {
                        return (a.___wasm_call_ctors = a.asm.F).apply(null, arguments);
                    };
                    var Oe = a._malloc = function() {
                        return (Oe = a._malloc = a.asm.H).apply(null, arguments);
                    }, Ve = a._free = function() {
                        return (Ve = a._free = a.asm.I).apply(null, arguments);
                    }, Ne = a.___getTypeName = function() {
                        return (Ne = a.___getTypeName = a.asm.J).apply(null, arguments);
                    };
                    a.__embind_initialize_bindings = function() {
                        return (a.__embind_initialize_bindings = a.asm.K).apply(null, arguments);
                    };
                    var Me = a.stackSave = function() {
                        return (Me = a.stackSave = a.asm.L).apply(null, arguments);
                    }, ke = a.stackRestore = function() {
                        return (ke = a.stackRestore = a.asm.M).apply(null, arguments);
                    }, Je = a.stackAlloc = function() {
                        return (Je = a.stackAlloc = a.asm.N).apply(null, arguments);
                    }, mt = a.___cxa_is_pointer_type = function() {
                        return (mt = a.___cxa_is_pointer_type = a.asm.O).apply(null, arguments);
                    };
                    a.dynCall_iji = function() {
                        return (a.dynCall_iji = a.asm.P).apply(null, arguments);
                    }, a.dynCall_jji = function() {
                        return (a.dynCall_jji = a.asm.Q).apply(null, arguments);
                    }, a.dynCall_iiji = function() {
                        return (a.dynCall_iiji = a.asm.R).apply(null, arguments);
                    }, a.dynCall_jiji = function() {
                        return (a.dynCall_jiji = a.asm.S).apply(null, arguments);
                    }, a.ccall = ce;
                    var Et;
                    En = function U() {
                        Et || Rt(), Et || (En = U);
                    };
                    function Rt(U) {
                        if (yt > 0 || (St(), yt > 0)) return;
                        function k() {
                            Et || (Et = !0, a.calledRun = !0, !P && (Ln(), o(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), Nn()));
                        }
                        a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                a.setStatus("");
                            }, 1), k();
                        }, 1)) : k();
                    }
                    if (a.preInit) for(typeof a.preInit == "function" && (a.preInit = [
                        a.preInit
                    ]); a.preInit.length > 0;)a.preInit.pop()();
                    return Rt(), i.ready;
                };
            })();
            t.exports = n;
        }(tv)), tv.exports;
    }
    var Vie = Pie();
    const Nie = Qa(Vie), Aie = new URL("/assets/openjpegwasm_decode-C4nnCcr6.wasm", import.meta.url), ud = {
        codec: void 0,
        decoder: void 0,
        decodeConfig: {}
    };
    function kie(t) {
        if (ud.decodeConfig = t, ud.codec) return Promise.resolve();
        const e = Nie({
            locateFile: (n)=>n.endsWith(".wasm") ? Aie.toString() : n
        });
        return new Promise((n, r)=>{
            e.then((i)=>{
                ud.codec = i, ud.decoder = new i.J2KDecoder, n();
            }, r);
        });
    }
    async function O7(t, e) {
        await kie();
        const n = ud.decoder, r = n.getEncodedBuffer(t.length);
        r.set(t), n.decode();
        const i = n.getFrameInfo(), a = n.getDecodedBuffer();
        new Uint8Array(a.length).set(a);
        const s = `x: ${n.getImageOffset().x}, y: ${n.getImageOffset().y}`, c = n.getNumDecompositions(), l = n.getNumLayers(), f = [
            "unknown",
            "LRCP",
            "RLCP",
            "RPCL",
            "PCRL",
            "CPRL"
        ][n.getProgressionOrder() + 1], u = n.getIsReversible(), g = `${n.getBlockDimensions().width} x ${n.getBlockDimensions().height}`, h = `${n.getTileSize().width} x ${n.getTileSize().height}`, v = `${n.getTileOffset().x}, ${n.getTileOffset().y}`, m = n.getColorSpace(), y = `${a.length.toLocaleString()} bytes`, C = `${(a.length / r.length).toFixed(2)}:1`, T = {
            columns: i.width,
            rows: i.height,
            bitsPerPixel: i.bitsPerSample,
            signed: i.isSigned,
            bytesPerPixel: e.bytesPerPixel,
            componentsPerPixel: i.componentCount
        }, x = Uie(i, a), S = {
            imageOffset: s,
            numDecompositions: c,
            numLayers: l,
            progessionOrder: f,
            reversible: u,
            blockDimensions: g,
            tileSize: h,
            tileOffset: v,
            colorTransform: m,
            decodedSize: y,
            compressionRatio: C
        };
        return {
            ...e,
            pixelData: x,
            imageInfo: T,
            encodeOptions: S,
            ...S,
            ...T
        };
    }
    function Uie(t, e) {
        return t.bitsPerSample > 8 ? t.isSigned ? new Int16Array(e.buffer, e.byteOffset, e.byteLength / 2) : new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2) : t.isSigned ? new Int8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    }
    var nv = {
        exports: {}
    }, I7;
    function Fie() {
        return I7 || (I7 = 1, function(t, e) {
            var n = (()=>{
                var r = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0;
                return typeof __filename < "u" && (r = r || __filename), function(a) {
                    a = a || {};
                    var a = typeof a < "u" ? a : {}, o, s;
                    a.ready = new Promise(function(L, V) {
                        o = L, s = V;
                    });
                    var c = Object.assign({}, a), l = typeof window == "object", f = typeof importScripts == "function", u = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g = "";
                    function h(L) {
                        return a.locateFile ? a.locateFile(L, g) : g + L;
                    }
                    var v, m, y;
                    if (u) {
                        var C = ec, T = ec;
                        f ? g = T.dirname(g) + "/" : g = __dirname + "/", v = (L, V)=>(L = Q(L) ? new URL(L) : T.normalize(L), C.readFileSync(L, V ? void 0 : "utf8")), y = (L)=>{
                            var V = v(L, !0);
                            return V.buffer || (V = new Uint8Array(V)), V;
                        }, m = (L, V, R)=>{
                            L = Q(L) ? new URL(L) : T.normalize(L), C.readFile(L, function(I, A) {
                                I ? R(I) : V(A.buffer);
                            });
                        }, process.argv.length > 1 && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), process.on("uncaughtException", function(L) {
                            if (!(L instanceof lt)) throw L;
                        }), process.on("unhandledRejection", function(L) {
                            throw L;
                        }), a.inspect = function() {
                            return "[Emscripten Module object]";
                        };
                    } else (l || f) && (f ? g = self.location.href : typeof document < "u" && document.currentScript && (g = document.currentScript.src), r && (g = r), g.indexOf("blob:") !== 0 ? g = g.substr(0, g.replace(/[?#].*/, "").lastIndexOf("/") + 1) : g = "", v = (L)=>{
                        var V = new XMLHttpRequest;
                        return V.open("GET", L, !1), V.send(null), V.responseText;
                    }, f && (y = (L)=>{
                        var V = new XMLHttpRequest;
                        return V.open("GET", L, !1), V.responseType = "arraybuffer", V.send(null), new Uint8Array(V.response);
                    }), m = (L, V, R)=>{
                        var I = new XMLHttpRequest;
                        I.open("GET", L, !0), I.responseType = "arraybuffer", I.onload = ()=>{
                            if (I.status == 200 || I.status == 0 && I.response) {
                                V(I.response);
                                return;
                            }
                            R();
                        }, I.onerror = R, I.send(null);
                    });
                    var x = a.print || console.log.bind(console), S = a.printErr || console.warn.bind(console);
                    Object.assign(a, c), c = null, a.arguments && a.arguments, a.thisProgram && a.thisProgram, a.quit && a.quit;
                    var D;
                    a.wasmBinary && (D = a.wasmBinary), a.noExitRuntime, typeof WebAssembly != "object" && Hn("no native wasm support detected");
                    var _, M = !1;
                    function P(L, V) {
                        L || Hn(V);
                    }
                    var F = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function N(L, V, R) {
                        for(var I = V + R, A = V; L[A] && !(A >= I);)++A;
                        if (A - V > 16 && L.buffer && F) return F.decode(L.subarray(V, A));
                        for(var Y = ""; V < A;){
                            var te = L[V++];
                            if (!(te & 128)) {
                                Y += String.fromCharCode(te);
                                continue;
                            }
                            var se = L[V++] & 63;
                            if ((te & 224) == 192) {
                                Y += String.fromCharCode((te & 31) << 6 | se);
                                continue;
                            }
                            var de = L[V++] & 63;
                            if ((te & 240) == 224 ? te = (te & 15) << 12 | se << 6 | de : te = (te & 7) << 18 | se << 12 | de << 6 | L[V++] & 63, te < 65536) Y += String.fromCharCode(te);
                            else {
                                var pe = te - 65536;
                                Y += String.fromCharCode(55296 | pe >> 10, 56320 | pe & 1023);
                            }
                        }
                        return Y;
                    }
                    function B(L, V) {
                        return L ? N(ue, L, V) : "";
                    }
                    function G(L, V, R, I) {
                        if (!(I > 0)) return 0;
                        for(var A = R, Y = R + I - 1, te = 0; te < L.length; ++te){
                            var se = L.charCodeAt(te);
                            if (se >= 55296 && se <= 57343) {
                                var de = L.charCodeAt(++te);
                                se = 65536 + ((se & 1023) << 10) | de & 1023;
                            }
                            if (se <= 127) {
                                if (R >= Y) break;
                                V[R++] = se;
                            } else if (se <= 2047) {
                                if (R + 1 >= Y) break;
                                V[R++] = 192 | se >> 6, V[R++] = 128 | se & 63;
                            } else if (se <= 65535) {
                                if (R + 2 >= Y) break;
                                V[R++] = 224 | se >> 12, V[R++] = 128 | se >> 6 & 63, V[R++] = 128 | se & 63;
                            } else {
                                if (R + 3 >= Y) break;
                                V[R++] = 240 | se >> 18, V[R++] = 128 | se >> 12 & 63, V[R++] = 128 | se >> 6 & 63, V[R++] = 128 | se & 63;
                            }
                        }
                        return V[R] = 0, R - A;
                    }
                    function Z(L, V, R) {
                        return G(L, ue, V, R);
                    }
                    function H(L) {
                        for(var V = 0, R = 0; R < L.length; ++R){
                            var I = L.charCodeAt(R);
                            I <= 127 ? V++ : I <= 2047 ? V += 2 : I >= 55296 && I <= 57343 ? (V += 4, ++R) : V += 3;
                        }
                        return V;
                    }
                    var ne, ae, ue, le, oe, re, X, ie, he;
                    function $e(L) {
                        ne = L, a.HEAP8 = ae = new Int8Array(L), a.HEAP16 = le = new Int16Array(L), a.HEAP32 = re = new Int32Array(L), a.HEAPU8 = ue = new Uint8Array(L), a.HEAPU16 = oe = new Uint16Array(L), a.HEAPU32 = X = new Uint32Array(L), a.HEAPF32 = ie = new Float32Array(L), a.HEAPF64 = he = new Float64Array(L);
                    }
                    a.INITIAL_MEMORY;
                    var je, He = [], rt = [], Qe = [];
                    function et() {
                        if (a.preRun) for(typeof a.preRun == "function" && (a.preRun = [
                            a.preRun
                        ]); a.preRun.length;)Nn(a.preRun.shift());
                        Mt(He);
                    }
                    function St() {
                        Mt(rt);
                    }
                    function Ln() {
                        if (a.postRun) for(typeof a.postRun == "function" && (a.postRun = [
                            a.postRun
                        ]); a.postRun.length;)Pe(a.postRun.shift());
                        Mt(Qe);
                    }
                    function Nn(L) {
                        He.unshift(L);
                    }
                    function zt(L) {
                        rt.unshift(L);
                    }
                    function Pe(L) {
                        Qe.unshift(L);
                    }
                    var Ct = 0, yt = null;
                    function En(L) {
                        Ct++, a.monitorRunDependencies && a.monitorRunDependencies(Ct);
                    }
                    function ln(L) {
                        if (Ct--, a.monitorRunDependencies && a.monitorRunDependencies(Ct), Ct == 0 && yt) {
                            var V = yt;
                            yt = null, V();
                        }
                    }
                    function Hn(L) {
                        a.onAbort && a.onAbort(L), L = "Aborted(" + L + ")", S(L), M = !0, L += ". Build with -sASSERTIONS for more info.";
                        var V = new WebAssembly.RuntimeError(L);
                        throw s(V), V;
                    }
                    var Un = "data:application/octet-stream;base64,";
                    function q(L) {
                        return L.startsWith(Un);
                    }
                    function Q(L) {
                        return L.startsWith("file://");
                    }
                    var me;
                    me = "openjphjs.wasm", q(me) || (me = h(me));
                    function J(L) {
                        try {
                            if (L == me && D) return new Uint8Array(D);
                            if (y) return y(L);
                            throw "both async and sync fetching of the wasm failed";
                        } catch (V) {
                            Hn(V);
                        }
                    }
                    function Ce() {
                        if (!D && (l || f)) {
                            if (typeof fetch == "function" && !Q(me)) return fetch(me, {
                                credentials: "same-origin"
                            }).then(function(L) {
                                if (!L.ok) throw "failed to load wasm binary file at '" + me + "'";
                                return L.arrayBuffer();
                            }).catch(function() {
                                return J(me);
                            });
                            if (m) return new Promise(function(L, V) {
                                m(me, function(R) {
                                    L(new Uint8Array(R));
                                }, V);
                            });
                        }
                        return Promise.resolve().then(function() {
                            return J(me);
                        });
                    }
                    function Ue() {
                        var L = {
                            env: W,
                            wasi_snapshot_preview1: W
                        };
                        function V(te, se) {
                            var de = te.exports;
                            a.asm = de, _ = a.asm.memory, $e(_.buffer), je = a.asm.__indirect_function_table, zt(a.asm.__wasm_call_ctors), ln();
                        }
                        En();
                        function R(te) {
                            V(te.instance);
                        }
                        function I(te) {
                            return Ce().then(function(se) {
                                return WebAssembly.instantiate(se, L);
                            }).then(function(se) {
                                return se;
                            }).then(te, function(se) {
                                S("failed to asynchronously prepare wasm: " + se), Hn(se);
                            });
                        }
                        function A() {
                            return !D && typeof WebAssembly.instantiateStreaming == "function" && !q(me) && !Q(me) && !u && typeof fetch == "function" ? fetch(me, {
                                credentials: "same-origin"
                            }).then(function(te) {
                                var se = WebAssembly.instantiateStreaming(te, L);
                                return se.then(R, function(de) {
                                    return S("wasm streaming compile failed: " + de), S("falling back to ArrayBuffer instantiation"), I(R);
                                });
                            }) : I(R);
                        }
                        if (a.instantiateWasm) try {
                            var Y = a.instantiateWasm(L, V);
                            return Y;
                        } catch (te) {
                            S("Module.instantiateWasm callback failed with error: " + te), s(te);
                        }
                        return A().catch(s), {};
                    }
                    function lt(L) {
                        this.name = "ExitStatus", this.message = "Program terminated with exit(" + L + ")", this.status = L;
                    }
                    function Mt(L) {
                        for(; L.length > 0;)L.shift()(a);
                    }
                    function jt(L, V, R, I) {
                        Hn("Assertion failed: " + B(L) + ", at: " + [
                            V ? B(V) : "unknown filename",
                            R,
                            I ? B(I) : "unknown function"
                        ]);
                    }
                    var Cn = [];
                    function tn(L) {
                        L.add_ref();
                    }
                    function Mr(L) {
                        var V = new ft(L);
                        return V.get_caught() || V.set_caught(!0), V.set_rethrown(!1), Cn.push(V), tn(V), V.get_exception_ptr();
                    }
                    var Yt = 0, mn = [];
                    function Tn(L) {
                        var V = mn[L];
                        return V || (L >= mn.length && (mn.length = L + 1), mn[L] = V = je.get(L)), V;
                    }
                    function De(L) {
                        if (L.release_ref() && !L.get_rethrown()) {
                            var V = L.get_destructor();
                            V && Tn(V)(L.excPtr), xe(L.excPtr);
                        }
                    }
                    function ze() {
                        _setThrew(0);
                        var L = Cn.pop();
                        De(L), Yt = 0;
                    }
                    function ft(L) {
                        this.excPtr = L, this.ptr = L - 24, this.set_type = function(V) {
                            X[this.ptr + 4 >> 2] = V;
                        }, this.get_type = function() {
                            return X[this.ptr + 4 >> 2];
                        }, this.set_destructor = function(V) {
                            X[this.ptr + 8 >> 2] = V;
                        }, this.get_destructor = function() {
                            return X[this.ptr + 8 >> 2];
                        }, this.set_refcount = function(V) {
                            re[this.ptr >> 2] = V;
                        }, this.set_caught = function(V) {
                            V = V ? 1 : 0, ae[this.ptr + 12 >> 0] = V;
                        }, this.get_caught = function() {
                            return ae[this.ptr + 12 >> 0] != 0;
                        }, this.set_rethrown = function(V) {
                            V = V ? 1 : 0, ae[this.ptr + 13 >> 0] = V;
                        }, this.get_rethrown = function() {
                            return ae[this.ptr + 13 >> 0] != 0;
                        }, this.init = function(V, R) {
                            this.set_adjusted_ptr(0), this.set_type(V), this.set_destructor(R), this.set_refcount(0), this.set_caught(!1), this.set_rethrown(!1);
                        }, this.add_ref = function() {
                            var V = re[this.ptr >> 2];
                            re[this.ptr >> 2] = V + 1;
                        }, this.release_ref = function() {
                            var V = re[this.ptr >> 2];
                            return re[this.ptr >> 2] = V - 1, V === 1;
                        }, this.set_adjusted_ptr = function(V) {
                            X[this.ptr + 16 >> 2] = V;
                        }, this.get_adjusted_ptr = function() {
                            return X[this.ptr + 16 >> 2];
                        }, this.get_exception_ptr = function() {
                            var V = mt(this.get_type());
                            if (V) return X[this.excPtr >> 2];
                            var R = this.get_adjusted_ptr();
                            return R !== 0 ? R : this.excPtr;
                        };
                    }
                    function nn(L) {
                        throw Yt || (Yt = L), L;
                    }
                    function Gr() {
                        var L = Yt;
                        if (!L) return Ve(0), 0;
                        var V = new ft(L);
                        V.set_adjusted_ptr(L);
                        var R = V.get_type();
                        if (!R) return Ve(0), L;
                        for(var I = 0; I < arguments.length; I++){
                            var A = arguments[I];
                            if (A === 0 || A === R) break;
                            var Y = V.ptr + 16;
                            if (Je(A, R, Y)) return Ve(A), L;
                        }
                        return Ve(R), L;
                    }
                    function ir() {
                        var L = Yt;
                        if (!L) return Ve(0), 0;
                        var V = new ft(L);
                        V.set_adjusted_ptr(L);
                        var R = V.get_type();
                        if (!R) return Ve(0), L;
                        for(var I = 0; I < arguments.length; I++){
                            var A = arguments[I];
                            if (A === 0 || A === R) break;
                            var Y = V.ptr + 16;
                            if (Je(A, R, Y)) return Ve(A), L;
                        }
                        return Ve(R), L;
                    }
                    function dr(L, V, R) {
                        var I = new ft(L);
                        throw I.init(V, R), Yt = L, L;
                    }
                    var br = {};
                    function pa(L) {
                        for(; L.length;){
                            var V = L.pop(), R = L.pop();
                            R(V);
                        }
                    }
                    function Lr(L) {
                        return this.fromWireType(re[L >> 2]);
                    }
                    var Pr = {}, Hi = {}, Li = {}, Fn = 48, ci = 57;
                    function _t(L) {
                        if (L === void 0) return "_unknown";
                        L = L.replace(/[^a-zA-Z0-9_]/g, "$");
                        var V = L.charCodeAt(0);
                        return V >= Fn && V <= ci ? "_" + L : L;
                    }
                    function Ht(L, V) {
                        return L = _t(L), new Function("body", "return function " + L + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(V);
                    }
                    function kt(L, V) {
                        var R = Ht(V, function(I) {
                            this.name = V, this.message = I;
                            var A = new Error(I).stack;
                            A !== void 0 && (this.stack = this.toString() + `
` + A.replace(/^Error(:[^\n]*)?\n/, ""));
                        });
                        return R.prototype = Object.create(L.prototype), R.prototype.constructor = R, R.prototype.toString = function() {
                            return this.message === void 0 ? this.name : this.name + ": " + this.message;
                        }, R;
                    }
                    var It = void 0;
                    function pr(L) {
                        throw new It(L);
                    }
                    function Zr(L, V, R) {
                        L.forEach(function(se) {
                            Li[se] = V;
                        });
                        function I(se) {
                            var de = R(se);
                            de.length !== L.length && pr("Mismatched type converter count");
                            for(var pe = 0; pe < L.length; ++pe)mr(L[pe], de[pe]);
                        }
                        var A = new Array(V.length), Y = [], te = 0;
                        V.forEach((se, de)=>{
                            Hi.hasOwnProperty(se) ? A[de] = Hi[se] : (Y.push(se), Pr.hasOwnProperty(se) || (Pr[se] = []), Pr[se].push(()=>{
                                A[de] = Hi[se], ++te, te === Y.length && I(A);
                            }));
                        }), Y.length === 0 && I(A);
                    }
                    function to(L) {
                        var V = br[L];
                        delete br[L];
                        var R = V.rawConstructor, I = V.rawDestructor, A = V.fields, Y = A.map((te)=>te.getterReturnType).concat(A.map((te)=>te.setterArgumentType));
                        Zr([
                            L
                        ], Y, (te)=>{
                            var se = {};
                            return A.forEach((de, pe)=>{
                                var Se = de.fieldName, Le = te[pe], Ze = de.getter, gt = de.getterContext, ut = te[pe + A.length], At = de.setter, Nt = de.setterContext;
                                se[Se] = {
                                    read: (Bt)=>Le.fromWireType(Ze(gt, Bt)),
                                    write: (Bt, Wn)=>{
                                        var wr = [];
                                        At(Nt, Bt, ut.toWireType(wr, Wn)), pa(wr);
                                    }
                                };
                            }), [
                                {
                                    name: V.name,
                                    fromWireType: function(de) {
                                        var pe = {};
                                        for(var Se in se)pe[Se] = se[Se].read(de);
                                        return I(de), pe;
                                    },
                                    toWireType: function(de, pe) {
                                        for(var Se in se)if (!(Se in pe)) throw new TypeError('Missing field:  "' + Se + '"');
                                        var Le = R();
                                        for(Se in se)se[Se].write(Le, pe[Se]);
                                        return de !== null && de.push(I, Le), Le;
                                    },
                                    argPackAdvance: 8,
                                    readValueFromPointer: Lr,
                                    destructorFunction: I
                                }
                            ];
                        });
                    }
                    function _o(L, V, R, I, A) {}
                    function ma(L) {
                        switch(L){
                            case 1:
                                return 0;
                            case 2:
                                return 1;
                            case 4:
                                return 2;
                            case 8:
                                return 3;
                            default:
                                throw new TypeError("Unknown type size: " + L);
                        }
                    }
                    function no() {
                        for(var L = new Array(256), V = 0; V < 256; ++V)L[V] = String.fromCharCode(V);
                        xi = L;
                    }
                    var xi = void 0;
                    function Kn(L) {
                        for(var V = "", R = L; ue[R];)V += xi[ue[R++]];
                        return V;
                    }
                    var Pi = void 0;
                    function Kt(L) {
                        throw new Pi(L);
                    }
                    function mr(L, V, R = {}) {
                        if (!("argPackAdvance" in V)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
                        var I = V.name;
                        if (L || Kt('type "' + I + '" must have a positive integer typeid pointer'), Hi.hasOwnProperty(L)) {
                            if (R.ignoreDuplicateRegistrations) return;
                            Kt("Cannot register type '" + I + "' twice");
                        }
                        if (Hi[L] = V, delete Li[L], Pr.hasOwnProperty(L)) {
                            var A = Pr[L];
                            delete Pr[L], A.forEach((Y)=>Y());
                        }
                    }
                    function Ro(L, V, R, I, A) {
                        var Y = ma(R);
                        V = Kn(V), mr(L, {
                            name: V,
                            fromWireType: function(te) {
                                return !!te;
                            },
                            toWireType: function(te, se) {
                                return se ? I : A;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: function(te) {
                                var se;
                                if (R === 1) se = ae;
                                else if (R === 2) se = le;
                                else if (R === 4) se = re;
                                else throw new TypeError("Unknown boolean type size: " + V);
                                return this.fromWireType(se[te >> Y]);
                            },
                            destructorFunction: null
                        });
                    }
                    function Si(L) {
                        if (!(this instanceof $r) || !(L instanceof $r)) return !1;
                        for(var V = this.$$.ptrType.registeredClass, R = this.$$.ptr, I = L.$$.ptrType.registeredClass, A = L.$$.ptr; V.baseClass;)R = V.upcast(R), V = V.baseClass;
                        for(; I.baseClass;)A = I.upcast(A), I = I.baseClass;
                        return V === I && R === A;
                    }
                    function Ki(L) {
                        return {
                            count: L.count,
                            deleteScheduled: L.deleteScheduled,
                            preservePointerOnDelete: L.preservePointerOnDelete,
                            ptr: L.ptr,
                            ptrType: L.ptrType,
                            smartPtr: L.smartPtr,
                            smartPtrType: L.smartPtrType
                        };
                    }
                    function Vi(L) {
                        function V(R) {
                            return R.$$.ptrType.registeredClass.name;
                        }
                        Kt(V(L) + " instance already deleted");
                    }
                    var li = !1;
                    function Pn(L) {}
                    function ro(L) {
                        L.smartPtr ? L.smartPtrType.rawDestructor(L.smartPtr) : L.ptrType.registeredClass.rawDestructor(L.ptr);
                    }
                    function ui(L) {
                        L.count.value -= 1;
                        var V = L.count.value === 0;
                        V && ro(L);
                    }
                    function Qo(L, V, R) {
                        if (V === R) return L;
                        if (R.baseClass === void 0) return null;
                        var I = Qo(L, V, R.baseClass);
                        return I === null ? null : R.downcast(I);
                    }
                    var Jr = {};
                    function Oo() {
                        return Object.keys(Wr).length;
                    }
                    function Pa() {
                        var L = [];
                        for(var V in Wr)Wr.hasOwnProperty(V) && L.push(Wr[V]);
                        return L;
                    }
                    var Qr = [];
                    function ei() {
                        for(; Qr.length;){
                            var L = Qr.pop();
                            L.$$.deleteScheduled = !1, L.delete();
                        }
                    }
                    var io = void 0;
                    function qn(L) {
                        io = L, Qr.length && io && io(ei);
                    }
                    function _s() {
                        a.getInheritedInstanceCount = Oo, a.getLiveInheritedInstances = Pa, a.flushPendingDeletes = ei, a.setDelayFunction = qn;
                    }
                    var Wr = {};
                    function Ni(L, V) {
                        for(V === void 0 && Kt("ptr should not be undefined"); L.baseClass;)V = L.upcast(V), L = L.baseClass;
                        return V;
                    }
                    function va(L, V) {
                        return V = Ni(L, V), Wr[V];
                    }
                    function ya(L, V) {
                        (!V.ptrType || !V.ptr) && pr("makeClassHandle requires ptr and ptrType");
                        var R = !!V.smartPtrType, I = !!V.smartPtr;
                        return R !== I && pr("Both smartPtrType and smartPtr must be specified"), V.count = {
                            value: 1
                        }, Ei(Object.create(L, {
                            $$: {
                                value: V
                            }
                        }));
                    }
                    function Ca(L) {
                        var V = this.getPointee(L);
                        if (!V) return this.destructor(L), null;
                        var R = va(this.registeredClass, V);
                        if (R !== void 0) {
                            if (R.$$.count.value === 0) return R.$$.ptr = V, R.$$.smartPtr = L, R.clone();
                            var I = R.clone();
                            return this.destructor(L), I;
                        }
                        function A() {
                            return this.isSmartPointer ? ya(this.registeredClass.instancePrototype, {
                                ptrType: this.pointeeType,
                                ptr: V,
                                smartPtrType: this,
                                smartPtr: L
                            }) : ya(this.registeredClass.instancePrototype, {
                                ptrType: this,
                                ptr: L
                            });
                        }
                        var Y = this.registeredClass.getActualType(V), te = Jr[Y];
                        if (!te) return A.call(this);
                        var se;
                        this.isConst ? se = te.constPointerType : se = te.pointerType;
                        var de = Qo(V, this.registeredClass, se.registeredClass);
                        return de === null ? A.call(this) : this.isSmartPointer ? ya(se.registeredClass.instancePrototype, {
                            ptrType: se,
                            ptr: de,
                            smartPtrType: this,
                            smartPtr: L
                        }) : ya(se.registeredClass.instancePrototype, {
                            ptrType: se,
                            ptr: de
                        });
                    }
                    function Ei(L) {
                        return typeof FinalizationRegistry > "u" ? (Ei = (V)=>V, L) : (li = new FinalizationRegistry((V)=>{
                            ui(V.$$);
                        }), Ei = (V)=>{
                            var R = V.$$, I = !!R.smartPtr;
                            if (I) {
                                var A = {
                                    $$: R
                                };
                                li.register(V, A, V);
                            }
                            return V;
                        }, Pn = (V)=>li.unregister(V), Ei(L));
                    }
                    function dc() {
                        if (this.$$.ptr || Vi(this), this.$$.preservePointerOnDelete) return this.$$.count.value += 1, this;
                        var L = Ei(Object.create(Object.getPrototypeOf(this), {
                            $$: {
                                value: Ki(this.$$)
                            }
                        }));
                        return L.$$.count.value += 1, L.$$.deleteScheduled = !1, L;
                    }
                    function gc() {
                        this.$$.ptr || Vi(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Kt("Object already scheduled for deletion"), Pn(this), ui(this.$$), this.$$.preservePointerOnDelete || (this.$$.smartPtr = void 0, this.$$.ptr = void 0);
                    }
                    function es() {
                        return !this.$$.ptr;
                    }
                    function Rs() {
                        return this.$$.ptr || Vi(this), this.$$.deleteScheduled && !this.$$.preservePointerOnDelete && Kt("Object already scheduled for deletion"), Qr.push(this), Qr.length === 1 && io && io(ei), this.$$.deleteScheduled = !0, this;
                    }
                    function fi() {
                        $r.prototype.isAliasOf = Si, $r.prototype.clone = dc, $r.prototype.delete = gc, $r.prototype.isDeleted = es, $r.prototype.deleteLater = Rs;
                    }
                    function $r() {}
                    function Di(L, V, R) {
                        if (L[V].overloadTable === void 0) {
                            var I = L[V];
                            L[V] = function() {
                                return L[V].overloadTable.hasOwnProperty(arguments.length) || Kt("Function '" + R + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + L[V].overloadTable + ")!"), L[V].overloadTable[arguments.length].apply(this, arguments);
                            }, L[V].overloadTable = [], L[V].overloadTable[I.argCount] = I;
                        }
                    }
                    function vr(L, V, R) {
                        a.hasOwnProperty(L) ? ((R === void 0 || a[L].overloadTable !== void 0 && a[L].overloadTable[R] !== void 0) && Kt("Cannot register public name '" + L + "' twice"), Di(a, L, L), a.hasOwnProperty(R) && Kt("Cannot register multiple overloads of a function with the same number of arguments (" + R + ")!"), a[L].overloadTable[R] = V) : (a[L] = V, R !== void 0 && (a[L].numArguments = R));
                    }
                    function an(L, V, R, I, A, Y, te, se) {
                        this.name = L, this.constructor = V, this.instancePrototype = R, this.rawDestructor = I, this.baseClass = A, this.getActualType = Y, this.upcast = te, this.downcast = se, this.pureVirtualFunctions = [];
                    }
                    function wa(L, V, R) {
                        for(; V !== R;)V.upcast || Kt("Expected null or instance of " + R.name + ", got an instance of " + V.name), L = V.upcast(L), V = V.baseClass;
                        return L;
                    }
                    function Va(L, V) {
                        if (V === null) return this.isReference && Kt("null is not a valid " + this.name), 0;
                        V.$$ || Kt('Cannot pass "' + Lo(V) + '" as a ' + this.name), V.$$.ptr || Kt("Cannot pass deleted object as a pointer of type " + this.name);
                        var R = V.$$.ptrType.registeredClass, I = wa(V.$$.ptr, R, this.registeredClass);
                        return I;
                    }
                    function Bn(L, V) {
                        var R;
                        if (V === null) return this.isReference && Kt("null is not a valid " + this.name), this.isSmartPointer ? (R = this.rawConstructor(), L !== null && L.push(this.rawDestructor, R), R) : 0;
                        V.$$ || Kt('Cannot pass "' + Lo(V) + '" as a ' + this.name), V.$$.ptr || Kt("Cannot pass deleted object as a pointer of type " + this.name), !this.isConst && V.$$.ptrType.isConst && Kt("Cannot convert argument of type " + (V.$$.smartPtrType ? V.$$.smartPtrType.name : V.$$.ptrType.name) + " to parameter type " + this.name);
                        var I = V.$$.ptrType.registeredClass;
                        if (R = wa(V.$$.ptr, I, this.registeredClass), this.isSmartPointer) switch(V.$$.smartPtr === void 0 && Kt("Passing raw pointer to smart pointer is illegal"), this.sharingPolicy){
                            case 0:
                                V.$$.smartPtrType === this ? R = V.$$.smartPtr : Kt("Cannot convert argument of type " + (V.$$.smartPtrType ? V.$$.smartPtrType.name : V.$$.ptrType.name) + " to parameter type " + this.name);
                                break;
                            case 1:
                                R = V.$$.smartPtr;
                                break;
                            case 2:
                                if (V.$$.smartPtrType === this) R = V.$$.smartPtr;
                                else {
                                    var A = V.clone();
                                    R = this.rawShare(R, Yi.toHandle(function() {
                                        A.delete();
                                    })), L !== null && L.push(this.rawDestructor, R);
                                }
                                break;
                            default:
                                Kt("Unsupporting sharing policy");
                        }
                        return R;
                    }
                    function ts(L, V) {
                        if (V === null) return this.isReference && Kt("null is not a valid " + this.name), 0;
                        V.$$ || Kt('Cannot pass "' + Lo(V) + '" as a ' + this.name), V.$$.ptr || Kt("Cannot pass deleted object as a pointer of type " + this.name), V.$$.ptrType.isConst && Kt("Cannot convert argument of type " + V.$$.ptrType.name + " to parameter type " + this.name);
                        var R = V.$$.ptrType.registeredClass, I = wa(V.$$.ptr, R, this.registeredClass);
                        return I;
                    }
                    function ti(L) {
                        return this.rawGetPointee && (L = this.rawGetPointee(L)), L;
                    }
                    function yr(L) {
                        this.rawDestructor && this.rawDestructor(L);
                    }
                    function ao(L) {
                        L !== null && L.delete();
                    }
                    function Ai() {
                        Xn.prototype.getPointee = ti, Xn.prototype.destructor = yr, Xn.prototype.argPackAdvance = 8, Xn.prototype.readValueFromPointer = Lr, Xn.prototype.deleteObject = ao, Xn.prototype.fromWireType = Ca;
                    }
                    function Xn(L, V, R, I, A, Y, te, se, de, pe, Se) {
                        this.name = L, this.registeredClass = V, this.isReference = R, this.isConst = I, this.isSmartPointer = A, this.pointeeType = Y, this.sharingPolicy = te, this.rawGetPointee = se, this.rawConstructor = de, this.rawShare = pe, this.rawDestructor = Se, !A && V.baseClass === void 0 ? I ? (this.toWireType = Va, this.destructorFunction = null) : (this.toWireType = ts, this.destructorFunction = null) : this.toWireType = Bn;
                    }
                    function ni(L, V, R) {
                        a.hasOwnProperty(L) || pr("Replacing nonexistant public symbol"), a[L].overloadTable !== void 0 && R !== void 0 ? a[L].overloadTable[R] = V : (a[L] = V, a[L].argCount = R);
                    }
                    function ki(L, V, R) {
                        var I = a["dynCall_" + L];
                        return R && R.length ? I.apply(null, [
                            V
                        ].concat(R)) : I.call(null, V);
                    }
                    function Na(L, V, R) {
                        if (L.includes("j")) return ki(L, V, R);
                        var I = Tn(V).apply(null, R);
                        return I;
                    }
                    function qi(L, V) {
                        var R = [];
                        return function() {
                            return R.length = 0, Object.assign(R, arguments), Na(L, V, R);
                        };
                    }
                    function un(L, V) {
                        L = Kn(L);
                        function R() {
                            return L.includes("j") ? qi(L, V) : Tn(V);
                        }
                        var I = R();
                        return typeof I != "function" && Kt("unknown function pointer with signature " + L + ": " + V), I;
                    }
                    var oo = void 0;
                    function Cr(L) {
                        var V = Oe(L), R = Kn(V);
                        return ce(V), R;
                    }
                    function Gn(L, V) {
                        var R = [], I = {};
                        function A(Y) {
                            if (!I[Y] && !Hi[Y]) {
                                if (Li[Y]) {
                                    Li[Y].forEach(A);
                                    return;
                                }
                                R.push(Y), I[Y] = !0;
                            }
                        }
                        throw V.forEach(A), new oo(L + ": " + R.map(Cr).join([
                            ", "
                        ]));
                    }
                    function Os(L, V, R, I, A, Y, te, se, de, pe, Se, Le, Ze) {
                        Se = Kn(Se), Y = un(A, Y), se && (se = un(te, se)), pe && (pe = un(de, pe)), Ze = un(Le, Ze);
                        var gt = _t(Se);
                        vr(gt, function() {
                            Gn("Cannot construct " + Se + " due to unbound types", [
                                I
                            ]);
                        }), Zr([
                            L,
                            V,
                            R
                        ], I ? [
                            I
                        ] : [], function(ut) {
                            ut = ut[0];
                            var At, Nt;
                            I ? (At = ut.registeredClass, Nt = At.instancePrototype) : Nt = $r.prototype;
                            var Bt = Ht(gt, function() {
                                if (Object.getPrototypeOf(this) !== Wn) throw new Pi("Use 'new' to construct " + Se);
                                if (wr.constructor_body === void 0) throw new Pi(Se + " has no accessible constructor");
                                var Tc = wr.constructor_body[arguments.length];
                                if (Tc === void 0) throw new Pi("Tried to invoke ctor of " + Se + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(wr.constructor_body).toString() + ") parameters instead!");
                                return Tc.apply(this, arguments);
                            }), Wn = Object.create(Nt, {
                                constructor: {
                                    value: Bt
                                }
                            });
                            Bt.prototype = Wn;
                            var wr = new an(Se, Bt, Wn, Ze, At, Y, se, pe), Us = new Xn(Se, wr, !0, !1, !1), xa = new Xn(Se + "*", wr, !1, !1, !1), Ql = new Xn(Se + " const*", wr, !1, !0, !1);
                            return Jr[L] = {
                                pointerType: xa,
                                constPointerType: Ql
                            }, ni(gt, Bt), [
                                Us,
                                xa,
                                Ql
                            ];
                        });
                    }
                    function di(L, V) {
                        for(var R = [], I = 0; I < L; I++)R.push(X[V + I * 4 >> 2]);
                        return R;
                    }
                    function Io(L, V) {
                        if (!(L instanceof Function)) throw new TypeError("new_ called with constructor type " + typeof L + " which is not a function");
                        var R = Ht(L.name || "unknownFunctionName", function() {});
                        R.prototype = L.prototype;
                        var I = new R, A = L.apply(I, V);
                        return A instanceof Object ? A : I;
                    }
                    function zr(L, V, R, I, A) {
                        var Y = V.length;
                        Y < 2 && Kt("argTypes array size mismatch! Must at least get return value and 'this' types!");
                        for(var te = V[1] !== null && R !== null, se = !1, de = 1; de < V.length; ++de)if (V[de] !== null && V[de].destructorFunction === void 0) {
                            se = !0;
                            break;
                        }
                        for(var pe = V[0].name !== "void", Se = "", Le = "", de = 0; de < Y - 2; ++de)Se += (de !== 0 ? ", " : "") + "arg" + de, Le += (de !== 0 ? ", " : "") + "arg" + de + "Wired";
                        var Ze = "return function " + _t(L) + "(" + Se + `) {
if (arguments.length !== ` + (Y - 2) + `) {
throwBindingError('function ` + L + " called with ' + arguments.length + ' arguments, expected " + (Y - 2) + ` args!');
}
`;
                        se && (Ze += `var destructors = [];
`);
                        var gt = se ? "destructors" : "null", ut = [
                            "throwBindingError",
                            "invoker",
                            "fn",
                            "runDestructors",
                            "retType",
                            "classParam"
                        ], At = [
                            Kt,
                            I,
                            A,
                            pa,
                            V[0],
                            V[1]
                        ];
                        te && (Ze += "var thisWired = classParam.toWireType(" + gt + `, this);
`);
                        for(var de = 0; de < Y - 2; ++de)Ze += "var arg" + de + "Wired = argType" + de + ".toWireType(" + gt + ", arg" + de + "); // " + V[de + 2].name + `
`, ut.push("argType" + de), At.push(V[de + 2]);
                        if (te && (Le = "thisWired" + (Le.length > 0 ? ", " : "") + Le), Ze += (pe ? "var rv = " : "") + "invoker(fn" + (Le.length > 0 ? ", " : "") + Le + `);
`, se) Ze += `runDestructors(destructors);
`;
                        else for(var de = te ? 1 : 2; de < V.length; ++de){
                            var Nt = de === 1 ? "thisWired" : "arg" + (de - 2) + "Wired";
                            V[de].destructorFunction !== null && (Ze += Nt + "_dtor(" + Nt + "); // " + V[de].name + `
`, ut.push(Nt + "_dtor"), At.push(V[de].destructorFunction));
                        }
                        pe && (Ze += `var ret = retType.fromWireType(rv);
return ret;
`), Ze += `}
`, ut.push(Ze);
                        var Bt = Io(Function, ut).apply(null, At);
                        return Bt;
                    }
                    function Xi(L, V, R, I, A, Y) {
                        P(V > 0);
                        var te = di(V, R);
                        A = un(I, A), Zr([], [
                            L
                        ], function(se) {
                            se = se[0];
                            var de = "constructor " + se.name;
                            if (se.registeredClass.constructor_body === void 0 && (se.registeredClass.constructor_body = []), se.registeredClass.constructor_body[V - 1] !== void 0) throw new Pi("Cannot register multiple constructors with identical number of parameters (" + (V - 1) + ") for class '" + se.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
                            return se.registeredClass.constructor_body[V - 1] = ()=>{
                                Gn("Cannot construct " + se.name + " due to unbound types", te);
                            }, Zr([], te, function(pe) {
                                return pe.splice(1, 0, null), se.registeredClass.constructor_body[V - 1] = zr(de, pe, null, A, Y), [];
                            }), [];
                        });
                    }
                    function Ta(L, V, R, I, A, Y, te, se) {
                        var de = di(R, I);
                        V = Kn(V), Y = un(A, Y), Zr([], [
                            L
                        ], function(pe) {
                            pe = pe[0];
                            var Se = pe.name + "." + V;
                            V.startsWith("@@") && (V = Symbol[V.substring(2)]), se && pe.registeredClass.pureVirtualFunctions.push(V);
                            function Le() {
                                Gn("Cannot call " + Se + " due to unbound types", de);
                            }
                            var Ze = pe.registeredClass.instancePrototype, gt = Ze[V];
                            return gt === void 0 || gt.overloadTable === void 0 && gt.className !== pe.name && gt.argCount === R - 2 ? (Le.argCount = R - 2, Le.className = pe.name, Ze[V] = Le) : (Di(Ze, V, Se), Ze[V].overloadTable[R - 2] = Le), Zr([], de, function(ut) {
                                var At = zr(Se, ut, pe, Y, te);
                                return Ze[V].overloadTable === void 0 ? (At.argCount = R - 2, Ze[V] = At) : Ze[V].overloadTable[R - 2] = At, [];
                            }), [];
                        });
                    }
                    var Ui = [], gr = [
                        {},
                        {
                            value: void 0
                        },
                        {
                            value: null
                        },
                        {
                            value: !0
                        },
                        {
                            value: !1
                        }
                    ];
                    function so(L) {
                        L > 4 && --gr[L].refcount === 0 && (gr[L] = void 0, Ui.push(L));
                    }
                    function hc() {
                        for(var L = 0, V = 5; V < gr.length; ++V)gr[V] !== void 0 && ++L;
                        return L;
                    }
                    function pc() {
                        for(var L = 5; L < gr.length; ++L)if (gr[L] !== void 0) return gr[L];
                        return null;
                    }
                    function Mo() {
                        a.count_emval_handles = hc, a.get_first_emval = pc;
                    }
                    var Yi = {
                        toValue: (L)=>(L || Kt("Cannot use deleted val. handle = " + L), gr[L].value),
                        toHandle: (L)=>{
                            switch(L){
                                case void 0:
                                    return 1;
                                case null:
                                    return 2;
                                case !0:
                                    return 3;
                                case !1:
                                    return 4;
                                default:
                                    {
                                        var V = Ui.length ? Ui.pop() : gr.length;
                                        return gr[V] = {
                                            refcount: 1,
                                            value: L
                                        }, V;
                                    }
                            }
                        }
                    };
                    function bo(L, V) {
                        V = Kn(V), mr(L, {
                            name: V,
                            fromWireType: function(R) {
                                var I = Yi.toValue(R);
                                return so(R), I;
                            },
                            toWireType: function(R, I) {
                                return Yi.toHandle(I);
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Lr,
                            destructorFunction: null
                        });
                    }
                    function Lo(L) {
                        if (L === null) return "null";
                        var V = typeof L;
                        return V === "object" || V === "array" || V === "function" ? L.toString() : "" + L;
                    }
                    function Zi(L, V) {
                        switch(V){
                            case 2:
                                return function(R) {
                                    return this.fromWireType(ie[R >> 2]);
                                };
                            case 3:
                                return function(R) {
                                    return this.fromWireType(he[R >> 3]);
                                };
                            default:
                                throw new TypeError("Unknown float type: " + L);
                        }
                    }
                    function ns(L, V, R) {
                        var I = ma(R);
                        V = Kn(V), mr(L, {
                            name: V,
                            fromWireType: function(A) {
                                return A;
                            },
                            toWireType: function(A, Y) {
                                return Y;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Zi(V, I),
                            destructorFunction: null
                        });
                    }
                    function Po(L, V, R, I, A, Y) {
                        var te = di(V, R);
                        L = Kn(L), A = un(I, A), vr(L, function() {
                            Gn("Cannot call " + L + " due to unbound types", te);
                        }, V - 1), Zr([], te, function(se) {
                            var de = [
                                se[0],
                                null
                            ].concat(se.slice(1));
                            return ni(L, zr(L, de, null, A, Y), V - 1), [];
                        });
                    }
                    function Is(L, V, R) {
                        switch(V){
                            case 0:
                                return R ? function(A) {
                                    return ae[A];
                                } : function(A) {
                                    return ue[A];
                                };
                            case 1:
                                return R ? function(A) {
                                    return le[A >> 1];
                                } : function(A) {
                                    return oe[A >> 1];
                                };
                            case 2:
                                return R ? function(A) {
                                    return re[A >> 2];
                                } : function(A) {
                                    return X[A >> 2];
                                };
                            default:
                                throw new TypeError("Unknown integer type: " + L);
                        }
                    }
                    function Vo(L, V, R, I, A) {
                        V = Kn(V);
                        var Y = ma(R), te = (Le)=>Le;
                        if (I === 0) {
                            var se = 32 - 8 * R;
                            te = (Le)=>Le << se >>> se;
                        }
                        var de = V.includes("unsigned"), pe = (Le, Ze)=>{}, Se;
                        de ? Se = function(Le, Ze) {
                            return pe(Ze, this.name), Ze >>> 0;
                        } : Se = function(Le, Ze) {
                            return pe(Ze, this.name), Ze;
                        }, mr(L, {
                            name: V,
                            fromWireType: te,
                            toWireType: Se,
                            argPackAdvance: 8,
                            readValueFromPointer: Is(V, Y, I !== 0),
                            destructorFunction: null
                        });
                    }
                    function No(L, V, R) {
                        var I = [
                            Int8Array,
                            Uint8Array,
                            Int16Array,
                            Uint16Array,
                            Int32Array,
                            Uint32Array,
                            Float32Array,
                            Float64Array
                        ], A = I[V];
                        function Y(te) {
                            te = te >> 2;
                            var se = X, de = se[te], pe = se[te + 1];
                            return new A(ne, pe, de);
                        }
                        R = Kn(R), mr(L, {
                            name: R,
                            fromWireType: Y,
                            argPackAdvance: 8,
                            readValueFromPointer: Y
                        }, {
                            ignoreDuplicateRegistrations: !0
                        });
                    }
                    function Ms(L, V) {
                        V = Kn(V);
                        var R = V === "std::string";
                        mr(L, {
                            name: V,
                            fromWireType: function(I) {
                                var A = X[I >> 2], Y = I + 4, te;
                                if (R) for(var se = Y, de = 0; de <= A; ++de){
                                    var pe = Y + de;
                                    if (de == A || ue[pe] == 0) {
                                        var Se = pe - se, Le = B(se, Se);
                                        te === void 0 ? te = Le : (te += "\0", te += Le), se = pe + 1;
                                    }
                                }
                                else {
                                    for(var Ze = new Array(A), de = 0; de < A; ++de)Ze[de] = String.fromCharCode(ue[Y + de]);
                                    te = Ze.join("");
                                }
                                return ce(I), te;
                            },
                            toWireType: function(I, A) {
                                A instanceof ArrayBuffer && (A = new Uint8Array(A));
                                var Y, te = typeof A == "string";
                                te || A instanceof Uint8Array || A instanceof Uint8ClampedArray || A instanceof Int8Array || Kt("Cannot pass non-string to std::string"), R && te ? Y = H(A) : Y = A.length;
                                var se = $(4 + Y + 1), de = se + 4;
                                if (X[se >> 2] = Y, R && te) Z(A, de, Y + 1);
                                else if (te) for(var pe = 0; pe < Y; ++pe){
                                    var Se = A.charCodeAt(pe);
                                    Se > 255 && (ce(de), Kt("String has UTF-16 code units that do not fit in 8 bits")), ue[de + pe] = Se;
                                }
                                else for(var pe = 0; pe < Y; ++pe)ue[de + pe] = A[pe];
                                return I !== null && I.push(ce, se), se;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Lr,
                            destructorFunction: function(I) {
                                ce(I);
                            }
                        });
                    }
                    var Vr = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
                    function Aa(L, V) {
                        for(var R = L, I = R >> 1, A = I + V / 2; !(I >= A) && oe[I];)++I;
                        if (R = I << 1, R - L > 32 && Vr) return Vr.decode(ue.subarray(L, R));
                        for(var Y = "", te = 0; !(te >= V / 2); ++te){
                            var se = le[L + te * 2 >> 1];
                            if (se == 0) break;
                            Y += String.fromCharCode(se);
                        }
                        return Y;
                    }
                    function Ao(L, V, R) {
                        if (R === void 0 && (R = 2147483647), R < 2) return 0;
                        R -= 2;
                        for(var I = V, A = R < L.length * 2 ? R / 2 : L.length, Y = 0; Y < A; ++Y){
                            var te = L.charCodeAt(Y);
                            le[V >> 1] = te, V += 2;
                        }
                        return le[V >> 1] = 0, V - I;
                    }
                    function ka(L) {
                        return L.length * 2;
                    }
                    function mc(L, V) {
                        for(var R = 0, I = ""; !(R >= V / 4);){
                            var A = re[L + R * 4 >> 2];
                            if (A == 0) break;
                            if (++R, A >= 65536) {
                                var Y = A - 65536;
                                I += String.fromCharCode(55296 | Y >> 10, 56320 | Y & 1023);
                            } else I += String.fromCharCode(A);
                        }
                        return I;
                    }
                    function co(L, V, R) {
                        if (R === void 0 && (R = 2147483647), R < 4) return 0;
                        for(var I = V, A = I + R - 4, Y = 0; Y < L.length; ++Y){
                            var te = L.charCodeAt(Y);
                            if (te >= 55296 && te <= 57343) {
                                var se = L.charCodeAt(++Y);
                                te = 65536 + ((te & 1023) << 10) | se & 1023;
                            }
                            if (re[V >> 2] = te, V += 4, V + 4 > A) break;
                        }
                        return re[V >> 2] = 0, V - I;
                    }
                    function ko(L) {
                        for(var V = 0, R = 0; R < L.length; ++R){
                            var I = L.charCodeAt(R);
                            I >= 55296 && I <= 57343 && ++R, V += 4;
                        }
                        return V;
                    }
                    function Ua(L, V, R) {
                        R = Kn(R);
                        var I, A, Y, te, se;
                        V === 2 ? (I = Aa, A = Ao, te = ka, Y = ()=>oe, se = 1) : V === 4 && (I = mc, A = co, te = ko, Y = ()=>X, se = 2), mr(L, {
                            name: R,
                            fromWireType: function(de) {
                                for(var pe = X[de >> 2], Se = Y(), Le, Ze = de + 4, gt = 0; gt <= pe; ++gt){
                                    var ut = de + 4 + gt * V;
                                    if (gt == pe || Se[ut >> se] == 0) {
                                        var At = ut - Ze, Nt = I(Ze, At);
                                        Le === void 0 ? Le = Nt : (Le += "\0", Le += Nt), Ze = ut + V;
                                    }
                                }
                                return ce(de), Le;
                            },
                            toWireType: function(de, pe) {
                                typeof pe != "string" && Kt("Cannot pass non-string to C++ string type " + R);
                                var Se = te(pe), Le = $(4 + Se + V);
                                return X[Le >> 2] = Se >> se, A(pe, Le + 4, Se + V), de !== null && de.push(ce, Le), Le;
                            },
                            argPackAdvance: 8,
                            readValueFromPointer: Lr,
                            destructorFunction: function(de) {
                                ce(de);
                            }
                        });
                    }
                    function Fa(L, V, R, I, A, Y) {
                        br[L] = {
                            name: Kn(V),
                            rawConstructor: un(R, I),
                            rawDestructor: un(A, Y),
                            fields: []
                        };
                    }
                    function bs(L, V, R, I, A, Y, te, se, de, pe) {
                        br[L].fields.push({
                            fieldName: Kn(V),
                            getterReturnType: R,
                            getter: un(I, A),
                            getterContext: Y,
                            setterArgumentType: te,
                            setter: un(se, de),
                            setterContext: pe
                        });
                    }
                    function Ls(L, V) {
                        V = Kn(V), mr(L, {
                            isVoid: !0,
                            name: V,
                            argPackAdvance: 0,
                            fromWireType: function() {},
                            toWireType: function(R, I) {}
                        });
                    }
                    function vc(L) {
                        L > 4 && (gr[L].refcount += 1);
                    }
                    function Ps(L, V) {
                        var R = Hi[L];
                        return R === void 0 && Kt(V + " has unknown type " + Cr(L)), R;
                    }
                    function rs(L, V) {
                        L = Ps(L, "_emval_take_value");
                        var R = L.readValueFromPointer(V);
                        return Yi.toHandle(R);
                    }
                    function yc() {
                        Hn("");
                    }
                    function Cc(L, V, R) {
                        ue.copyWithin(L, V, V + R);
                    }
                    function wc() {
                        return 2147483648;
                    }
                    function is(L) {
                        try {
                            return _.grow(L - ne.byteLength + 65535 >>> 16), $e(_.buffer), 1;
                        } catch  {}
                    }
                    function as(L) {
                        var V = ue.length;
                        L = L >>> 0;
                        var R = wc();
                        if (L > R) return !1;
                        let I = (de, pe)=>de + (pe - de % pe) % pe;
                        for(var A = 1; A <= 4; A *= 2){
                            var Y = V * (1 + .2 / A);
                            Y = Math.min(Y, L + 100663296);
                            var te = Math.min(R, I(Math.max(L, Y), 65536)), se = is(te);
                            if (se) return !0;
                        }
                        return !1;
                    }
                    function Ji(L) {
                        return 52;
                    }
                    function Ba(L, V, R, I, A) {
                        return 70;
                    }
                    var Fi = [
                        null,
                        [],
                        []
                    ];
                    function Vs(L, V) {
                        var R = Fi[L];
                        V === 0 || V === 10 ? ((L === 1 ? x : S)(N(R, 0)), R.length = 0) : R.push(V);
                    }
                    function Ns(L, V, R, I) {
                        for(var A = 0, Y = 0; Y < R; Y++){
                            var te = X[V >> 2], se = X[V + 4 >> 2];
                            V += 8;
                            for(var de = 0; de < se; de++)Vs(L, ue[te + de]);
                            A += se;
                        }
                        return X[I >> 2] = A, 0;
                    }
                    function lo(L) {
                        return L;
                    }
                    function As(L) {
                        var V = a["_" + L];
                        return V;
                    }
                    function Uo(L, V) {
                        ae.set(L, V);
                    }
                    function ks(L, V, R, I, A) {
                        var Y = {
                            string: (ut)=>{
                                var At = 0;
                                if (ut != null && ut !== 0) {
                                    var Nt = (ut.length << 2) + 1;
                                    At = ke(Nt), Z(ut, At, Nt);
                                }
                                return At;
                            },
                            array: (ut)=>{
                                var At = ke(ut.length);
                                return Uo(ut, At), At;
                            }
                        };
                        function te(ut) {
                            return V === "string" ? B(ut) : V === "boolean" ? !!ut : ut;
                        }
                        var se = As(L), de = [], pe = 0;
                        if (I) for(var Se = 0; Se < I.length; Se++){
                            var Le = Y[R[Se]];
                            Le ? (pe === 0 && (pe = Ne()), de[Se] = Le(I[Se])) : de[Se] = I[Se];
                        }
                        var Ze = se.apply(null, de);
                        function gt(ut) {
                            return pe !== 0 && Me(pe), te(ut);
                        }
                        return Ze = gt(Ze), Ze;
                    }
                    It = a.InternalError = kt(Error, "InternalError"), no(), Pi = a.BindingError = kt(Error, "BindingError"), fi(), _s(), Ai(), oo = a.UnboundTypeError = kt(Error, "UnboundTypeError"), Mo();
                    var W = {
                        __assert_fail: jt,
                        __cxa_begin_catch: Mr,
                        __cxa_end_catch: ze,
                        __cxa_find_matching_catch_2: Gr,
                        __cxa_find_matching_catch_3: ir,
                        __cxa_throw: dr,
                        __resumeException: nn,
                        _embind_finalize_value_object: to,
                        _embind_register_bigint: _o,
                        _embind_register_bool: Ro,
                        _embind_register_class: Os,
                        _embind_register_class_constructor: Xi,
                        _embind_register_class_function: Ta,
                        _embind_register_emval: bo,
                        _embind_register_float: ns,
                        _embind_register_function: Po,
                        _embind_register_integer: Vo,
                        _embind_register_memory_view: No,
                        _embind_register_std_string: Ms,
                        _embind_register_std_wstring: Ua,
                        _embind_register_value_object: Fa,
                        _embind_register_value_object_field: bs,
                        _embind_register_void: Ls,
                        _emval_decref: so,
                        _emval_incref: vc,
                        _emval_take_value: rs,
                        abort: yc,
                        emscripten_memcpy_big: Cc,
                        emscripten_resize_heap: as,
                        fd_close: Ji,
                        fd_seek: Ba,
                        fd_write: Ns,
                        invoke_i: ye,
                        invoke_ii: Et,
                        invoke_iii: Be,
                        invoke_iiii: ee,
                        invoke_v: k,
                        invoke_vi: Rt,
                        invoke_viiii: U,
                        invoke_viiiiii: _e,
                        llvm_eh_typeid_for: lo
                    };
                    Ue(), a.___wasm_call_ctors = function() {
                        return (a.___wasm_call_ctors = a.asm.__wasm_call_ctors).apply(null, arguments);
                    };
                    var $ = a._malloc = function() {
                        return ($ = a._malloc = a.asm.malloc).apply(null, arguments);
                    }, ce = a._free = function() {
                        return (ce = a._free = a.asm.free).apply(null, arguments);
                    }, xe = a.___cxa_free_exception = function() {
                        return (xe = a.___cxa_free_exception = a.asm.__cxa_free_exception).apply(null, arguments);
                    }, Oe = a.___getTypeName = function() {
                        return (Oe = a.___getTypeName = a.asm.__getTypeName).apply(null, arguments);
                    };
                    a.__embind_initialize_bindings = function() {
                        return (a.__embind_initialize_bindings = a.asm._embind_initialize_bindings).apply(null, arguments);
                    }, a.___errno_location = function() {
                        return (a.___errno_location = a.asm.__errno_location).apply(null, arguments);
                    };
                    var Ve = a.setTempRet0 = function() {
                        return (Ve = a.setTempRet0 = a.asm.setTempRet0).apply(null, arguments);
                    }, Ne = a.stackSave = function() {
                        return (Ne = a.stackSave = a.asm.stackSave).apply(null, arguments);
                    }, Me = a.stackRestore = function() {
                        return (Me = a.stackRestore = a.asm.stackRestore).apply(null, arguments);
                    }, ke = a.stackAlloc = function() {
                        return (ke = a.stackAlloc = a.asm.stackAlloc).apply(null, arguments);
                    }, Je = a.___cxa_can_catch = function() {
                        return (Je = a.___cxa_can_catch = a.asm.__cxa_can_catch).apply(null, arguments);
                    }, mt = a.___cxa_is_pointer_type = function() {
                        return (mt = a.___cxa_is_pointer_type = a.asm.__cxa_is_pointer_type).apply(null, arguments);
                    };
                    a.dynCall_ji = function() {
                        return (a.dynCall_ji = a.asm.dynCall_ji).apply(null, arguments);
                    }, a.dynCall_iiji = function() {
                        return (a.dynCall_iiji = a.asm.dynCall_iiji).apply(null, arguments);
                    }, a.dynCall_jiji = function() {
                        return (a.dynCall_jiji = a.asm.dynCall_jiji).apply(null, arguments);
                    };
                    function Et(L, V) {
                        var R = Ne();
                        try {
                            return Tn(L)(V);
                        } catch (I) {
                            if (Me(R), I !== I + 0) throw I;
                            _setThrew(1, 0);
                        }
                    }
                    function Rt(L, V) {
                        var R = Ne();
                        try {
                            Tn(L)(V);
                        } catch (I) {
                            if (Me(R), I !== I + 0) throw I;
                            _setThrew(1, 0);
                        }
                    }
                    function U(L, V, R, I, A) {
                        var Y = Ne();
                        try {
                            Tn(L)(V, R, I, A);
                        } catch (te) {
                            if (Me(Y), te !== te + 0) throw te;
                            _setThrew(1, 0);
                        }
                    }
                    function k(L) {
                        var V = Ne();
                        try {
                            Tn(L)();
                        } catch (R) {
                            if (Me(V), R !== R + 0) throw R;
                            _setThrew(1, 0);
                        }
                    }
                    function ee(L, V, R, I) {
                        var A = Ne();
                        try {
                            return Tn(L)(V, R, I);
                        } catch (Y) {
                            if (Me(A), Y !== Y + 0) throw Y;
                            _setThrew(1, 0);
                        }
                    }
                    function ye(L) {
                        var V = Ne();
                        try {
                            return Tn(L)();
                        } catch (R) {
                            if (Me(V), R !== R + 0) throw R;
                            _setThrew(1, 0);
                        }
                    }
                    function _e(L, V, R, I, A, Y, te) {
                        var se = Ne();
                        try {
                            Tn(L)(V, R, I, A, Y, te);
                        } catch (de) {
                            if (Me(se), de !== de + 0) throw de;
                            _setThrew(1, 0);
                        }
                    }
                    function Be(L, V, R) {
                        var I = Ne();
                        try {
                            return Tn(L)(V, R);
                        } catch (A) {
                            if (Me(I), A !== A + 0) throw A;
                            _setThrew(1, 0);
                        }
                    }
                    a.ccall = ks;
                    var Ae;
                    yt = function L() {
                        Ae || be(), Ae || (yt = L);
                    };
                    function be(L) {
                        if (Ct > 0 || (et(), Ct > 0)) return;
                        function V() {
                            Ae || (Ae = !0, a.calledRun = !0, !M && (St(), o(a), a.onRuntimeInitialized && a.onRuntimeInitialized(), Ln()));
                        }
                        a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
                            setTimeout(function() {
                                a.setStatus("");
                            }, 1), V();
                        }, 1)) : V();
                    }
                    if (a.preInit) for(typeof a.preInit == "function" && (a.preInit = [
                        a.preInit
                    ]); a.preInit.length > 0;)a.preInit.pop()();
                    return be(), a.ready;
                };
            })();
            t.exports = n;
        }(nv)), nv.exports;
    }
    var Bie = Fie();
    const Gie = Qa(Bie), Wie = new URL("/assets/openjphjs-C-BUUy4a.wasm", import.meta.url), fd = {
        codec: void 0,
        decoder: void 0,
        decodeConfig: {}
    };
    function $ie(t, e, n) {
        const r = {
            width: e,
            height: n
        };
        for(; t > 0;)r.width = Math.ceil(r.width / 2), r.height = Math.ceil(r.height / 2), t--;
        return r;
    }
    function zie(t) {
        if (fd.decodeConfig = t, fd.codec) return Promise.resolve();
        const e = Gie({
            locateFile: (n)=>n.endsWith(".wasm") ? Wie.toString() : n
        });
        return new Promise((n, r)=>{
            e.then((i)=>{
                fd.codec = i, fd.decoder = new i.HTJ2KDecoder, n();
            }, r);
        });
    }
    async function jie(t, e) {
        await zie();
        const n = new fd.codec.HTJ2KDecoder, r = n.getEncodedBuffer(t.length);
        r.set(t);
        const i = e.decodeLevel || 0;
        n.decodeSubResolution(i);
        const a = n.getFrameInfo();
        if (e.decodeLevel > 0) {
            const { width: F, height: N } = $ie(e.decodeLevel, a.width, a.height);
            a.width = F, a.height = N;
        }
        const o = n.getDecodedBuffer();
        new Uint8Array(o.length).set(o);
        const c = `x: ${n.getImageOffset().x}, y: ${n.getImageOffset().y}`, l = n.getNumDecompositions(), f = n.getNumLayers(), u = [
            "unknown",
            "LRCP",
            "RLCP",
            "RPCL",
            "PCRL",
            "CPRL"
        ][n.getProgressionOrder() + 1], g = n.getIsReversible(), h = `${n.getBlockDimensions().width} x ${n.getBlockDimensions().height}`, v = `${n.getTileSize().width} x ${n.getTileSize().height}`, m = `${n.getTileOffset().x}, ${n.getTileOffset().y}`, y = `${o.length.toLocaleString()} bytes`, C = `${(o.length / r.length).toFixed(2)}:1`, T = {
            columns: a.width,
            rows: a.height,
            bitsPerPixel: a.bitsPerSample,
            signed: a.isSigned,
            bytesPerPixel: e.bytesPerPixel,
            componentsPerPixel: a.componentCount
        };
        let x = Hie(a, o);
        const { buffer: S, byteOffset: D, byteLength: _ } = x, M = S.slice(D, D + _);
        x = new x.constructor(M);
        const P = {
            imageOffset: c,
            numDecompositions: l,
            numLayers: f,
            progessionOrder: u,
            reversible: g,
            blockDimensions: h,
            tileSize: v,
            tileOffset: m,
            decodedSize: y,
            compressionRatio: C
        };
        return {
            ...e,
            pixelData: x,
            imageInfo: T,
            encodeOptions: P,
            ...P,
            ...T
        };
    }
    function Hie(t, e) {
        return t.bitsPerSample > 8 ? t.isSigned ? new Int16Array(e.buffer, e.byteOffset, e.byteLength / 2) : new Uint16Array(e.buffer, e.byteOffset, e.byteLength / 2) : t.isSigned ? new Int8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    }
    function Kie(t, e) {
        const n = t.length, { rescaleSlope: r, rescaleIntercept: i, suvbw: a, doseGridScaling: o } = e;
        if (e.modality === "PT" && typeof a == "number" && !isNaN(a)) for(let s = 0; s < n; s++)t[s] = a * (t[s] * r + i);
        else if (e.modality === "RTDOSE" && typeof o == "number" && !isNaN(o)) for(let s = 0; s < n; s++)t[s] = t[s] * o;
        else for(let s = 0; s < n; s++)t[s] = t[s] * r + i;
        return !0;
    }
    const qie = {
        bilinear: cie,
        replicate: lie
    }, M7 = {
        Uint8Array,
        Uint16Array,
        Int16Array,
        Float32Array,
        Uint32Array
    };
    function Xie(t, e, n, r) {
        const i = t.pixelRepresentation !== void 0 && t.pixelRepresentation === 1, a = i && t.bitsStored !== void 0 ? 32 - t.bitsStored : void 0;
        if (i && a !== void 0) for(let T = 0; T < t.pixelData.length; T++)t.pixelData[T] = t.pixelData[T] << a >> a;
        let o = t.pixelData;
        t.pixelDataLength = t.pixelData.length;
        const { min: s, max: c } = x2(t.pixelData), l = typeof e.allowFloatRendering < "u" ? e.allowFloatRendering : !0;
        let f = Oy(t.photometricInterpretation) && e.targetBuffer?.offset === void 0;
        const g = e.preScale?.enabled && Object.values(e.preScale.scalingParameters).some((T)=>typeof T == "number" && !Number.isInteger(T)), h = !e.preScale.enabled || !l && g, v = e.targetBuffer?.type;
        if (v && e.preScale.enabled && !h) {
            const T = e.preScale.scalingParameters, x = c3(s, c, T);
            f = !Ere(x.min, x.max, M7[v]);
        }
        v && !f ? o = Zie(e, t, M7, o) : e.preScale.enabled && !h ? o = Jie(e, s, c, t) : o = wI(s, c, t);
        let m = s, y = c;
        if (e.preScale.enabled && !h) {
            const T = e.preScale.scalingParameters;
            if (TI(T), Yie(T)) {
                Kie(o, T), t.preScale = {
                    ...e.preScale,
                    scaled: !0
                };
                const S = c3(s, c, T);
                m = S.min, y = S.max;
            }
        } else h && (t.preScale = {
            enabled: !0,
            scaled: !1
        }, m = s, y = c);
        t.pixelData = o, t.smallestPixelValue = m, t.largestPixelValue = y;
        const C = new Date().getTime();
        return t.decodeTimeInMS = C - n, t;
    }
    function Yie(t) {
        const { rescaleSlope: e, rescaleIntercept: n, modality: r, doseGridScaling: i, suvbw: a } = t;
        return typeof e == "number" && typeof n == "number" || r === "RTDOSE" && typeof i == "number" || r === "PT" && typeof a == "number";
    }
    function Zie(t, e, n, r) {
        const { arrayBuffer: i, type: a, offset: o = 0, length: s, rows: c } = t.targetBuffer, l = n[a];
        if (!l) throw new Error(`target array ${a} is not supported, or doesn't exist.`);
        c && c != e.rows && eae(e, t.targetBuffer, l);
        const f = e.pixelDataLength, u = o, g = s ?? f - u, h = e.pixelData;
        if (g !== h.length) throw new Error(`target array for image does not have the same length (${g}) as the decoded image length (${h.length}).`);
        const v = i ? new l(i, u, g) : new l(g);
        return v.set(h, 0), r = v, r;
    }
    function Jie(t, e, n, r) {
        const i = t.preScale.scalingParameters;
        TI(i);
        const a = c3(e, n, i);
        return wI(a.min, a.max, r);
    }
    function wI(t, e, n) {
        const r = Iy(t, e), i = new r(n.pixelData.length);
        return i.set(n.pixelData, 0), i;
    }
    function c3(t, e, n) {
        const { rescaleSlope: r, rescaleIntercept: i, modality: a, doseGridScaling: o, suvbw: s } = n;
        return a === "PT" && typeof s == "number" && !isNaN(s) ? {
            min: s * (t * r + i),
            max: s * (e * r + i)
        } : a === "RTDOSE" && typeof o == "number" && !isNaN(o) ? {
            min: t * o,
            max: e * o
        } : typeof r == "number" && typeof i == "number" ? {
            min: r * t + i,
            max: r * e + i
        } : {
            min: t,
            max: e
        };
    }
    function TI(t) {
        if (!t) throw new Error("options.preScale.scalingParameters must be defined if preScale.enabled is true, and scalingParameters cannot be derived from the metadata providers.");
    }
    function Qie(t, e, n) {
        const { samplesPerPixel: r } = t, { rows: i, columns: a } = e, o = i * a * r, s = new n(o), c = s.byteLength / o;
        return {
            pixelData: s,
            rows: i,
            columns: a,
            frameInfo: {
                ...t.frameInfo,
                rows: i,
                columns: a
            },
            imageInfo: {
                ...t.imageInfo,
                rows: i,
                columns: a,
                bytesPerPixel: c
            }
        };
    }
    function eae(t, e, n) {
        const r = Qie(t, e, n), { scalingType: i = "replicate" } = e;
        return qie[i](t, r), Object.assign(t, r), t.pixelDataLength = t.pixelData.length, t;
    }
    async function xI(t, e, n, r, i, a) {
        const o = new Date().getTime();
        let s = null, c;
        switch(e){
            case "1.2.840.10008.1.2":
            case "1.2.840.10008.1.2.1":
                s = x7(t, n);
                break;
            case "1.2.840.10008.1.2.2":
                s = fie(t, n);
                break;
            case "1.2.840.10008.1.2.1.99":
                s = x7(t, n);
                break;
            case "1.2.840.10008.1.2.5":
                s = die(t, n);
                break;
            case "1.2.840.10008.1.2.4.50":
                c = {
                    ...t
                }, s = Tie(n, c);
                break;
            case "1.2.840.10008.1.2.4.51":
                s = Eie(t, n);
                break;
            case "1.2.840.10008.1.2.4.57":
                s = E7(t, n);
                break;
            case "1.2.840.10008.1.2.4.70":
                s = E7(t, n);
                break;
            case "1.2.840.10008.1.2.4.80":
                c = {
                    signed: t.pixelRepresentation === 1,
                    bytesPerPixel: t.bitsAllocated <= 8 ? 1 : 2,
                    ...t
                }, s = _7(n, c);
                break;
            case "1.2.840.10008.1.2.4.81":
                c = {
                    signed: t.pixelRepresentation === 1,
                    bytesPerPixel: t.bitsAllocated <= 8 ? 1 : 2,
                    ...t
                }, s = _7(n, c);
                break;
            case "1.2.840.10008.1.2.4.90":
                c = {
                    ...t
                }, s = O7(n, c);
                break;
            case "1.2.840.10008.1.2.4.91":
                c = {
                    ...t
                }, s = O7(n, c);
                break;
            case "3.2.840.10008.1.2.4.96":
            case "1.2.840.10008.1.2.4.201":
            case "1.2.840.10008.1.2.4.202":
            case "1.2.840.10008.1.2.4.203":
                c = {
                    ...t
                }, s = jie(n, c);
                break;
            default:
                throw new Error(`no decoder for transfer syntax ${e}`);
        }
        if (!s) throw new Error("decodePromise not defined");
        const l = await s, f = Xie(l, i, o);
        return a?.(f), f;
    }
    const tae = {
        decodeTask ({ imageFrame: t, transferSyntax: e, decodeConfig: n, options: r, pixelData: i, callbackFn: a }) {
            return xI(t, e, i, n, r, a);
        }
    };
    f3(tae);
    const Qf = {
        constants: sie,
        convertRGBColorByPixel: kO,
        convertRGBColorByPlane: UO,
        convertYBRFullByPixel: FO,
        convertYBRFullByPlane: BO,
        convertPALETTECOLOR: GO,
        wadouri: Ire,
        wadors: eie,
        init: rie,
        convertColorSpace: oI,
        createImage: S2,
        decodeJPEGBaseline8BitColor: sI,
        getImageFrame: cI,
        getPixelData: Py,
        getMinMax: x2,
        isColorImage: Oy,
        isJPEGBaseline8BitColor: aie,
        internal: zne,
        decodeImageFrame: xI
    };
    let Gd = !1, Au = null;
    async function SI() {
        return Gd ? (st.log("Cornerstone3D 이미 초기화됨 - 건너뜀"), !0) : Au ? (st.log("Cornerstone3D 초기화 진행 중 - 대기"), Au) : (Au = nae(), Au);
    }
    async function nae() {
        try {
            st.log("🚀 Cornerstone3D 전역 초기화 시작"), st.time("전역 초기화"), st.log("📦 Cornerstone3D Core 초기화..."), await Cb(), st.success("✅ Cornerstone3D Core 초기화 완료"), st.log("🔧 Cornerstone3D Tools 초기화..."), await Qte(), st.success("✅ Cornerstone3D Tools 초기화 완료"), st.log("🖼️ DICOM Image Loader 설정..."), Qf.external.cornerstone = await y2(()=>import("./index-DGyS4qEw.js"), []), Qf.external.dicomParser = zO;
            const t = "/cornerstone-dicom-image-loader/cornerstoneDICOMImageLoaderWebWorker.min.js";
            st.log("🔧 웹 워커 경로 설정", {
                webWorkerPath: t,
                isDev: !1
            });
            try {
                Qf.webWorkerManager.initialize({
                    maxWebWorkers: navigator.hardwareConcurrency || 1,
                    startWebWorkersOnDemand: !0,
                    taskConfiguration: {
                        decodeTask: {
                            initializeCodecsInWorker: !0,
                            usePDFJS: !1,
                            strict: !1
                        }
                    },
                    webWorkerPath: t
                }), st.success("✅ 웹 워커 매니저 초기화 완료");
            } catch (n) {
                st.warn("⚠️ 웹 워커 초기화 실패, 메인 스레드 사용", n);
            }
            L0("wadouri", Qf.wadouri.loadImage), L0("wadors", Qf.wadors.loadImage), st.success("✅ DICOM Image Loader 및 웹 워커 설정 완료"), st.log("🛠️ 도구 등록 시작...");
            const e = [
                {
                    tool: vy,
                    name: "Pan"
                },
                {
                    tool: wy,
                    name: "Zoom"
                },
                {
                    tool: yy,
                    name: "WindowLevel"
                },
                {
                    tool: Cy,
                    name: "StackScroll"
                },
                {
                    tool: Ty,
                    name: "Magnify"
                },
                {
                    tool: d2,
                    name: "Length"
                },
                {
                    tool: v2,
                    name: "Angle"
                },
                {
                    tool: AO,
                    name: "CobbAngle"
                },
                {
                    tool: f2,
                    name: "Bidirectional"
                },
                {
                    tool: u2,
                    name: "RectangleROI"
                },
                {
                    tool: g2,
                    name: "EllipticalROI"
                },
                {
                    tool: h2,
                    name: "CircleROI"
                },
                {
                    tool: hy,
                    name: "PlanarFreehandROI"
                },
                {
                    tool: p2,
                    name: "SplineROI"
                },
                {
                    tool: m2,
                    name: "ArrowAnnotate"
                },
                {
                    tool: Bd,
                    name: "Probe"
                }
            ];
            for (const { tool: n, name: r } of e)try {
                N_(n), st.success(`✅ ${r} 도구 등록 완료`);
            } catch (i) {
                if (i instanceof Error && i.message.includes("already been added")) st.warn(`⚠️ ${r} 도구 이미 등록됨 - 건너뜀`);
                else throw st.error(`❌ ${r} 도구 등록 실패`, i), i;
            }
            return st.success("✅ 모든 도구 등록 완료"), st.timeEnd("전역 초기화"), st.logMemoryUsage(), Gd = !0, st.success("🎉 Cornerstone3D 전역 초기화 최종 완료"), !0;
        } catch (t) {
            throw st.timeEnd("전역 초기화"), st.error("❌ Cornerstone3D 전역 초기화 실패", t), Gd = !1, Au = null, t;
        }
    }
    function rae() {
        return Gd;
    }
    function iae() {
        Gd = !1, Au = null, st.warn("🔄 Cornerstone3D 초기화 상태 리셋됨");
    }
    typeof window < "u" && (window.cornerstoneGlobalInit = {
        isInitialized: rae,
        reset: iae,
        initialize: SI
    });
    const aae = {}, b7 = (t)=>{
        let e;
        const n = new Set, r = (f, u)=>{
            const g = typeof f == "function" ? f(e) : f;
            if (!Object.is(g, e)) {
                const h = e;
                e = u ?? (typeof g != "object" || g === null) ? g : Object.assign({}, e, g), n.forEach((v)=>v(e, h));
            }
        }, i = ()=>e, c = {
            setState: r,
            getState: i,
            getInitialState: ()=>l,
            subscribe: (f)=>(n.add(f), ()=>n.delete(f)),
            destroy: ()=>{
                (aae ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), n.clear();
            }
        }, l = e = t(r, i, c);
        return c;
    }, oae = (t)=>t ? b7(t) : b7;
    var rv = {
        exports: {}
    }, iv = {}, av = {
        exports: {}
    }, ov = {};
    var L7;
    function sae() {
        if (L7) return ov;
        L7 = 1;
        var t = Wd();
        function e(u, g) {
            return u === g && (u !== 0 || 1 / u === 1 / g) || u !== u && g !== g;
        }
        var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, i = t.useEffect, a = t.useLayoutEffect, o = t.useDebugValue;
        function s(u, g) {
            var h = g(), v = r({
                inst: {
                    value: h,
                    getSnapshot: g
                }
            }), m = v[0].inst, y = v[1];
            return a(function() {
                m.value = h, m.getSnapshot = g, c(m) && y({
                    inst: m
                });
            }, [
                u,
                h,
                g
            ]), i(function() {
                return c(m) && y({
                    inst: m
                }), u(function() {
                    c(m) && y({
                        inst: m
                    });
                });
            }, [
                u
            ]), o(h), h;
        }
        function c(u) {
            var g = u.getSnapshot;
            u = u.value;
            try {
                var h = g();
                return !n(u, h);
            } catch  {
                return !0;
            }
        }
        function l(u, g) {
            return g();
        }
        var f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : s;
        return ov.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : f, ov;
    }
    var P7;
    function cae() {
        return P7 || (P7 = 1, av.exports = sae()), av.exports;
    }
    var V7;
    function lae() {
        if (V7) return iv;
        V7 = 1;
        var t = Wd(), e = cae();
        function n(l, f) {
            return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
        }
        var r = typeof Object.is == "function" ? Object.is : n, i = e.useSyncExternalStore, a = t.useRef, o = t.useEffect, s = t.useMemo, c = t.useDebugValue;
        return iv.useSyncExternalStoreWithSelector = function(l, f, u, g, h) {
            var v = a(null);
            if (v.current === null) {
                var m = {
                    hasValue: !1,
                    value: null
                };
                v.current = m;
            } else m = v.current;
            v = s(function() {
                function C(_) {
                    if (!T) {
                        if (T = !0, x = _, _ = g(_), h !== void 0 && m.hasValue) {
                            var M = m.value;
                            if (h(M, _)) return S = M;
                        }
                        return S = _;
                    }
                    if (M = S, r(x, _)) return M;
                    var P = g(_);
                    return h !== void 0 && h(M, P) ? (x = _, M) : (x = _, S = P);
                }
                var T = !1, x, S, D = u === void 0 ? null : u;
                return [
                    function() {
                        return C(f());
                    },
                    D === null ? void 0 : function() {
                        return C(D());
                    }
                ];
            }, [
                f,
                u,
                g,
                h
            ]);
            var y = i(l, v[0], v[1]);
            return o(function() {
                m.hasValue = !0, m.value = y;
            }, [
                y
            ]), c(y), y;
        }, iv;
    }
    var N7;
    function uae() {
        return N7 || (N7 = 1, rv.exports = lae()), rv.exports;
    }
    var fae = uae();
    const dae = Qa(fae), EI = {}, { useDebugValue: gae } = Rh, { useSyncExternalStoreWithSelector: hae } = dae;
    let A7 = !1;
    const pae = (t)=>t;
    function mae(t, e = pae, n) {
        (EI ? "production" : void 0) !== "production" && n && !A7 && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), A7 = !0);
        const r = hae(t.subscribe, t.getState, t.getServerState || t.getInitialState, e, n);
        return gae(r), r;
    }
    const vae = (t)=>{
        (EI ? "production" : void 0) !== "production" && typeof t != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
        const e = typeof t == "function" ? oae(t) : t, n = (r, i)=>mae(e, r, i);
        return Object.assign(n, e), n;
    }, yae = (t)=>vae, Cae = (t)=>(e, n, r)=>{
            const i = r.subscribe;
            return r.subscribe = (o, s, c)=>{
                let l = o;
                if (s) {
                    const f = c?.equalityFn || Object.is;
                    let u = o(r.getState());
                    l = (g)=>{
                        const h = o(g);
                        if (!f(u, h)) {
                            const v = u;
                            s(u = h, v);
                        }
                    }, c?.fireImmediately && s(u, u);
                }
                return i(l);
            }, t(e, n, r);
        }, wae = Cae;
    var Wi = [];
    for(var sv = 0; sv < 256; ++sv)Wi.push((sv + 256).toString(16).slice(1));
    function Tae(t, e = 0) {
        return (Wi[t[e + 0]] + Wi[t[e + 1]] + Wi[t[e + 2]] + Wi[t[e + 3]] + "-" + Wi[t[e + 4]] + Wi[t[e + 5]] + "-" + Wi[t[e + 6]] + Wi[t[e + 7]] + "-" + Wi[t[e + 8]] + Wi[t[e + 9]] + "-" + Wi[t[e + 10]] + Wi[t[e + 11]] + Wi[t[e + 12]] + Wi[t[e + 13]] + Wi[t[e + 14]] + Wi[t[e + 15]]).toLowerCase();
    }
    var j1, xae = new Uint8Array(16);
    function Sae() {
        if (!j1 && (j1 = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !j1)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return j1(xae);
    }
    var Eae = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    const k7 = {
        randomUUID: Eae
    };
    function Dae(t, e, n) {
        if (k7.randomUUID && !t) return k7.randomUUID();
        t = t || {};
        var r = t.random || (t.rng || Sae)();
        return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Tae(r);
    }
    const _ae = [
        {
            name: "Abdomen",
            windowCenter: 60,
            windowWidth: 400
        },
        {
            name: "Bone",
            windowCenter: 400,
            windowWidth: 1e3
        },
        {
            name: "Brain",
            windowCenter: 40,
            windowWidth: 80
        },
        {
            name: "Chest",
            windowCenter: -600,
            windowWidth: 1600
        },
        {
            name: "Lung",
            windowCenter: -600,
            windowWidth: 1600
        },
        {
            name: "Mediastinum",
            windowCenter: 50,
            windowWidth: 350
        }
    ], ku = yae()(wae((t, e)=>({
            viewports: new Map,
            activeViewportId: null,
            layoutType: "1x1",
            viewportConfigs: new Map,
            loadedSeries: [],
            currentSeries: null,
            currentImageIndex: 0,
            activeTool: null,
            toolGroups: new Map,
            annotations: [],
            selectedAnnotationUID: null,
            windowLevelPresets: _ae,
            currentWindowLevel: null,
            isLoading: !1,
            error: null,
            sidebarOpen: !0,
            currentRotation: 0,
            isFlippedHorizontal: !1,
            isFlippedVertical: !1,
            currentDicomDataSet: null,
            isLicenseModalOpen: !1,
            setActiveViewport: (n)=>{
                t({
                    activeViewportId: n
                });
            },
            setLayout: (n)=>{
                t({
                    layoutType: n
                });
            },
            loadSeries: (n)=>{
                console.log("🔄 새로운 시리즈 로드 시작 - 상태 초기화 중..."), t({
                    isLoading: !0,
                    error: null,
                    annotations: [],
                    currentSeries: null,
                    selectedAnnotationUID: null,
                    currentImageIndex: 0,
                    currentRotation: 0,
                    isFlippedHorizontal: !1,
                    isFlippedVertical: !1,
                    currentDicomDataSet: null
                }), t((r)=>{
                    const i = r.loadedSeries.findIndex((o)=>o.seriesInstanceUID === n.seriesInstanceUID);
                    let a;
                    return i >= 0 ? (a = [
                        ...r.loadedSeries
                    ], a[i] = n, console.log(`📁 기존 시리즈 업데이트: ${n.seriesInstanceUID}`)) : (a = [
                        ...r.loadedSeries,
                        n
                    ], console.log(`📁 새로운 시리즈 추가: ${n.seriesInstanceUID}`)), console.log("✅ 시리즈 로드 완료 - 로딩 상태 해제"), {
                        loadedSeries: a,
                        currentSeries: n,
                        currentImageIndex: 0,
                        isLoading: !1,
                        error: null
                    };
                });
            },
            setActiveTool: (n)=>{
                e().activeTool !== n && (console.log(`Activating tool: ${n}`), t({
                    activeTool: n
                }));
            },
            activateToolInViewport: (n, r)=>{
                if (!r?.current) return console.warn("No tool group available for tool activation"), !1;
                try {
                    console.log(`🔧 도구 활성화 시작: ${n}`);
                    const i = [
                        "Length",
                        "Angle",
                        "CobbAngle",
                        "Bidirectional",
                        "RectangleROI",
                        "EllipticalROI",
                        "CircleROI",
                        "PlanarFreehandROI",
                        "SplineROI",
                        "ArrowAnnotate",
                        "Probe"
                    ], a = [
                        "Pan",
                        "Zoom",
                        "WindowLevel",
                        "StackScroll",
                        "Magnify"
                    ];
                    if (console.log("📋 도구 카테고리 확인:", {
                        toolName: n,
                        isAnnotationTool: i.includes(n),
                        isBasicTool: a.includes(n)
                    }), [
                        ...i,
                        ...a
                    ].forEach((s)=>{
                        try {
                            r.current.setToolPassive(s);
                        } catch (c) {
                            console.warn(`Failed to set ${s} passive:`, c);
                        }
                    }), i.includes(n) || a.includes(n)) r.current.setToolActive(n, {
                        bindings: [
                            {
                                mouseButton: 1
                            }
                        ]
                    }), console.log(`✅ 도구 활성화: ${n} (왼쪽 버튼에 바인딩)`);
                    else return console.warn(`Unknown tool: ${n}`), !1;
                    return t({
                        activeTool: n
                    }), console.log("🎯 도구 활성화 완료! 현재 상태:", {
                        selectedTool: n,
                        mouseButton: 1,
                        message: `마우스 왼쪽 버튼으로 ${n} 도구를 사용할 수 있습니다.`
                    }), !0;
                } catch (i) {
                    return console.error(`Failed to activate tool ${n}:`, i), !1;
                }
            },
            addAnnotation: (n)=>{
                const r = {
                    ...n,
                    annotationUID: n.annotationUID || Dae()
                };
                t((i)=>({
                        annotations: [
                            ...i.annotations,
                            r
                        ],
                        selectedAnnotationUID: r.annotationUID
                    })), console.log(`📝 새 주석 추가: ${r.annotationUID}`);
            },
            updateAnnotation: (n, r)=>{
                if (typeof n != "string" || !n) {
                    console.error("Invalid annotationUID provided for update");
                    return;
                }
                t((i)=>({
                        annotations: i.annotations.map((a)=>a.annotationUID === n ? {
                                ...a,
                                ...r
                            } : a)
                    })), console.log(`Updated annotation: ${n}`);
            },
            updateAnnotationLabel: (n, r)=>{
                if (typeof n != "string" || !n) {
                    console.error("Invalid annotationUID provided for label update");
                    return;
                }
                if (typeof r != "string") {
                    console.error("Invalid label provided for annotation update");
                    return;
                }
                console.log(`📝 주석 라벨 업데이트: ${n} -> "${r}"`), t((i)=>({
                        annotations: i.annotations.map((a)=>a.annotationUID === n ? {
                                ...a,
                                data: {
                                    ...a.data,
                                    label: r,
                                    text: r
                                }
                            } : a)
                    })), console.log(`✅ 주석 라벨 업데이트 완료: ${n}`);
            },
            removeAnnotation: (n)=>{
                if (typeof n != "string" || !n) {
                    console.error("Invalid annotationUID provided for removal");
                    return;
                }
                console.log(`🗑️ 주석 삭제 시작: ${n}`);
                try {
                    Xl.removeAnnotation(n), console.log(`✅ Cornerstone에서 주석 제거 완료: ${n}`);
                    const r = window.cornerstoneRenderingEngine;
                    if (r) try {
                        const i = r.getViewport("dicom-viewport");
                        i && (i.render(), console.log("✅ 뷰포트 새로고침 완료"));
                    } catch (i) {
                        console.warn("뷰포트 새로고침 실패:", i);
                    }
                } catch (r) {
                    console.error("Cornerstone 주석 제거 실패:", r);
                }
                t((r)=>({
                        annotations: r.annotations.filter((i)=>i.annotationUID !== n),
                        selectedAnnotationUID: r.selectedAnnotationUID === n ? null : r.selectedAnnotationUID
                    })), console.log(`✅ 스토어에서 주석 제거 완료: ${n}`);
            },
            setWindowLevel: (n)=>{
                t({
                    currentWindowLevel: n
                }), console.log(`Window level set: C${n.windowCenter} W${n.windowWidth}`);
            },
            setLoading: (n)=>{
                t({
                    isLoading: n
                });
            },
            setError: (n)=>{
                t({
                    error: n,
                    isLoading: !1
                }), n && console.error("DICOM Viewer Error:", n);
            },
            toggleSidebar: ()=>{
                t((n)=>({
                        sidebarOpen: !n.sidebarOpen
                    }));
            },
            clearAllAnnotations: ()=>{
                const n = e().annotations;
                console.log(`🗑️ 모든 주석 지우기 시작: ${n.length}개`);
                try {
                    n.forEach((i)=>{
                        try {
                            Xl.removeAnnotation(i.annotationUID), console.log(`✅ Cornerstone에서 주석 제거: ${i.annotationUID}`);
                        } catch (a) {
                            console.error(`❌ 주석 제거 실패: ${i.annotationUID}`, a);
                        }
                    });
                    const r = window.cornerstoneRenderingEngine;
                    if (r) try {
                        const i = r.getViewport("dicom-viewport");
                        i && (i.render(), console.log("✅ 뷰포트 새로고침 완료"));
                    } catch (i) {
                        console.warn("뷰포트 새로고침 실패:", i);
                    }
                } catch (r) {
                    console.error("Cornerstone 주석 제거 실패:", r);
                }
                t({
                    annotations: [],
                    selectedAnnotationUID: null
                }), console.log("✅ 모든 주석 지우기 완료");
            },
            rotateImage: (n)=>{
                const { currentRotation: r } = e(), a = (r + (n === "right" ? 90 : -90)) % 360;
                t({
                    currentRotation: a
                });
                try {
                    const o = window.cornerstoneRenderingEngine;
                    if (o) {
                        const s = o.getViewport("dicom-viewport");
                        s && (s.setRotation(a), o.render(), console.log(`🔄 이미지 회전: ${n} (${a}도)`));
                    }
                } catch (o) {
                    console.error("이미지 회전 실패:", o);
                }
            },
            flipImage: (n)=>{
                const r = e(), i = n === "horizontal", a = {
                    isFlippedHorizontal: i ? !r.isFlippedHorizontal : r.isFlippedHorizontal,
                    isFlippedVertical: i ? r.isFlippedVertical : !r.isFlippedVertical
                };
                t(a);
                try {
                    const o = window.cornerstoneRenderingEngine;
                    if (o) {
                        const s = o.getViewport("dicom-viewport");
                        s ? (i ? (s.flip({
                            flipHorizontal: !0
                        }), console.log("🔄 수평 뒤집기 실행")) : (s.flip({
                            flipVertical: !0
                        }), console.log("🔄 수직 뒤집기 실행")), o.render(), console.log(`✅ 이미지 뒤집기 성공: ${n} (H:${a.isFlippedHorizontal}, V:${a.isFlippedVertical})`)) : console.error("❌ 뷰포트를 찾을 수 없습니다");
                    } else console.error("❌ 렌더링 엔진을 찾을 수 없습니다");
                } catch (o) {
                    console.error("❌ 이미지 뒤집기 실패:", o), t({
                        isFlippedHorizontal: r.isFlippedHorizontal,
                        isFlippedVertical: r.isFlippedVertical
                    });
                }
            },
            resetImageTransform: ()=>{
                const n = e();
                t({
                    currentRotation: 0,
                    isFlippedHorizontal: !1,
                    isFlippedVertical: !1
                });
                try {
                    const r = window.cornerstoneRenderingEngine;
                    if (r) {
                        const i = r.getViewport("dicom-viewport");
                        i && (i.setRotation(0), n.isFlippedHorizontal && (i.flip({
                            flipHorizontal: !0
                        }), console.log("🔄 수평 뒤집기 리셋")), n.isFlippedVertical && (i.flip({
                            flipVertical: !0
                        }), console.log("🔄 수직 뒤집기 리셋")), r.render(), console.log("✅ 이미지 변환 리셋 완료"));
                    }
                } catch (r) {
                    console.error("❌ 이미지 변환 리셋 실패:", r), t({
                        currentRotation: n.currentRotation,
                        isFlippedHorizontal: n.isFlippedHorizontal,
                        isFlippedVertical: n.isFlippedVertical
                    });
                }
            },
            setDicomDataSet: (n)=>{
                t({
                    currentDicomDataSet: n
                }), console.log("💾 DICOM 데이터셋 저장 완료");
            },
            toggleLicenseModal: ()=>{
                t((n)=>({
                        isLicenseModalOpen: !n.isLicenseModalOpen
                    }));
            },
            captureViewportAsPng: async ()=>{
                const n = "dicom-viewport";
                st.log("📸 뷰포트 캡처 시작...");
                try {
                    const { viewport: r, viewportElement: i } = await e().prepareViewportForCapture(n), a = await e().captureWithHTML2Canvas(i);
                    await e().downloadCanvasAsFile(a), st.success("✅ 주석이 포함된 화면 캡처가 완료되었습니다.");
                } catch (r) {
                    console.error("❌ 고해상도 캡처 실패, 기본 방법 시도:", r), await e().fallbackCapture(n);
                }
            },
            prepareViewportForCapture: async (n)=>{
                const r = ws("dicom-rendering-engine");
                if (!r) throw new Error("렌더링 엔진을 찾을 수 없습니다.");
                const i = r.getViewport(n);
                if (!i) throw new Error(`뷰포트(${n})를 찾을 수 없습니다.`);
                await i.render(), await new Promise((o)=>setTimeout(o, 200));
                const a = i.element || document.querySelector(`[data-viewport-uid="${n}"]`) || document.querySelector(".viewport-element") || document.querySelector(".cornerstone-viewport");
                if (!a) throw new Error("뷰포트 DOM 요소를 찾을 수 없습니다.");
                return {
                    viewport: i,
                    viewportElement: a
                };
            },
            captureWithHTML2Canvas: async (n)=>{
                console.log("📦 HTML2Canvas 라이브러리 로딩...");
                const r = await y2(()=>import("https://cdn.skypack.dev/html2canvas@1.4.1").then(async (m)=>{
                        await m.__tla;
                        return m;
                    }), []), i = window.devicePixelRatio || 1, a = Math.max(i, 2);
                console.log(`🎨 고해상도 캡처 시작 (scale: ${a})...`);
                const o = await r.default(n, {
                    backgroundColor: "#000000",
                    useCORS: !0,
                    allowTaint: !0,
                    scale: a,
                    width: n.offsetWidth,
                    height: n.offsetHeight,
                    logging: !1,
                    removeContainer: !0,
                    imageTimeout: 0,
                    ignoreElements: (s)=>s.classList.contains("cornerstone-canvas-background")
                });
                return console.log(`✅ 캡처 완료: ${o.width}x${o.height}`), o;
            },
            downloadCanvasAsFile: async (n)=>new Promise((r, i)=>{
                    n.toBlob((a)=>{
                        if (!a) {
                            i(new Error("Blob 생성 실패"));
                            return;
                        }
                        const o = URL.createObjectURL(a), c = `Clarity-Capture_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, "").replace("T", "_")}.png`, l = document.createElement("a");
                        l.href = o, l.download = c, document.body.appendChild(l), l.click(), document.body.removeChild(l), URL.revokeObjectURL(o), console.log(`✅ 파일 저장 완료: ${c}`), r();
                    }, "image/png", 1);
                }),
            fallbackCapture: async (n)=>{
                try {
                    const a = ws("dicom-rendering-engine").getViewport(n).getCanvas();
                    await e().downloadCanvasAsFile(a), st.success("이미지만 캡처 완료 (주석 제외)");
                } catch (r) {
                    console.error("❌ 폴백 방법도 실패:", r), st.error("❌ 화면 캡처에 완전히 실패했습니다."), alert("화면을 캡처하는 데 실패했습니다.");
                }
            }
        }))), Rae = ({ onError: t, onSuccess: e })=>{
        const n = _n.useRef(null), r = _n.useRef(null), i = _n.useRef(null), a = _n.useRef(!1), { activeTool: o, activateToolInViewport: s, addAnnotation: c, updateAnnotation: l, removeAnnotation: f, currentDicomDataSet: u } = ku((v)=>({
                activeTool: v.activeTool,
                activateToolInViewport: v.activateToolInViewport,
                addAnnotation: v.addAnnotation,
                updateAnnotation: v.updateAnnotation,
                removeAnnotation: v.removeAnnotation,
                currentDicomDataSet: v.currentDicomDataSet
            })), g = (v)=>{
            try {
                if (!v.data?.cachedStats) {
                    console.log("⚠️ cachedStats 없음");
                    return;
                }
                const m = v.data.cachedStats;
                console.log("🔍 stats:", m);
                const y = Object.keys(m)[0];
                console.log("🔍 imageId:", y);
                const C = m[y];
                if (console.log("🔍 measurementData:", C), console.log("🔍 measurementData의 모든 속성:", Object.keys(C || {})), console.log("🔍 measurementData.length:", C?.length), console.log("🔍 measurementData.area:", C?.area), console.log("🔍 measurementData.angle:", C?.angle), console.log("🔍 measurementData.unit:", C?.unit), u) {
                    const x = u.string("x00280030");
                    console.log("🔍 DICOM PixelSpacing:", x), console.log("🔍 DICOM 파일 메타데이터:", {
                        pixelSpacing: x,
                        hasPixelSpacing: !!x
                    });
                }
                let T = null;
                if (C?.length !== void 0 && C.length > 0) T = `${C.length.toFixed(1)} mm`, console.log(`📏 길이 변환: ${C.length} → ${T}`);
                else if (C?.area !== void 0 && C.area > 0) T = `${C.area.toFixed(1)} mm²`, console.log(`📐 면적 변환: ${C.area} → ${T}`);
                else {
                    console.log("⚠️ 지원되는 측정 데이터 없음");
                    return;
                }
                if (console.log("🔧 변환 전 annotation.data:", JSON.stringify(v.data, null, 2)), v.data.text = T, v.data.handles?.textBox && (v.data.handles.textBox.text = T, console.log("✅ textBox에도 설정 완료")), v.data.handles && (v.data.handles.text = T), v.data.cachedStats) {
                    const x = Object.keys(v.data.cachedStats)[0];
                    v.data.cachedStats[x] && (v.data.cachedStats[x].text = T);
                }
                console.log("🔧 변환 후 annotation.data:", JSON.stringify(v.data, null, 2)), console.log("✅ 최종 annotation.data.text:", v.data.text);
            } catch (m) {
                console.log("⚠️ mm 변환 실패:", m);
            }
        }, h = (v)=>{
            if (!v) return;
            st.log(`뷰포트에서 도구 활성화 요청: ${v}`), s(v, i) ? st.success(`✅ 뷰포트 도구 활성화 성공: ${v}`) : st.error(`❌ 뷰포트 도구 활성화 실패: ${v}`);
        };
        return _n.useEffect(()=>{
            (async ()=>{
                if (!(a.current || !n.current)) try {
                    st.log("🏗️ 뷰포트 초기화 시작 (한 번만 실행)"), await SI();
                    const m = "dicom-rendering-engine", y = "dicom-viewport", C = "dicom-tool-group";
                    if (r.current) try {
                        r.current.destroy();
                    } catch (M) {
                        console.warn("기존 렌더링 엔진 정리 중 오류:", M);
                    }
                    let T = ws(m);
                    T || (T = new LK(m)), r.current = T;
                    const x = {
                        viewportId: y,
                        type: On.STACK,
                        element: n.current,
                        defaultOptions: {
                            background: [
                                0,
                                0,
                                0
                            ]
                        }
                    };
                    T.enableElement(x), st.success("✅ 뷰포트 활성화 완료");
                    let S = $4(C);
                    if (S && YC(C), S = gX(C), !S) throw new Error("도구 그룹 생성 실패");
                    [
                        yy.toolName,
                        vy.toolName,
                        wy.toolName,
                        Cy.toolName,
                        Ty.toolName,
                        d2.toolName,
                        v2.toolName,
                        AO.toolName,
                        f2.toolName,
                        u2.toolName,
                        g2.toolName,
                        h2.toolName,
                        hy.toolName,
                        p2.toolName,
                        m2.toolName,
                        Bd.toolName
                    ].forEach((M)=>{
                        S.addTool(M);
                    }), [
                        "WindowLevel",
                        "Pan",
                        "Zoom",
                        "StackScroll",
                        "Magnify",
                        "Length",
                        "Angle",
                        "CobbAngle",
                        "Bidirectional",
                        "RectangleROI",
                        "EllipticalROI",
                        "CircleROI",
                        "PlanarFreehandROI",
                        "SplineROI",
                        "ArrowAnnotate",
                        "Probe"
                    ].forEach((M)=>{
                        S.setToolPassive(M);
                    }), S.addViewport(y, m), i.current = S, st.success("✅ 뷰포트 초기화 완료"), a.current = !0, e("뷰포트 초기화 완료"), o && h(o);
                } catch (m) {
                    st.error("❌ 뷰포트 초기화 실패", m), t(`뷰포트 초기화 실패: ${m instanceof Error ? m.message : String(m)}`);
                }
            })();
        }, []), _n.useEffect(()=>{
            o && i.current && a.current && h(o);
        }, [
            o,
            s
        ]), _n.useEffect(()=>{
            if (!a.current) return;
            st.log("🎯 CornerstoneJS 표준 주석 이벤트 리스너 설정 시작");
            const v = (S)=>{
                console.log("🎉 [ANNOTATION_COMPLETED] 이벤트 수신!", S.detail), st.log("🎉 ANNOTATION_COMPLETED 이벤트 수신", S.detail);
                try {
                    const D = S.detail?.annotation;
                    if (!D || !D.annotationUID) {
                        console.warn("❌ 주석 데이터가 유효하지 않음:", D), st.warn("❌ 주석 데이터가 유효하지 않음:", D);
                        return;
                    }
                    console.log("📝 주석 UID:", D.annotationUID), console.log("🔧 도구 이름:", D.metadata?.toolName), console.log("📊 주석 데이터:", D.data), console.log("📏 cachedStats:", D.data?.cachedStats), D.isVisible = !0, g(D), (()=>{
                        setTimeout(()=>g(D), 50), setTimeout(()=>g(D), 100), setTimeout(()=>g(D), 200), setTimeout(()=>g(D), 300), setTimeout(()=>g(D), 500), setTimeout(()=>g(D), 1e3);
                    })();
                    const M = setInterval(()=>{
                        D.data?.text && !D.data.text.includes("mm") && (console.log("🔄 텍스트가 px로 변경됨, 다시 mm로 복원"), g(D));
                    }, 500);
                    setTimeout(()=>clearInterval(M), 5e3);
                    const P = {
                        annotationUID: D.annotationUID,
                        toolName: D.metadata?.toolName || "Unknown",
                        data: D.data,
                        metadata: D.metadata,
                        viewportId: "dicom-viewport"
                    };
                    console.log("✅ 새 주석을 스토어에 추가:", P), st.success("✅ 새 주석을 스토어에 추가:", P), c(P);
                } catch (D) {
                    console.error("❌ 주석 완료 이벤트 처리 실패:", D), st.error("❌ 주석 완료 이벤트 처리 실패:", D);
                }
            }, m = (S)=>{
                st.log("✏️ ANNOTATION_MODIFIED 이벤트 수신", S.detail);
                try {
                    const D = S.detail?.annotation;
                    if (D && D.annotationUID) {
                        g(D), setTimeout(()=>g(D), 50);
                        const _ = {
                            data: D.data,
                            metadata: D.metadata
                        };
                        l(D.annotationUID, _);
                    }
                } catch (D) {
                    st.error("❌ 주석 수정 이벤트 처리 실패:", D);
                }
            }, y = (S)=>{
                st.log("🗑️ ANNOTATION_REMOVED 이벤트 수신", S.detail);
                try {
                    const D = S.detail?.annotation;
                    D && D.annotationUID && f(D.annotationUID);
                } catch (D) {
                    st.error("❌ 주석 삭제 이벤트 처리 실패:", D);
                }
            }, C = z.ANNOTATION_COMPLETED, T = z.ANNOTATION_MODIFIED, x = z.ANNOTATION_REMOVED;
            return console.log("🎯 CornerstoneJS 이벤트 등록:", {
                ANNOTATION_COMPLETED: C,
                ANNOTATION_MODIFIED: T,
                ANNOTATION_REMOVED: x
            }), st.log("🎯 CornerstoneJS 이벤트 등록:", {
                ANNOTATION_COMPLETED: C,
                ANNOTATION_MODIFIED: T,
                ANNOTATION_REMOVED: x
            }), Ke.addEventListener(C, v), Ke.addEventListener(T, m), Ke.addEventListener(x, y), console.log("✅ CornerstoneJS 주석 이벤트 리스너 등록 완료!"), st.success("✅ 모든 주석 이벤트 리스너 등록 완료"), ()=>{
                Ke.removeEventListener(C, v), Ke.removeEventListener(T, m), Ke.removeEventListener(x, y), st.log("🧹 주석 이벤트 리스너 정리 완료");
            };
        }, [
            a.current,
            c,
            l,
            f
        ]), _n.useEffect(()=>()=>{
                try {
                    i.current && YC("dicom-tool-group"), r.current && r.current.destroy();
                } catch (v) {
                    console.warn("뷰포트 정리 중 오류:", v);
                }
            }, []), _n.useEffect(()=>{
            r.current && i.current && a.current && (window.cornerstoneRenderingEngine = r.current, window.cornerstoneToolGroupRef = i, st.log("🌐 전역 참조 설정 완료"));
        }, [
            a.current
        ]), ge.jsx("div", {
            ref: n,
            style: {
                width: "100%",
                height: "100%",
                minHeight: "400px",
                backgroundColor: "#000000",
                position: "relative"
            }
        });
    }, Oae = _n.memo(Rae, ()=>(st.log("DicomViewport: props 변경 없음 - 리렌더링 건너뜀"), !0));
    function Iae({ files: t, onError: e, onSuccess: n }) {
        const r = _n.useRef(!1);
        _n.useEffect(()=>{
            if (t.length === 0) {
                r.current = !1, st.log("📋 파일 없음 - loadingRef 초기화");
                return;
            }
            if (r.current) {
                st.log("⚠️ 이미 로딩 중이므로 건너뜀");
                return;
            }
            const i = async ()=>{
                r.current = !0;
                try {
                    st.log("📁 DICOM 파일 로딩 시작", {
                        fileCount: t.length
                    }), st.time("DICOM 파일 처리");
                    const o = ws("dicom-rendering-engine");
                    if (!o) throw new Error("렌더링 엔진이 초기화되지 않았습니다. 뷰포트를 먼저 초기화해주세요.");
                    const s = o.getViewport("dicom-viewport");
                    if (!s) throw new Error("뷰포트를 찾을 수 없습니다.");
                    const c = [];
                    for(let l = 0; l < t.length; l++){
                        const f = t[l];
                        st.progress("파일 처리", l + 1, t.length, f.name);
                        try {
                            st.time(`파일 처리 ${l + 1}`);
                            const u = await f.arrayBuffer(), g = new Uint8Array(u);
                            st.log("파일 정보:", {
                                fileName: f.name,
                                fileSize: g.length,
                                fileType: f.type
                            });
                            try {
                                const h = zO.parseDicom(g);
                                if (l === 0) {
                                    const { setDicomDataSet: T } = ku.getState();
                                    T(h), st.log("💾 첫 번째 파일의 DICOM 데이터셋 스토어에 저장");
                                }
                                const v = {
                                    sopInstanceUID: h.string("x00080018"),
                                    studyInstanceUID: h.string("x0020000d"),
                                    seriesInstanceUID: h.string("x0020000e"),
                                    modality: h.string("x00080060"),
                                    patientName: h.string("x00100010"),
                                    studyDate: h.string("x00080020"),
                                    rows: h.uint16("x00280010"),
                                    columns: h.uint16("x00280011"),
                                    pixelSpacing: h.string("x00280030")
                                };
                                st.success("DICOM 파싱 성공", v);
                                const m = new Blob([
                                    g
                                ], {
                                    type: "application/dicom"
                                }), C = `wadouri:${URL.createObjectURL(m)}`;
                                c.push(C), st.success(`ImageID 생성: ${C.substring(0, 50)}...`), st.timeEnd(`파일 처리 ${l + 1}`);
                            } catch (h) {
                                throw st.timeEnd(`파일 처리 ${l + 1}`), st.error("DICOM 파싱 실패", {
                                    fileName: f.name,
                                    error: h,
                                    fileSize: g.length
                                }), new Error(`DICOM 파싱 실패 (${f.name}): ${h instanceof Error ? h.message : String(h)}`);
                            }
                        } catch (u) {
                            throw st.timeEnd(`파일 처리 ${l + 1}`), st.error("파일 읽기 실패", {
                                fileName: f.name,
                                error: u
                            }), new Error(`파일 읽기 실패 (${f.name}): ${u instanceof Error ? u.message : String(u)}`);
                        }
                    }
                    if (c.length === 0) throw new Error("처리할 수 있는 DICOM 파일이 없습니다.");
                    st.log(`🎯 ${c.length}개 이미지로 스택 설정 시작`), st.time("스택 설정 및 렌더링");
                    try {
                        st.log("뷰포트 스택 설정 시작", {
                            imageCount: c.length
                        }), await s.setStack(c), st.success("✅ 스택 설정 완료"), s.render(), st.success("✅ 렌더링 완료"), st.timeEnd("스택 설정 및 렌더링"), st.timeEnd("DICOM 파일 처리"), st.logMemoryUsage(), st.success("🎉 DICOM 로딩 최종 완료", {
                            fileCount: t.length,
                            imageCount: c.length
                        }), n(`${t.length}개 DICOM 파일이 성공적으로 로드되었습니다`);
                    } catch (l) {
                        throw st.timeEnd("스택 설정 및 렌더링"), st.error("스택 설정 실패", {
                            error: l,
                            imageCount: c.length
                        }), new Error(`스택 설정 실패: ${l instanceof Error ? l.message : String(l)}`);
                    }
                } catch (o) {
                    st.timeEnd("DICOM 파일 처리"), st.error("DICOM 파일 로딩 최종 실패", o), st.dumpErrors(), e(`DICOM 로딩 실패: ${o instanceof Error ? o.message : String(o)}`);
                } finally{
                    r.current = !1;
                }
            }, a = setTimeout(()=>{
                i();
            }, 100);
            return ()=>{
                clearTimeout(a), r.current = !1, st.log("🧹 useDicomLoader cleanup - loadingRef 초기화");
            };
        }, [
            t,
            e,
            n,
            t.length,
            ...t.map((i)=>i.name + i.size)
        ]);
    }
    const Mae = ({ files: t, onError: e, onSuccess: n })=>(st.log("🏗️ DicomRenderer 렌더링", {
            fileCount: t.length
        }), Iae({
            files: t,
            onError: e,
            onSuccess: n
        }), ge.jsx(Oae, {
            onError: e,
            onSuccess: n
        })), bae = _n.memo(Mae, (t, e)=>{
        if (t.files.length !== e.files.length) return st.log("DicomRenderer: 파일 개수 변경으로 리렌더링", {
            prev: t.files.length,
            next: e.files.length
        }), !1;
        if (e.files.length === 0) return st.log("DicomRenderer: 빈 파일 배열 - 리렌더링 허용"), !1;
        for(let n = 0; n < t.files.length; n++)if (t.files[n].name !== e.files[n].name || t.files[n].size !== e.files[n].size || t.files[n].lastModified !== e.files[n].lastModified) return st.log("DicomRenderer: 파일 내용 변경으로 리렌더링"), !1;
        return st.log("DicomRenderer: props 변경 없음 - 리렌더링 건너뜀"), !0;
    }), U7 = {
        x00080005: "Specific Character Set",
        x00080008: "Image Type",
        x00080012: "Instance Creation Date",
        x00080013: "Instance Creation Time",
        x00080016: "SOP Class UID",
        x00080018: "SOP Instance UID",
        x00080020: "Study Date",
        x00080021: "Series Date",
        x00080022: "Acquisition Date",
        x00080023: "Content Date",
        x00080030: "Study Time",
        x00080031: "Series Time",
        x00080032: "Acquisition Time",
        x00080033: "Content Time",
        x00080050: "Accession Number",
        x00080060: "Modality",
        x00080064: "Conversion Type",
        x00080070: "Manufacturer",
        x00080080: "Institution Name",
        x00080081: "Institution Address",
        x00080090: "Referring Physician Name",
        x00081010: "Station Name",
        x00081030: "Study Description",
        x0008103e: "Series Description",
        x00081040: "Institutional Department Name",
        x00081050: "Performing Physician Name",
        x00081060: "Name of Physician Reading Study",
        x00081070: "Operators Name",
        x00081080: "Admitting Diagnoses Description",
        x00081090: "Manufacturers Model Name",
        x00100010: "Patient Name",
        x00100020: "Patient ID",
        x00100030: "Patient Birth Date",
        x00100040: "Patient Sex",
        x00100050: "Patient Insurance Plan Code Sequence",
        x00101010: "Patient Age",
        x00101020: "Patient Size",
        x00101030: "Patient Weight",
        x0018001: "Contrast/Bolus Agent",
        x00180015: "Body Part Examined",
        x00180050: "Slice Thickness",
        x00180060: "KVP",
        x00180088: "Spacing Between Slices",
        x00180090: "Data Collection Diameter",
        x001800a0: "Data Collection Diameter",
        x00181000: "Device Serial Number",
        x00181020: "Software Version(s)",
        x00181030: "Protocol Name",
        x00181040: "Contrast/Bolus Route",
        x00181041: "Contrast/Bolus Volume",
        x00181050: "Spatial Resolution",
        x00181060: "Trigger Time",
        x00181088: "Heart Rate",
        x00181090: "Cardiac Number of Images",
        x001810a0: "Number of Phase Encoding Steps",
        x00181100: "Reconstruction Diameter",
        x00181110: "Distance Source to Detector",
        x00181111: "Distance Source to Patient",
        x00181120: "Gantry/Detector Tilt",
        x00181130: "Table Height",
        x00181140: "Rotation Direction",
        x00181150: "Exposure Time",
        x00181151: "X-Ray Tube Current",
        x00181152: "Exposure",
        x00181160: "Filter Type",
        x00181170: "Generator Power",
        x00181190: "Focal Spot(s)",
        x001811a0: "Anode Target Material",
        x00181200: "Date of Last Calibration",
        x00181201: "Time of Last Calibration",
        x00181210: "Convolution Kernel",
        x00185100: "Patient Position",
        x0020000d: "Study Instance UID",
        x0020000e: "Series Instance UID",
        x00200010: "Study ID",
        x00200011: "Series Number",
        x00200012: "Acquisition Number",
        x00200013: "Instance Number",
        x00200020: "Patient Orientation",
        x00200032: "Image Position (Patient)",
        x00200037: "Image Orientation (Patient)",
        x00200052: "Frame of Reference UID",
        x00200060: "Laterality",
        x00201040: "Position Reference Indicator",
        x00201041: "Slice Location",
        x00280002: "Samples per Pixel",
        x00280004: "Photometric Interpretation",
        x00280006: "Planar Configuration",
        x00280008: "Number of Frames",
        x00280009: "Frame Increment Pointer",
        x00280010: "Rows",
        x00280011: "Columns",
        x00280030: "Pixel Spacing",
        x00280034: "Pixel Aspect Ratio",
        x00280100: "Bits Allocated",
        x00280101: "Bits Stored",
        x00280102: "High Bit",
        x00280103: "Pixel Representation",
        x00281040: "Pixel Intensity Relationship",
        x00281041: "Pixel Intensity Relationship Sign",
        x00281050: "Window Center",
        x00281051: "Window Width",
        x00281052: "Rescale Intercept",
        x00281053: "Rescale Slope",
        x00281054: "Rescale Type",
        x00281055: "Window Center & Width Explanation",
        x00321032: "Requesting Physician",
        x00321033: "Requesting Service",
        x00321060: "Requested Procedure Description",
        x00400002: "Scheduled Procedure Step Start Date",
        x00400003: "Scheduled Procedure Step Start Time",
        x00400006: "Scheduled Performing Physician Name",
        x00400007: "Scheduled Procedure Step Description",
        x00400009: "Scheduled Procedure Step ID",
        x00400010: "Scheduled Station Name",
        x00400011: "Scheduled Procedure Step Location",
        x00400012: "Pre-Medication",
        x00400020: "Scheduled Procedure Step Status",
        x00400244: "Performed Procedure Step Start Date",
        x00400245: "Performed Procedure Step Start Time",
        x00400253: "Performed Procedure Step ID",
        x00400254: "Performed Procedure Step Description",
        x00400275: "Request Attributes Sequence",
        x00880130: "Storage Media File-set ID",
        x00880140: "Storage Media File-set UID"
    }, F7 = {
        background: "transparent",
        border: "none",
        padding: "0",
        margin: "0",
        cursor: "pointer",
        outline: "none",
        WebkitAppearance: "none",
        MozAppearance: "none",
        appearance: "none",
        boxSizing: "border-box",
        fontFamily: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit"
    }, Lae = ({ isOpen: t, onClose: e, dataSet: n, inline: r = !1 })=>{
        const [i, a] = Rh.useState(""), [o, s] = Rh.useState(null);
        if (!t) return null;
        const c = `
    .meta-tag-scroll-container {
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: #4a5568 #2d3748;
    }
    .meta-tag-scroll-container::-webkit-scrollbar {
      width: 8px;
    }
    .meta-tag-scroll-container::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 4px;
    }
    .meta-tag-scroll-container::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }
    .meta-tag-scroll-container::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }
  `, f = (()=>{
            const v = [];
            return !n || !n.elements ? v : (Object.keys(n.elements).forEach((m)=>{
                const y = n.elements[m];
                try {
                    let C = "";
                    y.vr === "US" || y.vr === "UL" ? C = n.uint16(m)?.toString() || n.uint32(m)?.toString() || "" : y.vr === "FL" || y.vr === "FD" ? C = n.float(m)?.toString() || n.double(m)?.toString() || "" : y.vr === "SQ" ? C = "[Sequence Data]" : y.vr === "OB" || y.vr === "OW" ? C = "[Binary Data]" : C = n.string(m) || "", C.length > 100 && (C = C.substring(0, 100) + "...");
                    const T = U7[m] || "Unknown Tag";
                    v.push({
                        tag: m.replace("x", "").toUpperCase(),
                        vr: y.vr || "UN",
                        name: T,
                        value: C || "(empty)"
                    });
                } catch  {
                    v.push({
                        tag: m.replace("x", "").toUpperCase(),
                        vr: y.vr || "UN",
                        name: U7[m] || "Unknown Tag",
                        value: "(parsing failed)"
                    });
                }
            }), v.sort((m, y)=>m.tag.localeCompare(y.tag)));
        })(), u = f.filter((v)=>v.tag.toLowerCase().includes(i.toLowerCase()) || v.name.toLowerCase().includes(i.toLowerCase()) || v.value.toLowerCase().includes(i.toLowerCase()) || v.vr.toLowerCase().includes(i.toLowerCase())), g = async (v, m)=>{
            try {
                await navigator.clipboard.writeText(v), s(m), setTimeout(()=>s(null), 2e3);
            } catch (y) {
                console.error("클립보드 복사 실패:", y);
            }
        }, h = ge.jsxs(ge.Fragment, {
            children: [
                ge.jsx("style", {
                    children: c
                }),
                ge.jsxs("div", {
                    className: "rounded-lg shadow-xl flex flex-col",
                    style: {
                        width: "100%",
                        height: "100%",
                        maxWidth: "none",
                        maxHeight: "none",
                        minWidth: r ? "auto" : "600px",
                        minHeight: r ? "auto" : "500px",
                        backgroundColor: "#222222",
                        color: "#ffffff",
                        padding: "40px"
                    },
                    children: [
                        ge.jsxs("div", {
                            className: "border-b",
                            style: {
                                borderColor: "#374151",
                                paddingBottom: "16px",
                                marginBottom: "16px",
                                position: "relative"
                            },
                            children: [
                                ge.jsxs("div", {
                                    style: {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: "10px"
                                    },
                                    children: [
                                        ge.jsx(Oh, {
                                            className: "text-blue-400",
                                            size: 24
                                        }),
                                        ge.jsx("h2", {
                                            className: "text-xl font-semibold text-white",
                                            children: "DICOM Meta Tags"
                                        }),
                                        ge.jsxs("span", {
                                            className: "text-sm text-gray-300",
                                            children: [
                                                "(총 ",
                                                f.length,
                                                "개의 태그)"
                                            ]
                                        })
                                    ]
                                }),
                                ge.jsx("button", {
                                    onClick: e,
                                    className: "p-2 rounded-full transition-colors",
                                    style: {
                                        ...F7,
                                        position: "absolute",
                                        top: "0",
                                        right: "0",
                                        color: "#9ca3af",
                                        width: "32px",
                                        height: "32px",
                                        borderRadius: "50%",
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center"
                                    },
                                    onMouseEnter: (v)=>{
                                        v.currentTarget.style.backgroundColor = "#374151";
                                    },
                                    onMouseLeave: (v)=>{
                                        v.currentTarget.style.backgroundColor = "transparent";
                                    },
                                    title: "모달 닫기",
                                    children: ge.jsx(l3, {
                                        size: 20
                                    })
                                })
                            ]
                        }),
                        ge.jsxs("div", {
                            className: "border-b",
                            style: {
                                borderColor: "#374151",
                                paddingBottom: "16px",
                                marginBottom: "16px"
                            },
                            children: [
                                ge.jsxs("div", {
                                    style: {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: "10px"
                                    },
                                    children: [
                                        ge.jsx(G7, {
                                            className: "text-gray-400",
                                            size: 16
                                        }),
                                        ge.jsx("input", {
                                            type: "text",
                                            placeholder: "태그 ID, 이름, 값으로 검색...",
                                            value: i,
                                            onChange: (v)=>a(v.target.value),
                                            className: "border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none px-3",
                                            style: {
                                                width: "300px",
                                                height: "36px",
                                                backgroundColor: "#374151",
                                                borderColor: "#4b5563",
                                                color: "#ffffff"
                                            }
                                        })
                                    ]
                                }),
                                ge.jsxs("p", {
                                    className: "text-sm text-gray-400 mt-2",
                                    children: [
                                        u.length,
                                        "개의 태그가 표시됨",
                                        i && ` (전체 ${f.length}개 중 검색 결과)`
                                    ]
                                })
                            ]
                        }),
                        ge.jsxs("div", {
                            className: "flex-1 meta-tag-scroll-container",
                            style: {
                                height: "calc(100% - 120px)",
                                minHeight: "200px"
                            },
                            children: [
                                ge.jsxs("table", {
                                    className: "w-full border-collapse",
                                    children: [
                                        ge.jsx("thead", {
                                            className: "sticky top-0",
                                            style: {
                                                backgroundColor: "#1f2937"
                                            },
                                            children: ge.jsxs("tr", {
                                                children: [
                                                    ge.jsx("th", {
                                                        className: "px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider border-b",
                                                        style: {
                                                            borderColor: "#374151"
                                                        },
                                                        children: "Tag ID"
                                                    }),
                                                    ge.jsx("th", {
                                                        className: "px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider border-b",
                                                        style: {
                                                            borderColor: "#374151"
                                                        },
                                                        children: "VR"
                                                    }),
                                                    ge.jsx("th", {
                                                        className: "px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider border-b",
                                                        style: {
                                                            borderColor: "#374151"
                                                        },
                                                        children: "Tag Name"
                                                    }),
                                                    ge.jsx("th", {
                                                        className: "px-4 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider border-b",
                                                        style: {
                                                            borderColor: "#374151"
                                                        },
                                                        children: "Value"
                                                    }),
                                                    ge.jsx("th", {
                                                        className: "px-4 py-3 text-center text-xs font-medium text-gray-300 uppercase tracking-wider border-b",
                                                        style: {
                                                            borderColor: "#374151"
                                                        },
                                                        children: "Copy"
                                                    })
                                                ]
                                            })
                                        }),
                                        ge.jsx("tbody", {
                                            className: "divide-y",
                                            style: {
                                                divideColor: "#374151"
                                            },
                                            children: u.map((v, m)=>ge.jsxs("tr", {
                                                    style: {
                                                        backgroundColor: m % 2 === 0 ? "#2d3748" : "#374151",
                                                        borderBottomColor: "#4a5568"
                                                    },
                                                    children: [
                                                        ge.jsxs("td", {
                                                            className: "px-4 py-3 text-sm font-mono text-gray-200",
                                                            children: [
                                                                "(",
                                                                v.tag.substring(0, 4),
                                                                ",",
                                                                v.tag.substring(4, 8),
                                                                ")"
                                                            ]
                                                        }),
                                                        ge.jsx("td", {
                                                            className: "px-4 py-3 text-sm font-mono text-gray-300",
                                                            children: v.vr
                                                        }),
                                                        ge.jsx("td", {
                                                            className: "px-4 py-3 text-sm text-gray-200",
                                                            children: v.name
                                                        }),
                                                        ge.jsx("td", {
                                                            className: "px-4 py-3 text-sm text-gray-300 max-w-md",
                                                            children: ge.jsx("div", {
                                                                className: "break-words",
                                                                children: v.value
                                                            })
                                                        }),
                                                        ge.jsx("td", {
                                                            className: "px-4 py-3 text-center",
                                                            children: ge.jsx("button", {
                                                                onClick: ()=>g(`${v.name}: ${v.value}`, v.tag),
                                                                className: `rounded transition-colors ${o === v.tag ? "text-green-400" : "text-gray-400"}`,
                                                                style: {
                                                                    ...F7,
                                                                    width: "24px",
                                                                    height: "24px",
                                                                    borderRadius: "4px",
                                                                    display: "flex",
                                                                    alignItems: "center",
                                                                    justifyContent: "center"
                                                                },
                                                                onMouseEnter: (y)=>{
                                                                    y.currentTarget.style.backgroundColor = "#4a5568";
                                                                },
                                                                onMouseLeave: (y)=>{
                                                                    y.currentTarget.style.backgroundColor = "transparent";
                                                                },
                                                                title: "클립보드에 복사",
                                                                children: ge.jsx(AM, {
                                                                    size: 14
                                                                })
                                                            })
                                                        })
                                                    ]
                                                }, v.tag))
                                        })
                                    ]
                                }),
                                u.length === 0 && ge.jsxs("div", {
                                    className: "text-center py-12",
                                    children: [
                                        ge.jsx(Oh, {
                                            className: "mx-auto text-gray-500 mb-4",
                                            size: 48
                                        }),
                                        ge.jsx("p", {
                                            className: "text-gray-400",
                                            children: i ? "검색 결과가 없습니다." : "DICOM 태그 정보가 없습니다."
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                })
            ]
        });
        return r ? h : ge.jsx("div", {
            className: "fixed z-50",
            style: {
                left: "280px",
                top: "70px",
                right: "0",
                bottom: "0",
                backgroundColor: "rgba(0, 0, 0, 0.85)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                padding: "20px"
            },
            children: h
        });
    }, Pae = {
        background: "transparent",
        border: "none",
        padding: "0",
        margin: "0",
        cursor: "pointer",
        outline: "none",
        WebkitAppearance: "none",
        MozAppearance: "none",
        appearance: "none",
        boxSizing: "border-box",
        fontFamily: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit"
    }, Vae = ()=>[
            {
                name: "@cornerstonejs/core",
                version: "^1.77.9",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "@cornerstonejs/dicom-image-loader",
                version: "^1.77.9",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "@cornerstonejs/nifti-volume-loader",
                version: "^1.77.9",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "@cornerstonejs/streaming-image-volume-loader",
                version: "^1.77.9",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "@cornerstonejs/tools",
                version: "^1.77.9",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "dcmjs",
                version: "^0.43.0",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "dicom-parser",
                version: "^1.8.21",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "lucide-react",
                version: "^0.408.0",
                license: "ISC",
                type: "dependency"
            },
            {
                name: "react",
                version: "^18.2.0",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "react-dom",
                version: "^18.2.0",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "uuid",
                version: "^10.0.0",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "zustand",
                version: "^4.4.7",
                license: "MIT",
                type: "dependency"
            },
            {
                name: "@types/node",
                version: "^24.0.13",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "@types/react",
                version: "^19.1.8",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "@types/react-dom",
                version: "^19.1.6",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "@types/uuid",
                version: "^10.0.0",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "@vitejs/plugin-react",
                version: "^4.2.1",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "typescript",
                version: "^5.2.2",
                license: "Apache-2.0",
                type: "devDependency"
            },
            {
                name: "vite",
                version: "^5.2.0",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "vite-plugin-static-copy",
                version: "^3.1.1",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "vite-plugin-top-level-await",
                version: "^1.5.0",
                license: "MIT",
                type: "devDependency"
            },
            {
                name: "vite-plugin-wasm",
                version: "^3.5.0",
                license: "MIT",
                type: "devDependency"
            }
        ].sort((e, n)=>e.name.localeCompare(n.name)), Nae = ({ isOpen: t, onClose: e, inline: n = !1 })=>{
        if (console.log("🔥 LicenseModal 렌더됨, isOpen:", t, "inline:", n), !t) return console.log("🔥 LicenseModal isOpen이 false여서 null 반환"), null;
        const r = Vae(), i = r.filter((c)=>c.type === "dependency"), a = r.filter((c)=>c.type === "devDependency"), s = ge.jsxs(ge.Fragment, {
            children: [
                ge.jsx("style", {
                    children: `
    .license-scroll-container {
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: thin;
      scrollbar-color: #4a5568 #2d3748;
    }
    .license-scroll-container::-webkit-scrollbar {
      width: 8px;
    }
    .license-scroll-container::-webkit-scrollbar-track {
      background: #2d3748;
      border-radius: 4px;
    }
    .license-scroll-container::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 4px;
    }
    .license-scroll-container::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }
  `
                }),
                ge.jsxs("div", {
                    className: "flex flex-col",
                    style: {
                        width: "100%",
                        height: "100%",
                        backgroundColor: "#2d2d2d",
                        color: "#ffffff",
                        padding: "24px"
                    },
                    children: [
                        ge.jsxs("div", {
                            className: "border-b",
                            style: {
                                borderColor: "#374151",
                                paddingBottom: "12px",
                                marginBottom: "16px",
                                position: "relative"
                            },
                            children: [
                                ge.jsx("div", {
                                    children: ge.jsx("h2", {
                                        style: {
                                            fontSize: "20px",
                                            fontWeight: "bold",
                                            color: "#ffffff",
                                            margin: 0
                                        },
                                        children: "Clarity"
                                    })
                                }),
                                ge.jsxs("div", {
                                    style: {
                                        marginTop: "8px"
                                    },
                                    children: [
                                        ge.jsx("p", {
                                            style: {
                                                fontSize: "14px",
                                                color: "#d1d5db",
                                                margin: 0
                                            },
                                            children: "DICOM Medical Image Viewer"
                                        }),
                                        ge.jsx("p", {
                                            style: {
                                                fontSize: "12px",
                                                color: "#9ca3af",
                                                margin: 0
                                            },
                                            children: "Created by stra2003@gmail.com"
                                        }),
                                        ge.jsx("p", {
                                            style: {
                                                fontSize: "12px",
                                                color: "#9ca3af",
                                                margin: 0
                                            },
                                            children: "Version 0.1.0 - Alpha Release"
                                        })
                                    ]
                                }),
                                ge.jsx("button", {
                                    onClick: e,
                                    className: "p-2 rounded-full transition-colors",
                                    style: {
                                        ...Pae,
                                        position: "absolute",
                                        top: "0",
                                        right: "0",
                                        color: "#9ca3af",
                                        width: "32px",
                                        height: "32px",
                                        borderRadius: "50%",
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center"
                                    },
                                    onMouseEnter: (c)=>{
                                        c.currentTarget.style.backgroundColor = "#374151";
                                    },
                                    onMouseLeave: (c)=>{
                                        c.currentTarget.style.backgroundColor = "transparent";
                                    },
                                    title: "모달 닫기",
                                    children: ge.jsx(l3, {
                                        size: 20
                                    })
                                })
                            ]
                        }),
                        ge.jsxs("div", {
                            className: "flex-1 license-scroll-container",
                            style: {
                                height: "calc(100% - 180px)",
                                minHeight: "200px"
                            },
                            children: [
                                i.length > 0 && ge.jsxs("div", {
                                    style: {
                                        marginBottom: "24px"
                                    },
                                    children: [
                                        ge.jsxs("h3", {
                                            style: {
                                                fontSize: "14px",
                                                fontWeight: "600",
                                                color: "#ffffff",
                                                marginBottom: "12px"
                                            },
                                            children: [
                                                "Runtime Dependencies (",
                                                i.length,
                                                ")"
                                            ]
                                        }),
                                        ge.jsx("div", {
                                            className: "grid gap-2",
                                            children: i.map((c)=>ge.jsx("div", {
                                                    className: "p-3 rounded-lg border",
                                                    style: {
                                                        backgroundColor: "#2d2d2d",
                                                        borderColor: "#4a5568"
                                                    },
                                                    children: ge.jsxs("div", {
                                                        className: "flex justify-between items-start",
                                                        children: [
                                                            ge.jsxs("div", {
                                                                className: "flex-1",
                                                                children: [
                                                                    ge.jsx("h4", {
                                                                        style: {
                                                                            fontSize: "10px",
                                                                            fontWeight: "500",
                                                                            color: "#ffffff",
                                                                            margin: 0
                                                                        },
                                                                        children: c.name
                                                                    }),
                                                                    ge.jsxs("p", {
                                                                        style: {
                                                                            fontSize: "10px",
                                                                            color: "#9ca3af",
                                                                            margin: 0
                                                                        },
                                                                        children: [
                                                                            "Version: ",
                                                                            c.version
                                                                        ]
                                                                    })
                                                                ]
                                                            }),
                                                            ge.jsx("span", {
                                                                style: {
                                                                    fontSize: "10px",
                                                                    fontWeight: "500",
                                                                    padding: "2px 6px",
                                                                    borderRadius: "4px",
                                                                    backgroundColor: c.license === "MIT" ? "#065f46" : "#7c2d12",
                                                                    color: c.license === "MIT" ? "#10b981" : "#f97316"
                                                                },
                                                                children: c.license
                                                            })
                                                        ]
                                                    })
                                                }, c.name))
                                        })
                                    ]
                                }),
                                a.length > 0 && ge.jsxs("div", {
                                    children: [
                                        ge.jsxs("h3", {
                                            style: {
                                                fontSize: "14px",
                                                fontWeight: "600",
                                                color: "#ffffff",
                                                marginBottom: "12px",
                                                marginTop: "24px",
                                                paddingTop: "16px",
                                                borderTop: "1px solid #374151"
                                            },
                                            children: [
                                                "Development Dependencies (",
                                                a.length,
                                                ")"
                                            ]
                                        }),
                                        ge.jsx("div", {
                                            className: "grid gap-2",
                                            children: a.map((c)=>ge.jsx("div", {
                                                    className: "p-3 rounded-lg border",
                                                    style: {
                                                        backgroundColor: "#2d2d2d",
                                                        borderColor: "#4a5568"
                                                    },
                                                    children: ge.jsxs("div", {
                                                        className: "flex justify-between items-start",
                                                        children: [
                                                            ge.jsxs("div", {
                                                                className: "flex-1",
                                                                children: [
                                                                    ge.jsx("h4", {
                                                                        style: {
                                                                            fontSize: "10px",
                                                                            fontWeight: "500",
                                                                            color: "#e5e7eb",
                                                                            margin: 0
                                                                        },
                                                                        children: c.name
                                                                    }),
                                                                    ge.jsxs("p", {
                                                                        style: {
                                                                            fontSize: "10px",
                                                                            color: "#6b7280",
                                                                            margin: 0
                                                                        },
                                                                        children: [
                                                                            "Version: ",
                                                                            c.version
                                                                        ]
                                                                    })
                                                                ]
                                                            }),
                                                            ge.jsx("span", {
                                                                style: {
                                                                    fontSize: "10px",
                                                                    fontWeight: "500",
                                                                    padding: "2px 6px",
                                                                    borderRadius: "4px",
                                                                    backgroundColor: c.license === "MIT" ? "#065f46" : "#7c2d12",
                                                                    color: c.license === "MIT" ? "#10b981" : "#f97316"
                                                                },
                                                                children: c.license
                                                            })
                                                        ]
                                                    })
                                                }, c.name))
                                        })
                                    ]
                                }),
                                r.length === 0 && ge.jsx("div", {
                                    className: "text-center py-12",
                                    children: ge.jsx("p", {
                                        style: {
                                            fontSize: "12px",
                                            color: "#9ca3af"
                                        },
                                        children: "라이브러리 정보가 없습니다."
                                    })
                                })
                            ]
                        }),
                        ge.jsx("div", {
                            style: {
                                borderTop: "1px solid #374151",
                                padding: "12px 24px",
                                backgroundColor: "#2d2d2d",
                                flexShrink: 0
                            },
                            children: ge.jsxs("div", {
                                style: {
                                    textAlign: "center"
                                },
                                children: [
                                    ge.jsx("p", {
                                        style: {
                                            fontSize: "8px",
                                            color: "#9ca3af",
                                            marginBottom: "4px",
                                            margin: 0
                                        },
                                        children: "이 애플리케이션은 위에 나열된 오픈소스 라이브러리들을 사용하여 제작되었습니다."
                                    }),
                                    ge.jsx("p", {
                                        style: {
                                            fontSize: "8px",
                                            color: "#6b7280",
                                            margin: 0
                                        },
                                        children: "모든 라이브러리는 각각의 라이선스 조건에 따라 사용됩니다."
                                    })
                                ]
                            })
                        })
                    ]
                })
            ]
        });
        return n ? s : (console.log("🔥 LicenseModal 팝업 모드로 렌더링 중..."), ge.jsx("div", {
            className: "fixed",
            style: {
                position: "fixed",
                top: "0",
                left: "0",
                right: "0",
                bottom: "0",
                width: "100vw",
                height: "100vh",
                backgroundColor: "rgba(0, 0, 0, 0.75)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                zIndex: 99999
            },
            onClick: (c)=>{
                console.log("🔥 모달 배경 클릭됨"), c.target === c.currentTarget && e();
            },
            children: ge.jsx("div", {
                style: {
                    width: "480px",
                    height: "640px",
                    backgroundColor: "#2d2d2d",
                    borderRadius: "8px",
                    overflow: "hidden",
                    boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.8)",
                    position: "relative"
                },
                onClick: (c)=>{
                    console.log("🔥 모달 내용 클릭됨"), c.stopPropagation();
                },
                children: s
            })
        }));
    }, pi = {
        background: "transparent",
        border: "none",
        padding: "0",
        margin: "0",
        cursor: "pointer",
        outline: "none",
        WebkitAppearance: "none",
        MozAppearance: "none",
        appearance: "none",
        boxSizing: "border-box",
        fontFamily: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit"
    };
    function Aae() {
        const [t, e] = _n.useState(!1), [n, r] = _n.useState(!1), [i, a] = _n.useState(null), [o, s] = _n.useState([]), [c, l] = _n.useState(!0), [f, u] = _n.useState(!1), [g, h] = _n.useState(!1), [v, m] = _n.useState(""), [y, C] = _n.useState(null), [T, x] = _n.useState(""), [S, D] = _n.useState(!1), _ = _n.useRef(null), { activeTool: M, setActiveTool: P, annotations: F, clearAllAnnotations: N, removeAnnotation: B, updateAnnotationLabel: G, rotateImage: Z, flipImage: H, resetImageTransform: ne, currentRotation: ae, isFlippedHorizontal: ue, isFlippedVertical: le, currentDicomDataSet: oe, isLicenseModalOpen: re, toggleLicenseModal: X, captureViewportAsPng: ie } = ku((Pe)=>({
                activeTool: Pe.activeTool,
                setActiveTool: Pe.setActiveTool,
                annotations: Pe.annotations,
                clearAllAnnotations: Pe.clearAllAnnotations,
                removeAnnotation: Pe.removeAnnotation,
                updateAnnotationLabel: Pe.updateAnnotationLabel,
                rotateImage: Pe.rotateImage,
                flipImage: Pe.flipImage,
                resetImageTransform: Pe.resetImageTransform,
                currentRotation: Pe.currentRotation,
                isFlippedHorizontal: Pe.isFlippedHorizontal,
                isFlippedVertical: Pe.isFlippedVertical,
                currentDicomDataSet: Pe.currentDicomDataSet,
                isLicenseModalOpen: Pe.isLicenseModalOpen,
                toggleLicenseModal: Pe.toggleLicenseModal,
                captureViewportAsPng: Pe.captureViewportAsPng
            })), he = (Pe, Ct)=>{
            C(Pe), x(Ct || `${F.find((yt)=>yt.annotationUID === Pe)?.toolName} #${F.findIndex((yt)=>yt.annotationUID === Pe) + 1}`), console.log(`📝 주석 편집 시작: ${Pe}`, Ct);
        }, $e = ()=>{
            y && T.trim() && (G(y, T.trim()), console.log(`💾 주석 라벨 저장: ${y} -> "${T.trim()}"`)), C(null), x("");
        }, je = ()=>{
            C(null), x(""), console.log("❌ 주석 편집 취소");
        }, He = (Pe)=>{
            Pe.key === "Enter" ? $e() : Pe.key === "Escape" && je();
        };
        _n.useEffect(()=>{
            M || (P("WindowLevel"), console.log("기본 도구로 WindowLevel 설정"));
        }, [
            M,
            P
        ]);
        const rt = ()=>{
            const Pe = document.createElement("input");
            Pe.type = "file", Pe.multiple = !0, Pe.accept = ".dcm,application/dicom", Pe.onchange = (Ct)=>{
                const yt = Array.from(Ct.target.files || []);
                yt.length > 0 && Qe(yt), Ct.target.value = "";
            }, Pe.click();
        }, Qe = async (Pe)=>{
            console.log("🔄 파일 처리 시작 - 완전한 상태 초기화"), r(!1), a(null), u(!1), s([]), N();
            const { setLoading: Ct, setError: yt } = ku.getState();
            Ct(!1), yt(null), console.log("✅ 모든 상태 초기화 완료");
            const En = Pe.filter((ln)=>ln.name.toLowerCase().endsWith(".dcm") || ln.type === "application/dicom");
            if (En.length === 0) {
                a("DICOM 파일이 없습니다. .dcm 파일을 선택해주세요.");
                return;
            }
            try {
                console.log(`📁 ${En.length}개의 DICOM 파일 처리 시작`), await new Promise((ln)=>setTimeout(ln, 50)), r(!0), s(En), console.log("🎯 DicomRenderer로 파일 전달 완료");
            } catch (ln) {
                console.error("❌ 파일 처리 중 오류:", ln), a("파일 로드 중 오류가 발생했습니다."), r(!1);
            }
        }, et = (Pe)=>{
            Pe.preventDefault(), e(!1);
            const Ct = Array.from(Pe.dataTransfer.files);
            console.log("🎯 드래그앤드롭으로 파일 처리 시작"), Qe(Ct);
        }, St = (Pe)=>{
            Pe.preventDefault(), e(!0);
        }, Ln = (Pe)=>{
            Pe.preventDefault(), e(!1);
        }, Nn = (Pe)=>{
            console.log("✅ App: 렌더링 성공", Pe), u(!0), r(!1), a(null);
            const { setLoading: Ct, setError: yt } = ku.getState();
            Ct(!1), yt(null), m(`✓ ${o.length}개 파일 렌더링 완료`), h(!0), setTimeout(()=>{
                h(!1);
            }, 5e3), console.log("🎉 파일 로딩 완전히 완료 - 모든 상태 정리됨");
        }, zt = (Pe)=>{
            console.error("❌ App: 렌더링 실패", Pe), u(!1), r(!1), a(Pe);
            const { setLoading: Ct, setError: yt } = ku.getState();
            Ct(!1), yt(Pe), console.log("💥 파일 로딩 실패 - 모든 상태 정리됨");
        };
        return ge.jsxs(ge.Fragment, {
            children: [
                ge.jsxs("div", {
                    className: "app",
                    children: [
                        ge.jsx("header", {
                            className: "app-header",
                            children: ge.jsxs("div", {
                                className: "header-content",
                                children: [
                                    ge.jsxs("div", {
                                        className: "header-left",
                                        children: [
                                            ge.jsx(Hm, {
                                                className: "header-icon"
                                            }),
                                            ge.jsx("h1", {
                                                children: "Clarity"
                                            }),
                                            ge.jsx("span", {
                                                className: "version",
                                                children: "Alpha"
                                            })
                                        ]
                                    }),
                                    ge.jsx("div", {
                                        className: "header-right",
                                        children: ge.jsx("span", {
                                            className: "status-ready",
                                            children: "Ready"
                                        })
                                    })
                                ]
                            })
                        }),
                        ge.jsxs("div", {
                            className: "app-content",
                            children: [
                                ge.jsx("button", {
                                    className: "sidebar-toggle",
                                    onClick: ()=>l(!c),
                                    style: pi,
                                    children: c ? "◀" : "▶"
                                }),
                                c && ge.jsxs("aside", {
                                    className: "sidebar",
                                    children: [
                                        ge.jsxs("div", {
                                            className: "sidebar-content",
                                            children: [
                                                ge.jsxs("div", {
                                                    className: "sidebar-section",
                                                    children: [
                                                        ge.jsxs("h3", {
                                                            className: "sidebar-section-title",
                                                            children: [
                                                                ge.jsx(k6, {
                                                                    size: 16
                                                                }),
                                                                "파일 관리"
                                                            ]
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "file-upload-section",
                                                            children: ge.jsxs("button", {
                                                                className: "file-upload-button",
                                                                onClick: rt,
                                                                disabled: n,
                                                                style: {
                                                                    ...pi,
                                                                    width: "100%",
                                                                    padding: "12px 16px",
                                                                    backgroundColor: "#3b82f6",
                                                                    color: "white",
                                                                    borderRadius: "8px",
                                                                    fontSize: "14px",
                                                                    fontWeight: "500",
                                                                    cursor: n ? "not-allowed" : "pointer",
                                                                    display: "flex",
                                                                    alignItems: "center",
                                                                    justifyContent: "center",
                                                                    gap: "8px",
                                                                    transition: "background-color 0.2s",
                                                                    opacity: n ? .6 : 1
                                                                },
                                                                onMouseEnter: (Pe)=>{
                                                                    n || (Pe.currentTarget.style.backgroundColor = "#2563eb");
                                                                },
                                                                onMouseLeave: (Pe)=>{
                                                                    n || (Pe.currentTarget.style.backgroundColor = "#3b82f6");
                                                                },
                                                                title: "DICOM 파일 업로드 (.dcm)",
                                                                children: [
                                                                    ge.jsx(k6, {
                                                                        size: 16
                                                                    }),
                                                                    ge.jsx("span", {
                                                                        children: "DICOM 파일 불러오기"
                                                                    })
                                                                ]
                                                            })
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "sidebar-section",
                                                    children: [
                                                        ge.jsxs("h3", {
                                                            className: "sidebar-section-title",
                                                            children: [
                                                                ge.jsx(Oh, {
                                                                    size: 16
                                                                }),
                                                                "파일 정보"
                                                            ]
                                                        }),
                                                        o.length > 0 ? ge.jsxs("div", {
                                                            className: "series-info",
                                                            children: [
                                                                ge.jsxs("div", {
                                                                    className: "info-item",
                                                                    children: [
                                                                        ge.jsx("label", {
                                                                            children: "로드된 파일:"
                                                                        }),
                                                                        ge.jsxs("span", {
                                                                            children: [
                                                                                o.length,
                                                                                "개"
                                                                            ]
                                                                        })
                                                                    ]
                                                                }),
                                                                ge.jsxs("div", {
                                                                    className: "info-item",
                                                                    children: [
                                                                        ge.jsx("label", {
                                                                            children: "렌더링 상태:"
                                                                        }),
                                                                        ge.jsx("span", {
                                                                            style: {
                                                                                color: f ? "#10b981" : n ? "#f59e0b" : "#ef4444"
                                                                            },
                                                                            children: f ? "✅ 완료" : n ? "⏳ 진행중" : "❌ 실패"
                                                                        })
                                                                    ]
                                                                }),
                                                                o.slice(0, 3).map((Pe, Ct)=>ge.jsxs("div", {
                                                                        className: "info-item",
                                                                        children: [
                                                                            ge.jsxs("label", {
                                                                                children: [
                                                                                    "파일 ",
                                                                                    Ct + 1,
                                                                                    ":"
                                                                                ]
                                                                            }),
                                                                            ge.jsx("span", {
                                                                                children: Pe.name
                                                                            })
                                                                        ]
                                                                    }, Ct)),
                                                                o.length > 3 && ge.jsx("div", {
                                                                    className: "info-item",
                                                                    children: ge.jsxs("span", {
                                                                        children: [
                                                                            "... 및 ",
                                                                            o.length - 3,
                                                                            "개 더"
                                                                        ]
                                                                    })
                                                                }),
                                                                f && oe && ge.jsx("div", {
                                                                    className: "info-item",
                                                                    style: {
                                                                        marginTop: "12px"
                                                                    },
                                                                    children: ge.jsxs("button", {
                                                                        onClick: ()=>D(!S),
                                                                        style: {
                                                                            ...pi,
                                                                            width: "100%",
                                                                            padding: "8px 12px",
                                                                            backgroundColor: S ? "#dc2626" : "#059669",
                                                                            color: "white",
                                                                            borderRadius: "6px",
                                                                            fontSize: "13px",
                                                                            fontWeight: "500",
                                                                            cursor: "pointer",
                                                                            display: "flex",
                                                                            alignItems: "center",
                                                                            justifyContent: "center",
                                                                            gap: "8px",
                                                                            transition: "background-color 0.2s"
                                                                        },
                                                                        onMouseEnter: (Pe)=>{
                                                                            Pe.currentTarget.style.backgroundColor = S ? "#b91c1c" : "#047857";
                                                                        },
                                                                        onMouseLeave: (Pe)=>{
                                                                            Pe.currentTarget.style.backgroundColor = S ? "#dc2626" : "#059669";
                                                                        },
                                                                        title: S ? "Meta Tag 창 닫기" : "DICOM 파일의 모든 메타 태그 정보를 확인합니다",
                                                                        children: [
                                                                            ge.jsx(HM, {
                                                                                size: 14
                                                                            }),
                                                                            ge.jsx("span", {
                                                                                children: S ? "Meta Tag 닫기" : "Meta Tag 보기"
                                                                            })
                                                                        ]
                                                                    })
                                                                })
                                                            ]
                                                        }) : ge.jsx("p", {
                                                            className: "no-data",
                                                            children: "파일이 로드되지 않았습니다"
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "sidebar-section",
                                                    style: {
                                                        display: "flex",
                                                        flexDirection: "column",
                                                        height: "400px"
                                                    },
                                                    children: [
                                                        ge.jsxs("h3", {
                                                            className: "sidebar-section-title",
                                                            children: [
                                                                ge.jsx(Oh, {
                                                                    size: 16
                                                                }),
                                                                "주석 목록 (",
                                                                F.length,
                                                                "개)"
                                                            ]
                                                        }),
                                                        F.length > 0 ? ge.jsxs(ge.Fragment, {
                                                            children: [
                                                                ge.jsx("div", {
                                                                    className: "annotations-list",
                                                                    style: {
                                                                        flexGrow: 1,
                                                                        overflowY: "auto",
                                                                        overflowX: "hidden",
                                                                        padding: "8px",
                                                                        marginBottom: "12px",
                                                                        scrollbarWidth: "thin",
                                                                        scrollbarColor: "#cbd5e1 #f1f5f9"
                                                                    },
                                                                    children: F.map((Pe, Ct)=>ge.jsx("div", {
                                                                            className: "annotation-item",
                                                                            style: {
                                                                                marginBottom: "4px",
                                                                                padding: "4px 4px 0px 4px",
                                                                                backgroundColor: "#242424"
                                                                            },
                                                                            children: ge.jsxs("div", {
                                                                                className: "annotation-header",
                                                                                style: {
                                                                                    display: "flex",
                                                                                    justifyContent: "space-between",
                                                                                    alignItems: "center",
                                                                                    marginBottom: "4px"
                                                                                },
                                                                                children: [
                                                                                    ge.jsxs("div", {
                                                                                        className: "annotation-info",
                                                                                        style: {
                                                                                            display: "flex",
                                                                                            flexDirection: "column",
                                                                                            flex: 1
                                                                                        },
                                                                                        children: [
                                                                                            ge.jsx("div", {
                                                                                                style: {
                                                                                                    marginBottom: "2px"
                                                                                                },
                                                                                                children: y === Pe.annotationUID ? ge.jsx("input", {
                                                                                                    type: "text",
                                                                                                    value: T,
                                                                                                    onChange: (yt)=>x(yt.target.value),
                                                                                                    onKeyPress: He,
                                                                                                    onBlur: $e,
                                                                                                    autoFocus: !0,
                                                                                                    style: {
                                                                                                        border: "1px solid #3b82f6",
                                                                                                        borderRadius: "4px",
                                                                                                        padding: "4px 8px",
                                                                                                        fontSize: "14px",
                                                                                                        width: "100%",
                                                                                                        background: "#fff",
                                                                                                        outline: "none",
                                                                                                        fontWeight: "500"
                                                                                                    },
                                                                                                    placeholder: "주석 이름 입력..."
                                                                                                }) : ge.jsx("span", {
                                                                                                    className: "annotation-name",
                                                                                                    onClick: ()=>he(Pe.annotationUID, Pe.data?.label || Pe.data?.text || `${Pe.toolName} #${Ct + 1}`),
                                                                                                    style: {
                                                                                                        cursor: "pointer",
                                                                                                        fontSize: "14px",
                                                                                                        fontWeight: "500",
                                                                                                        color: "rgb(16, 185, 129)",
                                                                                                        padding: "4px 6px",
                                                                                                        transition: "background-color 0.2s",
                                                                                                        display: "inline-block",
                                                                                                        minHeight: "24px",
                                                                                                        minWidth: "60px",
                                                                                                        width: "100%"
                                                                                                    },
                                                                                                    onMouseEnter: (yt)=>{
                                                                                                        yt.currentTarget.style.backgroundColor = "rgba(16, 185, 129, 0.1)";
                                                                                                    },
                                                                                                    onMouseLeave: (yt)=>{
                                                                                                        yt.currentTarget.style.backgroundColor = "transparent";
                                                                                                    },
                                                                                                    title: "클릭하여 이름 편집",
                                                                                                    children: Pe.data?.label || `${Pe.toolName} #${Ct + 1}`
                                                                                                })
                                                                                            }),
                                                                                            ge.jsxs("div", {
                                                                                                style: {
                                                                                                    display: "none"
                                                                                                },
                                                                                                children: [
                                                                                                    ge.jsx("span", {
                                                                                                        className: "annotation-tool",
                                                                                                        style: {
                                                                                                            fontSize: "11px",
                                                                                                            color: "#888"
                                                                                                        },
                                                                                                        children: Pe.toolName
                                                                                                    }),
                                                                                                    ge.jsxs("span", {
                                                                                                        className: "annotation-id",
                                                                                                        style: {
                                                                                                            fontSize: "11px",
                                                                                                            color: "#888"
                                                                                                        },
                                                                                                        children: [
                                                                                                            "#",
                                                                                                            Ct + 1
                                                                                                        ]
                                                                                                    })
                                                                                                ]
                                                                                            })
                                                                                        ]
                                                                                    }),
                                                                                    ge.jsx("button", {
                                                                                        className: "annotation-delete-btn",
                                                                                        onClick: ()=>{
                                                                                            console.log(`🗑️ 주석 삭제 요청: ${Pe.annotationUID}`), B(Pe.annotationUID);
                                                                                        },
                                                                                        title: "주석 삭제",
                                                                                        style: {
                                                                                            ...pi,
                                                                                            color: "#ef4444",
                                                                                            padding: "4px",
                                                                                            borderRadius: "4px",
                                                                                            display: "flex",
                                                                                            alignItems: "center",
                                                                                            justifyContent: "center",
                                                                                            transition: "background-color 0.2s"
                                                                                        },
                                                                                        onMouseEnter: (yt)=>{
                                                                                            yt.currentTarget.style.backgroundColor = "rgba(239, 68, 68, 0.1)";
                                                                                        },
                                                                                        onMouseLeave: (yt)=>{
                                                                                            yt.currentTarget.style.backgroundColor = "transparent";
                                                                                        },
                                                                                        children: ge.jsx(l3, {
                                                                                            size: 14
                                                                                        })
                                                                                    })
                                                                                ]
                                                                            })
                                                                        }, Pe.annotationUID))
                                                                }),
                                                                ge.jsx("div", {
                                                                    style: {
                                                                        paddingTop: "8px",
                                                                        borderTop: "1px solid #e5e7eb",
                                                                        textAlign: "center",
                                                                        flexShrink: 0
                                                                    },
                                                                    children: ge.jsx("button", {
                                                                        onClick: N,
                                                                        style: {
                                                                            ...pi,
                                                                            background: "#ef4444",
                                                                            color: "white",
                                                                            borderRadius: "6px",
                                                                            padding: "8px 16px",
                                                                            fontSize: "12px",
                                                                            fontWeight: "500",
                                                                            cursor: "pointer",
                                                                            transition: "background-color 0.2s",
                                                                            width: "100%"
                                                                        },
                                                                        onMouseEnter: (Pe)=>{
                                                                            Pe.currentTarget.style.backgroundColor = "#dc2626";
                                                                        },
                                                                        onMouseLeave: (Pe)=>{
                                                                            Pe.currentTarget.style.backgroundColor = "#ef4444";
                                                                        },
                                                                        title: "모든 주석을 삭제합니다",
                                                                        children: "모든 주석 지우기"
                                                                    })
                                                                })
                                                            ]
                                                        }) : ge.jsx("p", {
                                                            className: "no-data",
                                                            children: "주석이 없습니다"
                                                        })
                                                    ]
                                                })
                                            ]
                                        }),
                                        ge.jsx("div", {
                                            style: {
                                                borderTop: "1px solid #404040",
                                                padding: "12px 16px",
                                                marginTop: "auto",
                                                backgroundColor: "#2d2d2d"
                                            },
                                            children: ge.jsxs("div", {
                                                style: {
                                                    display: "flex",
                                                    flexDirection: "column",
                                                    gap: "4px",
                                                    alignItems: "center",
                                                    textAlign: "center"
                                                },
                                                children: [
                                                    ge.jsx("p", {
                                                        style: {
                                                            fontSize: "11px",
                                                            color: "#a1a1aa",
                                                            margin: 0
                                                        },
                                                        children: "Clarity v0.1.0"
                                                    }),
                                                    ge.jsx("button", {
                                                        onClick: ()=>{
                                                            console.log("🔗 라이선스 버튼 클릭됨, 현재 상태:", re), X(), console.log("🔗 토글 후 상태 변경 요청됨");
                                                        },
                                                        style: {
                                                            ...pi,
                                                            color: "#3b82f6",
                                                            fontSize: "8px",
                                                            textDecoration: "underline",
                                                            padding: "2px 0",
                                                            transition: "color 0.2s"
                                                        },
                                                        onMouseEnter: (Pe)=>{
                                                            Pe.currentTarget.style.color = "#2563eb";
                                                        },
                                                        onMouseLeave: (Pe)=>{
                                                            Pe.currentTarget.style.color = "#3b82f6";
                                                        },
                                                        title: "오픈소스 라이선스 정보 보기",
                                                        children: "오픈소스 라이선스"
                                                    })
                                                ]
                                            })
                                        })
                                    ]
                                }),
                                ge.jsxs("main", {
                                    className: `main-content ${c ? "with-sidebar" : ""}`,
                                    children: [
                                        ge.jsxs("div", {
                                            className: "toolbar",
                                            children: [
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "기본 도구"
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                {
                                                                    tool: "Pan",
                                                                    icon: FM,
                                                                    tooltip: "Pan Tool - 화면 이동"
                                                                },
                                                                {
                                                                    tool: "Zoom",
                                                                    icon: XM,
                                                                    tooltip: "Zoom Tool - 확대/축소"
                                                                },
                                                                {
                                                                    tool: "WindowLevel",
                                                                    icon: NM,
                                                                    tooltip: "Window Level Tool - 창 레벨 조정"
                                                                },
                                                                {
                                                                    tool: "Magnify",
                                                                    icon: G7,
                                                                    tooltip: "Magnify Tool - 돋보기"
                                                                }
                                                            ].map(({ tool: Pe, icon: Ct, tooltip: yt })=>ge.jsx("button", {
                                                                    className: `toolbar-button ${M === Pe ? "active" : ""}`,
                                                                    onClick: ()=>P(Pe),
                                                                    disabled: n,
                                                                    title: yt,
                                                                    style: pi,
                                                                    children: ge.jsx(Ct, {
                                                                        size: 16
                                                                    })
                                                                }, Pe))
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "측정 도구"
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                {
                                                                    tool: "Length",
                                                                    icon: $M,
                                                                    tooltip: "Length Tool - 길이 측정"
                                                                },
                                                                {
                                                                    tool: "Angle",
                                                                    icon: qM,
                                                                    tooltip: "Angle Tool - 각도 측정"
                                                                },
                                                                {
                                                                    tool: "CobbAngle",
                                                                    icon: GM,
                                                                    tooltip: "Cobb Angle Tool - 콥 각도"
                                                                },
                                                                {
                                                                    tool: "Bidirectional",
                                                                    icon: BM,
                                                                    tooltip: "Bidirectional Tool - 양방향 측정"
                                                                }
                                                            ].map(({ tool: Pe, icon: Ct, tooltip: yt })=>ge.jsx("button", {
                                                                    className: `toolbar-button ${M === Pe ? "active" : ""}`,
                                                                    onClick: ()=>P(Pe),
                                                                    disabled: n,
                                                                    title: yt,
                                                                    style: pi,
                                                                    children: ge.jsx(Ct, {
                                                                        size: 16
                                                                    })
                                                                }, Pe))
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "ROI 도구"
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                {
                                                                    tool: "RectangleROI",
                                                                    icon: jM,
                                                                    tooltip: "Rectangle ROI - 사각형 관심영역"
                                                                },
                                                                {
                                                                    tool: "EllipticalROI",
                                                                    icon: PM,
                                                                    tooltip: "Elliptical ROI - 타원형 관심영역"
                                                                },
                                                                {
                                                                    tool: "CircleROI",
                                                                    icon: VM,
                                                                    tooltip: "Circle ROI - 원형 관심영역"
                                                                }
                                                            ].map(({ tool: Pe, icon: Ct, tooltip: yt })=>ge.jsx("button", {
                                                                    className: `toolbar-button ${M === Pe ? "active" : ""}`,
                                                                    onClick: ()=>P(Pe),
                                                                    disabled: n,
                                                                    title: yt,
                                                                    style: pi,
                                                                    children: ge.jsx(Ct, {
                                                                        size: 16
                                                                    })
                                                                }, Pe))
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "고급 그리기"
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                {
                                                                    tool: "PlanarFreehandROI",
                                                                    icon: bM,
                                                                    tooltip: "Freehand ROI - 자유곡선 그리기"
                                                                },
                                                                {
                                                                    tool: "SplineROI",
                                                                    icon: zM,
                                                                    tooltip: "Spline ROI - 스플라인 곡선"
                                                                }
                                                            ].map(({ tool: Pe, icon: Ct, tooltip: yt })=>ge.jsx("button", {
                                                                    className: `toolbar-button ${M === Pe ? "active" : ""}`,
                                                                    onClick: ()=>P(Pe),
                                                                    disabled: n,
                                                                    title: yt,
                                                                    style: pi,
                                                                    children: ge.jsx(Ct, {
                                                                        size: 16
                                                                    })
                                                                }, Pe))
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "주석 도구"
                                                        }),
                                                        ge.jsx("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                {
                                                                    tool: "ArrowAnnotate",
                                                                    icon: MM,
                                                                    tooltip: "Text Annotation - 텍스트 주석 (화살표 + 텍스트)"
                                                                },
                                                                {
                                                                    tool: "Probe",
                                                                    icon: KM,
                                                                    tooltip: "Probe Tool - 정보 탐침"
                                                                }
                                                            ].map(({ tool: Pe, icon: Ct, tooltip: yt })=>ge.jsx("button", {
                                                                    className: `toolbar-button ${M === Pe ? "active" : ""}`,
                                                                    onClick: ()=>P(Pe),
                                                                    disabled: n,
                                                                    title: yt,
                                                                    style: pi,
                                                                    children: ge.jsx(Ct, {
                                                                        size: 16
                                                                    })
                                                                }, Pe))
                                                        })
                                                    ]
                                                }),
                                                ge.jsxs("div", {
                                                    className: "toolbar-section",
                                                    children: [
                                                        ge.jsx("label", {
                                                            className: "toolbar-label",
                                                            children: "이미지 조작"
                                                        }),
                                                        ge.jsxs("div", {
                                                            className: "toolbar-group",
                                                            children: [
                                                                ge.jsx("button", {
                                                                    className: `toolbar-button ${ue ? "active" : ""}`,
                                                                    onClick: ()=>H("horizontal"),
                                                                    disabled: n,
                                                                    title: "수평 뒤집기 (Flip Horizontal)",
                                                                    style: pi,
                                                                    children: ge.jsx(kM, {
                                                                        size: 16
                                                                    })
                                                                }),
                                                                ge.jsx("button", {
                                                                    className: `toolbar-button ${le ? "active" : ""}`,
                                                                    onClick: ()=>H("vertical"),
                                                                    disabled: n,
                                                                    title: "수직 뒤집기 (Flip Vertical)",
                                                                    style: pi,
                                                                    children: ge.jsx(UM, {
                                                                        size: 16
                                                                    })
                                                                }),
                                                                ge.jsx("button", {
                                                                    className: "toolbar-button",
                                                                    onClick: ()=>Z("left"),
                                                                    disabled: n,
                                                                    title: "왼쪽으로 90도 회전 (Rotate Left)",
                                                                    style: pi,
                                                                    children: ge.jsx(A6, {
                                                                        size: 16
                                                                    })
                                                                }),
                                                                ge.jsx("button", {
                                                                    className: "toolbar-button",
                                                                    onClick: ()=>Z("right"),
                                                                    disabled: n,
                                                                    title: "오른쪽으로 90도 회전 (Rotate Right)",
                                                                    style: pi,
                                                                    children: ge.jsx(WM, {
                                                                        size: 16
                                                                    })
                                                                }),
                                                                ge.jsx("button", {
                                                                    className: "toolbar-button",
                                                                    onClick: ne,
                                                                    disabled: n,
                                                                    title: `이미지 변환 리셋 (현재: ${ae}도, H:${ue}, V:${le})`,
                                                                    style: pi,
                                                                    children: ge.jsx(A6, {
                                                                        size: 16
                                                                    })
                                                                }),
                                                                ge.jsx("button", {
                                                                    className: "toolbar-button",
                                                                    onClick: ()=>{
                                                                        console.log("📸 화면 캡처 버튼 클릭됨"), ie();
                                                                    },
                                                                    disabled: n || !f,
                                                                    title: "현재 뷰포트 화면을 PNG 이미지로 캡처하여 저장합니다",
                                                                    style: pi,
                                                                    children: ge.jsx(LM, {
                                                                        size: 16
                                                                    })
                                                                })
                                                            ]
                                                        })
                                                    ]
                                                })
                                            ]
                                        }),
                                        i && ge.jsxs("div", {
                                            className: "error-banner",
                                            children: [
                                                ge.jsxs("span", {
                                                    children: [
                                                        "⚠️ ",
                                                        i
                                                    ]
                                                }),
                                                ge.jsx("button", {
                                                    onClick: ()=>a(null),
                                                    className: "error-close",
                                                    style: pi,
                                                    children: "×"
                                                })
                                            ]
                                        }),
                                        n && ge.jsx("div", {
                                            className: "loading-overlay",
                                            children: ge.jsxs("div", {
                                                className: "loading-content",
                                                children: [
                                                    ge.jsx("div", {
                                                        className: "loading-spinner",
                                                        children: "⟳"
                                                    }),
                                                    ge.jsx("p", {
                                                        children: "로딩 중..."
                                                    })
                                                ]
                                            })
                                        }),
                                        ge.jsx("div", {
                                            ref: _,
                                            className: `viewport-container ${t ? "dragging" : ""}`,
                                            onDrop: et,
                                            onDragOver: St,
                                            onDragLeave: Ln,
                                            children: ge.jsxs("div", {
                                                className: "viewport-container-inner",
                                                children: [
                                                    ge.jsx("div", {
                                                        className: "viewport-info",
                                                        children: ge.jsxs("span", {
                                                            className: "engine-indicator",
                                                            children: [
                                                                "Tool: ",
                                                                M
                                                            ]
                                                        })
                                                    }),
                                                    t && ge.jsx("div", {
                                                        className: "drop-overlay",
                                                        children: ge.jsxs("div", {
                                                            className: "drop-message",
                                                            children: [
                                                                ge.jsx(Hm, {
                                                                    className: "drop-icon"
                                                                }),
                                                                ge.jsx("p", {
                                                                    children: "DICOM 파일을 여기에 드롭하세요"
                                                                }),
                                                                ge.jsx("small", {
                                                                    children: ".dcm 파일을 지원합니다"
                                                                })
                                                            ]
                                                        })
                                                    }),
                                                    o.length > 0 && !t && !S && ge.jsx(bae, {
                                                        files: o,
                                                        onError: zt,
                                                        onSuccess: Nn
                                                    }),
                                                    S && ge.jsx("div", {
                                                        style: {
                                                            position: "absolute",
                                                            top: 0,
                                                            left: 0,
                                                            right: 0,
                                                            bottom: 0,
                                                            backgroundColor: "#222222",
                                                            borderRadius: "8px",
                                                            border: "1px solid #e5e7eb",
                                                            overflow: "hidden"
                                                        },
                                                        children: ge.jsx(Lae, {
                                                            isOpen: !0,
                                                            onClose: ()=>D(!1),
                                                            dataSet: oe,
                                                            inline: !0
                                                        })
                                                    }),
                                                    !n && !i && o.length === 0 && ge.jsxs("div", {
                                                        className: "empty-state",
                                                        children: [
                                                            ge.jsx(Hm, {
                                                                className: "empty-icon"
                                                            }),
                                                            ge.jsx("h3", {
                                                                children: "DICOM 이미지가 로드되지 않았습니다"
                                                            }),
                                                            ge.jsx("p", {
                                                                children: '파일을 드래그하거나 "파일 불러오기" 버튼을 클릭하세요'
                                                            }),
                                                            ge.jsx("small", {
                                                                children: "지원 형식: .dcm"
                                                            })
                                                        ]
                                                    }),
                                                    g && ge.jsxs("div", {
                                                        style: {
                                                            position: "fixed",
                                                            bottom: "20px",
                                                            right: "20px",
                                                            background: "rgba(16, 185, 129, 0.95)",
                                                            color: "white",
                                                            padding: "12px 20px",
                                                            borderRadius: "8px",
                                                            fontSize: "14px",
                                                            fontWeight: "500",
                                                            boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
                                                            zIndex: 1001,
                                                            animation: "fadeInUp 0.3s ease-out",
                                                            backdropFilter: "blur(8px)",
                                                            display: "flex",
                                                            alignItems: "center",
                                                            gap: "12px"
                                                        },
                                                        children: [
                                                            ge.jsx("span", {
                                                                children: v
                                                            }),
                                                            ge.jsx("button", {
                                                                onClick: ()=>h(!1),
                                                                style: {
                                                                    ...pi,
                                                                    color: "rgba(255, 255, 255, 0.8)",
                                                                    width: "20px",
                                                                    height: "20px",
                                                                    borderRadius: "50%",
                                                                    display: "flex",
                                                                    alignItems: "center",
                                                                    justifyContent: "center",
                                                                    fontSize: "16px",
                                                                    lineHeight: "1"
                                                                },
                                                                onMouseEnter: (Pe)=>{
                                                                    Pe.currentTarget.style.backgroundColor = "rgba(255, 255, 255, 0.2)";
                                                                },
                                                                onMouseLeave: (Pe)=>{
                                                                    Pe.currentTarget.style.backgroundColor = "transparent";
                                                                },
                                                                title: "닫기",
                                                                children: "×"
                                                            })
                                                        ]
                                                    })
                                                ]
                                            })
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                console.log("🎯 모달 렌더 체크, isLicenseModalOpen:", re),
                re && ge.jsx(Nae, {
                    isOpen: re,
                    onClose: ()=>{
                        console.log("🎯 모달 닫기 클릭됨"), X();
                    },
                    inline: !1
                })
            ]
        });
    }
    _M.createRoot(document.getElementById("root")).render(ge.jsx(Rh.StrictMode, {
        children: ge.jsx(Aae, {})
    }));
})();
export { wo as $, Bv as A, xj as B, M3 as C, gP as D, Ge as E, Yl as F, da as G, Wl as H, To as I, Ot as J, si as K, tr as L, lv as M, Pv as N, Te as O, hL as P, zh as Q, b3 as R, sf as S, rS as T, Ur as U, qr as V, Yo as W, dB as X, Ts as Y, vd as Z, CE as _, Wt as a, jae as a$, qs as a0, oG as a1, _u as a2, Ih as a3, La as a4, ST as a5, ot as a6, w_ as a7, D4 as a8, _D as a9, Fe as aA, gf as aB, nq as aC, An as aD, Wv as aE, Ij as aF, $ae as aG, L0 as aH, zae as aI, oj as aJ, ga as aK, SK as aL, EK as aM, DK as aN, xo as aO, ig as aP, gd as aQ, kae as aR, Uae as aS, Fae as aT, MD as aU, Ej as aV, Sj as aW, Mj as aX, Cd as aY, jp as aZ, kH as a_, $n as aa, Cb as ab, Tb as ac, xb as ad, Bae as ae, tf as af, Gae as ag, rT as ah, g3 as ai, sc as aj, u3 as ak, sr as al, So as am, wi as an, F4 as ao, uf as ap, ua as aq, sp as ar, cp as as, LK as at, u_ as au, f_ as av, kC as aw, tg as ax, ws as ay, Es as az, M0 as b, Zo as b0, hk as c, Xo as d, ZE as e, kz as f, eg as g, Ke as h, pn as i, Ys as j, Qc as k, cn as l, K as m, Xr as n, FL as o, zn as p, jn as q, xt as r, kr as s, We as t, El as u, Hc as v, kn as w, bi as x, Yr as y, r$ as z, __tla };
